[
    {
        "Keyword": [
            "WITH RECURSIVE with_query_name AS ( select ) ",
            "WITH with_query_name  ( column_name )  AS ( select ) ",
            "WITH with_query_name AS NOT MATERIALIZED ( select ) ",
            "WITH with_query_name AS MATERIALIZED ( select ) ",
            "WITH with_query_name AS ( select ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (with_clause WITH RECURSIVE (cte_list (common_table_expr AS ( ))))",
            " (with_clause WITH (cte_list (common_table_expr (opt_name_list ( )) AS ( ))))",
            " (with_clause WITH (cte_list (common_table_expr AS (opt_materialized NOT MATERIALIZED) ( ))))",
            " (with_clause WITH (cte_list (common_table_expr AS (opt_materialized MATERIALIZED) ( ))))",
            " (with_clause WITH (cte_list (common_table_expr AS ( ))))"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>WITH</CodeLiteral> clause allows you to specify one or more subqueries that can be referenced by name in the primary query. The subqueries effectively act as temporary tables or views for the duration of the primary query. Each subquery can be a SELECT, TABLE, VALUES, INSERT, UPDATE or DELETE statement. When writing a data-modifying statement (INSERT, UPDATE or DELETE) in <CodeLiteral>WITH</CodeLiteral>, it is usual to include a <CodeLiteral>RETURNING</CodeLiteral> clause. It is the output of <CodeLiteral>RETURNING</CodeLiteral>, not the underlying table that the statement modifies, that forms the temporary table that is read by the primary query. If <CodeLiteral>RETURNING</CodeLiteral> is omitted, the statement is still executed, but it produces no output so it cannot be referenced as a table by the primary query.\n A name (without schema qualification) must be specified for each <CodeLiteral>WITH</CodeLiteral> query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.\n If <CodeLiteral>RECURSIVE</CodeLiteral> is specified, it allows a SELECT subquery to reference itself by name. Such a subquery must have the form\n <code>non_recursive_term UNION [ ALL | DISTINCT ] recursive_term\n</code>\n where the recursive self-reference must appear on the right-hand side of the <CodeLiteral>UNION</CodeLiteral>. Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursive SELECT query in a data-modifying statement. See Section 7.8 for an example.\n Another effect of <CodeLiteral>RECURSIVE</CodeLiteral> is that <CodeLiteral>WITH</CodeLiteral> queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without <CodeLiteral>RECURSIVE</CodeLiteral>, <CodeLiteral>WITH</CodeLiteral> queries can only reference sibling <CodeLiteral>WITH</CodeLiteral> queries that are earlier in the <CodeLiteral>WITH</CodeLiteral> list.\n When there are multiple queries in the <CodeLiteral>WITH</CodeLiteral> clause, <CodeLiteral>RECURSIVE</CodeLiteral> should be written only once, immediately after <CodeLiteral>WITH</CodeLiteral>. It applies to all queries in the <CodeLiteral>WITH</CodeLiteral> clause, though it has no effect on queries that do not use recursion or forward references.\n The primary query and the <CodeLiteral>WITH</CodeLiteral> queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in <CodeLiteral>WITH</CodeLiteral> cannot be seen from other parts of the query, other than by reading its <CodeLiteral>RETURNING</CodeLiteral> output. If two such data-modifying statements attempt to modify the same row, the results are unspecified.\n A key property of <CodeLiteral>WITH</CodeLiteral> queries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output.\n However, a <CodeLiteral>WITH</CodeLiteral> query can be marked <CodeLiteral>NOT MATERIALIZED</CodeLiteral> to remove this guarantee. In that case, the <CodeLiteral>WITH</CodeLiteral> query can be folded into the primary query much as though it were a simple sub-<CodeLiteral>SELECT</CodeLiteral> in the primary query's <CodeLiteral>FROM</CodeLiteral> clause. This results in duplicate computations if the primary query refers to that <CodeLiteral>WITH</CodeLiteral> query more than once; but if each such use requires only a few rows of the <CodeLiteral>WITH</CodeLiteral> query's total output, <CodeLiteral>NOT MATERIALIZED</CodeLiteral> can provide a net savings by allowing the queries to be optimized jointly. <CodeLiteral>NOT MATERIALIZED</CodeLiteral> is ignored if it is attached to a <CodeLiteral>WITH</CodeLiteral> query that is recursive or is not side-effect-free (i.e., is not a plain <CodeLiteral>SELECT</CodeLiteral> containing no volatile functions).\n By default, a side-effect-free <CodeLiteral>WITH</CodeLiteral> query is folded into the primary query if it is used exactly once in the primary query's <CodeLiteral>FROM</CodeLiteral> clause. This allows joint optimization of the two query levels in situations where that should be semantically invisible. However, such folding can be prevented by marking the <CodeLiteral>WITH</CodeLiteral> query as <CodeLiteral>MATERIALIZED</CodeLiteral>. That might be useful, for example, if the <CodeLiteral>WITH</CodeLiteral> query is being used as an optimization fence to prevent the planner from choosing a bad plan. PostgreSQL versions before v12 never did such folding, so queries written for older versions might rely on <CodeLiteral>WITH</CodeLiteral> to act as an optimization fence.\n See Section 7.8 for additional information. ",
        "Demo": [
            "WITH RECURSIVE numbers AS (\n  SELECT 1 AS num\n  UNION ALL\n  SELECT num + 1 FROM numbers WHERE num < 5\n)\nSELECT * FROM numbers;",
            "WITH with_query_name AS (SELECT * FROM some_table) SELECT * FROM with_query_name;",
            "WITH with_query_name AS NOT MATERIALIZED (SELECT * FROM employees WHERE department_id = 3) SELECT * FROM with_query_name;",
            "WITH with_query_name AS MATERIALIZED (SELECT id, name FROM employees WHERE department_id = 3) SELECT * FROM with_query_name;",
            "WITH employee_totals AS (\n  SELECT department_id, COUNT(*) as total_employees\n  FROM employees\n  GROUP BY department_id\n)\nSELECT department.name, employee_totals.total_employees\nFROM department\nJOIN employee_totals ON department.id = employee_totals.department_id;"
        ],
        "Count": [
            5,
            6,
            6,
            5,
            4
        ]
    },
    {
        "Keyword": [
            "FROM ONLY table_name alias",
            "FROM table_name * alias",
            "FROM table_name AS alias"
        ],
        "Src": "SELECT",
        "Tree": [
            " (from_clause FROM (from_list (table_ref (relation_expr ONLY))))",
            "Found error",
            " (from_clause FROM (from_list (table_ref (opt_alias_clause (table_alias_clause AS)))))"
        ],
        "Route": "",
        "Description": "The name (optionally schema-qualified) of an existing table or view. If <CodeLiteral>ONLY</CodeLiteral> is specified before the table name, only that table is scanned. If <CodeLiteral>ONLY</CodeLiteral> is not specified, the table and all its descendant tables (if any) are scanned. Optionally, <CodeLiteral>*</CodeLiteral> can be specified after the table name to explicitly indicate that descendant tables are included. A substitute name for the <CodeLiteral>FROM</CodeLiteral> item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given <CodeLiteral>FROM foo AS f</CodeLiteral>, the remainder of the SELECT must refer to this <CodeLiteral>FROM</CodeLiteral> item as <CodeLiteral>f</CodeLiteral> not <CodeLiteral>foo</CodeLiteral>. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.",
        "Demo": [
            "SELECT * FROM ONLY employees AS e",
            "SELECT * FROM employees AS e",
            "SELECT * FROM employees AS e;"
        ],
        "Count": [
            2,
            null,
            2
        ]
    },
    {
        "Keyword": [
            "TABLESAMPLE BERNOULLI ( argument )  REPEATABLE ( seed ) ",
            "TABLESAMPLE SYSTEM ( argument )  REPEATABLE ( seed ) ",
            "TABLESAMPLE BERNOULLI ( argument ) ",
            "TABLESAMPLE SYSTEM ( argument ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (tablesample_clause TABLESAMPLE (func_name (type_function_name (identifier BERNOULLI))) ( )  (opt_repeatable_clause REPEATABLE ( )))",
            " (tablesample_clause TABLESAMPLE (func_name (type_function_name (unreserved_keyword SYSTEM))) ( )  (opt_repeatable_clause REPEATABLE ( )))",
            " (tablesample_clause TABLESAMPLE (func_name (type_function_name (identifier BERNOULLI))) ( ))",
            " (tablesample_clause TABLESAMPLE (func_name (type_function_name (unreserved_keyword SYSTEM))) ( ))"
        ],
        "Route": "",
        "Description": "A <CodeLiteral>TABLESAMPLE</CodeLiteral> clause after a table_name indicates that the specified sampling_method should be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such as <CodeLiteral>WHERE</CodeLiteral> clauses. The standard PostgreSQL distribution includes two sampling methods, <CodeLiteral>BERNOULLI</CodeLiteral> and <CodeLiteral>SYSTEM</CodeLiteral>, and other sampling methods can be installed in the database via extensions.\n  The <CodeLiteral>BERNOULLI</CodeLiteral> and <CodeLiteral>SYSTEM</CodeLiteral> sampling methods each accept a single argument which is the fraction of the table to sample, expressed as a percentage between 0 and 100. This argument can be any real-valued expression. (Other sampling methods might accept more or different arguments.) These two methods each return a randomly-chosen sample of the table that will contain approximately the specified percentage of the table's rows. The <CodeLiteral>BERNOULLI</CodeLiteral> method scans the whole table and selects or ignores individual rows independently with the specified probability. The <CodeLiteral>SYSTEM</CodeLiteral> method does block-level sampling with each block having the specified chance of being selected; all rows in each selected block are returned. The <CodeLiteral>SYSTEM</CodeLiteral> method is significantly faster than the <CodeLiteral>BERNOULLI</CodeLiteral> method when small sampling percentages are specified, but it may return a less-random sample of the table as a result of clustering effects.\n  The optional <CodeLiteral>REPEATABLE</CodeLiteral> clause specifies a seed number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and argument values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. If <CodeLiteral>REPEATABLE</CodeLiteral> is not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept <CodeLiteral>REPEATABLE</CodeLiteral>, and will always produce new samples on each use.",
        "Demo": [
            "SELECT * FROM employees TABLESAMPLE BERNOULLI (10) REPEATABLE (42);",
            "SELECT * FROM employees TABLESAMPLE SYSTEM (10) REPEATABLE (42);",
            "SELECT * FROM employees TABLESAMPLE BERNOULLI (10);",
            "SELECT * FROM employees TABLESAMPLE SYSTEM (10);"
        ],
        "Count": [
            7,
            7,
            4,
            4
        ]
    },
    {
        "Keyword": [
            "LATERAL ( select )  alias"
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref LATERAL (select_with_parens ( )))"
        ],
        "Route": "",
        "Description": "A sub-SELECT can appear in the <CodeLiteral>FROM</CodeLiteral> clause. This acts as though its output were created as a temporary table for the duration of this single SELECT command. Note that the sub-SELECT must be surrounded by parentheses, and an alias must be provided for it. A VALUES command can also be used here.",
        "Demo": [
            "SELECT a.id, b.val FROM table1 a, LATERAL (SELECT value AS val FROM table2 WHERE table2.id = a.id) b"
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "with_query_name AS alias"
        ],
        "Src": "SELECT",
        "Tree": [
            "(common_table_expr AS)"
        ],
        "Route": "",
        "Description": "A <CodeLiteral>WITH</CodeLiteral> query is referenced by writing its name, just as though the query's name were a table name. (In fact, the <CodeLiteral>WITH</CodeLiteral> query hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table's name.) An alias can be provided in the same way as for a table.",
        "Demo": [
            "WITH summary AS (SELECT department, COUNT(*) AS total_employees FROM employees GROUP BY department) SELECT * FROM summary;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "LATERAL function_name ( argument ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref LATERAL (func_table (func_expr_windowless (func_application ( )))))"
        ],
        "Route": "",
        "Description": "Function calls can appear in the <CodeLiteral>FROM</CodeLiteral> clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single SELECT command. When the optional WITH ORDINALITY clause is added to the function call, a new column is appended after all the function's output columns with numbering for each row.\n  An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by <CodeLiteral>ORDINALITY</CodeLiteral> if present.\n  Multiple function calls can be combined into a single <CodeLiteral>FROM</CodeLiteral>-clause item by surrounding them with <CodeLiteral>ROWS FROM( ... )</CodeLiteral>. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.\n  If the function has been defined as returning the record data type, then an alias or the key word <CodeLiteral>AS</CodeLiteral> must be present, followed by a column definition list in the form <CodeLiteral>( column_name data_type [, ... ])</CodeLiteral>. The column definition list must match the actual number and types of columns returned by the function.\n  When using the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside <CodeLiteral>ROWS FROM( ... )</CodeLiteral>. A column definition list can be placed after the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> construct only if there's just a single function and no <CodeLiteral>WITH ORDINALITY</CodeLiteral> clause.\n  To use <CodeLiteral>ORDINALITY</CodeLiteral> together with a column definition list, you must use the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> syntax and put the column definition list inside <CodeLiteral>ROWS FROM( ... )</CodeLiteral>.",
        "Demo": [
            ""
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "WITH ORDINALITY",
            "AS alias",
            "alias ( column_alias ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (opt_ordinality WITH ORDINALITY)",
            " (alias_clause AS)",
            " (alias_clause ( ))"
        ],
        "Route": "",
        "Description": "Function calls can appear in the <CodeLiteral>FROM</CodeLiteral> clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single SELECT command. When the optional WITH ORDINALITY clause is added to the function call, a new column is appended after all the function's output columns with numbering for each row.\n  An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by <CodeLiteral>ORDINALITY</CodeLiteral> if present.\n  Multiple function calls can be combined into a single <CodeLiteral>FROM</CodeLiteral>-clause item by surrounding them with <CodeLiteral>ROWS FROM( ... )</CodeLiteral>. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.\n  If the function has been defined as returning the record data type, then an alias or the key word <CodeLiteral>AS</CodeLiteral> must be present, followed by a column definition list in the form <CodeLiteral>( column_name data_type [, ... ])</CodeLiteral>. The column definition list must match the actual number and types of columns returned by the function.\n  When using the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside <CodeLiteral>ROWS FROM( ... )</CodeLiteral>. A column definition list can be placed after the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> construct only if there's just a single function and no <CodeLiteral>WITH ORDINALITY</CodeLiteral> clause.\n  To use <CodeLiteral>ORDINALITY</CodeLiteral> together with a column definition list, you must use the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> syntax and put the column definition list inside <CodeLiteral>ROWS FROM( ... )</CodeLiteral>.",
        "Demo": [
            "SELECT * FROM generate_series(1, 5) WITH ORDINALITY AS t(number, ord)",
            "SELECT * FROM generate_series(1, 3) AS series(id)",
            "SELECT * FROM generate_series(1, 5) AS t (number) WHERE t.number <= 3;"
        ],
        "Count": [
            2,
            1,
            2
        ]
    },
    {
        "Keyword": [
            "LATERAL function_name ( argument )  alias ( column_definition ) ",
            "function_name ( argument )  AS alias ( column_definition ) ",
            "function_name ( argument )  alias ( column_definition ) ",
            "LATERAL function_name ( argument )  AS ( column_definition ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref LATERAL (func_table (func_expr_windowless (func_application ( )))) (func_alias_clause (alias_clause AS ( ))))",
            " (table_ref (func_table (func_expr_windowless (func_application ( )))) (func_alias_clause (alias_clause AS ( ))))",
            " (table_ref (func_table (func_expr_windowless (func_application ( )))) (func_alias_clause (alias_clause ( ))))",
            " (table_ref LATERAL (func_table (func_expr_windowless (func_application ( )))) (func_alias_clause (alias_clause AS ( ))))"
        ],
        "Route": "",
        "Description": "Function calls can appear in the <CodeLiteral>FROM</CodeLiteral> clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single SELECT command. When the optional WITH ORDINALITY clause is added to the function call, a new column is appended after all the function's output columns with numbering for each row.\n  An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by <CodeLiteral>ORDINALITY</CodeLiteral> if present.\n  Multiple function calls can be combined into a single <CodeLiteral>FROM</CodeLiteral>-clause item by surrounding them with <CodeLiteral>ROWS FROM( ... )</CodeLiteral>. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.\n  If the function has been defined as returning the record data type, then an alias or the key word <CodeLiteral>AS</CodeLiteral> must be present, followed by a column definition list in the form <CodeLiteral>( column_name data_type [, ... ])</CodeLiteral>. The column definition list must match the actual number and types of columns returned by the function.\n  When using the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside <CodeLiteral>ROWS FROM( ... )</CodeLiteral>. A column definition list can be placed after the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> construct only if there's just a single function and no <CodeLiteral>WITH ORDINALITY</CodeLiteral> clause.\n  To use <CodeLiteral>ORDINALITY</CodeLiteral> together with a column definition list, you must use the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> syntax and put the column definition list inside <CodeLiteral>ROWS FROM( ... )</CodeLiteral>.",
        "Demo": [
            "SELECT * FROM LATERAL generate_series(1,5) AS t (num) WITH ORDINALITY;",
            "SELECT * FROM generate_series(1, 5) AS series (number);",
            "SELECT * FROM generate_series(1,5) AS t(num);",
            ""
        ],
        "Count": [
            6,
            5,
            4,
            6
        ]
    },
    {
        "Keyword": [
            "LATERAL ROWS FROM ( function_name ( argument )  AS ( column_definition )  ) ",
            "LATERAL ROWS FROM ( function_name ( argument )  ) ",
            "ROWS FROM ( function_name ( argument )  AS ( column_definition )  ) ",
            "ROWS FROM ( function_name ( argument )  ) "
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error",
            "Parse error",
            "Parse error",
            "Parse error"
        ],
        "Route": "",
        "Description": "Function calls can appear in the <CodeLiteral>FROM</CodeLiteral> clause. (This is especially useful for functions that return result sets, but any function can be used.) This acts as though the function's output were created as a temporary table for the duration of this single SELECT command. When the optional WITH ORDINALITY clause is added to the function call, a new column is appended after all the function's output columns with numbering for each row.\n  An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by <CodeLiteral>ORDINALITY</CodeLiteral> if present.\n  Multiple function calls can be combined into a single <CodeLiteral>FROM</CodeLiteral>-clause item by surrounding them with <CodeLiteral>ROWS FROM( ... )</CodeLiteral>. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.\n  If the function has been defined as returning the record data type, then an alias or the key word <CodeLiteral>AS</CodeLiteral> must be present, followed by a column definition list in the form <CodeLiteral>( column_name data_type [, ... ])</CodeLiteral>. The column definition list must match the actual number and types of columns returned by the function.\n  When using the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> syntax, if one of the functions requires a column definition list, it's preferred to put the column definition list after the function call inside <CodeLiteral>ROWS FROM( ... )</CodeLiteral>. A column definition list can be placed after the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> construct only if there's just a single function and no <CodeLiteral>WITH ORDINALITY</CodeLiteral> clause.\n  To use <CodeLiteral>ORDINALITY</CodeLiteral> together with a column definition list, you must use the <CodeLiteral>ROWS FROM( ... )</CodeLiteral> syntax and put the column definition list inside <CodeLiteral>ROWS FROM( ... )</CodeLiteral>.",
        "Demo": [
            "SELECT * FROM LATERAL ROWS FROM (generate_series(1,3) AS t(num)) AS s;",
            "SELECT * FROM LATERAL ROWS FROM (generate_series(1,5) WITH ORDINALITY) AS t(num, ord);",
            "SELECT * FROM ROWS FROM (generate_series(1, 3) AS s(num)) t;",
            "SELECT * FROM ROWS FROM (generate_series(1, 5) WITH ORDINALITY) AS t(num, ord)"
        ],
        "Count": [
            null,
            null,
            null,
            null
        ]
    },
    {
        "Keyword": [
            "ON join_condition"
        ],
        "Src": "SELECT",
        "Tree": [
            "(table_ref (join_qual ON))"
        ],
        "Route": "",
        "Description": "join_condition is an expression resulting in a value of type boolean (similar to a <CodeLiteral>WHERE</CodeLiteral> clause) that specifies which rows in a join are considered to match.",
        "Demo": [
            "SELECT * FROM employees e JOIN departments d ON e.department_id = d.id"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "USING ( join_column ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (join_qual USING ( ))"
        ],
        "Route": "",
        "Description": "A clause of the form <CodeLiteral>USING ( a, b, ... )</CodeLiteral> is shorthand for <CodeLiteral>ON left_table.a = right_table.a AND left_table.b = right_table.b ...</CodeLiteral>. Also, <CodeLiteral>USING</CodeLiteral> implies that only one of each pair of equivalent columns will be included in the join output, not both.",
        "Demo": [
            "SELECT * FROM employees INNER JOIN departments USING (department_id);"
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "from_item NATURAL INNER JOIN from_item",
            "from_item NATURAL JOIN from_item",
            "from_item NATURAL LEFT OUTER JOIN from_item",
            "from_item NATURAL LEFT JOIN from_item",
            "from_item NATURAL RIGHT OUTER JOIN from_item",
            "from_item NATURAL RIGHT JOIN from_item",
            "from_item NATURAL FULL OUTER JOIN from_item",
            "from_item NATURAL FULL JOIN from_item"
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref NATURAL (join_type INNER) JOIN)",
            " (table_ref NATURAL JOIN)",
            " (table_ref NATURAL (join_type LEFT OUTER) JOIN)",
            " (table_ref NATURAL (join_type LEFT) JOIN)",
            " (table_ref NATURAL (join_type RIGHT OUTER) JOIN)",
            " (table_ref NATURAL (join_type RIGHT) JOIN)",
            " (table_ref NATURAL (join_type FULL OUTER) JOIN)",
            " (table_ref NATURAL (join_type FULL) JOIN)"
        ],
        "Route": "",
        "Description": "<CodeLiteral>NATURAL</CodeLiteral> is shorthand for a <CodeLiteral>USING</CodeLiteral> list that mentions all columns in the two tables that have matching names. If there are no common column names, <CodeLiteral>NATURAL</CodeLiteral> is equivalent to <CodeLiteral>ON TRUE</CodeLiteral>.One of\n  \n   \n   \n   <CodeLiteral>[ INNER ] JOIN</CodeLiteral>\n   \n   \n   <CodeLiteral>LEFT [ OUTER ] JOIN</CodeLiteral>\n   \n   \n   <CodeLiteral>RIGHT [ OUTER ] JOIN</CodeLiteral>\n   \n   \n   <CodeLiteral>FULL [ OUTER ] JOIN</CodeLiteral>\n   \n   \n  \n  For the <CodeLiteral>INNER</CodeLiteral> and <CodeLiteral>OUTER</CodeLiteral> join types, a join condition must be specified, namely exactly one of <CodeLiteral>ON join_condition</CodeLiteral>, <CodeLiteral>USING (join_column [, ...])</CodeLiteral>, or <CodeLiteral>NATURAL</CodeLiteral>. See below for the meaning.\n  A <CodeLiteral>JOIN</CodeLiteral> clause combines two <CodeLiteral>FROM</CodeLiteral> items, which for convenience we will refer to as \u201ctables\u201d, though in reality they can be any type of <CodeLiteral>FROM</CodeLiteral> item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, <CodeLiteral>JOIN</CodeLiteral>s nest left-to-right. In any case <CodeLiteral>JOIN</CodeLiteral> binds more tightly than the commas separating <CodeLiteral>FROM</CodeLiteral>-list items. All the <CodeLiteral>JOIN</CodeLiteral> options are just a notational convenience, since they do nothing you couldn't do with plain <CodeLiteral>FROM</CodeLiteral> and <CodeLiteral>WHERE</CodeLiteral>.\n  <CodeLiteral>LEFT OUTER JOIN</CodeLiteral> returns all rows in the qualified Cartesian product (i.e., all combined rows that pass its join condition), plus one copy of each row in the left-hand table for which there was no right-hand row that passed the join condition. This left-hand row is extended to the full width of the joined table by inserting null values for the right-hand columns. Note that only the <CodeLiteral>JOIN</CodeLiteral> clause's own condition is considered while deciding which rows have matches. Outer conditions are applied afterwards.\n  Conversely, <CodeLiteral>RIGHT OUTER JOIN</CodeLiteral> returns all the joined rows, plus one row for each unmatched right-hand row (extended with nulls on the left). This is just a notational convenience, since you could convert it to a <CodeLiteral>LEFT OUTER JOIN</CodeLiteral> by switching the left and right tables.\n  <CodeLiteral>FULL OUTER JOIN</CodeLiteral> returns all the joined rows, plus one row for each unmatched left-hand row (extended with nulls on the right), plus one row for each unmatched right-hand row (extended with nulls on the left).",
        "Demo": [
            "SELECT * FROM employees NATURAL INNER JOIN departments;",
            "SELECT * FROM employees NATURAL JOIN departments;",
            "SELECT * FROM employees NATURAL LEFT OUTER JOIN departments;",
            "SELECT * FROM employees NATURAL LEFT JOIN departments;",
            "SELECT * FROM employees NATURAL RIGHT OUTER JOIN departments;",
            "SELECT * FROM users NATURAL RIGHT JOIN orders;",
            "SELECT * FROM employee NATURAL FULL OUTER JOIN department;",
            "SELECT * FROM employees e NATURAL FULL JOIN departments d;"
        ],
        "Count": [
            3,
            2,
            4,
            3,
            4,
            3,
            4,
            3
        ]
    },
    {
        "Keyword": [
            "from_item CROSS JOIN from_item"
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref CROSS JOIN)"
        ],
        "Route": "",
        "Description": "<CodeLiteral>CROSS JOIN</CodeLiteral> is equivalent to <CodeLiteral>INNER JOIN ON (TRUE)</CodeLiteral>, that is, no rows are removed by qualification. They produce a simple Cartesian product, the same result as you get from listing the two tables at the top level of <CodeLiteral>FROM</CodeLiteral>, but restricted by the join condition (if any).",
        "Demo": [
            "SELECT * FROM table1 CROSS JOIN table2;"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "LATERAL ( select )  alias",
            " ( select )  AS alias"
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref LATERAL (select_with_parens ( )))",
            " (table_ref (select_with_parens ( )) (opt_alias_clause (table_alias_clause AS)))"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LATERAL</CodeLiteral> key word can precede a sub-SELECT <CodeLiteral>FROM</CodeLiteral> item. This allows the sub-SELECT to refer to columns of <CodeLiteral>FROM</CodeLiteral> items that appear before it in the <CodeLiteral>FROM</CodeLiteral> list. (Without <CodeLiteral>LATERAL</CodeLiteral>, each sub-SELECT is evaluated independently and so cannot cross-reference any other <CodeLiteral>FROM</CodeLiteral> item.)\n  <CodeLiteral>LATERAL</CodeLiteral> can also precede a function-call <CodeLiteral>FROM</CodeLiteral> item, but in this case it is a noise word, because the function expression can refer to earlier <CodeLiteral>FROM</CodeLiteral> items in any case.\n  A <CodeLiteral>LATERAL</CodeLiteral> item can appear at top level in the <CodeLiteral>FROM</CodeLiteral> list, or within a <CodeLiteral>JOIN</CodeLiteral> tree. In the latter case it can also refer to any items that are on the left-hand side of a <CodeLiteral>JOIN</CodeLiteral> that it is on the right-hand side of.\n  When a <CodeLiteral>FROM</CodeLiteral> item contains <CodeLiteral>LATERAL</CodeLiteral> cross-references, evaluation proceeds as follows: for each row of the <CodeLiteral>FROM</CodeLiteral> item providing the cross-referenced column(s), or set of rows of multiple <CodeLiteral>FROM</CodeLiteral> items providing the columns, the <CodeLiteral>LATERAL</CodeLiteral> item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).\n  The column source table(s) must be <CodeLiteral>INNER</CodeLiteral> or <CodeLiteral>LEFT</CodeLiteral> joined to the <CodeLiteral>LATERAL</CodeLiteral> item, else there would not be a well-defined set of rows from which to compute each set of rows for the <CodeLiteral>LATERAL</CodeLiteral> item. Thus, although a construct such as <CodeLiteral>X RIGHT JOIN LATERAL Y</CodeLiteral> is syntactically valid, it is not actually allowed for Y to reference X.",
        "Demo": [
            "SELECT a.*, b.val FROM a, LATERAL (SELECT x.val FROM x WHERE x.key = a.key) AS b",
            "SELECT a.id, b.val FROM a, LATERAL (SELECT x.val FROM x WHERE x.a_id = a.id) AS b"
        ],
        "Count": [
            3,
            3
        ]
    },
    {
        "Keyword": [
            "LATERAL function_name ( argument ) ",
            "function_name ( argument )  WITH ORDINALITY",
            "function_name ( argument )  AS alias"
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref LATERAL (func_alias_clause (alias_clause ( ))))",
            " (func_table (func_expr_windowless (func_application ( ))) (opt_ordinality WITH ORDINALITY))",
            " (table_ref (func_table (func_expr_windowless (func_application ( )))) (func_alias_clause (alias_clause AS)))"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LATERAL</CodeLiteral> key word can precede a sub-SELECT <CodeLiteral>FROM</CodeLiteral> item. This allows the sub-SELECT to refer to columns of <CodeLiteral>FROM</CodeLiteral> items that appear before it in the <CodeLiteral>FROM</CodeLiteral> list. (Without <CodeLiteral>LATERAL</CodeLiteral>, each sub-SELECT is evaluated independently and so cannot cross-reference any other <CodeLiteral>FROM</CodeLiteral> item.)\n  <CodeLiteral>LATERAL</CodeLiteral> can also precede a function-call <CodeLiteral>FROM</CodeLiteral> item, but in this case it is a noise word, because the function expression can refer to earlier <CodeLiteral>FROM</CodeLiteral> items in any case.\n  A <CodeLiteral>LATERAL</CodeLiteral> item can appear at top level in the <CodeLiteral>FROM</CodeLiteral> list, or within a <CodeLiteral>JOIN</CodeLiteral> tree. In the latter case it can also refer to any items that are on the left-hand side of a <CodeLiteral>JOIN</CodeLiteral> that it is on the right-hand side of.\n  When a <CodeLiteral>FROM</CodeLiteral> item contains <CodeLiteral>LATERAL</CodeLiteral> cross-references, evaluation proceeds as follows: for each row of the <CodeLiteral>FROM</CodeLiteral> item providing the cross-referenced column(s), or set of rows of multiple <CodeLiteral>FROM</CodeLiteral> items providing the columns, the <CodeLiteral>LATERAL</CodeLiteral> item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).\n  The column source table(s) must be <CodeLiteral>INNER</CodeLiteral> or <CodeLiteral>LEFT</CodeLiteral> joined to the <CodeLiteral>LATERAL</CodeLiteral> item, else there would not be a well-defined set of rows from which to compute each set of rows for the <CodeLiteral>LATERAL</CodeLiteral> item. Thus, although a construct such as <CodeLiteral>X RIGHT JOIN LATERAL Y</CodeLiteral> is syntactically valid, it is not actually allowed for Y to reference X.",
        "Demo": [
            "SELECT a.*, L.func_result FROM a, LATERAL function_name(a.column) AS L(func_result)",
            "SELECT * FROM some_table, LATERAL generate_series(1, some_table.num) WITH ORDINALITY",
            "SELECT employees.name, lateral_data.emails FROM employees, LATERAL generate_series(1, 3) AS lateral_data(emails) WHERE employees.id = lateral_data.emails;"
        ],
        "Count": [
            3,
            4,
            3
        ]
    },
    {
        "Keyword": [
            "LATERAL function_name ( argument )  alias ( column_definition ) ",
            "function_name ( argument )  AS alias ( column_definition ) ",
            "function_name ( argument )  alias ( column_definition ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref LATERAL (func_table (func_expr_windowless (func_application ( )))) (func_alias_clause (alias_clause ( ))))",
            " (table_ref (func_table (func_expr_windowless (func_application ( )))) (func_alias_clause (alias_clause AS ( ))))",
            " (table_ref (func_table (func_expr_windowless (func_application ( )))) (func_alias_clause (alias_clause ( ))))"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LATERAL</CodeLiteral> key word can precede a sub-SELECT <CodeLiteral>FROM</CodeLiteral> item. This allows the sub-SELECT to refer to columns of <CodeLiteral>FROM</CodeLiteral> items that appear before it in the <CodeLiteral>FROM</CodeLiteral> list. (Without <CodeLiteral>LATERAL</CodeLiteral>, each sub-SELECT is evaluated independently and so cannot cross-reference any other <CodeLiteral>FROM</CodeLiteral> item.)\n  <CodeLiteral>LATERAL</CodeLiteral> can also precede a function-call <CodeLiteral>FROM</CodeLiteral> item, but in this case it is a noise word, because the function expression can refer to earlier <CodeLiteral>FROM</CodeLiteral> items in any case.\n  A <CodeLiteral>LATERAL</CodeLiteral> item can appear at top level in the <CodeLiteral>FROM</CodeLiteral> list, or within a <CodeLiteral>JOIN</CodeLiteral> tree. In the latter case it can also refer to any items that are on the left-hand side of a <CodeLiteral>JOIN</CodeLiteral> that it is on the right-hand side of.\n  When a <CodeLiteral>FROM</CodeLiteral> item contains <CodeLiteral>LATERAL</CodeLiteral> cross-references, evaluation proceeds as follows: for each row of the <CodeLiteral>FROM</CodeLiteral> item providing the cross-referenced column(s), or set of rows of multiple <CodeLiteral>FROM</CodeLiteral> items providing the columns, the <CodeLiteral>LATERAL</CodeLiteral> item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).\n  The column source table(s) must be <CodeLiteral>INNER</CodeLiteral> or <CodeLiteral>LEFT</CodeLiteral> joined to the <CodeLiteral>LATERAL</CodeLiteral> item, else there would not be a well-defined set of rows from which to compute each set of rows for the <CodeLiteral>LATERAL</CodeLiteral> item. Thus, although a construct such as <CodeLiteral>X RIGHT JOIN LATERAL Y</CodeLiteral> is syntactically valid, it is not actually allowed for Y to reference X.",
        "Demo": [
            "SELECT a.id, f.val FROM accounts a, LATERAL generate_series(1, a.id) AS f(val)",
            "",
            "SELECT employees.name, departments_info.* FROM employees, LATERAL generate_series(1, employees.years_of_service) AS departments_info(department_count) WHERE employees.id = 1;"
        ],
        "Count": [
            5,
            5,
            4
        ]
    },
    {
        "Keyword": [
            "LATERAL function_name ( argument )  AS ( column_definition ) ",
            "function_name ( argument )  AS ( column_definition ) "
        ],
        "Src": "SELECT",
        "Tree": [
            "Found error",
            "Parse error"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LATERAL</CodeLiteral> key word can precede a sub-SELECT <CodeLiteral>FROM</CodeLiteral> item. This allows the sub-SELECT to refer to columns of <CodeLiteral>FROM</CodeLiteral> items that appear before it in the <CodeLiteral>FROM</CodeLiteral> list. (Without <CodeLiteral>LATERAL</CodeLiteral>, each sub-SELECT is evaluated independently and so cannot cross-reference any other <CodeLiteral>FROM</CodeLiteral> item.)\n  <CodeLiteral>LATERAL</CodeLiteral> can also precede a function-call <CodeLiteral>FROM</CodeLiteral> item, but in this case it is a noise word, because the function expression can refer to earlier <CodeLiteral>FROM</CodeLiteral> items in any case.\n  A <CodeLiteral>LATERAL</CodeLiteral> item can appear at top level in the <CodeLiteral>FROM</CodeLiteral> list, or within a <CodeLiteral>JOIN</CodeLiteral> tree. In the latter case it can also refer to any items that are on the left-hand side of a <CodeLiteral>JOIN</CodeLiteral> that it is on the right-hand side of.\n  When a <CodeLiteral>FROM</CodeLiteral> item contains <CodeLiteral>LATERAL</CodeLiteral> cross-references, evaluation proceeds as follows: for each row of the <CodeLiteral>FROM</CodeLiteral> item providing the cross-referenced column(s), or set of rows of multiple <CodeLiteral>FROM</CodeLiteral> items providing the columns, the <CodeLiteral>LATERAL</CodeLiteral> item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).\n  The column source table(s) must be <CodeLiteral>INNER</CodeLiteral> or <CodeLiteral>LEFT</CodeLiteral> joined to the <CodeLiteral>LATERAL</CodeLiteral> item, else there would not be a well-defined set of rows from which to compute each set of rows for the <CodeLiteral>LATERAL</CodeLiteral> item. Thus, although a construct such as <CodeLiteral>X RIGHT JOIN LATERAL Y</CodeLiteral> is syntactically valid, it is not actually allowed for Y to reference X.",
        "Demo": [
            "SELECT department.name, lateral_info.employee_count FROM department, LATERAL (SELECT COUNT(*) AS employee_count FROM employee WHERE employee.department_id = department.id) AS lateral_info",
            "SELECT people.name, compute_age(people.birth_year) AS (age INT) FROM people, LATERAL compute_age(people.birth_year) AS age_calculation(age)"
        ],
        "Count": [
            null,
            null
        ]
    },
    {
        "Keyword": [
            "LATERAL ROWS FROM ( function_name ( argument )  ) ",
            "ROWS FROM ( function_name ( argument )  )  WITH ORDINALITY",
            "ROWS FROM ( function_name ( argument )  AS ( column_definition )  )  AS alias",
            "ROWS FROM ( function_name ( argument )  )  AS alias",
            "ROWS FROM ( function_name ( argument )  AS ( column_definition )  )  alias  ( column_alias ) ",
            "ROWS FROM ( function_name ( argument )  )  alias  ( column_alias ) ",
            "ROWS FROM ( function_name ( argument )  AS ( column_definition )  )  alias",
            "ROWS FROM ( function_name ( argument )  )  alias",
            "ROWS FROM ( function_name ( argument )  AS ( column_definition )  ) ",
            "ROWS FROM ( function_name ( argument )  ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref LATERAL (func_table ROWS FROM (rowsfrom_list (rowsfrom_item (func_expr_windowless (func_application ( )))))))",
            "Found error",
            "Parse error",
            " (table_ref (func_table ROWS FROM (rowsfrom_list (rowsfrom_item (func_expr_windowless (func_application ( )))))) (func_alias_clause (alias_clause AS)))",
            "Parse error",
            " (table_ref (func_table ROWS FROM (rowsfrom_list (rowsfrom_item (func_expr_windowless (func_application ( )))))) (func_alias_clause (alias_clause ( ))))",
            "Parse error",
            " (func_table ROWS FROM (rowsfrom_list (rowsfrom_item (func_expr_windowless (func_application ( ))))))",
            "Parse error",
            " (func_table ROWS FROM (rowsfrom_list (rowsfrom_item (func_expr_windowless (func_application ( ))))))"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LATERAL</CodeLiteral> key word can precede a sub-SELECT <CodeLiteral>FROM</CodeLiteral> item. This allows the sub-SELECT to refer to columns of <CodeLiteral>FROM</CodeLiteral> items that appear before it in the <CodeLiteral>FROM</CodeLiteral> list. (Without <CodeLiteral>LATERAL</CodeLiteral>, each sub-SELECT is evaluated independently and so cannot cross-reference any other <CodeLiteral>FROM</CodeLiteral> item.)\n  <CodeLiteral>LATERAL</CodeLiteral> can also precede a function-call <CodeLiteral>FROM</CodeLiteral> item, but in this case it is a noise word, because the function expression can refer to earlier <CodeLiteral>FROM</CodeLiteral> items in any case.\n  A <CodeLiteral>LATERAL</CodeLiteral> item can appear at top level in the <CodeLiteral>FROM</CodeLiteral> list, or within a <CodeLiteral>JOIN</CodeLiteral> tree. In the latter case it can also refer to any items that are on the left-hand side of a <CodeLiteral>JOIN</CodeLiteral> that it is on the right-hand side of.\n  When a <CodeLiteral>FROM</CodeLiteral> item contains <CodeLiteral>LATERAL</CodeLiteral> cross-references, evaluation proceeds as follows: for each row of the <CodeLiteral>FROM</CodeLiteral> item providing the cross-referenced column(s), or set of rows of multiple <CodeLiteral>FROM</CodeLiteral> items providing the columns, the <CodeLiteral>LATERAL</CodeLiteral> item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).\n  The column source table(s) must be <CodeLiteral>INNER</CodeLiteral> or <CodeLiteral>LEFT</CodeLiteral> joined to the <CodeLiteral>LATERAL</CodeLiteral> item, else there would not be a well-defined set of rows from which to compute each set of rows for the <CodeLiteral>LATERAL</CodeLiteral> item. Thus, although a construct such as <CodeLiteral>X RIGHT JOIN LATERAL Y</CodeLiteral> is syntactically valid, it is not actually allowed for Y to reference X.",
        "Demo": [
            "SELECT a.id, b.val FROM a JOIN LATERAL ROWS FROM (generate_series(1, a.id)) AS b(val) ON true;",
            "SELECT * FROM generate_series(1, 5) WITH ORDINALITY AS g(id, ordinality);",
            "SELECT * FROM orders, LATERAL ROWS FROM (generate_series(1, orders.quantity) AS s(i)) AS line_items;",
            "SELECT * FROM employees e, LATERAL ROWS FROM (generate_series(1, e.years_of_experience)) AS years_exp(seq)",
            "SELECT * FROM my_table, LATERAL ROWS FROM (generate_series(1, my_table.value) AS s(series_number)) series_alias (series_value);",
            "SELECT * FROM my_table, LATERAL ROWS FROM (my_function(my_table.column)) AS alias (column_alias);",
            "SELECT * FROM my_table, LATERAL ROWS FROM (generate_series(1, my_table.value) AS t(num)) sub_query",
            "SELECT * FROM my_table, LATERAL ROWS FROM (generate_series(1, my_table.max_value)) AS series(value)",
            "SELECT * FROM my_table, LATERAL ROWS FROM (generate_series(1, my_table.num) AS g(num));",
            "SELECT * FROM table1, LATERAL ROWS FROM (generate_series(1, table1.num)) AS series(value) WHERE table1.id = 1;"
        ],
        "Count": [
            5,
            null,
            null,
            5,
            null,
            6,
            null,
            4,
            null,
            4
        ]
    },
    {
        "Keyword": [
            "from_item INNER JOIN from_item ON join_condition",
            "from_item JOIN from_item ON join_condition",
            "from_item LEFT OUTER JOIN from_item ON join_condition",
            "from_item LEFT JOIN from_item ON join_condition",
            "from_item RIGHT OUTER JOIN from_item ON join_condition",
            "from_item RIGHT JOIN from_item ON join_condition",
            "from_item FULL OUTER JOIN from_item ON join_condition",
            "from_item FULL JOIN from_item ON join_condition",
            "from_item INNER JOIN from_item USING ( join_column ) ",
            "from_item JOIN from_item USING ( join_column ) ",
            "from_item LEFT OUTER JOIN from_item USING ( join_column ) ",
            "from_item LEFT JOIN from_item USING ( join_column ) ",
            "from_item RIGHT OUTER JOIN from_item USING ( join_column ) ",
            "from_item RIGHT JOIN from_item USING ( join_column ) ",
            "from_item FULL OUTER JOIN from_item USING ( join_column ) ",
            "from_item FULL JOIN from_item USING ( join_column ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (table_ref (join_type INNER) JOIN (join_qual ON))",
            " (table_ref JOIN (join_qual ON))",
            " (table_ref (join_type LEFT OUTER) JOIN (join_qual ON))",
            " (table_ref (join_type LEFT) JOIN (join_qual ON))",
            " (table_ref (join_type RIGHT OUTER) JOIN (join_qual ON))",
            " (table_ref (join_type RIGHT) JOIN (join_qual ON))",
            " (table_ref (join_type FULL OUTER) JOIN (join_qual ON))",
            " (table_ref (join_type FULL) JOIN (join_qual ON))",
            " (table_ref (join_type INNER) JOIN (join_qual USING ( )))",
            " (table_ref JOIN (join_qual USING ( )))",
            " (table_ref (join_type LEFT OUTER) JOIN (join_qual USING ( )))",
            " (table_ref (join_type LEFT) JOIN (join_qual USING ( )))",
            " (table_ref (join_type RIGHT OUTER) JOIN (join_qual USING ( )))",
            " (table_ref (join_type RIGHT) JOIN (join_qual USING ( )))",
            " (table_ref (join_type FULL OUTER) JOIN (join_qual USING ( )))",
            " (table_ref (join_type FULL) JOIN (join_qual USING ( )))"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LATERAL</CodeLiteral> key word can precede a sub-SELECT <CodeLiteral>FROM</CodeLiteral> item. This allows the sub-SELECT to refer to columns of <CodeLiteral>FROM</CodeLiteral> items that appear before it in the <CodeLiteral>FROM</CodeLiteral> list. (Without <CodeLiteral>LATERAL</CodeLiteral>, each sub-SELECT is evaluated independently and so cannot cross-reference any other <CodeLiteral>FROM</CodeLiteral> item.)\n  <CodeLiteral>LATERAL</CodeLiteral> can also precede a function-call <CodeLiteral>FROM</CodeLiteral> item, but in this case it is a noise word, because the function expression can refer to earlier <CodeLiteral>FROM</CodeLiteral> items in any case.\n  A <CodeLiteral>LATERAL</CodeLiteral> item can appear at top level in the <CodeLiteral>FROM</CodeLiteral> list, or within a <CodeLiteral>JOIN</CodeLiteral> tree. In the latter case it can also refer to any items that are on the left-hand side of a <CodeLiteral>JOIN</CodeLiteral> that it is on the right-hand side of.\n  When a <CodeLiteral>FROM</CodeLiteral> item contains <CodeLiteral>LATERAL</CodeLiteral> cross-references, evaluation proceeds as follows: for each row of the <CodeLiteral>FROM</CodeLiteral> item providing the cross-referenced column(s), or set of rows of multiple <CodeLiteral>FROM</CodeLiteral> items providing the columns, the <CodeLiteral>LATERAL</CodeLiteral> item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).\n  The column source table(s) must be <CodeLiteral>INNER</CodeLiteral> or <CodeLiteral>LEFT</CodeLiteral> joined to the <CodeLiteral>LATERAL</CodeLiteral> item, else there would not be a well-defined set of rows from which to compute each set of rows for the <CodeLiteral>LATERAL</CodeLiteral> item. Thus, although a construct such as <CodeLiteral>X RIGHT JOIN LATERAL Y</CodeLiteral> is syntactically valid, it is not actually allowed for Y to reference X. Join type can be one of <CodeLiteral>[ INNER ] JOIN</CodeLiteral>\n   <CodeLiteral>LEFT [ OUTER ] JOIN</CodeLiteral>\n  <CodeLiteral>RIGHT [ OUTER ] JOIN</CodeLiteral>\n   <CodeLiteral>FULL [ OUTER ] JOIN</CodeLiteral>\n  For the <CodeLiteral>INNER</CodeLiteral> and <CodeLiteral>OUTER</CodeLiteral> join types, a join condition must be specified, namely exactly one of <CodeLiteral>ON join_condition</CodeLiteral>, <CodeLiteral>USING (join_column [, ...])</CodeLiteral>, or <CodeLiteral>NATURAL</CodeLiteral>. See below for the meaning.\n  A <CodeLiteral>JOIN</CodeLiteral> clause combines two <CodeLiteral>FROM</CodeLiteral> items, which for convenience we will refer to as \u201ctables\u201d, though in reality they can be any type of <CodeLiteral>FROM</CodeLiteral> item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, <CodeLiteral>JOIN</CodeLiteral>s nest left-to-right. In any case <CodeLiteral>JOIN</CodeLiteral> binds more tightly than the commas separating <CodeLiteral>FROM</CodeLiteral>-list items. All the <CodeLiteral>JOIN</CodeLiteral> options are just a notational convenience, since they do nothing you couldn't do with plain <CodeLiteral>FROM</CodeLiteral> and <CodeLiteral>WHERE</CodeLiteral>.\n  <CodeLiteral>LEFT OUTER JOIN</CodeLiteral> returns all rows in the qualified Cartesian product (i.e., all combined rows that pass its join condition), plus one copy of each row in the left-hand table for which there was no right-hand row that passed the join condition. This left-hand row is extended to the full width of the joined table by inserting null values for the right-hand columns. Note that only the <CodeLiteral>JOIN</CodeLiteral> clause's own condition is considered while deciding which rows have matches. Outer conditions are applied afterwards.\n  Conversely, <CodeLiteral>RIGHT OUTER JOIN</CodeLiteral> returns all the joined rows, plus one row for each unmatched right-hand row (extended with nulls on the left). This is just a notational convenience, since you could convert it to a <CodeLiteral>LEFT OUTER JOIN</CodeLiteral> by switching the left and right tables.\n  <CodeLiteral>FULL OUTER JOIN</CodeLiteral> returns all the joined rows, plus one row for each unmatched left-hand row (extended with nulls on the right), plus one row for each unmatched right-hand row (extended with nulls on the left).",
        "Demo": [
            "SELECT a.id, b.name FROM employees a INNER JOIN departments b ON a.department_id = b.id",
            "SELECT * FROM employees e INNER JOIN departments d ON e.department_id = d.id;",
            "SELECT a.id, b.name FROM users a LEFT OUTER JOIN orders b ON a.id = b.user_id",
            "SELECT e.employee_name, d.department_name\nFROM employees e\nLEFT JOIN departments d ON e.department_id = d.id;",
            "SELECT * FROM employees RIGHT OUTER JOIN departments ON employees.department_id = departments.id;",
            "SELECT a.id, b.name FROM employees a RIGHT JOIN departments b ON a.department_id = b.id",
            "SELECT * FROM employee FULL OUTER JOIN department ON employee.department_id = department.id;",
            "SELECT * FROM employees FULL JOIN departments ON employees.department_id = departments.id",
            "SELECT t1.name, t2.salary FROM employees t1 INNER JOIN payroll t2 USING (employee_id)",
            "SELECT * FROM employees e JOIN departments d USING (department_id);",
            "SELECT * FROM employees LEFT OUTER JOIN departments USING (department_id);",
            "SELECT * FROM employees e LEFT JOIN departments d USING (department_id);",
            "SELECT * FROM employees RIGHT OUTER JOIN departments USING (department_id);",
            "SELECT employees.name, departments.department_name FROM employees RIGHT JOIN departments USING (department_id)",
            "SELECT * FROM employees FULL OUTER JOIN departments USING (department_id)",
            "SELECT * FROM employees FULL JOIN departments USING (department_id);"
        ],
        "Count": [
            3,
            2,
            4,
            3,
            4,
            3,
            4,
            3,
            5,
            4,
            6,
            5,
            6,
            5,
            6,
            5
        ]
    },
    {
        "Keyword": [
            "GROUP BY ROLLUP ( expression ) ",
            "GROUP BY CUBE ( expression ) ",
            "GROUP BY GROUPING SETS grouping_element ",
            "GROUP BY expression"
        ],
        "Src": "SELECT",
        "Tree": [
            " (group_clause GROUP BY (group_by_list (group_by_item (rollup_clause ROLLUP))))",
            " (group_clause GROUP BY (group_by_list (group_by_item (cube_clause CUBE))))",
            " (group_clause GROUP BY (group_by_list (group_by_item (grouping_sets_clause GROUPING SETS))))",
            " (group_clause GROUP BY)"
        ],
        "Route": "",
        "Description": "The optional <CodeLiteral>GROUP BY</CodeLiteral> clause has the general form\n <code>GROUP BY grouping_element [, ...]\n</code>\n <CodeLiteral>GROUP BY</CodeLiteral> will condense into a single row all selected rows that share the same values for the grouped expressions. An expression used inside a grouping_element can be an input column name, or the name or ordinal number of an output column (SELECT list item), or an arbitrary expression formed from input-column values. In case of ambiguity, a <CodeLiteral>GROUP BY</CodeLiteral> name will be interpreted as an input-column name rather than an output column name.\n If any of <CodeLiteral>GROUPING SETS</CodeLiteral>, <CodeLiteral>ROLLUP</CodeLiteral> or <CodeLiteral>CUBE</CodeLiteral> are present as grouping elements, then the <CodeLiteral>GROUP BY</CodeLiteral> clause as a whole defines some number of independent grouping sets. The effect of this is equivalent to constructing a <CodeLiteral>UNION ALL</CodeLiteral> between subqueries with the individual grouping sets as their <CodeLiteral>GROUP BY</CodeLiteral> clauses. For further details on the handling of grouping sets see Section 7.2.4.\n Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no <CodeLiteral>GROUP BY</CodeLiteral> clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a <CodeLiteral>FILTER</CodeLiteral> clause to the aggregate function call; see Section 4.2.7 for more information. When a <CodeLiteral>FILTER</CodeLiteral> clause is present, only those rows matching it are included in the input to that aggregate function.\n When <CodeLiteral>GROUP BY</CodeLiteral> is present, or any aggregate functions are present, it is not valid for the SELECT list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.\n Keep in mind that all aggregate functions are evaluated before evaluating any \u201cscalar\u201d expressions in the <CodeLiteral>HAVING</CodeLiteral> clause or <CodeLiteral>SELECT</CodeLiteral> list. This means that, for example, a <CodeLiteral>CASE</CodeLiteral> expression cannot be used to skip evaluation of an aggregate function; see Section 4.2.14.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified with <CodeLiteral>GROUP BY</CodeLiteral>. ",
        "Demo": [
            "SELECT department, ROLLUP(total_sales) FROM sales GROUP BY ROLLUP(department)",
            "SELECT department, SUM(salary) AS total_salary FROM employees GROUP BY CUBE (department)",
            "SELECT department, SUM(salary) AS total_salary FROM employees GROUP BY GROUPING SETS ((department), ());",
            "SELECT department, COUNT(*) as num_employees FROM employees GROUP BY department;"
        ],
        "Count": [
            3,
            3,
            4,
            2
        ]
    },
    {
        "Keyword": [
            "HAVING condition"
        ],
        "Src": "SELECT",
        "Tree": [
            " (having_clause HAVING)"
        ],
        "Route": "",
        "Description": "The optional <CodeLiteral>HAVING</CodeLiteral> clause has the general form\n <code>HAVING condition\n</code>\n where condition is the same as specified for the <CodeLiteral>WHERE</CodeLiteral> clause.\n <CodeLiteral>HAVING</CodeLiteral> eliminates group rows that do not satisfy the condition. <CodeLiteral>HAVING</CodeLiteral> is different from <CodeLiteral>WHERE</CodeLiteral>: <CodeLiteral>WHERE</CodeLiteral> filters individual rows before the application of <CodeLiteral>GROUP BY</CodeLiteral>, while <CodeLiteral>HAVING</CodeLiteral> filters group rows created by <CodeLiteral>GROUP BY</CodeLiteral>. Each column referenced in condition must unambiguously reference a grouping column, unless the reference appears within an aggregate function or the ungrouped column is functionally dependent on the grouping columns.\n The presence of <CodeLiteral>HAVING</CodeLiteral> turns a query into a grouped query even if there is no <CodeLiteral>GROUP BY</CodeLiteral> clause. This is the same as what happens when the query contains aggregate functions but no <CodeLiteral>GROUP BY</CodeLiteral> clause. All the selected rows are considered to form a single group, and the SELECT list and <CodeLiteral>HAVING</CodeLiteral> clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the <CodeLiteral>HAVING</CodeLiteral> condition is true, zero rows if it is not true.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified with <CodeLiteral>HAVING</CodeLiteral>. ",
        "Demo": [
            "SELECT COUNT(*) FROM employees HAVING COUNT(*) > 5;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "UNBOUNDED PRECEDING",
            "offset PRECEDING",
            "CURRENT ROW",
            "offset FOLLOWING",
            "UNBOUNDED FOLLOWING"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frame_bound UNBOUNDED PRECEDING)",
            " (frame_bound PRECEDING)",
            " (frame_bound CURRENT ROW)",
            " (frame_bound FOLLOWING)",
            " (frame_bound UNBOUNDED FOLLOWING)"
        ],
        "Route": "",
        "Description": "The optional <CodeLiteral>WINDOW</CodeLiteral> clause has the general form\n <code>WINDOW window_name AS ( window_definition ) [, ...]\n</code>\n where window_name is a name that can be referenced from <CodeLiteral>OVER</CodeLiteral> clauses or subsequent window definitions, and window_definition is\n <code>[ existing_window_name ]\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\n</code>\n If an existing_window_name is specified it must refer to an earlier entry in the <CodeLiteral>WINDOW</CodeLiteral> list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own <CodeLiteral>PARTITION BY</CodeLiteral> clause, and it can specify <CodeLiteral>ORDER BY</CodeLiteral> only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.\n The elements of the <CodeLiteral>PARTITION BY</CodeLiteral> list are interpreted in much the same fashion as elements of a <CodeLiteral>GROUP BY</CodeLiteral> Clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular <CodeLiteral>GROUP BY</CodeLiteral> clause. They are allowed here because windowing occurs after grouping and aggregation.\n Similarly, the elements of the <CodeLiteral>ORDER BY</CodeLiteral> list are interpreted in much the same fashion as elements of an <CodeLiteral>ORDER BY</CodeLiteral> Clause, except that the expressions are always taken as simple expressions and never the name or number of an output column.\n The optional frame_clause defines the window frame for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the current row). The frame_clause can be one of\n <code>{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\n</code>\n where frame_start and frame_end can be one of\n <code>UNBOUNDED PRECEDING\noffset PRECEDING\nCURRENT ROW\noffset FOLLOWING\nUNBOUNDED FOLLOWING\n</code>\n and frame_exclusion can be one of\n <code>EXCLUDE CURRENT ROW\nEXCLUDE GROUP\nEXCLUDE TIES\nEXCLUDE NO OTHERS\n</code>\n If frame_end is omitted it defaults to <CodeLiteral>CURRENT ROW</CodeLiteral>. Restrictions are that frame_start cannot be <CodeLiteral>UNBOUNDED FOLLOWING</CodeLiteral>, frame_end cannot be <CodeLiteral>UNBOUNDED PRECEDING</CodeLiteral>, and the frame_end choice cannot appear earlier in the above list of frame_start and frame_end options than the frame_start choice does \u2014 for example <CodeLiteral>RANGE BETWEEN CURRENT ROW AND offset PRECEDING</CodeLiteral> is not allowed.\n The default framing option is <CodeLiteral>RANGE UNBOUNDED PRECEDING</CodeLiteral>, which is the same as <CodeLiteral>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</CodeLiteral>; it sets the frame to be all rows from the partition start up through the current row's last peer (a row that the window's <CodeLiteral>ORDER BY</CodeLiteral> clause considers equivalent to the current row; all rows are peers if there is no <CodeLiteral>ORDER BY</CodeLiteral>). In general, <CodeLiteral>UNBOUNDED PRECEDING</CodeLiteral> means that the frame starts with the first row of the partition, and similarly <CodeLiteral>UNBOUNDED FOLLOWING</CodeLiteral> means that the frame ends with the last row of the partition, regardless of <CodeLiteral>RANGE</CodeLiteral>, <CodeLiteral>ROWS</CodeLiteral> or <CodeLiteral>GROUPS</CodeLiteral> mode. In <CodeLiteral>ROWS</CodeLiteral> mode, <CodeLiteral>CURRENT ROW</CodeLiteral> means that the frame starts or ends with the current row; but in <CodeLiteral>RANGE</CodeLiteral> or <CodeLiteral>GROUPS</CodeLiteral> mode it means that the frame starts or ends with the current row's first or last peer in the <CodeLiteral>ORDER BY</CodeLiteral> ordering. The offset <CodeLiteral>PRECEDING</CodeLiteral> and offset <CodeLiteral>FOLLOWING</CodeLiteral> options vary in meaning depending on the frame mode. In <CodeLiteral>ROWS</CodeLiteral> mode, the offset is an integer indicating that the frame starts or ends that many rows before or after the current row. In <CodeLiteral>GROUPS</CodeLiteral> mode, the offset is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a peer group is a group of rows that are equivalent according to the window's <CodeLiteral>ORDER BY</CodeLiteral> clause. In <CodeLiteral>RANGE</CodeLiteral> mode, use of an offset option requires that there be exactly one <CodeLiteral>ORDER BY</CodeLiteral> column in the window definition. Then the frame contains those rows whose ordering column value is no more than offset less than (for <CodeLiteral>PRECEDING</CodeLiteral>) or more than (for <CodeLiteral>FOLLOWING</CodeLiteral>) the current row's ordering column value. In these cases the data type of the offset expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an interval. In all these cases, the value of the offset must be non-null and non-negative. Also, while the offset does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.\n The frame_exclusion option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. <CodeLiteral>EXCLUDE CURRENT ROW</CodeLiteral> excludes the current row from the frame. <CodeLiteral>EXCLUDE GROUP</CodeLiteral> excludes the current row and its ordering peers from the frame. <CodeLiteral>EXCLUDE TIES</CodeLiteral> excludes any peers of the current row from the frame, but not the current row itself. <CodeLiteral>EXCLUDE NO OTHERS</CodeLiteral> simply specifies explicitly the default behavior of not excluding the current row or its peers.\n Beware that the <CodeLiteral>ROWS</CodeLiteral> mode can produce unpredictable results if the <CodeLiteral>ORDER BY</CodeLiteral> ordering does not order the rows uniquely. The <CodeLiteral>RANGE</CodeLiteral> and <CodeLiteral>GROUPS</CodeLiteral> modes are designed to ensure that rows that are peers in the <CodeLiteral>ORDER BY</CodeLiteral> ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.\n The purpose of a <CodeLiteral>WINDOW</CodeLiteral> clause is to specify the behavior of window functions appearing in the query's SELECT List or <CodeLiteral>ORDER BY</CodeLiteral> Clause. These functions can reference the <CodeLiteral>WINDOW</CodeLiteral> clause entries by name in their <CodeLiteral>OVER</CodeLiteral> clauses. A <CodeLiteral>WINDOW</CodeLiteral> clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any <CodeLiteral>WINDOW</CodeLiteral> clause at all, since a window function call can specify its window definition directly in its <CodeLiteral>OVER</CodeLiteral> clause. However, the <CodeLiteral>WINDOW</CodeLiteral> clause saves typing when the same window definition is needed for more than one window function.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified with <CodeLiteral>WINDOW</CodeLiteral>.\n Window functions are described in detail in Section 3.5, Section 4.2.8, and Section 7.2.5. ",
        "Demo": [
            "SELECT employee_id, salary, AVG(salary) OVER (PARTITION BY department_id ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_avg_salary FROM employees;",
            "SELECT employee_id, salary, AVG(salary) OVER (ORDER BY department_id ROWS 3 PRECEDING) AS avg_prev_3_salaries FROM employees;",
            "SELECT department, employee_id, salary, AVG(salary) OVER (w) FROM employees WINDOW w AS (PARTITION BY department ORDER BY salary RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)",
            "SELECT employee_id, salary, AVG(salary) OVER (ORDER BY department_id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS avg_salary_next_two FROM employees",
            "SELECT employee_name, department, salary, AVG(salary) OVER (PARTITION BY department ORDER BY salary ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS avg_salary_from_current_to_last FROM employees;"
        ],
        "Count": [
            2,
            1,
            2,
            1,
            2
        ]
    },
    {
        "Keyword": [
            "EXCLUDE CURRENT ROW",
            "EXCLUDE GROUP",
            "EXCLUDE TIES",
            "EXCLUDE NO OTHERS"
        ],
        "Src": "SELECT",
        "Tree": [
            " (opt_window_exclusion_clause EXCLUDE CURRENT ROW)",
            " (opt_window_exclusion_clause EXCLUDE GROUP)",
            " (opt_window_exclusion_clause EXCLUDE TIES)",
            " (opt_window_exclusion_clause EXCLUDE NO OTHERS)"
        ],
        "Route": "",
        "Description": "The optional <CodeLiteral>WINDOW</CodeLiteral> clause has the general form\n <code>WINDOW window_name AS ( window_definition ) [, ...]\n</code>\n where window_name is a name that can be referenced from <CodeLiteral>OVER</CodeLiteral> clauses or subsequent window definitions, and window_definition is\n <code>[ existing_window_name ]\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\n</code>\n If an existing_window_name is specified it must refer to an earlier entry in the <CodeLiteral>WINDOW</CodeLiteral> list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own <CodeLiteral>PARTITION BY</CodeLiteral> clause, and it can specify <CodeLiteral>ORDER BY</CodeLiteral> only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.\n The elements of the <CodeLiteral>PARTITION BY</CodeLiteral> list are interpreted in much the same fashion as elements of a <CodeLiteral>GROUP BY</CodeLiteral> Clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular <CodeLiteral>GROUP BY</CodeLiteral> clause. They are allowed here because windowing occurs after grouping and aggregation.\n Similarly, the elements of the <CodeLiteral>ORDER BY</CodeLiteral> list are interpreted in much the same fashion as elements of an <CodeLiteral>ORDER BY</CodeLiteral> Clause, except that the expressions are always taken as simple expressions and never the name or number of an output column.\n The optional frame_clause defines the window frame for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the current row). The frame_clause can be one of\n <code>{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\n</code>\n where frame_start and frame_end can be one of\n <code>UNBOUNDED PRECEDING\noffset PRECEDING\nCURRENT ROW\noffset FOLLOWING\nUNBOUNDED FOLLOWING\n</code>\n and frame_exclusion can be one of\n <code>EXCLUDE CURRENT ROW\nEXCLUDE GROUP\nEXCLUDE TIES\nEXCLUDE NO OTHERS\n</code>\n If frame_end is omitted it defaults to <CodeLiteral>CURRENT ROW</CodeLiteral>. Restrictions are that frame_start cannot be <CodeLiteral>UNBOUNDED FOLLOWING</CodeLiteral>, frame_end cannot be <CodeLiteral>UNBOUNDED PRECEDING</CodeLiteral>, and the frame_end choice cannot appear earlier in the above list of frame_start and frame_end options than the frame_start choice does \u2014 for example <CodeLiteral>RANGE BETWEEN CURRENT ROW AND offset PRECEDING</CodeLiteral> is not allowed.\n The default framing option is <CodeLiteral>RANGE UNBOUNDED PRECEDING</CodeLiteral>, which is the same as <CodeLiteral>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</CodeLiteral>; it sets the frame to be all rows from the partition start up through the current row's last peer (a row that the window's <CodeLiteral>ORDER BY</CodeLiteral> clause considers equivalent to the current row; all rows are peers if there is no <CodeLiteral>ORDER BY</CodeLiteral>). In general, <CodeLiteral>UNBOUNDED PRECEDING</CodeLiteral> means that the frame starts with the first row of the partition, and similarly <CodeLiteral>UNBOUNDED FOLLOWING</CodeLiteral> means that the frame ends with the last row of the partition, regardless of <CodeLiteral>RANGE</CodeLiteral>, <CodeLiteral>ROWS</CodeLiteral> or <CodeLiteral>GROUPS</CodeLiteral> mode. In <CodeLiteral>ROWS</CodeLiteral> mode, <CodeLiteral>CURRENT ROW</CodeLiteral> means that the frame starts or ends with the current row; but in <CodeLiteral>RANGE</CodeLiteral> or <CodeLiteral>GROUPS</CodeLiteral> mode it means that the frame starts or ends with the current row's first or last peer in the <CodeLiteral>ORDER BY</CodeLiteral> ordering. The offset <CodeLiteral>PRECEDING</CodeLiteral> and offset <CodeLiteral>FOLLOWING</CodeLiteral> options vary in meaning depending on the frame mode. In <CodeLiteral>ROWS</CodeLiteral> mode, the offset is an integer indicating that the frame starts or ends that many rows before or after the current row. In <CodeLiteral>GROUPS</CodeLiteral> mode, the offset is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a peer group is a group of rows that are equivalent according to the window's <CodeLiteral>ORDER BY</CodeLiteral> clause. In <CodeLiteral>RANGE</CodeLiteral> mode, use of an offset option requires that there be exactly one <CodeLiteral>ORDER BY</CodeLiteral> column in the window definition. Then the frame contains those rows whose ordering column value is no more than offset less than (for <CodeLiteral>PRECEDING</CodeLiteral>) or more than (for <CodeLiteral>FOLLOWING</CodeLiteral>) the current row's ordering column value. In these cases the data type of the offset expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an interval. In all these cases, the value of the offset must be non-null and non-negative. Also, while the offset does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.\n The frame_exclusion option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. <CodeLiteral>EXCLUDE CURRENT ROW</CodeLiteral> excludes the current row from the frame. <CodeLiteral>EXCLUDE GROUP</CodeLiteral> excludes the current row and its ordering peers from the frame. <CodeLiteral>EXCLUDE TIES</CodeLiteral> excludes any peers of the current row from the frame, but not the current row itself. <CodeLiteral>EXCLUDE NO OTHERS</CodeLiteral> simply specifies explicitly the default behavior of not excluding the current row or its peers.\n Beware that the <CodeLiteral>ROWS</CodeLiteral> mode can produce unpredictable results if the <CodeLiteral>ORDER BY</CodeLiteral> ordering does not order the rows uniquely. The <CodeLiteral>RANGE</CodeLiteral> and <CodeLiteral>GROUPS</CodeLiteral> modes are designed to ensure that rows that are peers in the <CodeLiteral>ORDER BY</CodeLiteral> ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.\n The purpose of a <CodeLiteral>WINDOW</CodeLiteral> clause is to specify the behavior of window functions appearing in the query's SELECT List or <CodeLiteral>ORDER BY</CodeLiteral> Clause. These functions can reference the <CodeLiteral>WINDOW</CodeLiteral> clause entries by name in their <CodeLiteral>OVER</CodeLiteral> clauses. A <CodeLiteral>WINDOW</CodeLiteral> clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any <CodeLiteral>WINDOW</CodeLiteral> clause at all, since a window function call can specify its window definition directly in its <CodeLiteral>OVER</CodeLiteral> clause. However, the <CodeLiteral>WINDOW</CodeLiteral> clause saves typing when the same window definition is needed for more than one window function.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified with <CodeLiteral>WINDOW</CodeLiteral>.\n Window functions are described in detail in Section 3.5, Section 4.2.8, and Section 7.2.5. ",
        "Demo": [
            "SELECT employee_id, salary, AVG(salary) OVER (PARTITION BY department_id ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE CURRENT ROW) AS avg_previous_salaries FROM employees;",
            "SELECT employee_id, department, SUM(salary) OVER w AS department_total_salary FROM employees WINDOW w AS (PARTITION BY department ORDER BY salary RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE GROUP)",
            "",
            "SELECT employee_id, salary, AVG(salary) OVER (PARTITION BY department_id ORDER BY salary RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE NO OTHERS) AS running_avg_salary FROM employees;"
        ],
        "Count": [
            3,
            2,
            2,
            3
        ]
    },
    {
        "Keyword": [
            "WINDOW window_name AS ( existing_window_name ) ",
            "WINDOW window_name AS ( PARTITION BY expression ) ",
            "WINDOW window_name AS ( ORDER BY expression ASC ) ",
            "WINDOW window_name AS ( ORDER BY expression DESC ) ",
            "WINDOW window_name AS ( ORDER BY expression USING operator ) ",
            "WINDOW window_name AS ( ORDER BY expression NULLS FIRST ) ",
            "WINDOW window_name AS ( ORDER BY expression NULLS LAST ) ",
            "WINDOW window_name AS ( ORDER BY expression ) ",
            "WINDOW window_name AS ( RANGE frame_start ) ",
            "WINDOW window_name AS ( ROWS frame_start ) ",
            "WINDOW window_name AS ( GROUPS frame_start ) ",
            "WINDOW window_name AS ( RANGE BETWEEN frame_start AND frame_end ) ",
            "WINDOW window_name AS ( ROWS BETWEEN frame_start AND frame_end ) ",
            "WINDOW window_name AS ( GROUPS BETWEEN frame_start AND frame_end ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification ( )))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_partition_clause PARTITION BY)))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_sort_clause (sort_clause ORDER BY (sortby_list (sortby (opt_asc_desc ASC)))))))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_sort_clause (sort_clause ORDER BY (sortby_list (sortby (opt_asc_desc DESC)))))))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_sort_clause (sort_clause ORDER BY (sortby_list (sortby USING))))))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_sort_clause (sort_clause ORDER BY (sortby_list (sortby (opt_nulls_order NULLS FIRST)))))))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_sort_clause (sort_clause ORDER BY (sortby_list (sortby (opt_nulls_order NULLS LAST)))))))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_sort_clause (sort_clause ORDER BY))))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_frame_clause RANGE)))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_frame_clause ROWS)))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_frame_clause GROUPS)))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_frame_clause RANGE (frame_extent BETWEEN AND))))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_frame_clause ROWS (frame_extent BETWEEN AND))))))",
            " (window_clause WINDOW (window_definition_list (window_definition AS (window_specification (opt_frame_clause GROUPS (frame_extent BETWEEN AND))))))"
        ],
        "Route": "",
        "Description": "The optional <CodeLiteral>WINDOW</CodeLiteral> clause has the general form\n <code>WINDOW window_name AS ( window_definition ) [, ...]\n</code>\n where window_name is a name that can be referenced from <CodeLiteral>OVER</CodeLiteral> clauses or subsequent window definitions, and window_definition is\n <code>[ existing_window_name ]\n[ PARTITION BY expression [, ...] ]\n[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]\n[ frame_clause ]\n</code>\n If an existing_window_name is specified it must refer to an earlier entry in the <CodeLiteral>WINDOW</CodeLiteral> list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own <CodeLiteral>PARTITION BY</CodeLiteral> clause, and it can specify <CodeLiteral>ORDER BY</CodeLiteral> only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.\n The elements of the <CodeLiteral>PARTITION BY</CodeLiteral> list are interpreted in much the same fashion as elements of a <CodeLiteral>GROUP BY</CodeLiteral> Clause, except that they are always simple expressions and never the name or number of an output column. Another difference is that these expressions can contain aggregate function calls, which are not allowed in a regular <CodeLiteral>GROUP BY</CodeLiteral> clause. They are allowed here because windowing occurs after grouping and aggregation.\n Similarly, the elements of the <CodeLiteral>ORDER BY</CodeLiteral> list are interpreted in much the same fashion as elements of an <CodeLiteral>ORDER BY</CodeLiteral> Clause, except that the expressions are always taken as simple expressions and never the name or number of an output column.\n The optional frame_clause defines the window frame for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the current row). The frame_clause can be one of\n <code>{ RANGE | ROWS | GROUPS } frame_start [ frame_exclusion ]\n{ RANGE | ROWS | GROUPS } BETWEEN frame_start AND frame_end [ frame_exclusion ]\n</code>\n where frame_start and frame_end can be one of\n <code>UNBOUNDED PRECEDING\noffset PRECEDING\nCURRENT ROW\noffset FOLLOWING\nUNBOUNDED FOLLOWING\n</code>\n and frame_exclusion can be one of\n <code>EXCLUDE CURRENT ROW\nEXCLUDE GROUP\nEXCLUDE TIES\nEXCLUDE NO OTHERS\n</code>\n If frame_end is omitted it defaults to <CodeLiteral>CURRENT ROW</CodeLiteral>. Restrictions are that frame_start cannot be <CodeLiteral>UNBOUNDED FOLLOWING</CodeLiteral>, frame_end cannot be <CodeLiteral>UNBOUNDED PRECEDING</CodeLiteral>, and the frame_end choice cannot appear earlier in the above list of frame_start and frame_end options than the frame_start choice does \u2014 for example <CodeLiteral>RANGE BETWEEN CURRENT ROW AND offset PRECEDING</CodeLiteral> is not allowed.\n The default framing option is <CodeLiteral>RANGE UNBOUNDED PRECEDING</CodeLiteral>, which is the same as <CodeLiteral>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</CodeLiteral>; it sets the frame to be all rows from the partition start up through the current row's last peer (a row that the window's <CodeLiteral>ORDER BY</CodeLiteral> clause considers equivalent to the current row; all rows are peers if there is no <CodeLiteral>ORDER BY</CodeLiteral>). In general, <CodeLiteral>UNBOUNDED PRECEDING</CodeLiteral> means that the frame starts with the first row of the partition, and similarly <CodeLiteral>UNBOUNDED FOLLOWING</CodeLiteral> means that the frame ends with the last row of the partition, regardless of <CodeLiteral>RANGE</CodeLiteral>, <CodeLiteral>ROWS</CodeLiteral> or <CodeLiteral>GROUPS</CodeLiteral> mode. In <CodeLiteral>ROWS</CodeLiteral> mode, <CodeLiteral>CURRENT ROW</CodeLiteral> means that the frame starts or ends with the current row; but in <CodeLiteral>RANGE</CodeLiteral> or <CodeLiteral>GROUPS</CodeLiteral> mode it means that the frame starts or ends with the current row's first or last peer in the <CodeLiteral>ORDER BY</CodeLiteral> ordering. The offset <CodeLiteral>PRECEDING</CodeLiteral> and offset <CodeLiteral>FOLLOWING</CodeLiteral> options vary in meaning depending on the frame mode. In <CodeLiteral>ROWS</CodeLiteral> mode, the offset is an integer indicating that the frame starts or ends that many rows before or after the current row. In <CodeLiteral>GROUPS</CodeLiteral> mode, the offset is an integer indicating that the frame starts or ends that many peer groups before or after the current row's peer group, where a peer group is a group of rows that are equivalent according to the window's <CodeLiteral>ORDER BY</CodeLiteral> clause. In <CodeLiteral>RANGE</CodeLiteral> mode, use of an offset option requires that there be exactly one <CodeLiteral>ORDER BY</CodeLiteral> column in the window definition. Then the frame contains those rows whose ordering column value is no more than offset less than (for <CodeLiteral>PRECEDING</CodeLiteral>) or more than (for <CodeLiteral>FOLLOWING</CodeLiteral>) the current row's ordering column value. In these cases the data type of the offset expression depends on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an interval. In all these cases, the value of the offset must be non-null and non-negative. Also, while the offset does not have to be a simple constant, it cannot contain variables, aggregate functions, or window functions.\n The frame_exclusion option allows rows around the current row to be excluded from the frame, even if they would be included according to the frame start and frame end options. <CodeLiteral>EXCLUDE CURRENT ROW</CodeLiteral> excludes the current row from the frame. <CodeLiteral>EXCLUDE GROUP</CodeLiteral> excludes the current row and its ordering peers from the frame. <CodeLiteral>EXCLUDE TIES</CodeLiteral> excludes any peers of the current row from the frame, but not the current row itself. <CodeLiteral>EXCLUDE NO OTHERS</CodeLiteral> simply specifies explicitly the default behavior of not excluding the current row or its peers.\n Beware that the <CodeLiteral>ROWS</CodeLiteral> mode can produce unpredictable results if the <CodeLiteral>ORDER BY</CodeLiteral> ordering does not order the rows uniquely. The <CodeLiteral>RANGE</CodeLiteral> and <CodeLiteral>GROUPS</CodeLiteral> modes are designed to ensure that rows that are peers in the <CodeLiteral>ORDER BY</CodeLiteral> ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.\n The purpose of a <CodeLiteral>WINDOW</CodeLiteral> clause is to specify the behavior of window functions appearing in the query's SELECT List or <CodeLiteral>ORDER BY</CodeLiteral> Clause. These functions can reference the <CodeLiteral>WINDOW</CodeLiteral> clause entries by name in their <CodeLiteral>OVER</CodeLiteral> clauses. A <CodeLiteral>WINDOW</CodeLiteral> clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any <CodeLiteral>WINDOW</CodeLiteral> clause at all, since a window function call can specify its window definition directly in its <CodeLiteral>OVER</CodeLiteral> clause. However, the <CodeLiteral>WINDOW</CodeLiteral> clause saves typing when the same window definition is needed for more than one window function.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified with <CodeLiteral>WINDOW</CodeLiteral>.\n Window functions are described in detail in Section 3.5, Section 4.2.8, and Section 7.2.5. ",
        "Demo": [
            "SELECT employee_id, salary, AVG(salary) OVER w FROM employees WINDOW w AS (PARTITION BY department ORDER BY salary ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)",
            "SELECT employee_id, department, COUNT(employee_id) OVER w AS dept_employees\nFROM employees\nWINDOW w AS (PARTITION BY department);",
            "SELECT employee_id, salary, AVG(salary) OVER my_window FROM employees WINDOW my_window AS (ORDER BY department_id ASC);",
            "SELECT emp_id, salary, AVG(salary) OVER w AS avg_salary FROM employees WINDOW w AS (ORDER BY salary DESC)",
            "SELECT employee_id, department_id, salary, AVG(salary) OVER w AS avg_salary FROM employees WINDOW w AS (ORDER BY department_id USING >) ORDER BY department_id;",
            "SELECT employee_id, salary, AVG(salary) OVER w AS average_salary FROM employees WINDOW w AS (ORDER BY department_id NULLS FIRST)",
            "SELECT employee_id, salary, AVG(salary) OVER w AS avg_salary FROM employees WINDOW w AS (ORDER BY department_id NULLS LAST)",
            "SELECT employee_name, salary, AVG(salary) OVER w AS average_salary FROM employees WINDOW w AS (ORDER BY department_id) ORDER BY department_id;",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "Count": [
            4,
            4,
            5,
            5,
            5,
            6,
            6,
            4,
            3,
            3,
            3,
            5,
            5,
            5
        ]
    },
    {
        "Keyword": [
            "expression AS output_name"
        ],
        "Src": "SELECT",
        "Tree": [
            "(target_el AS)"
        ],
        "Route": "",
        "Description": "The SELECT list (between the key words <CodeLiteral>SELECT</CodeLiteral> and <CodeLiteral>FROM</CodeLiteral>) specifies expressions that form the output rows of the SELECT statement. The expressions can (and usually do) refer to columns computed in the <CodeLiteral>FROM</CodeLiteral> clause.\n Just as in a table, every output column of a SELECT has a name. In a simple SELECT this name is just used to label the column for display, but when the SELECT is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write <CodeLiteral>AS</CodeLiteral> output_name after the column's expression. (You can omit <CodeLiteral>AS</CodeLiteral>, but only if the desired output name does not match any PostgreSQL keyword (see Appendix C). For protection against possible future keyword additions, it is recommended that you always either write <CodeLiteral>AS</CodeLiteral> or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as <CodeLiteral>?column?</CodeLiteral>.\n An output column's name can be used to refer to the column's value in <CodeLiteral>ORDER BY</CodeLiteral> and <CodeLiteral>GROUP BY</CodeLiteral> clauses, but not in the <CodeLiteral>WHERE</CodeLiteral> or <CodeLiteral>HAVING</CodeLiteral> clauses; there you must write out the expression instead.\n Instead of an expression, <CodeLiteral>*</CodeLiteral> can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write <CodeLiteral>table_name.*</CodeLiteral> as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with <CodeLiteral>AS</CodeLiteral>; the output column names will be the same as the table columns' names.\n According to the SQL standard, the expressions in the output list should be computed before applying <CodeLiteral>DISTINCT</CodeLiteral>, <CodeLiteral>ORDER BY</CodeLiteral>, or <CodeLiteral>LIMIT</CodeLiteral>. This is obviously necessary when using <CodeLiteral>DISTINCT</CodeLiteral>, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after <CodeLiteral>ORDER BY</CodeLiteral> and <CodeLiteral>LIMIT</CodeLiteral>; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. PostgreSQL will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in <CodeLiteral>DISTINCT</CodeLiteral>, <CodeLiteral>ORDER BY</CodeLiteral> or <CodeLiteral>GROUP BY</CodeLiteral>. (As a counterexample, <CodeLiteral>SELECT f(x) FROM tab ORDER BY 1</CodeLiteral> clearly must evaluate f(x) before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that <CodeLiteral>LIMIT</CodeLiteral> will act to cut off the output from a set-returning function.\n \n  <ClauseName>Note</ClauseName>\n  PostgreSQL versions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan. ",
        "Demo": [
            "SELECT first_name || ' ' || last_name AS full_name FROM employees;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "DISTINCT ON ( expression ) ",
            "DISTINCT"
        ],
        "Src": "SELECT",
        "Tree": [
            " (distinct_clause DISTINCT ON ( ))",
            " (distinct_clause DISTINCT)"
        ],
        "Route": "",
        "Description": "If <CodeLiteral>SELECT DISTINCT</CodeLiteral> is specified, all duplicate rows are removed from the result set (one row is kept from each group of duplicates). <CodeLiteral>SELECT ALL</CodeLiteral> specifies the opposite: all rows are kept; that is the default.\n <CodeLiteral>SELECT DISTINCT ON ( expression [, ...] )</CodeLiteral> keeps only the first row of each set of rows where the given expressions evaluate to equal. The <CodeLiteral>DISTINCT ON</CodeLiteral> expressions are interpreted using the same rules as for <CodeLiteral>ORDER BY</CodeLiteral> (see above). Note that the \u201cfirst row\u201d of each set is unpredictable unless <CodeLiteral>ORDER BY</CodeLiteral> is used to ensure that the desired row appears first. For example:\n <code>SELECT DISTINCT ON (location) location, time, report\n FROM weather_reports\n ORDER BY location, time DESC;\n</code>\n retrieves the most recent weather report for each location. But if we had not used <CodeLiteral>ORDER BY</CodeLiteral> to force descending order of time values for each location, we'd have gotten a report from an unpredictable time for each location.\n The <CodeLiteral>DISTINCT ON</CodeLiteral> expression(s) must match the leftmost <CodeLiteral>ORDER BY</CodeLiteral> expression(s). The <CodeLiteral>ORDER BY</CodeLiteral> clause will normally contain additional expression(s) that determine the desired precedence of rows within each <CodeLiteral>DISTINCT ON</CodeLiteral> group.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified with <CodeLiteral>DISTINCT</CodeLiteral>. ",
        "Demo": [
            "SELECT DISTINCT ON (department) department, max(salary) AS max_salary FROM employees ORDER BY department, salary DESC;",
            "SELECT DISTINCT name FROM employees;"
        ],
        "Count": [
            4,
            1
        ]
    },
    {
        "Keyword": [
            "UNION ALL select",
            "UNION DISTINCT select",
            "UNION select"
        ],
        "Src": "SELECT",
        "Tree": [
            " (select_clause UNION (all_or_distinct ALL))",
            " (select_clause UNION (all_or_distinct DISTINCT))",
            " (select_clause UNION)"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>UNION</CodeLiteral> clause has this general form:\n <code>select_statement UNION [ ALL | DISTINCT ] select_statement\n</code>\n select_statement is any SELECT statement without an <CodeLiteral>ORDER BY</CodeLiteral>, <CodeLiteral>LIMIT</CodeLiteral>, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral>, or <CodeLiteral>FOR KEY SHARE</CodeLiteral> clause. (<CodeLiteral>ORDER BY</CodeLiteral> and <CodeLiteral>LIMIT</CodeLiteral> can be attached to a subexpression if it is enclosed in parentheses. Without parentheses, these clauses will be taken to apply to the result of the <CodeLiteral>UNION</CodeLiteral>, not to its right-hand input expression.)\n The <CodeLiteral>UNION</CodeLiteral> operator computes the set union of the rows returned by the involved SELECT statements. A row is in the set union of two result sets if it appears in at least one of the result sets. The two SELECT statements that represent the direct operands of the <CodeLiteral>UNION</CodeLiteral> must produce the same number of columns, and corresponding columns must be of compatible data types.\n The result of <CodeLiteral>UNION</CodeLiteral> does not contain any duplicate rows unless the <CodeLiteral>ALL</CodeLiteral> option is specified. <CodeLiteral>ALL</CodeLiteral> prevents elimination of duplicates. (Therefore, <CodeLiteral>UNION ALL</CodeLiteral> is usually significantly quicker than <CodeLiteral>UNION</CodeLiteral>; use <CodeLiteral>ALL</CodeLiteral> when you can.) <CodeLiteral>DISTINCT</CodeLiteral> can be written to explicitly specify the default behavior of eliminating duplicate rows.\n Multiple <CodeLiteral>UNION</CodeLiteral> operators in the same SELECT statement are evaluated left to right, unless otherwise indicated by parentheses.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified either for a <CodeLiteral>UNION</CodeLiteral> result or for any input of a <CodeLiteral>UNION</CodeLiteral>. ",
        "Demo": [
            "SELECT 'Apples' AS Fruit UNION ALL SELECT 'Oranges';",
            "SELECT 1 AS number UNION DISTINCT SELECT 1 AS number;",
            "SELECT 'Apple' AS Fruit UNION SELECT 'Banana' AS Fruit;"
        ],
        "Count": [
            2,
            2,
            1
        ]
    },
    {
        "Keyword": [
            "INTERSECT ALL select",
            "INTERSECT DISTINCT select",
            "INTERSECT select"
        ],
        "Src": "SELECT",
        "Tree": [
            " (simple_select_intersect INTERSECT (all_or_distinct ALL))",
            " (simple_select_intersect INTERSECT (all_or_distinct DISTINCT))",
            " (simple_select_intersect INTERSECT)"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>INTERSECT</CodeLiteral> clause has this general form:\n <code>select_statement INTERSECT [ ALL | DISTINCT ] select_statement\n</code>\n select_statement is any SELECT statement without an <CodeLiteral>ORDER BY</CodeLiteral>, <CodeLiteral>LIMIT</CodeLiteral>, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral>, or <CodeLiteral>FOR KEY SHARE</CodeLiteral> clause.\n The <CodeLiteral>INTERSECT</CodeLiteral> operator computes the set intersection of the rows returned by the involved SELECT statements. A row is in the intersection of two result sets if it appears in both result sets.\n The result of <CodeLiteral>INTERSECT</CodeLiteral> does not contain any duplicate rows unless the <CodeLiteral>ALL</CodeLiteral> option is specified. With <CodeLiteral>ALL</CodeLiteral>, a row that has m duplicates in the left table and n duplicates in the right table will appear min(m,n) times in the result set. <CodeLiteral>DISTINCT</CodeLiteral> can be written to explicitly specify the default behavior of eliminating duplicate rows.\n Multiple <CodeLiteral>INTERSECT</CodeLiteral> operators in the same SELECT statement are evaluated left to right, unless parentheses dictate otherwise. <CodeLiteral>INTERSECT</CodeLiteral> binds more tightly than <CodeLiteral>UNION</CodeLiteral>. That is, <CodeLiteral>A UNION B INTERSECT C</CodeLiteral> will be read as <CodeLiteral>A UNION (B INTERSECT C)</CodeLiteral>.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified either for an <CodeLiteral>INTERSECT</CodeLiteral> result or for any input of an <CodeLiteral>INTERSECT</CodeLiteral>. ",
        "Demo": [
            "SELECT id, name FROM employees WHERE department = 'Sales' INTERSECT ALL SELECT id, name FROM employees WHERE location = 'New York';",
            "SELECT id, name FROM employee WHERE department = 'Sales' INTERSECT DISTINCT SELECT id, name FROM employee WHERE location = 'New York'",
            "SELECT id, name FROM employees WHERE department = 'Sales' INTERSECT SELECT id, name FROM employees WHERE location = 'New York'"
        ],
        "Count": [
            2,
            2,
            1
        ]
    },
    {
        "Keyword": [
            "select_statement EXCEPT ALL select_statement",
            "select_statement EXCEPT DISTINCT select_statement",
            "select_statement EXCEPT select_statement"
        ],
        "Src": "SELECT",
        "Tree": [
            " (select_clause EXCEPT (all_or_distinct ALL))",
            " (select_clause EXCEPT (all_or_distinct DISTINCT))",
            " (select_clause EXCEPT)"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>EXCEPT</CodeLiteral> clause has this general form:\n <code>select_statement EXCEPT [ ALL | DISTINCT ] select_statement\n</code>\n select_statement is any SELECT statement without an <CodeLiteral>ORDER BY</CodeLiteral>, <CodeLiteral>LIMIT</CodeLiteral>, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral>, or <CodeLiteral>FOR KEY SHARE</CodeLiteral> clause.\n The <CodeLiteral>EXCEPT</CodeLiteral> operator computes the set of rows that are in the result of the left SELECT statement but not in the result of the right one.\n The result of <CodeLiteral>EXCEPT</CodeLiteral> does not contain any duplicate rows unless the <CodeLiteral>ALL</CodeLiteral> option is specified. With <CodeLiteral>ALL</CodeLiteral>, a row that has m duplicates in the left table and n duplicates in the right table will appear max(m-n,0) times in the result set. <CodeLiteral>DISTINCT</CodeLiteral> can be written to explicitly specify the default behavior of eliminating duplicate rows.\n Multiple <CodeLiteral>EXCEPT</CodeLiteral> operators in the same SELECT statement are evaluated left to right, unless parentheses dictate otherwise. <CodeLiteral>EXCEPT</CodeLiteral> binds at the same level as <CodeLiteral>UNION</CodeLiteral>.\n Currently, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> cannot be specified either for an <CodeLiteral>EXCEPT</CodeLiteral> result or for any input of an <CodeLiteral>EXCEPT</CodeLiteral>. ",
        "Demo": [
            "SELECT id, name FROM employees EXCEPT ALL SELECT id, name FROM managers",
            "SELECT 1 AS value EXCEPT DISTINCT SELECT 1 AS value;",
            "SELECT id, name FROM employees EXCEPT SELECT id, name FROM managers"
        ],
        "Count": [
            2,
            2,
            1
        ]
    },
    {
        "Keyword": [
            "ORDER BY expression ASC",
            "ORDER BY expression DESC",
            "ORDER BY expression USING operator",
            "ORDER BY expression NULLS FIRST",
            "ORDER BY expression NULLS LAST",
            "ORDER BY expression"
        ],
        "Src": "SELECT",
        "Tree": [
            " (sort_clause ORDER BY (sortby_list (sortby (opt_asc_desc ASC))))",
            " (sort_clause ORDER BY (sortby_list (sortby (opt_asc_desc DESC))))",
            " (sort_clause ORDER BY (sortby_list (sortby USING)))",
            " (sort_clause ORDER BY (sortby_list (sortby (opt_nulls_order NULLS FIRST))))",
            " (sort_clause ORDER BY (sortby_list (sortby (opt_nulls_order NULLS LAST))))",
            " (sort_clause ORDER BY)"
        ],
        "Route": "",
        "Description": "The optional <CodeLiteral>ORDER BY</CodeLiteral> clause has this general form:\n <code>ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...]\n</code>\n The <CodeLiteral>ORDER BY</CodeLiteral> clause causes the result rows to be sorted according to the specified expression(s). If two rows are equal according to the leftmost expression, they are compared according to the next expression and so on. If they are equal according to all specified expressions, they are returned in an implementation-dependent order.\n Each expression can be the name or ordinal number of an output column (SELECT list item), or it can be an arbitrary expression formed from input-column values.\n The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the <CodeLiteral>AS</CodeLiteral> clause.\n It is also possible to use arbitrary expressions in the <CodeLiteral>ORDER BY</CodeLiteral> clause, including columns that do not appear in the SELECT output list. Thus the following statement is valid:\n <code>SELECT name FROM distributors ORDER BY code;\n</code>\n A limitation of this feature is that an <CodeLiteral>ORDER BY</CodeLiteral> clause applying to the result of a <CodeLiteral>UNION</CodeLiteral>, <CodeLiteral>INTERSECT</CodeLiteral>, or <CodeLiteral>EXCEPT</CodeLiteral> clause can only specify an output column name or number, not an expression.\n If an <CodeLiteral>ORDER BY</CodeLiteral> expression is a simple name that matches both an output column name and an input column name, <CodeLiteral>ORDER BY</CodeLiteral> will interpret it as the output column name. This is the opposite of the choice that <CodeLiteral>GROUP BY</CodeLiteral> will make in the same situation. This inconsistency is made to be compatible with the SQL standard.\n Optionally one can add the key word <CodeLiteral>ASC</CodeLiteral> (ascending) or <CodeLiteral>DESC</CodeLiteral> (descending) after any expression in the <CodeLiteral>ORDER BY</CodeLiteral> clause. If not specified, <CodeLiteral>ASC</CodeLiteral> is assumed by default. Alternatively, a specific ordering operator name can be specified in the <CodeLiteral>USING</CodeLiteral> clause. An ordering operator must be a less-than or greater-than member of some B-tree operator family. <CodeLiteral>ASC</CodeLiteral> is usually equivalent to <CodeLiteral>USING <</CodeLiteral> and <CodeLiteral>DESC</CodeLiteral> is usually equivalent to <CodeLiteral>USING ></CodeLiteral>. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)\n If <CodeLiteral>NULLS LAST</CodeLiteral> is specified, null values sort after all non-null values; if <CodeLiteral>NULLS FIRST</CodeLiteral> is specified, null values sort before all non-null values. If neither is specified, the default behavior is <CodeLiteral>NULLS LAST</CodeLiteral> when <CodeLiteral>ASC</CodeLiteral> is specified or implied, and <CodeLiteral>NULLS FIRST</CodeLiteral> when <CodeLiteral>DESC</CodeLiteral> is specified (thus, the default is to act as though nulls are larger than non-nulls). When <CodeLiteral>USING</CodeLiteral> is specified, the default nulls ordering depends on whether the operator is a less-than or greater-than operator.\n Note that ordering options apply only to the expression they follow; for example <CodeLiteral>ORDER BY x, y DESC</CodeLiteral> does not mean the same thing as <CodeLiteral>ORDER BY x DESC, y DESC</CodeLiteral>.\n Character-string data is sorted according to the collation that applies to the column being sorted. That can be overridden at need by including a <CodeLiteral>COLLATE</CodeLiteral> clause in the expression, for example <CodeLiteral>ORDER BY mycolumn COLLATE \"en_US\"</CodeLiteral>. For more information see Section 4.2.10 and Section 23.2. ",
        "Demo": [
            "SELECT name, age FROM people ORDER BY age ASC;",
            "SELECT id, name FROM employees ORDER BY name DESC;",
            "SELECT name FROM employees ORDER BY name USING <",
            "SELECT employee_id, name, age FROM employees ORDER BY age NULLS FIRST;",
            "SELECT id, name FROM employees ORDER BY salary NULLS LAST;",
            "SELECT * FROM employees ORDER BY last_name ASC, hire_date DESC NULLS LAST;"
        ],
        "Count": [
            3,
            3,
            3,
            4,
            4,
            2
        ]
    },
    {
        "Keyword": [
            "LIMIT count",
            "LIMIT count",
            "LIMIT ALL",
            "LIMIT ALL"
        ],
        "Src": "SELECT",
        "Tree": [
            " (select_no_parens (opt_select_limit (select_limit (limit_clause LIMIT))))",
            " (select_no_parens (select_limit (limit_clause LIMIT)))",
            " (select_no_parens (opt_select_limit (select_limit (limit_clause LIMIT (select_limit_value ALL)))))",
            " (select_no_parens (select_limit (limit_clause LIMIT (select_limit_value ALL))))"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LIMIT</CodeLiteral> clause consists of two independent sub-clauses:\n <code>LIMIT { count | ALL }\nOFFSET start\n</code>\n count specifies the maximum number of rows to return, while start specifies the number of rows to skip before starting to return rows. When both are specified, start rows are skipped before starting to count the count rows to be returned.\n If the count expression evaluates to NULL, it is treated as <CodeLiteral>LIMIT ALL</CodeLiteral>, i.e., no limit. If start evaluates to NULL, it is treated the same as <CodeLiteral>OFFSET 0</CodeLiteral>.\n SQL:2008 introduced a different syntax to achieve the same result, which PostgreSQL also supports. It is:\n <code>OFFSET start { ROW | ROWS }\nFETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY\n</code>\n In this syntax, the start or count value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If count is omitted in a <CodeLiteral>FETCH</CodeLiteral> clause, it defaults to 1. <CodeLiteral>ROW</CodeLiteral> and <CodeLiteral>ROWS</CodeLiteral> as well as <CodeLiteral>FIRST</CodeLiteral> and <CodeLiteral>NEXT</CodeLiteral> are noise words that don't influence the effects of these clauses. According to the standard, the <CodeLiteral>OFFSET</CodeLiteral> clause must come before the <CodeLiteral>FETCH</CodeLiteral> clause if both are present; but PostgreSQL is laxer and allows either order.\n When using <CodeLiteral>LIMIT</CodeLiteral>, it is a good idea to use an <CodeLiteral>ORDER BY</CodeLiteral> clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows \u2014 you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify <CodeLiteral>ORDER BY</CodeLiteral>.\n The query planner takes <CodeLiteral>LIMIT</CodeLiteral> into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for <CodeLiteral>LIMIT</CodeLiteral> and <CodeLiteral>OFFSET</CodeLiteral>. Thus, using different <CodeLiteral>LIMIT</CodeLiteral>/<CodeLiteral>OFFSET</CodeLiteral> values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with <CodeLiteral>ORDER BY</CodeLiteral>. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless <CodeLiteral>ORDER BY</CodeLiteral> is used to constrain the order.\n It is even possible for repeated executions of the same <CodeLiteral>LIMIT</CodeLiteral> query to return different subsets of the rows of a table, if there is not an <CodeLiteral>ORDER BY</CodeLiteral> to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case. ",
        "Demo": [
            "SELECT * FROM employees ORDER BY employee_id LIMIT 5 OFFSET 3",
            "SELECT * FROM employees ORDER BY employee_id LIMIT 5 OFFSET 3",
            "SELECT * FROM employees ORDER BY employee_id LIMIT ALL;",
            "SELECT * FROM employees ORDER BY employee_id LIMIT ALL;"
        ],
        "Count": [
            1,
            1,
            2,
            2
        ]
    },
    {
        "Keyword": [
            "OFFSET start ROW",
            "OFFSET start ROWS",
            "OFFSET start",
            "OFFSET start ROW",
            "OFFSET start ROWS",
            "OFFSET start"
        ],
        "Src": "SELECT",
        "Tree": [
            " (select_no_parens (opt_select_limit (select_limit (offset_clause OFFSET (row_or_rows ROW)))))",
            " (select_no_parens (opt_select_limit (select_limit (offset_clause OFFSET (row_or_rows ROWS)))))",
            " (select_no_parens (opt_select_limit (select_limit (offset_clause OFFSET))))",
            " (select_no_parens (select_limit (offset_clause OFFSET (row_or_rows ROW))))",
            " (select_no_parens (select_limit (offset_clause OFFSET (row_or_rows ROWS))))",
            " (select_no_parens (select_limit (offset_clause OFFSET)))"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LIMIT</CodeLiteral> clause consists of two independent sub-clauses:\n <code>LIMIT { count | ALL }\nOFFSET start\n</code>\n count specifies the maximum number of rows to return, while start specifies the number of rows to skip before starting to return rows. When both are specified, start rows are skipped before starting to count the count rows to be returned.\n If the count expression evaluates to NULL, it is treated as <CodeLiteral>LIMIT ALL</CodeLiteral>, i.e., no limit. If start evaluates to NULL, it is treated the same as <CodeLiteral>OFFSET 0</CodeLiteral>.\n SQL:2008 introduced a different syntax to achieve the same result, which PostgreSQL also supports. It is:\n <code>OFFSET start { ROW | ROWS }\nFETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY\n</code>\n In this syntax, the start or count value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If count is omitted in a <CodeLiteral>FETCH</CodeLiteral> clause, it defaults to 1. <CodeLiteral>ROW</CodeLiteral> and <CodeLiteral>ROWS</CodeLiteral> as well as <CodeLiteral>FIRST</CodeLiteral> and <CodeLiteral>NEXT</CodeLiteral> are noise words that don't influence the effects of these clauses. According to the standard, the <CodeLiteral>OFFSET</CodeLiteral> clause must come before the <CodeLiteral>FETCH</CodeLiteral> clause if both are present; but PostgreSQL is laxer and allows either order.\n When using <CodeLiteral>LIMIT</CodeLiteral>, it is a good idea to use an <CodeLiteral>ORDER BY</CodeLiteral> clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows \u2014 you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify <CodeLiteral>ORDER BY</CodeLiteral>.\n The query planner takes <CodeLiteral>LIMIT</CodeLiteral> into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for <CodeLiteral>LIMIT</CodeLiteral> and <CodeLiteral>OFFSET</CodeLiteral>. Thus, using different <CodeLiteral>LIMIT</CodeLiteral>/<CodeLiteral>OFFSET</CodeLiteral> values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with <CodeLiteral>ORDER BY</CodeLiteral>. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless <CodeLiteral>ORDER BY</CodeLiteral> is used to constrain the order.\n It is even possible for repeated executions of the same <CodeLiteral>LIMIT</CodeLiteral> query to return different subsets of the rows of a table, if there is not an <CodeLiteral>ORDER BY</CodeLiteral> to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case. ",
        "Demo": [
            "SELECT * FROM products ORDER BY price OFFSET 5 ROW LIMIT 10;",
            "SELECT * FROM employees ORDER BY employee_id OFFSET 5 ROWS;",
            "SELECT * FROM employees ORDER BY employee_id LIMIT 5 OFFSET 10;",
            "SELECT * FROM products ORDER BY price OFFSET 5 ROW LIMIT 10;",
            "SELECT * FROM employees ORDER BY employee_id OFFSET 5 ROWS;",
            "SELECT * FROM employees ORDER BY employee_id LIMIT 5 OFFSET 10;"
        ],
        "Count": [
            2,
            2,
            1,
            2,
            2,
            1
        ]
    },
    {
        "Keyword": [
            "FETCH FIRST count ROW ONLY",
            "FETCH NEXT count ROW ONLY",
            "FETCH FIRST count ROWS ONLY",
            "FETCH NEXT count ROWS ONLY"
        ],
        "Src": "SELECT",
        "Tree": [
            " (limit_clause FETCH (first_or_next FIRST) (row_or_rows ROW) ONLY)",
            " (limit_clause FETCH (first_or_next NEXT) (row_or_rows ROW) ONLY)",
            " (limit_clause FETCH (first_or_next FIRST) (row_or_rows ROWS) ONLY)",
            " (limit_clause FETCH (first_or_next NEXT) (row_or_rows ROWS) ONLY)"
        ],
        "Route": "",
        "Description": "The <CodeLiteral>LIMIT</CodeLiteral> clause consists of two independent sub-clauses:\n <code>LIMIT { count | ALL }\nOFFSET start\n</code>\n count specifies the maximum number of rows to return, while start specifies the number of rows to skip before starting to return rows. When both are specified, start rows are skipped before starting to count the count rows to be returned.\n If the count expression evaluates to NULL, it is treated as <CodeLiteral>LIMIT ALL</CodeLiteral>, i.e., no limit. If start evaluates to NULL, it is treated the same as <CodeLiteral>OFFSET 0</CodeLiteral>.\n SQL:2008 introduced a different syntax to achieve the same result, which PostgreSQL also supports. It is:\n <code>OFFSET start { ROW | ROWS }\nFETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY\n</code>\n In this syntax, the start or count value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If count is omitted in a <CodeLiteral>FETCH</CodeLiteral> clause, it defaults to 1. <CodeLiteral>ROW</CodeLiteral> and <CodeLiteral>ROWS</CodeLiteral> as well as <CodeLiteral>FIRST</CodeLiteral> and <CodeLiteral>NEXT</CodeLiteral> are noise words that don't influence the effects of these clauses. According to the standard, the <CodeLiteral>OFFSET</CodeLiteral> clause must come before the <CodeLiteral>FETCH</CodeLiteral> clause if both are present; but PostgreSQL is laxer and allows either order.\n When using <CodeLiteral>LIMIT</CodeLiteral>, it is a good idea to use an <CodeLiteral>ORDER BY</CodeLiteral> clause that constrains the result rows into a unique order. Otherwise you will get an unpredictable subset of the query's rows \u2014 you might be asking for the tenth through twentieth rows, but tenth through twentieth in what ordering? You don't know what ordering unless you specify <CodeLiteral>ORDER BY</CodeLiteral>.\n The query planner takes <CodeLiteral>LIMIT</CodeLiteral> into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for <CodeLiteral>LIMIT</CodeLiteral> and <CodeLiteral>OFFSET</CodeLiteral>. Thus, using different <CodeLiteral>LIMIT</CodeLiteral>/<CodeLiteral>OFFSET</CodeLiteral> values to select different subsets of a query result will give inconsistent results unless you enforce a predictable result ordering with <CodeLiteral>ORDER BY</CodeLiteral>. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless <CodeLiteral>ORDER BY</CodeLiteral> is used to constrain the order.\n It is even possible for repeated executions of the same <CodeLiteral>LIMIT</CodeLiteral> query to return different subsets of the rows of a table, if there is not an <CodeLiteral>ORDER BY</CodeLiteral> to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case. ",
        "Demo": [
            "SELECT * FROM employees ORDER BY employee_id OFFSET 5 ROWS FETCH FIRST 10 ROW ONLY;",
            "SELECT * FROM employees OFFSET 5 ROWS FETCH NEXT 10 ROW ONLY;",
            "SELECT * FROM employees ORDER BY employee_id OFFSET 5 ROWS FETCH FIRST 10 ROWS ONLY",
            "SELECT * FROM employees ORDER BY employee_id OFFSET 5 ROWS FETCH NEXT 10 ROWS ONLY;"
        ],
        "Count": [
            4,
            4,
            4,
            4
        ]
    },
    {
        "Keyword": [
            "FOR UPDATE OF table_name",
            "FOR NO KEY UPDATE OF table_name",
            "FOR SHARE OF table_name",
            "FOR KEY SHARE OF table_name",
            "FOR UPDATE NOWAIT",
            "FOR NO KEY UPDATE NOWAIT",
            "FOR SHARE NOWAIT",
            "FOR KEY SHARE NOWAIT",
            "FOR UPDATE SKIP LOCKED",
            "FOR NO KEY UPDATE SKIP LOCKED",
            "FOR SHARE SKIP LOCKED",
            "FOR KEY SHARE SKIP LOCKED",
            "FOR UPDATE",
            "FOR NO KEY UPDATE",
            "FOR SHARE",
            "FOR KEY SHARE"
        ],
        "Src": "SELECT",
        "Tree": [
            " (for_locking_item (for_locking_strength FOR UPDATE) (locked_rels_list OF))",
            " (for_locking_item (for_locking_strength FOR NO KEY UPDATE) (locked_rels_list OF))",
            " (for_locking_item (for_locking_strength FOR SHARE) (locked_rels_list OF))",
            " (for_locking_item (for_locking_strength FOR KEY SHARE) (locked_rels_list OF))",
            " (for_locking_item (for_locking_strength FOR UPDATE) (opt_nowait_or_skip NOWAIT))",
            " (for_locking_item (for_locking_strength FOR NO KEY UPDATE) (opt_nowait_or_skip NOWAIT))",
            " (for_locking_item (for_locking_strength FOR SHARE) (opt_nowait_or_skip NOWAIT))",
            " (for_locking_item (for_locking_strength FOR KEY SHARE) (opt_nowait_or_skip NOWAIT))",
            " (for_locking_item (for_locking_strength FOR UPDATE) (opt_nowait_or_skip SKIP LOCKED))",
            " (for_locking_item (for_locking_strength FOR NO KEY UPDATE) (opt_nowait_or_skip SKIP LOCKED))",
            " (for_locking_item (for_locking_strength FOR SHARE) (opt_nowait_or_skip SKIP LOCKED))",
            " (for_locking_item (for_locking_strength FOR KEY SHARE) (opt_nowait_or_skip SKIP LOCKED))",
            " (for_locking_strength FOR UPDATE)",
            " (for_locking_strength FOR NO KEY UPDATE)",
            " (for_locking_strength FOR SHARE)",
            " (for_locking_strength FOR KEY SHARE)"
        ],
        "Route": "",
        "Description": "<CodeLiteral>FOR UPDATE</CodeLiteral>, <CodeLiteral>FOR NO KEY UPDATE</CodeLiteral>, <CodeLiteral>FOR SHARE</CodeLiteral> and <CodeLiteral>FOR KEY SHARE</CodeLiteral> are locking clauses; they affect how <CodeLiteral>SELECT</CodeLiteral> locks rows as they are obtained from the table.\n The locking clause has the general form\n <code>FOR lock_strength [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ]\n</code>\n where lock_strength can be one of\n <code>UPDATE\nNO KEY UPDATE\nSHARE\nKEY SHARE\n</code>\n For more information on each row-level lock mode, refer to Section 13.3.2.\n To prevent the operation from waiting for other transactions to commit, use either the <CodeLiteral>NOWAIT</CodeLiteral> or <CodeLiteral>SKIP LOCKED</CodeLiteral> option. With <CodeLiteral>NOWAIT</CodeLiteral>, the statement reports an error, rather than waiting, if a selected row cannot be locked immediately. With <CodeLiteral>SKIP LOCKED</CodeLiteral>, any selected rows that cannot be immediately locked are skipped. Skipping locked rows provides an inconsistent view of the data, so this is not suitable for general purpose work, but can be used to avoid lock contention with multiple consumers accessing a queue-like table. Note that <CodeLiteral>NOWAIT</CodeLiteral> and <CodeLiteral>SKIP LOCKED</CodeLiteral> apply only to the row-level lock(s) \u2014 the required <CodeLiteral>ROW SHARE</CodeLiteral> table-level lock is still taken in the ordinary way (see Chapter 13). You can use LOCK with the <CodeLiteral>NOWAIT</CodeLiteral> option first, if you need to acquire the table-level lock without waiting.\n If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the SELECT are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to <CodeLiteral>WITH</CodeLiteral> queries referenced by the primary query. If you want row locking to occur within a <CodeLiteral>WITH</CodeLiteral> query, specify a locking clause within the <CodeLiteral>WITH</CodeLiteral> query.\n Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed as <CodeLiteral>NOWAIT</CodeLiteral> if that is specified in any of the clauses affecting it. Otherwise, it is processed as <CodeLiteral>SKIP LOCKED</CodeLiteral> if that is specified in any of the clauses affecting it.\n The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.\n When a locking clause appears at the top level of a SELECT query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a <CodeLiteral>LIMIT</CodeLiteral> is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by <CodeLiteral>OFFSET</CodeLiteral> will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.\n When a locking clause appears in a sub-SELECT, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,\n <code>SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;\n</code>\n will lock only rows having <CodeLiteral>col1 = 5</CodeLiteral>, even though that condition is not textually within the sub-query.\n Previous releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:\n <code>BEGIN;\nSELECT * FROM mytable WHERE key = 1 FOR UPDATE;\nSAVEPOINT s;\nUPDATE mytable SET ... WHERE key = 1;\nROLLBACK TO s;\n</code>\n would fail to preserve the <CodeLiteral>FOR UPDATE</CodeLiteral> lock after the ROLLBACK TO. This has been fixed in release 9.3.\n \n  <ClauseName>Caution</ClauseName>\n  It is possible for a SELECT command running at the <CodeLiteral>READ COMMITTED</CodeLiteral> transaction isolation level and using <CodeLiteral>ORDER BY</CodeLiteral> and a locking clause to return rows out of order. This is because <CodeLiteral>ORDER BY</CodeLiteral> is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the <CodeLiteral>SELECT</CodeLiteral> unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the <CodeLiteral>FOR UPDATE/SHARE</CodeLiteral> clause in a sub-query, for example\n  <code>SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;\n</code>\n  Note that this will result in locking all rows of mytable, whereas <CodeLiteral>FOR UPDATE</CodeLiteral> at the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if the <CodeLiteral>ORDER BY</CodeLiteral> is combined with <CodeLiteral>LIMIT</CodeLiteral> or other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.\n  At the <CodeLiteral>REPEATABLE READ</CodeLiteral> or <CodeLiteral>SERIALIZABLE</CodeLiteral> transaction isolation level this would cause a serialization failure (with a <CodeLiteral>SQLSTATE</CodeLiteral> of <CodeLiteral>'40001'</CodeLiteral>), so there is no possibility of receiving rows out of order under these isolation levels. ",
        "Demo": [
            "SELECT * FROM employees FOR UPDATE OF employees NOWAIT;",
            "SELECT * FROM employees FOR NO KEY UPDATE OF employees NOWAIT;",
            "SELECT * FROM employees FOR SHARE OF employees;",
            "SELECT * FROM employees FOR KEY SHARE OF employees;",
            "SELECT * FROM employees WHERE department = 'Sales' FOR UPDATE NOWAIT;",
            "SELECT * FROM employees WHERE department = 'HR' FOR NO KEY UPDATE NOWAIT;",
            "SELECT * FROM employees FOR SHARE NOWAIT;",
            "SELECT * FROM employees FOR KEY SHARE NOWAIT;",
            "SELECT * FROM orders WHERE status = 'pending' FOR UPDATE SKIP LOCKED;",
            "SELECT * FROM orders WHERE customer_id = 5 FOR NO KEY UPDATE SKIP LOCKED;",
            "SELECT * FROM orders WHERE status = 'pending' FOR SHARE SKIP LOCKED;",
            "SELECT * FROM orders WHERE status = 'pending' FOR KEY SHARE SKIP LOCKED;",
            "SELECT * FROM employees FOR UPDATE;",
            "SELECT * FROM employees WHERE department_id = 5 FOR NO KEY UPDATE;",
            "SELECT * FROM employees FOR SHARE;",
            "SELECT * FROM employees FOR KEY SHARE;"
        ],
        "Count": [
            3,
            5,
            3,
            4,
            3,
            5,
            3,
            4,
            4,
            6,
            4,
            5,
            2,
            4,
            2,
            3
        ]
    },
    {
        "Keyword": [
            "TABLE ONLY table_name",
            "TABLE table_name *",
            "TABLE table_name"
        ],
        "Src": "SELECT",
        "Tree": [
            "(simple_select_pramary TABLE (relation_expr ONLY))",
            "(simple_select_pramary TABLE)",
            "(simple_select_pramary TABLE)"
        ],
        "Route": "",
        "Description": "The command\n <code>TABLE name\n</code>\n is equivalent to\n <code>SELECT * FROM name\n</code>\n It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the <CodeLiteral>WITH</CodeLiteral>, <CodeLiteral>UNION</CodeLiteral>, <CodeLiteral>INTERSECT</CodeLiteral>, <CodeLiteral>EXCEPT</CodeLiteral>, <CodeLiteral>ORDER BY</CodeLiteral>, <CodeLiteral>LIMIT</CodeLiteral>, <CodeLiteral>OFFSET</CodeLiteral>, <CodeLiteral>FETCH</CodeLiteral> and <CodeLiteral>FOR</CodeLiteral> locking clauses can be used with TABLE; the <CodeLiteral>WHERE</CodeLiteral> clause and any form of aggregation cannot be used. ",
        "Demo": [
            "TABLE ONLY employees",
            "TABLE employees;",
            "TABLE employees;"
        ],
        "Count": [
            2,
            1,
            1
        ]
    }
]