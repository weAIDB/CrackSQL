[
    {
        "type": "keyword",
        "keyword": "subquery MINUS subquery",
        "tree": "(subquery_operation_part MINUS)",
        "description": "You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION</code> <code>ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order. The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character). If component queries select character data, then the data type of the return values are determined as follows: If both queries select values of data type <code>CHAR</code> of equal length, then the returned values have data type <code>CHAR</code> of that length. If the queries select values of <code>CHAR</code> with different lengths, then the returned value is <code>VARCHAR2</code> with the length of the larger <code>CHAR</code> value. If either or both of the queries select values of data type <code>VARCHAR2</code>, then the returned values have data type <code>VARCHAR2</code>. If component queries select numeric data, then the data type of the return values is determined by numeric precedence: If any query selects values of type <code>BINARY_DOUBLE</code>, then the returned values have data type <code>BINARY_DOUBLE</code>. If no query selects values of type <code>BINARY_DOUBLE</code> but any query selects values of type <code>BINARY_FLOAT</code>, then the returned values have data type <code>BINARY_FLOAT</code>. If all queries select values of type <code>NUMBER</code>, then the returned values have data type <code>NUMBER</code>. In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error. See Also: Table 2-8(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-98BE3A78-6E33-4181-B5CB-D96FD9DC1694__G195937) for more information on implicit conversion and \"Numeric Precedence(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-4C0B65DB-E751-4957-A1ED-5044BAFA7812)\" for information on numeric precedence <subsect>Examples</subsect> The following query is valid:<code>SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>This is implicitly converted to the following compound query:<code>SELECT TO_BINARY_FLOAT(3) FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>The following query returns an error:<code>SELECT '3' FROM DUAL INTERSECT SELECT 3f FROM DUAL;</code> <subsect>Restrictions on the Set Operators</subsect> The set operators are subject to the following restrictions: The set operators are not valid on columns of type <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>VARRAY</code>, or nested table. The <code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> operators are not valid on <code>LONG</code> columns. If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the <code>order_by_clause</code>. You cannot also specify the <code>for_update_clause</code> with the set operators. You cannot specify the <code>order_by_clause</code> in the <code>subquery</code> of these operators. You cannot use these operators in <code>SELECT</code> statements containing <code>TABLE</code> collection expressions. Note: To comply with emerging SQL standards, a future release of Oracle will give the <code>INTERSECT</code> operator greater precedence than the other set operators. Therefore, you should use parentheses to specify order of evaluation in queries that use the <code>INTERSECT</code> operator with other set operators. <subsect>UNION Example</subsect> The following statement combines the results of two queries with the <code>UNION</code> operator, which eliminates duplicate selected rows. This statement shows that you must match data type (using the <code>TO_CHAR</code> function) when columns do not exist in one or the other table: <code>SELECT location_id, department_name \"Department\", TO_CHAR(NULL) \"Warehouse\" FROM departments UNION SELECT location_id, TO_CHAR(NULL) \"Department\", warehouse_name FROM warehouses; LOCATION_ID Department Warehouse ----------- ------------------------------ --------------------------- 1400 IT 1400 Southlake, Texas 1500 Shipping 1500 San Francisco 1600 New Jersey 1700 Accounting 1700 Administration 1700 Benefits 1700 Construction 1700 Contracting 1700 Control And Credit ...</code> <subsect>UNION ALL Example</subsect> The <code>UNION</code> operator returns only distinct rows that appear in either result, while the <code>UNION</code> <code>ALL</code> operator returns all rows. The <code>UNION</code> <code>ALL</code> operator does not eliminate duplicate selected rows: <code>SELECT product_id FROM order_items UNION SELECT product_id FROM inventories ORDER BY product_id; SELECT location_id FROM locations UNION ALL SELECT location_id FROM departments ORDER BY location_id; </code>A <code>location_id</code> value that appears multiple times in either or both queries (such as '<code>1700</code>') is returned only once by the <code>UNION</code> operator, but multiple times by the <code>UNION</code> <code>ALL</code> operator. <subsect>INTERSECT Example</subsect> The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those unique rows returned by both queries: <code>SELECT product_id FROM inventories INTERSECT SELECT product_id FROM order_items ORDER BY product_id;</code> <subsect>MINUS Example</subsect> The following statement combines results with the <code>MINUS</code> operator, which returns only unique rows returned by the first query but not by the second: <code>SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id;</code>\n",
        "detail": "[DESCRIPTION]: You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION</code> <code>ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order. The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character). If component queries select character data, then the data type of the return values are determined as follows: If both queries select values of data type <code>CHAR</code> of equal length, then the returned values have data type <code>CHAR</code> of that length. If the queries select values of <code>CHAR</code> with different lengths, then the returned value is <code>VARCHAR2</code> with the length of the larger <code>CHAR</code> value. If either or both of the queries select values of data type <code>VARCHAR2</code>, then the returned values have data type <code>VARCHAR2</code>. If component queries select numeric data, then the data type of the return values is determined by numeric precedence: If any query selects values of type <code>BINARY_DOUBLE</code>, then the returned values have data type <code>BINARY_DOUBLE</code>. If no query selects values of type <code>BINARY_DOUBLE</code> but any query selects values of type <code>BINARY_FLOAT</code>, then the returned values have data type <code>BINARY_FLOAT</code>. If all queries select values of type <code>NUMBER</code>, then the returned values have data type <code>NUMBER</code>. In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error. See Also: Table 2-8(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-98BE3A78-6E33-4181-B5CB-D96FD9DC1694__G195937) for more information on implicit conversion and \"Numeric Precedence(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-4C0B65DB-E751-4957-A1ED-5044BAFA7812)\" for information on numeric precedence <subsect>Examples</subsect> The following query is valid:<code>SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>This is implicitly converted to the following compound query:<code>SELECT TO_BINARY_FLOAT(3) FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>The following query returns an error:<code>SELECT '3' FROM DUAL INTERSECT SELECT 3f FROM DUAL;</code> <subsect>Restrictions on the Set Operators</subsect> The set operators are subject to the following restrictions: The set operators are not valid on columns of type <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>VARRAY</code>, or nested table. The <code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> operators are not valid on <code>LONG</code> columns. If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the <code>order_by_clause</code>. You cannot also specify the <code>for_update_clause</code> with the set operators. You cannot specify the <code>order_by_clause</code> in the <code>subquery</code> of these operators. You cannot use these operators in <code>SELECT</code> statements containing <code>TABLE</code> collection expressions. Note: To comply with emerging SQL standards, a future release of Oracle will give the <code>INTERSECT</code> operator greater precedence than the other set operators. Therefore, you should use parentheses to specify order of evaluation in queries that use the <code>INTERSECT</code> operator with other set operators. <subsect>UNION Example</subsect> The following statement combines the results of two queries with the <code>UNION</code> operator, which eliminates duplicate selected rows. This statement shows that you must match data type (using the <code>TO_CHAR</code> function) when columns do not exist in one or the other table: <code>SELECT location_id, department_name \"Department\", TO_CHAR(NULL) \"Warehouse\" FROM departments UNION SELECT location_id, TO_CHAR(NULL) \"Department\", warehouse_name FROM warehouses; LOCATION_ID Department Warehouse ----------- ------------------------------ --------------------------- 1400 IT 1400 Southlake, Texas 1500 Shipping 1500 San Francisco 1600 New Jersey 1700 Accounting 1700 Administration 1700 Benefits 1700 Construction 1700 Contracting 1700 Control And Credit ...</code> <subsect>UNION ALL Example</subsect> The <code>UNION</code> operator returns only distinct rows that appear in either result, while the <code>UNION</code> <code>ALL</code> operator returns all rows. The <code>UNION</code> <code>ALL</code> operator does not eliminate duplicate selected rows: <code>SELECT product_id FROM order_items UNION SELECT product_id FROM inventories ORDER BY product_id; SELECT location_id FROM locations UNION ALL SELECT location_id FROM departments ORDER BY location_id; </code>A <code>location_id</code> value that appears multiple times in either or both queries (such as '<code>1700</code>') is returned only once by the <code>UNION</code> operator, but multiple times by the <code>UNION</code> <code>ALL</code> operator. <subsect>INTERSECT Example</subsect> The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those unique rows returned by both queries: <code>SELECT product_id FROM inventories INTERSECT SELECT product_id FROM order_items ORDER BY product_id;</code> <subsect>MINUS Example</subsect> The following statement combines results with the <code>MINUS</code> operator, which returns only unique rows returned by the first query but not by the second: <code>SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id;</code>\n<sep>[DEMO]: SELECT 3 FROM DUAL MINUS SELECT 3f FROM DUAL;",
        "example": [
            "SELECT 3 FROM DUAL MINUS SELECT 3f FROM DUAL;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "subquery INTERSECT subquery",
        "tree": "(subquery_operation_part INTERSECT)",
        "description": "You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION</code> <code>ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order. The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character). If component queries select character data, then the data type of the return values are determined as follows: If both queries select values of data type <code>CHAR</code> of equal length, then the returned values have data type <code>CHAR</code> of that length. If the queries select values of <code>CHAR</code> with different lengths, then the returned value is <code>VARCHAR2</code> with the length of the larger <code>CHAR</code> value. If either or both of the queries select values of data type <code>VARCHAR2</code>, then the returned values have data type <code>VARCHAR2</code>. If component queries select numeric data, then the data type of the return values is determined by numeric precedence: If any query selects values of type <code>BINARY_DOUBLE</code>, then the returned values have data type <code>BINARY_DOUBLE</code>. If no query selects values of type <code>BINARY_DOUBLE</code> but any query selects values of type <code>BINARY_FLOAT</code>, then the returned values have data type <code>BINARY_FLOAT</code>. If all queries select values of type <code>NUMBER</code>, then the returned values have data type <code>NUMBER</code>. In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error. See Also: Table 2-8(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-98BE3A78-6E33-4181-B5CB-D96FD9DC1694__G195937) for more information on implicit conversion and \"Numeric Precedence(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-4C0B65DB-E751-4957-A1ED-5044BAFA7812)\" for information on numeric precedence <subsect>Examples</subsect> The following query is valid:<code>SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>This is implicitly converted to the following compound query:<code>SELECT TO_BINARY_FLOAT(3) FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>The following query returns an error:<code>SELECT '3' FROM DUAL INTERSECT SELECT 3f FROM DUAL;</code> <subsect>Restrictions on the Set Operators</subsect> The set operators are subject to the following restrictions: The set operators are not valid on columns of type <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>VARRAY</code>, or nested table. The <code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> operators are not valid on <code>LONG</code> columns. If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the <code>order_by_clause</code>. You cannot also specify the <code>for_update_clause</code> with the set operators. You cannot specify the <code>order_by_clause</code> in the <code>subquery</code> of these operators. You cannot use these operators in <code>SELECT</code> statements containing <code>TABLE</code> collection expressions. Note: To comply with emerging SQL standards, a future release of Oracle will give the <code>INTERSECT</code> operator greater precedence than the other set operators. Therefore, you should use parentheses to specify order of evaluation in queries that use the <code>INTERSECT</code> operator with other set operators. <subsect>UNION Example</subsect> The following statement combines the results of two queries with the <code>UNION</code> operator, which eliminates duplicate selected rows. This statement shows that you must match data type (using the <code>TO_CHAR</code> function) when columns do not exist in one or the other table: <code>SELECT location_id, department_name \"Department\", TO_CHAR(NULL) \"Warehouse\" FROM departments UNION SELECT location_id, TO_CHAR(NULL) \"Department\", warehouse_name FROM warehouses; LOCATION_ID Department Warehouse ----------- ------------------------------ --------------------------- 1400 IT 1400 Southlake, Texas 1500 Shipping 1500 San Francisco 1600 New Jersey 1700 Accounting 1700 Administration 1700 Benefits 1700 Construction 1700 Contracting 1700 Control And Credit ...</code> <subsect>UNION ALL Example</subsect> The <code>UNION</code> operator returns only distinct rows that appear in either result, while the <code>UNION</code> <code>ALL</code> operator returns all rows. The <code>UNION</code> <code>ALL</code> operator does not eliminate duplicate selected rows: <code>SELECT product_id FROM order_items UNION SELECT product_id FROM inventories ORDER BY product_id; SELECT location_id FROM locations UNION ALL SELECT location_id FROM departments ORDER BY location_id; </code>A <code>location_id</code> value that appears multiple times in either or both queries (such as '<code>1700</code>') is returned only once by the <code>UNION</code> operator, but multiple times by the <code>UNION</code> <code>ALL</code> operator. <subsect>INTERSECT Example</subsect> The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those unique rows returned by both queries: <code>SELECT product_id FROM inventories INTERSECT SELECT product_id FROM order_items ORDER BY product_id;</code> <subsect>MINUS Example</subsect> The following statement combines results with the <code>MINUS</code> operator, which returns only unique rows returned by the first query but not by the second: <code>SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id;</code>\n",
        "detail": "[DESCRIPTION]: You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION</code> <code>ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order. The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character). If component queries select character data, then the data type of the return values are determined as follows: If both queries select values of data type <code>CHAR</code> of equal length, then the returned values have data type <code>CHAR</code> of that length. If the queries select values of <code>CHAR</code> with different lengths, then the returned value is <code>VARCHAR2</code> with the length of the larger <code>CHAR</code> value. If either or both of the queries select values of data type <code>VARCHAR2</code>, then the returned values have data type <code>VARCHAR2</code>. If component queries select numeric data, then the data type of the return values is determined by numeric precedence: If any query selects values of type <code>BINARY_DOUBLE</code>, then the returned values have data type <code>BINARY_DOUBLE</code>. If no query selects values of type <code>BINARY_DOUBLE</code> but any query selects values of type <code>BINARY_FLOAT</code>, then the returned values have data type <code>BINARY_FLOAT</code>. If all queries select values of type <code>NUMBER</code>, then the returned values have data type <code>NUMBER</code>. In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error. See Also: Table 2-8(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-98BE3A78-6E33-4181-B5CB-D96FD9DC1694__G195937) for more information on implicit conversion and \"Numeric Precedence(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-4C0B65DB-E751-4957-A1ED-5044BAFA7812)\" for information on numeric precedence <subsect>Examples</subsect> The following query is valid:<code>SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>This is implicitly converted to the following compound query:<code>SELECT TO_BINARY_FLOAT(3) FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>The following query returns an error:<code>SELECT '3' FROM DUAL INTERSECT SELECT 3f FROM DUAL;</code> <subsect>Restrictions on the Set Operators</subsect> The set operators are subject to the following restrictions: The set operators are not valid on columns of type <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>VARRAY</code>, or nested table. The <code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> operators are not valid on <code>LONG</code> columns. If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the <code>order_by_clause</code>. You cannot also specify the <code>for_update_clause</code> with the set operators. You cannot specify the <code>order_by_clause</code> in the <code>subquery</code> of these operators. You cannot use these operators in <code>SELECT</code> statements containing <code>TABLE</code> collection expressions. Note: To comply with emerging SQL standards, a future release of Oracle will give the <code>INTERSECT</code> operator greater precedence than the other set operators. Therefore, you should use parentheses to specify order of evaluation in queries that use the <code>INTERSECT</code> operator with other set operators. <subsect>UNION Example</subsect> The following statement combines the results of two queries with the <code>UNION</code> operator, which eliminates duplicate selected rows. This statement shows that you must match data type (using the <code>TO_CHAR</code> function) when columns do not exist in one or the other table: <code>SELECT location_id, department_name \"Department\", TO_CHAR(NULL) \"Warehouse\" FROM departments UNION SELECT location_id, TO_CHAR(NULL) \"Department\", warehouse_name FROM warehouses; LOCATION_ID Department Warehouse ----------- ------------------------------ --------------------------- 1400 IT 1400 Southlake, Texas 1500 Shipping 1500 San Francisco 1600 New Jersey 1700 Accounting 1700 Administration 1700 Benefits 1700 Construction 1700 Contracting 1700 Control And Credit ...</code> <subsect>UNION ALL Example</subsect> The <code>UNION</code> operator returns only distinct rows that appear in either result, while the <code>UNION</code> <code>ALL</code> operator returns all rows. The <code>UNION</code> <code>ALL</code> operator does not eliminate duplicate selected rows: <code>SELECT product_id FROM order_items UNION SELECT product_id FROM inventories ORDER BY product_id; SELECT location_id FROM locations UNION ALL SELECT location_id FROM departments ORDER BY location_id; </code>A <code>location_id</code> value that appears multiple times in either or both queries (such as '<code>1700</code>') is returned only once by the <code>UNION</code> operator, but multiple times by the <code>UNION</code> <code>ALL</code> operator. <subsect>INTERSECT Example</subsect> The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those unique rows returned by both queries: <code>SELECT product_id FROM inventories INTERSECT SELECT product_id FROM order_items ORDER BY product_id;</code> <subsect>MINUS Example</subsect> The following statement combines results with the <code>MINUS</code> operator, which returns only unique rows returned by the first query but not by the second: <code>SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id;</code>\n<sep>[DEMO]: SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL;",
        "example": [
            "SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "subquery UNION ALL subquery",
        "tree": "(subquery_operation_part UNION ALL)",
        "description": "You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION</code> <code>ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order. The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character). If component queries select character data, then the data type of the return values are determined as follows: If both queries select values of data type <code>CHAR</code> of equal length, then the returned values have data type <code>CHAR</code> of that length. If the queries select values of <code>CHAR</code> with different lengths, then the returned value is <code>VARCHAR2</code> with the length of the larger <code>CHAR</code> value. If either or both of the queries select values of data type <code>VARCHAR2</code>, then the returned values have data type <code>VARCHAR2</code>. If component queries select numeric data, then the data type of the return values is determined by numeric precedence: If any query selects values of type <code>BINARY_DOUBLE</code>, then the returned values have data type <code>BINARY_DOUBLE</code>. If no query selects values of type <code>BINARY_DOUBLE</code> but any query selects values of type <code>BINARY_FLOAT</code>, then the returned values have data type <code>BINARY_FLOAT</code>. If all queries select values of type <code>NUMBER</code>, then the returned values have data type <code>NUMBER</code>. In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error. See Also: Table 2-8(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-98BE3A78-6E33-4181-B5CB-D96FD9DC1694__G195937) for more information on implicit conversion and \"Numeric Precedence(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-4C0B65DB-E751-4957-A1ED-5044BAFA7812)\" for information on numeric precedence <subsect>Examples</subsect> The following query is valid:<code>SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>This is implicitly converted to the following compound query:<code>SELECT TO_BINARY_FLOAT(3) FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>The following query returns an error:<code>SELECT '3' FROM DUAL INTERSECT SELECT 3f FROM DUAL;</code> <subsect>Restrictions on the Set Operators</subsect> The set operators are subject to the following restrictions: The set operators are not valid on columns of type <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>VARRAY</code>, or nested table. The <code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> operators are not valid on <code>LONG</code> columns. If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the <code>order_by_clause</code>. You cannot also specify the <code>for_update_clause</code> with the set operators. You cannot specify the <code>order_by_clause</code> in the <code>subquery</code> of these operators. You cannot use these operators in <code>SELECT</code> statements containing <code>TABLE</code> collection expressions. Note: To comply with emerging SQL standards, a future release of Oracle will give the <code>INTERSECT</code> operator greater precedence than the other set operators. Therefore, you should use parentheses to specify order of evaluation in queries that use the <code>INTERSECT</code> operator with other set operators. <subsect>UNION Example</subsect> The following statement combines the results of two queries with the <code>UNION</code> operator, which eliminates duplicate selected rows. This statement shows that you must match data type (using the <code>TO_CHAR</code> function) when columns do not exist in one or the other table: <code>SELECT location_id, department_name \"Department\", TO_CHAR(NULL) \"Warehouse\" FROM departments UNION SELECT location_id, TO_CHAR(NULL) \"Department\", warehouse_name FROM warehouses; LOCATION_ID Department Warehouse ----------- ------------------------------ --------------------------- 1400 IT 1400 Southlake, Texas 1500 Shipping 1500 San Francisco 1600 New Jersey 1700 Accounting 1700 Administration 1700 Benefits 1700 Construction 1700 Contracting 1700 Control And Credit ...</code> <subsect>UNION ALL Example</subsect> The <code>UNION</code> operator returns only distinct rows that appear in either result, while the <code>UNION</code> <code>ALL</code> operator returns all rows. The <code>UNION</code> <code>ALL</code> operator does not eliminate duplicate selected rows: <code>SELECT product_id FROM order_items UNION SELECT product_id FROM inventories ORDER BY product_id; SELECT location_id FROM locations UNION ALL SELECT location_id FROM departments ORDER BY location_id; </code>A <code>location_id</code> value that appears multiple times in either or both queries (such as '<code>1700</code>') is returned only once by the <code>UNION</code> operator, but multiple times by the <code>UNION</code> <code>ALL</code> operator. <subsect>INTERSECT Example</subsect> The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those unique rows returned by both queries: <code>SELECT product_id FROM inventories INTERSECT SELECT product_id FROM order_items ORDER BY product_id;</code> <subsect>MINUS Example</subsect> The following statement combines results with the <code>MINUS</code> operator, which returns only unique rows returned by the first query but not by the second: <code>SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id;</code>\n",
        "detail": "[DESCRIPTION]: You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION</code> <code>ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order. The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character). If component queries select character data, then the data type of the return values are determined as follows: If both queries select values of data type <code>CHAR</code> of equal length, then the returned values have data type <code>CHAR</code> of that length. If the queries select values of <code>CHAR</code> with different lengths, then the returned value is <code>VARCHAR2</code> with the length of the larger <code>CHAR</code> value. If either or both of the queries select values of data type <code>VARCHAR2</code>, then the returned values have data type <code>VARCHAR2</code>. If component queries select numeric data, then the data type of the return values is determined by numeric precedence: If any query selects values of type <code>BINARY_DOUBLE</code>, then the returned values have data type <code>BINARY_DOUBLE</code>. If no query selects values of type <code>BINARY_DOUBLE</code> but any query selects values of type <code>BINARY_FLOAT</code>, then the returned values have data type <code>BINARY_FLOAT</code>. If all queries select values of type <code>NUMBER</code>, then the returned values have data type <code>NUMBER</code>. In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error. See Also: Table 2-8(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-98BE3A78-6E33-4181-B5CB-D96FD9DC1694__G195937) for more information on implicit conversion and \"Numeric Precedence(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-4C0B65DB-E751-4957-A1ED-5044BAFA7812)\" for information on numeric precedence <subsect>Examples</subsect> The following query is valid:<code>SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>This is implicitly converted to the following compound query:<code>SELECT TO_BINARY_FLOAT(3) FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>The following query returns an error:<code>SELECT '3' FROM DUAL INTERSECT SELECT 3f FROM DUAL;</code> <subsect>Restrictions on the Set Operators</subsect> The set operators are subject to the following restrictions: The set operators are not valid on columns of type <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>VARRAY</code>, or nested table. The <code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> operators are not valid on <code>LONG</code> columns. If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the <code>order_by_clause</code>. You cannot also specify the <code>for_update_clause</code> with the set operators. You cannot specify the <code>order_by_clause</code> in the <code>subquery</code> of these operators. You cannot use these operators in <code>SELECT</code> statements containing <code>TABLE</code> collection expressions. Note: To comply with emerging SQL standards, a future release of Oracle will give the <code>INTERSECT</code> operator greater precedence than the other set operators. Therefore, you should use parentheses to specify order of evaluation in queries that use the <code>INTERSECT</code> operator with other set operators. <subsect>UNION Example</subsect> The following statement combines the results of two queries with the <code>UNION</code> operator, which eliminates duplicate selected rows. This statement shows that you must match data type (using the <code>TO_CHAR</code> function) when columns do not exist in one or the other table: <code>SELECT location_id, department_name \"Department\", TO_CHAR(NULL) \"Warehouse\" FROM departments UNION SELECT location_id, TO_CHAR(NULL) \"Department\", warehouse_name FROM warehouses; LOCATION_ID Department Warehouse ----------- ------------------------------ --------------------------- 1400 IT 1400 Southlake, Texas 1500 Shipping 1500 San Francisco 1600 New Jersey 1700 Accounting 1700 Administration 1700 Benefits 1700 Construction 1700 Contracting 1700 Control And Credit ...</code> <subsect>UNION ALL Example</subsect> The <code>UNION</code> operator returns only distinct rows that appear in either result, while the <code>UNION</code> <code>ALL</code> operator returns all rows. The <code>UNION</code> <code>ALL</code> operator does not eliminate duplicate selected rows: <code>SELECT product_id FROM order_items UNION SELECT product_id FROM inventories ORDER BY product_id; SELECT location_id FROM locations UNION ALL SELECT location_id FROM departments ORDER BY location_id; </code>A <code>location_id</code> value that appears multiple times in either or both queries (such as '<code>1700</code>') is returned only once by the <code>UNION</code> operator, but multiple times by the <code>UNION</code> <code>ALL</code> operator. <subsect>INTERSECT Example</subsect> The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those unique rows returned by both queries: <code>SELECT product_id FROM inventories INTERSECT SELECT product_id FROM order_items ORDER BY product_id;</code> <subsect>MINUS Example</subsect> The following statement combines results with the <code>MINUS</code> operator, which returns only unique rows returned by the first query but not by the second: <code>SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id;</code>\n<sep>[DEMO]: SELECT 3 FROM DUAL UNION ALL SELECT 3f FROM DUAL;",
        "example": [
            "SELECT 3 FROM DUAL UNION ALL SELECT 3f FROM DUAL;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "subquery UNION subquery",
        "tree": "(subquery_operation_part UNION)",
        "description": "You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION</code> <code>ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order. The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character). If component queries select character data, then the data type of the return values are determined as follows: If both queries select values of data type <code>CHAR</code> of equal length, then the returned values have data type <code>CHAR</code> of that length. If the queries select values of <code>CHAR</code> with different lengths, then the returned value is <code>VARCHAR2</code> with the length of the larger <code>CHAR</code> value. If either or both of the queries select values of data type <code>VARCHAR2</code>, then the returned values have data type <code>VARCHAR2</code>. If component queries select numeric data, then the data type of the return values is determined by numeric precedence: If any query selects values of type <code>BINARY_DOUBLE</code>, then the returned values have data type <code>BINARY_DOUBLE</code>. If no query selects values of type <code>BINARY_DOUBLE</code> but any query selects values of type <code>BINARY_FLOAT</code>, then the returned values have data type <code>BINARY_FLOAT</code>. If all queries select values of type <code>NUMBER</code>, then the returned values have data type <code>NUMBER</code>. In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error. See Also: Table 2-8(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-98BE3A78-6E33-4181-B5CB-D96FD9DC1694__G195937) for more information on implicit conversion and \"Numeric Precedence(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-4C0B65DB-E751-4957-A1ED-5044BAFA7812)\" for information on numeric precedence <subsect>Examples</subsect> The following query is valid:<code>SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>This is implicitly converted to the following compound query:<code>SELECT TO_BINARY_FLOAT(3) FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>The following query returns an error:<code>SELECT '3' FROM DUAL INTERSECT SELECT 3f FROM DUAL;</code> <subsect>Restrictions on the Set Operators</subsect> The set operators are subject to the following restrictions: The set operators are not valid on columns of type <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>VARRAY</code>, or nested table. The <code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> operators are not valid on <code>LONG</code> columns. If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the <code>order_by_clause</code>. You cannot also specify the <code>for_update_clause</code> with the set operators. You cannot specify the <code>order_by_clause</code> in the <code>subquery</code> of these operators. You cannot use these operators in <code>SELECT</code> statements containing <code>TABLE</code> collection expressions. Note: To comply with emerging SQL standards, a future release of Oracle will give the <code>INTERSECT</code> operator greater precedence than the other set operators. Therefore, you should use parentheses to specify order of evaluation in queries that use the <code>INTERSECT</code> operator with other set operators. <subsect>UNION Example</subsect> The following statement combines the results of two queries with the <code>UNION</code> operator, which eliminates duplicate selected rows. This statement shows that you must match data type (using the <code>TO_CHAR</code> function) when columns do not exist in one or the other table: <code>SELECT location_id, department_name \"Department\", TO_CHAR(NULL) \"Warehouse\" FROM departments UNION SELECT location_id, TO_CHAR(NULL) \"Department\", warehouse_name FROM warehouses; LOCATION_ID Department Warehouse ----------- ------------------------------ --------------------------- 1400 IT 1400 Southlake, Texas 1500 Shipping 1500 San Francisco 1600 New Jersey 1700 Accounting 1700 Administration 1700 Benefits 1700 Construction 1700 Contracting 1700 Control And Credit ...</code> <subsect>UNION ALL Example</subsect> The <code>UNION</code> operator returns only distinct rows that appear in either result, while the <code>UNION</code> <code>ALL</code> operator returns all rows. The <code>UNION</code> <code>ALL</code> operator does not eliminate duplicate selected rows: <code>SELECT product_id FROM order_items UNION SELECT product_id FROM inventories ORDER BY product_id; SELECT location_id FROM locations UNION ALL SELECT location_id FROM departments ORDER BY location_id; </code>A <code>location_id</code> value that appears multiple times in either or both queries (such as '<code>1700</code>') is returned only once by the <code>UNION</code> operator, but multiple times by the <code>UNION</code> <code>ALL</code> operator. <subsect>INTERSECT Example</subsect> The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those unique rows returned by both queries: <code>SELECT product_id FROM inventories INTERSECT SELECT product_id FROM order_items ORDER BY product_id;</code> <subsect>MINUS Example</subsect> The following statement combines results with the <code>MINUS</code> operator, which returns only unique rows returned by the first query but not by the second: <code>SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id;</code>\n",
        "detail": "[DESCRIPTION]: You can combine multiple queries using the set operators <code>UNION</code>, <code>UNION</code> <code>ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. All set operators have equal precedence. If a SQL statement contains multiple set operators, then Oracle Database evaluates them from the left to right unless parentheses explicitly specify another order. The corresponding expressions in the select lists of the component queries of a compound query must match in number and must be in the same data type group (such as numeric or character). If component queries select character data, then the data type of the return values are determined as follows: If both queries select values of data type <code>CHAR</code> of equal length, then the returned values have data type <code>CHAR</code> of that length. If the queries select values of <code>CHAR</code> with different lengths, then the returned value is <code>VARCHAR2</code> with the length of the larger <code>CHAR</code> value. If either or both of the queries select values of data type <code>VARCHAR2</code>, then the returned values have data type <code>VARCHAR2</code>. If component queries select numeric data, then the data type of the return values is determined by numeric precedence: If any query selects values of type <code>BINARY_DOUBLE</code>, then the returned values have data type <code>BINARY_DOUBLE</code>. If no query selects values of type <code>BINARY_DOUBLE</code> but any query selects values of type <code>BINARY_FLOAT</code>, then the returned values have data type <code>BINARY_FLOAT</code>. If all queries select values of type <code>NUMBER</code>, then the returned values have data type <code>NUMBER</code>. In queries using set operators, Oracle does not perform implicit conversion across data type groups. Therefore, if the corresponding expressions of component queries resolve to both character data and numeric data, Oracle returns an error. See Also: Table 2-8(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-98BE3A78-6E33-4181-B5CB-D96FD9DC1694__G195937) for more information on implicit conversion and \"Numeric Precedence(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html#GUID-4C0B65DB-E751-4957-A1ED-5044BAFA7812)\" for information on numeric precedence <subsect>Examples</subsect> The following query is valid:<code>SELECT 3 FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>This is implicitly converted to the following compound query:<code>SELECT TO_BINARY_FLOAT(3) FROM DUAL INTERSECT SELECT 3f FROM DUAL; </code>The following query returns an error:<code>SELECT '3' FROM DUAL INTERSECT SELECT 3f FROM DUAL;</code> <subsect>Restrictions on the Set Operators</subsect> The set operators are subject to the following restrictions: The set operators are not valid on columns of type <code>BLOB</code>, <code>CLOB</code>, <code>BFILE</code>, <code>VARRAY</code>, or nested table. The <code>UNION</code>, <code>INTERSECT</code>, and <code>MINUS</code> operators are not valid on <code>LONG</code> columns. If the select list preceding the set operator contains an expression, then you must provide a column alias for the expression in order to refer to it in the <code>order_by_clause</code>. You cannot also specify the <code>for_update_clause</code> with the set operators. You cannot specify the <code>order_by_clause</code> in the <code>subquery</code> of these operators. You cannot use these operators in <code>SELECT</code> statements containing <code>TABLE</code> collection expressions. Note: To comply with emerging SQL standards, a future release of Oracle will give the <code>INTERSECT</code> operator greater precedence than the other set operators. Therefore, you should use parentheses to specify order of evaluation in queries that use the <code>INTERSECT</code> operator with other set operators. <subsect>UNION Example</subsect> The following statement combines the results of two queries with the <code>UNION</code> operator, which eliminates duplicate selected rows. This statement shows that you must match data type (using the <code>TO_CHAR</code> function) when columns do not exist in one or the other table: <code>SELECT location_id, department_name \"Department\", TO_CHAR(NULL) \"Warehouse\" FROM departments UNION SELECT location_id, TO_CHAR(NULL) \"Department\", warehouse_name FROM warehouses; LOCATION_ID Department Warehouse ----------- ------------------------------ --------------------------- 1400 IT 1400 Southlake, Texas 1500 Shipping 1500 San Francisco 1600 New Jersey 1700 Accounting 1700 Administration 1700 Benefits 1700 Construction 1700 Contracting 1700 Control And Credit ...</code> <subsect>UNION ALL Example</subsect> The <code>UNION</code> operator returns only distinct rows that appear in either result, while the <code>UNION</code> <code>ALL</code> operator returns all rows. The <code>UNION</code> <code>ALL</code> operator does not eliminate duplicate selected rows: <code>SELECT product_id FROM order_items UNION SELECT product_id FROM inventories ORDER BY product_id; SELECT location_id FROM locations UNION ALL SELECT location_id FROM departments ORDER BY location_id; </code>A <code>location_id</code> value that appears multiple times in either or both queries (such as '<code>1700</code>') is returned only once by the <code>UNION</code> operator, but multiple times by the <code>UNION</code> <code>ALL</code> operator. <subsect>INTERSECT Example</subsect> The following statement combines the results with the <code>INTERSECT</code> operator, which returns only those unique rows returned by both queries: <code>SELECT product_id FROM inventories INTERSECT SELECT product_id FROM order_items ORDER BY product_id;</code> <subsect>MINUS Example</subsect> The following statement combines results with the <code>MINUS</code> operator, which returns only unique rows returned by the first query but not by the second: <code>SELECT product_id FROM inventories MINUS SELECT product_id FROM order_items ORDER BY product_id;</code>\n<sep>[DEMO]: SELECT 3 FROM DUAL UNION SELECT 3f FROM DUAL;",
        "example": [
            "SELECT 3 FROM DUAL UNION SELECT 3f FROM DUAL;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "WITH subquery_factoring_clause",
        "tree": "(with_clause WITH)",
        "description": "Use the <code>with_clause</code> to define the following: PL/SQL procedures and functions (using the <code>plsql_declarations</code> clause) Subquery blocks (using <code>subquery_factoring_clause</code> or <code>subav_factoring_clause</code>, or both) <subsubsect>plsql_declarations</subsubsect> The <code>plsql_declarations</code> clause lets you declare and define PL/SQL functions and procedures. You can then reference the PL/SQL functions in the query in which you specify this clause, as well as its subqueries, if any. For the purposes of name resolution, these function names have precedence over schema-level stored functions. If the query in which you specify this clause is not a top-level <code>SELECT</code> statement, then the following rules apply to the top-level SQL statement that contains the query: If the top-level statement is a <code>SELECT</code> statement, then it must have either a <code>WITH</code> <code>plsql_declarations</code> clause or the <code>WITH_PLSQL</code> hint. If the top-level statement is a <code>DELETE</code>, <code>MERGE</code>, <code>INSERT</code>, or <code>UPDATE</code> statement, then it must have the <code>WITH_PLSQL</code> hint. The <code>WITH_PLSQL</code> hint only enables you to specify the <code>WITH</code> <code>plsql_declarations</code> clause within the statement. It is not an optimizer hint. See Also: Oracle Database PL/SQL Language Reference for syntax and restrictions for <code>function_declaration</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=LNPLS01322) and <code>procedure_declaration</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=LNPLS01336). \"Using a PL/SQL Function in the WITH Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABJFIDC)\" <subsubsect>subquery_factoring_clause</subsubsect> The <code>subquery_factoring_clause</code> lets you assign a name (<code>query_name</code>) to a subquery block. You can then reference the subquery block multiple places in the query by specifying <code>query_name</code>. Oracle Database optimizes the query by treating the <code>query_name</code> as either an inline view or as a temporary table. The <code>query_name</code> is subject to the same naming conventions and restrictions as database schema objects. Refer to \"Database Object Naming Rules(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Database-Object-Names-and-Qualifiers.html#GUID-75337742-67FD-4EC0-985F-741C93D918DA)\" for information on database object names. The column aliases following the <code>query_name</code> and the set operators separating multiple subqueries in the <code>AS</code> clause are valid and required for recursive subquery factoring. The <code>search_clause</code> and <code>cycle_clause</code> are valid only for recursive subquery factoring but are not required. See \"Recursive Subquery Factoring(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BCEJGIBG)\". You can specify this clause in any top-level <code>SELECT</code> statement and in most types of subqueries. The query name is visible to the main query and to all subsequent subqueries. For recursive subquery factoring, the query name is even visible to the subquery that defines the query name itself. <subsubsect>Recursive Subquery Factoring</subsubsect> If a <code>subquery_factoring_clause</code> refers to its own <code>query_name</code> in the subquery that defines it, then the <code>subquery_factoring_clause</code> is said to be recursive. A recursive <code>subquery_factoring_clause</code> must contain two query blocks: the first is the anchor member and the second is the recursive member. The anchor member must appear before the recursive member, and it cannot reference <code>query_name</code>. The anchor member can be composed of one or more query blocks combined by the set operators: <code>UNION</code> <code>ALL</code>, <code>UNION</code>, <code>INTERSECT</code> or <code>MINUS</code>. The recursive member must follow the anchor member and must reference <code>query_name</code> exactly once. You must combine the recursive member with the anchor member using the <code>UNION</code> <code>ALL</code> set operator. The number of column aliases following <code>WITH</code> <code>query_name</code> and the number of columns in the <code>SELECT</code> lists of the anchor and recursive query blocks must be the same. The recursive member cannot contain any of the following elements: The <code>DISTINCT</code> keyword or a <code>GROUP</code> <code>BY</code> clause The <code>model_clause</code> An aggregate function. However, analytic functions are permitted in the select list. Subqueries that refer to <code>query_name</code>. Outer joins that refer to <code>query_name</code> as the right table. In previous releases of Oracle Database, the recursive member of a recursive <code>WITH</code> clause ran serially regardless of the parallelism of the entire query (also known as the top-level <code>SELECT</code> statement). Beginning with Oracle Database 12c Release 2 (12.2), the recursive member runs in parallel if the optimizer determines that the top-level <code>SELECT</code> statement can be executed in parallel.",
        "detail": "[DESCRIPTION]: Use the <code>with_clause</code> to define the following: PL/SQL procedures and functions (using the <code>plsql_declarations</code> clause) Subquery blocks (using <code>subquery_factoring_clause</code> or <code>subav_factoring_clause</code>, or both) <subsubsect>plsql_declarations</subsubsect> The <code>plsql_declarations</code> clause lets you declare and define PL/SQL functions and procedures. You can then reference the PL/SQL functions in the query in which you specify this clause, as well as its subqueries, if any. For the purposes of name resolution, these function names have precedence over schema-level stored functions. If the query in which you specify this clause is not a top-level <code>SELECT</code> statement, then the following rules apply to the top-level SQL statement that contains the query: If the top-level statement is a <code>SELECT</code> statement, then it must have either a <code>WITH</code> <code>plsql_declarations</code> clause or the <code>WITH_PLSQL</code> hint. If the top-level statement is a <code>DELETE</code>, <code>MERGE</code>, <code>INSERT</code>, or <code>UPDATE</code> statement, then it must have the <code>WITH_PLSQL</code> hint. The <code>WITH_PLSQL</code> hint only enables you to specify the <code>WITH</code> <code>plsql_declarations</code> clause within the statement. It is not an optimizer hint. See Also: Oracle Database PL/SQL Language Reference for syntax and restrictions for <code>function_declaration</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=LNPLS01322) and <code>procedure_declaration</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=LNPLS01336). \"Using a PL/SQL Function in the WITH Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABJFIDC)\" <subsubsect>subquery_factoring_clause</subsubsect> The <code>subquery_factoring_clause</code> lets you assign a name (<code>query_name</code>) to a subquery block. You can then reference the subquery block multiple places in the query by specifying <code>query_name</code>. Oracle Database optimizes the query by treating the <code>query_name</code> as either an inline view or as a temporary table. The <code>query_name</code> is subject to the same naming conventions and restrictions as database schema objects. Refer to \"Database Object Naming Rules(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Database-Object-Names-and-Qualifiers.html#GUID-75337742-67FD-4EC0-985F-741C93D918DA)\" for information on database object names. The column aliases following the <code>query_name</code> and the set operators separating multiple subqueries in the <code>AS</code> clause are valid and required for recursive subquery factoring. The <code>search_clause</code> and <code>cycle_clause</code> are valid only for recursive subquery factoring but are not required. See \"Recursive Subquery Factoring(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BCEJGIBG)\". You can specify this clause in any top-level <code>SELECT</code> statement and in most types of subqueries. The query name is visible to the main query and to all subsequent subqueries. For recursive subquery factoring, the query name is even visible to the subquery that defines the query name itself. <subsubsect>Recursive Subquery Factoring</subsubsect> If a <code>subquery_factoring_clause</code> refers to its own <code>query_name</code> in the subquery that defines it, then the <code>subquery_factoring_clause</code> is said to be recursive. A recursive <code>subquery_factoring_clause</code> must contain two query blocks: the first is the anchor member and the second is the recursive member. The anchor member must appear before the recursive member, and it cannot reference <code>query_name</code>. The anchor member can be composed of one or more query blocks combined by the set operators: <code>UNION</code> <code>ALL</code>, <code>UNION</code>, <code>INTERSECT</code> or <code>MINUS</code>. The recursive member must follow the anchor member and must reference <code>query_name</code> exactly once. You must combine the recursive member with the anchor member using the <code>UNION</code> <code>ALL</code> set operator. The number of column aliases following <code>WITH</code> <code>query_name</code> and the number of columns in the <code>SELECT</code> lists of the anchor and recursive query blocks must be the same. The recursive member cannot contain any of the following elements: The <code>DISTINCT</code> keyword or a <code>GROUP</code> <code>BY</code> clause The <code>model_clause</code> An aggregate function. However, analytic functions are permitted in the select list. Subqueries that refer to <code>query_name</code>. Outer joins that refer to <code>query_name</code> as the right table. In previous releases of Oracle Database, the recursive member of a recursive <code>WITH</code> clause ran serially regardless of the parallelism of the entire query (also known as the top-level <code>SELECT</code> statement). Beginning with Oracle Database 12c Release 2 (12.2), the recursive member runs in parallel if the optimizer determines that the top-level <code>SELECT</code> statement can be executed in parallel.<sep>[DEMO]: WITH costs AS ( SELECT * FROM employees ) SELECT * FROM costs;",
        "example": [
            "WITH costs AS ( SELECT * FROM employees ) SELECT * FROM costs;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "query_name ( c_alias ) AS ( subquery )",
        "tree": "(subquery_factoring_clause (paren_column_list ( )) AS ( ))",
        "description": "The <code>subquery_factoring_clause</code> lets you assign a name (<code>query_name</code>) to a subquery block. You can then reference the subquery block multiple places in the query by specifying <code>query_name</code>. Oracle Database optimizes the query by treating the <code>query_name</code> as either an inline view or as a temporary table. The <code>query_name</code> is subject to the same naming conventions and restrictions as database schema objects. Refer to \"Database Object Naming Rules(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Database-Object-Names-and-Qualifiers.html#GUID-75337742-67FD-4EC0-985F-741C93D918DA)\" for information on database object names. The column aliases following the <code>query_name</code> and the set operators separating multiple subqueries in the <code>AS</code> clause are valid and required for recursive subquery factoring. The <code>search_clause</code> and <code>cycle_clause</code> are valid only for recursive subquery factoring but are not required. See \"Recursive Subquery Factoring(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BCEJGIBG)\". You can specify this clause in any top-level <code>SELECT</code> statement and in most types of subqueries. The query name is visible to the main query and to all subsequent subqueries. For recursive subquery factoring, the query name is even visible to the subquery that defines the query name itself.",
        "detail": "[DESCRIPTION]: The <code>subquery_factoring_clause</code> lets you assign a name (<code>query_name</code>) to a subquery block. You can then reference the subquery block multiple places in the query by specifying <code>query_name</code>. Oracle Database optimizes the query by treating the <code>query_name</code> as either an inline view or as a temporary table. The <code>query_name</code> is subject to the same naming conventions and restrictions as database schema objects. Refer to \"Database Object Naming Rules(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Database-Object-Names-and-Qualifiers.html#GUID-75337742-67FD-4EC0-985F-741C93D918DA)\" for information on database object names. The column aliases following the <code>query_name</code> and the set operators separating multiple subqueries in the <code>AS</code> clause are valid and required for recursive subquery factoring. The <code>search_clause</code> and <code>cycle_clause</code> are valid only for recursive subquery factoring but are not required. See \"Recursive Subquery Factoring(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BCEJGIBG)\". You can specify this clause in any top-level <code>SELECT</code> statement and in most types of subqueries. The query name is visible to the main query and to all subsequent subqueries. For recursive subquery factoring, the query name is even visible to the subquery that defines the query name itself.<sep>[DEMO]: WITH employee_summary (employee_id, total_sales) AS (  SELECT employee_id, SUM(sales_amount)  FROM sales  GROUP BY employee_id ) SELECT e.employee_id, e.employee_name, es.total_sales FROM employees e JOIN employee_summary es ON e.employee_id = es.employee_id;",
        "example": [
            "WITH employee_summary (employee_id, total_sales) AS (  SELECT employee_id, SUM(sales_amount)  FROM sales  GROUP BY employee_id ) SELECT e.employee_id, e.employee_name, es.total_sales FROM employees e JOIN employee_summary es ON e.employee_id = es.employee_id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH DEPTH FIRST BY c_alias SET ordering_column",
        "tree": "(search_clause SEARCH DEPTH FIRST BY SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH BREADTH FIRST BY c_alias ASC SET ordering_column",
        "tree": "(search_clause SEARCH BREADTH FIRST BY ASC SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id ASC SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id ASC SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH BREADTH FIRST BY c_alias DESC SET ordering_column",
        "tree": "(search_clause SEARCH BREADTH FIRST BY DESC SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id DESC SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id DESC SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH BREADTH FIRST BY c_alias NULLS LAST SET ordering_column",
        "tree": "(search_clause SEARCH BREADTH FIRST BY NULLS LAST SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id NULLS LAST SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id NULLS LAST SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH DEPTH FIRST BY c_alias NULLS FIRST SET ordering_column",
        "tree": "(search_clause SEARCH DEPTH FIRST BY NULLS FIRST SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id NULLS FIRST SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id NULLS FIRST SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH DEPTH FIRST BY c_alias NULLS LAST SET ordering_column",
        "tree": "(search_clause SEARCH DEPTH FIRST BY NULLS LAST SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id NULLS LAST SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id NULLS LAST SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH BREADTH FIRST BY c_alias SET ordering_column",
        "tree": "(search_clause SEARCH BREADTH FIRST BY SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH BREADTH FIRST BY c_alias NULLS FIRST SET ordering_column",
        "tree": "(search_clause SEARCH BREADTH FIRST BY NULLS FIRST SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id NULLS FIRST SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH BREADTH FIRST BY employee_id NULLS FIRST SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH DEPTH FIRST BY c_alias DESC SET ordering_column",
        "tree": "(search_clause SEARCH DEPTH FIRST BY DESC SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id DESC SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id DESC SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SEARCH DEPTH FIRST BY c_alias ASC SET ordering_column",
        "tree": "(search_clause SEARCH DEPTH FIRST BY ASC SET)",
        "description": "Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.",
        "detail": "[DESCRIPTION]: Use the <code>SEARCH</code> clause to specify an ordering for the rows. Specify <code>BREADTH</code> <code>FIRST</code> <code>BY</code> if you want sibling rows returned before any child rows are returned. Specify <code>DEPTH</code> <code>FIRST</code> <code>BY</code> if you want child rows returned before any siblings rows are returned. Sibling rows are ordered by the columns listed after the <code>BY</code> keyword. The <code>c_alias</code> list following the <code>SEARCH</code> keyword must contain column names from the column alias list for <code>query_name</code>. The <code>ordering_column</code> is automatically added to the column list for the query name. The query that selects from <code>query_name</code> can include an <code>ORDER</code> <code>BY</code> on <code>ordering_column</code> to return the rows in the order that was specified by the <code>SEARCH</code> clause.<sep>[DEMO]: WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id ASC SET ordering_column SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) SEARCH DEPTH FIRST BY employee_id ASC SET ordering_column SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "CYCLE c_alias SET cycle_mark_c_alias TO cycle_value DEFAULT no_cycle_value",
        "tree": "(cycle_clause CYCLE SET TO DEFAULT)",
        "description": "Use the <code>CYCLE</code> clause to mark cycles in the recursion. The <code>c_alias</code> list following the <code>CYCLE</code> keyword must contain column names from the column alias list for <code>query_name</code>. Oracle Database uses these columns to detect a cycle. <code>cycle_value</code> and <code>no_cycle_value</code> should be character strings of length 1. If a cycle is detected, then the cycle mark column specified by <code>cycle_mark_c_alias</code> for the row causing the cycle is set to the value specified for <code>cycle_value</code>. The recursion will then stop for this row. That is, it will not look for child rows for the offending row, but it will continue for other noncyclic rows. If no cycles are found, then the cycle mark column is set to the default value specified for <code>no_cycle_value</code>. The cycle mark column is automatically added to the column list for the <code>query_name</code>. A row is considered to form a cycle if one of its ancestor rows has the same values for the cycle columns. If you omit the <code>CYCLE</code> clause, then the recursive <code>WITH</code> clause returns an error if cycles are discovered. In this case, a row forms a cycle if one of its ancestor rows has the same values for all the columns in the column alias list for <code>query_name</code> that are referenced in the <code>WHERE</code> clause of the recursive member. <subsubsect>Restrictions on Subquery Factoring</subsubsect> This clause is subject to the following restrictions: You can specify only one <code>subquery_factoring_clause</code> in a single SQL statement. Any <code>query_name</code> defined in the <code>subquery_factoring_clause</code> can be used in any subsequent named query block in the <code>subquery_factoring_clause</code>. In a compound query with set operators, you cannot use the <code>query_name</code> for any of the component queries, but you can use the <code>query_name</code> in the <code>FROM</code> clause of any of the component queries. You cannot specify duplicate names in the column alias list for <code>query_name</code>. The name used for the <code>ordering_column</code> has to be different from the name used for <code>cycle_mark_c_alias</code>. The <code>ordering_column</code> and cycle mark column names cannot already be in the column alias list for <code>query_name</code>. See Also: Oracle Database Concepts(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=CNCPT010) for information about inline views \"Subquery Factoring: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2129904)\" \"Recursive Subquery Factoring: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABCDJDB)\"",
        "detail": "[DESCRIPTION]: Use the <code>CYCLE</code> clause to mark cycles in the recursion. The <code>c_alias</code> list following the <code>CYCLE</code> keyword must contain column names from the column alias list for <code>query_name</code>. Oracle Database uses these columns to detect a cycle. <code>cycle_value</code> and <code>no_cycle_value</code> should be character strings of length 1. If a cycle is detected, then the cycle mark column specified by <code>cycle_mark_c_alias</code> for the row causing the cycle is set to the value specified for <code>cycle_value</code>. The recursion will then stop for this row. That is, it will not look for child rows for the offending row, but it will continue for other noncyclic rows. If no cycles are found, then the cycle mark column is set to the default value specified for <code>no_cycle_value</code>. The cycle mark column is automatically added to the column list for the <code>query_name</code>. A row is considered to form a cycle if one of its ancestor rows has the same values for the cycle columns. If you omit the <code>CYCLE</code> clause, then the recursive <code>WITH</code> clause returns an error if cycles are discovered. In this case, a row forms a cycle if one of its ancestor rows has the same values for all the columns in the column alias list for <code>query_name</code> that are referenced in the <code>WHERE</code> clause of the recursive member. <subsubsect>Restrictions on Subquery Factoring</subsubsect> This clause is subject to the following restrictions: You can specify only one <code>subquery_factoring_clause</code> in a single SQL statement. Any <code>query_name</code> defined in the <code>subquery_factoring_clause</code> can be used in any subsequent named query block in the <code>subquery_factoring_clause</code>. In a compound query with set operators, you cannot use the <code>query_name</code> for any of the component queries, but you can use the <code>query_name</code> in the <code>FROM</code> clause of any of the component queries. You cannot specify duplicate names in the column alias list for <code>query_name</code>. The name used for the <code>ordering_column</code> has to be different from the name used for <code>cycle_mark_c_alias</code>. The <code>ordering_column</code> and cycle mark column names cannot already be in the column alias list for <code>query_name</code>. See Also: Oracle Database Concepts(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=CNCPT010) for information about inline views \"Subquery Factoring: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2129904)\" \"Recursive Subquery Factoring: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABCDJDB)\"<sep>[DEMO]: WITH a AS (SELECT * FROM employees) CYCLE employee_id SET cycle_mark TO 'CYCLE' DEFAULT 'NO_CYCLE' SELECT * FROM a;",
        "example": [
            "WITH a AS (SELECT * FROM employees) CYCLE employee_id SET cycle_mark TO 'CYCLE' DEFAULT 'NO_CYCLE' SELECT * FROM a;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "subav_name ANALYTIC VIEW AS ( USING base_av_name )",
        "tree": "(subav_factoring_clause ANALYTIC VIEW AS ( (subav_clause USING) ))",
        "description": "With the <code>subav_factoring_clause</code>, you can define a transitory analytic view that filters fact data prior to aggregation or adds calculated measures to a query of an analytic view. The <code>subav_name</code> argument assigns a name to the transitory analytic view. You can then reference the transitory analytic view multiple places in the query by specifying <code>subav_name</code>. The <code>subav_name</code> is subject to the same naming conventions and restrictions as database schema objects. Refer to \"Database Object Naming Rules(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Database-Object-Names-and-Qualifiers.html#GUID-75337742-67FD-4EC0-985F-741C93D918DA)\" for information on database object names. You can specify this clause in any top-level <code>SELECT</code> statement and in most types of subqueries. The query name is visible to the main query and to all subsequent subqueries. The <code>subav_clause</code> argument defines a transitory analytic view. With the <code>USING</code> keyword, subav_clause specify the name of an analytic view, which may be a transitory analytic view previously defined in the <code>WITH</code> clause or it may be a persistent analytic view. A persistent analytic view is defined in a <code>CREATE</code> <code>ANALYTIC</code> <code>VIEW</code> statement. If the analytic view is a persistent one, then the current user must have select access on it. See Also:Analytic Views: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__P-1314421-F3347731)",
        "detail": "[DESCRIPTION]: With the <code>subav_factoring_clause</code>, you can define a transitory analytic view that filters fact data prior to aggregation or adds calculated measures to a query of an analytic view. The <code>subav_name</code> argument assigns a name to the transitory analytic view. You can then reference the transitory analytic view multiple places in the query by specifying <code>subav_name</code>. The <code>subav_name</code> is subject to the same naming conventions and restrictions as database schema objects. Refer to \"Database Object Naming Rules(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Database-Object-Names-and-Qualifiers.html#GUID-75337742-67FD-4EC0-985F-741C93D918DA)\" for information on database object names. You can specify this clause in any top-level <code>SELECT</code> statement and in most types of subqueries. The query name is visible to the main query and to all subsequent subqueries. The <code>subav_clause</code> argument defines a transitory analytic view. With the <code>USING</code> keyword, subav_clause specify the name of an analytic view, which may be a transitory analytic view previously defined in the <code>WITH</code> clause or it may be a persistent analytic view. A persistent analytic view is defined in a <code>CREATE</code> <code>ANALYTIC</code> <code>VIEW</code> statement. If the analytic view is a persistent one, then the current user must have select access on it. See Also:Analytic Views: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__P-1314421-F3347731)<sep>[DEMO]: WITH my_av ANALYTIC VIEW AS ( USING sales_av HIERARCHIES (time_hier) ADD MEASURES ( lag_sales AS (LAG(sales) OVER (HIERARCHY time_hier OFFSET 1)) )) SELECT * FROM my_av HIERARCHIES (time_hier);",
        "example": [
            "WITH my_av ANALYTIC VIEW AS ( USING sales_av HIERARCHIES (time_hier) ADD MEASURES ( lag_sales AS (LAG(sales) OVER (HIERARCHY time_hier OFFSET 1)) )) SELECT * FROM my_av HIERARCHIES (time_hier);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "HIERARCHIES ( hier_id )",
        "tree": "(hierarchies_clause HIERARCHIES ( ))",
        "description": "The <code>hierarchies_clause</code> specifies the hierarchies of the base analytic view that the results of the transitory analytic view are dimensioned by. With the <code>HIERARCHIES</code> keyword, specify the alias of one or more hierarchies of the base analytic view. If you do not specify a <code>HIERARCHIES</code> clause, then the default hierarchies of the base analytic view are used.",
        "detail": "[DESCRIPTION]: The <code>hierarchies_clause</code> specifies the hierarchies of the base analytic view that the results of the transitory analytic view are dimensioned by. With the <code>HIERARCHIES</code> keyword, specify the alias of one or more hierarchies of the base analytic view. If you do not specify a <code>HIERARCHIES</code> clause, then the default hierarchies of the base analytic view are used.<sep>[DEMO]: WITH my_av ANALYTIC VIEW AS ( USING sales_av HIERARCHIES (time_hier) ADD MEASURES ( lag_sales AS (LAG(sales) OVER (HIERARCHY time_hier OFFSET 1)) )) SELECT * FROM my_av HIERARCHIES (time_hier);",
        "example": [
            "WITH my_av ANALYTIC VIEW AS ( USING sales_av HIERARCHIES (time_hier) ADD MEASURES ( lag_sales AS (LAG(sales) OVER (HIERARCHY time_hier OFFSET 1)) )) SELECT * FROM my_av HIERARCHIES (time_hier);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FILTER FACT ( hier_id TO predicate )",
        "tree": "(filter_clauses FILTER FACT ( (filter_clause TO) ))",
        "description": "You may specify a given <code>hier_alias</code> in at most one <code>filter_clause</code>. The filter clause applies the specified predicate condition to the fact table, which reduces the number of rows returned from the table before aggregation of the measure values. The predicate may contain any SQL row function or operation. The predicate may refer to any attribute of the specified hierarchy or it may refer to a measure of the analytic view if you specify the <code>MEASURES</code> keyword. For example, the following clause restricts the aggregation of measure values to those for the first and second quarters of every year of a time hierarchy.<code>FILTER FACT (time_hier TO quarter_of_year IN (1,2))</code>If you then select from the transitory analytic view the sales for the years 2000 and 2001, the values returned are the aggregated values of the first and second quarters only. An example of specifying a predicate for a measure in the filter clause is the following.<code>FILTER FACT (MEASURES TO sales BETWEEN 100 AND 200)</code>",
        "detail": "[DESCRIPTION]: You may specify a given <code>hier_alias</code> in at most one <code>filter_clause</code>. The filter clause applies the specified predicate condition to the fact table, which reduces the number of rows returned from the table before aggregation of the measure values. The predicate may contain any SQL row function or operation. The predicate may refer to any attribute of the specified hierarchy or it may refer to a measure of the analytic view if you specify the <code>MEASURES</code> keyword. For example, the following clause restricts the aggregation of measure values to those for the first and second quarters of every year of a time hierarchy.<code>FILTER FACT (time_hier TO quarter_of_year IN (1,2))</code>If you then select from the transitory analytic view the sales for the years 2000 and 2001, the values returned are the aggregated values of the first and second quarters only. An example of specifying a predicate for a measure in the filter clause is the following.<code>FILTER FACT (MEASURES TO sales BETWEEN 100 AND 200)</code><sep>[DEMO]: WITH my_av ANALYTIC VIEW AS ( USING sales_av FILTER FACT ( time_hier TO quarter_of_year ) ) SELECT * FROM my_av;",
        "example": [
            "WITH my_av ANALYTIC VIEW AS ( USING sales_av FILTER FACT ( time_hier TO quarter_of_year ) ) SELECT * FROM my_av;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ADD MEASURES ( meas_name AS ( expression ) )",
        "tree": "(add_calcs_clause ADD MEASURES ( (add_calc_meas_clause AS ( )) ))",
        "description": "With the <code>ADD</code> <code>MEASURES</code> keywords, you may add calculated measures to the transitory analytic view. <code>meas_name AS (expression)</code> specifies a name for the calculated measure and an analytic view expression that specifies values for the calculated measure. The analytic view expression can be any valid <code>calc_meas_expression</code> as described in Analytic View Expressions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/analytic-view-measure-expressions.html#GUID-F8C7ED67-A4EC-479C-975F-12F1F4B8CBA0). For example, the following adds a calculated measure named \u201cshare_sales.\u201d <code>ADD MEASURES (share_sales AS (SHARE_OF(sales HIERARCHY time_hier PARENT)))</code>",
        "detail": "[DESCRIPTION]: With the <code>ADD</code> <code>MEASURES</code> keywords, you may add calculated measures to the transitory analytic view. <code>meas_name AS (expression)</code> specifies a name for the calculated measure and an analytic view expression that specifies values for the calculated measure. The analytic view expression can be any valid <code>calc_meas_expression</code> as described in Analytic View Expressions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/analytic-view-measure-expressions.html#GUID-F8C7ED67-A4EC-479C-975F-12F1F4B8CBA0). For example, the following adds a calculated measure named \u201cshare_sales.\u201d <code>ADD MEASURES (share_sales AS (SHARE_OF(sales HIERARCHY time_hier PARENT)))</code><sep>[DEMO]: WITH my_av ANALYTIC VIEW AS ( USING sales_av HIERARCHIES (time_hier) ADD MEASURES ( lag_sales AS (LAG(sales) OVER (HIERARCHY time_hier OFFSET 1)) )) SELECT * FROM my_av HIERARCHIES (time_hier);",
        "example": [
            "WITH my_av ANALYTIC VIEW AS ( USING sales_av HIERARCHIES (time_hier) ADD MEASURES ( lag_sales AS (LAG(sales) OVER (HIERARCHY time_hier OFFSET 1)) )) SELECT * FROM my_av HIERARCHIES (time_hier);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS BETWEEN TIMESTAMP expr AND expr",
        "tree": "(flashback_query_clause VERSIONS BETWEEN TIMESTAMP AND)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS BETWEEN TIMESTAMP SYSTIMESTAMP AND SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees VERSIONS BETWEEN TIMESTAMP SYSTIMESTAMP AND SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS BETWEEN TIMESTAMP MINVALUE AND expr",
        "tree": "(flashback_query_clause VERSIONS BETWEEN TIMESTAMP (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MINVALUE))))))))))) AND)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS BETWEEN TIMESTAMP MINVALUE AND SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees VERSIONS BETWEEN TIMESTAMP MINVALUE AND SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS BETWEEN SCN expr AND MAXVALUE",
        "tree": "(flashback_query_clause VERSIONS BETWEEN SCN AND (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MAXVALUE))))))))))))",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS BETWEEN SCN SYSTIMESTAMP AND MAXVALUE;",
        "example": [
            "SELECT salary FROM employees VERSIONS BETWEEN SCN SYSTIMESTAMP AND MAXVALUE;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS BETWEEN TIMESTAMP MINVALUE AND MAXVALUE",
        "tree": "(flashback_query_clause VERSIONS BETWEEN TIMESTAMP (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MINVALUE))))))))))) AND (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MAXVALUE))))))))))))",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS BETWEEN TIMESTAMP MINVALUE AND MAXVALUE;",
        "example": [
            "SELECT salary FROM employees VERSIONS BETWEEN TIMESTAMP MINVALUE AND MAXVALUE;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS PERIOD FOR valid_time_column BETWEEN expr AND MAXVALUE",
        "tree": "(flashback_query_clause VERSIONS PERIOD FOR BETWEEN AND (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MAXVALUE))))))))))))",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS PERIOD FOR time_column BETWEEN SYSTIMESTAMP AND MAXVALUE;",
        "example": [
            "SELECT salary FROM employees VERSIONS PERIOD FOR time_column BETWEEN SYSTIMESTAMP AND MAXVALUE;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS BETWEEN TIMESTAMP expr AND MAXVALUE",
        "tree": "(flashback_query_clause VERSIONS BETWEEN TIMESTAMP AND (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MAXVALUE))))))))))))",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS BETWEEN TIMESTAMP SYSTIMESTAMP AND MAXVALUE;",
        "example": [
            "SELECT salary FROM employees VERSIONS BETWEEN TIMESTAMP SYSTIMESTAMP AND MAXVALUE;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS BETWEEN SCN expr AND expr",
        "tree": "(flashback_query_clause VERSIONS BETWEEN SCN AND)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS BETWEEN SCN SYSTIMESTAMP AND SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees VERSIONS BETWEEN SCN SYSTIMESTAMP AND SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS PERIOD FOR valid_time_column BETWEEN MINVALUE AND expr",
        "tree": "(flashback_query_clause VERSIONS PERIOD FOR BETWEEN (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MINVALUE))))))))))) AND)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS PERIOD FOR time_column BETWEEN MINVALUE AND SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees VERSIONS PERIOD FOR time_column BETWEEN MINVALUE AND SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS BETWEEN SCN MINVALUE AND MAXVALUE",
        "tree": "(flashback_query_clause VERSIONS BETWEEN SCN (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MINVALUE))))))))))) AND (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MAXVALUE))))))))))))",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS BETWEEN SCN MINVALUE AND MAXVALUE;",
        "example": [
            "SELECT salary FROM employees VERSIONS BETWEEN SCN MINVALUE AND MAXVALUE;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "AS OF SCN expr",
        "tree": "(flashback_query_clause AS OF SCN)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees AS OF SCN SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees AS OF SCN SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS PERIOD FOR valid_time_column BETWEEN expr AND expr",
        "tree": "(flashback_query_clause VERSIONS PERIOD FOR BETWEEN AND)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS PERIOD FOR time_column BETWEEN SYSTIMESTAMP AND SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees VERSIONS PERIOD FOR time_column BETWEEN SYSTIMESTAMP AND SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS PERIOD FOR valid_time_column BETWEEN MINVALUE AND MAXVALUE",
        "tree": "(flashback_query_clause VERSIONS PERIOD FOR BETWEEN (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MINVALUE))))))))))) AND (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MAXVALUE))))))))))))",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS PERIOD FOR time_column BETWEEN MINVALUE AND MAXVALUE;",
        "example": [
            "SELECT salary FROM employees VERSIONS PERIOD FOR time_column BETWEEN MINVALUE AND MAXVALUE;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "VERSIONS BETWEEN SCN MINVALUE AND expr",
        "tree": "(flashback_query_clause VERSIONS BETWEEN SCN (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (atom (constant MINVALUE))))))))))) AND)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees VERSIONS BETWEEN SCN MINVALUE AND SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees VERSIONS BETWEEN SCN MINVALUE AND SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "AS OF PERIOD FOR valid_time_column",
        "tree": "(flashback_query_clause AS OF PERIOD FOR)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees AS OF PERIOD FOR valid_time_column SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees AS OF PERIOD FOR valid_time_column SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "AS OF TIMESTAMP expr",
        "tree": "(flashback_query_clause AS OF TIMESTAMP)",
        "description": "Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history",
        "detail": "[DESCRIPTION]: Use the <code>flashback_query_clause</code> to retrieve data from a table, view, or materialized view based on time dimensions associated with the data. This clause implements SQL-driven Flashback, which lets you specify the following: A different system change number or timestamp for each object in the select list, using the clauses <code>VERSIONS</code> <code>BETWEEN</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code> or <code>VERSIONS</code> <code>AS</code> <code>OF</code> <code>{</code> <code>SCN</code> <code>|</code> <code>TIMESTAMP</code> <code>}</code>. You can also implement session-level Flashback using the <code>DBMS_FLASHBACK</code> package. A valid time period for each object in the select list, using the clauses <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> or <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code>. You can also implement valid-time session-level Flashback using the <code>DBMS_FLASHBACK_ARCHIVE</code> package. A Flashback Query lets you retrieve a history of changes made to a row. You can retrieve the corresponding identifier of the transaction that made the change using the <code>VERSIONS_XID</code> pseudocolumn. You can also retrieve information about the transaction that resulted in a particular row version by issuing an Oracle Flashback Transaction Query. You do this by querying the <code>FLASHBACK_TRANSACTION_QUERY</code> data dictionary view for a particular transaction ID. <subsubsect>VERSIONS BETWEEN { SCN | TIMESTAMP }</subsubsect> Specify <code>VERSIONS</code> <code>BETWEEN</code> to retrieve multiple versions of the rows returned by the query. Oracle Database returns all committed versions of the rows that existed between two SCNs or between two timestamp values. The first specified SCN or timestamp must be earlier than the second specified SCN or timestamp. The rows returned include deleted and subsequently reinserted versions of the rows. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>SCN</code> ... to retrieve the versions of the row that existed between two SCNs. Both expressions must evaluate to a number and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the SCN of the oldest and most recent data available, respectively. Specify <code>VERSIONS</code> <code>BETWEEN</code> <code>TIMESTAMP</code> ... to retrieve the versions of the row that existed between two timestamps. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> and <code>MAXVALUE</code> resolve to the timestamp of the oldest and most recent data available, respectively. <subsubsect>AS OF { SCN | TIMESTAMP }</subsubsect> Specify <code>AS</code> <code>OF</code> to retrieve the single version of the rows returned by the query at a particular change number (SCN) or timestamp. If you specify <code>SCN</code>, then <code>expr</code> must evaluate to a number. If you specify <code>TIMESTAMP</code>, then <code>expr</code> must evaluate to a timestamp value. In either case, <code>expr</code> cannot evaluate to NULL. Oracle Database returns rows as they existed at the specified system change number or time. Oracle Database provides a group of version query pseudocolumns that let you retrieve additional information about the various row versions. Refer to \"Version Query Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Version-Query-Pseudocolumns.html#GUID-F4DB0235-43A9-4AA2-8E9C-F2D9699D4AAD)\" for more information. When both clauses are used together, the <code>AS</code> <code>OF</code> clause determines the SCN or moment in time from which the database issues the query. The <code>VERSIONS</code> clause determines the versions of the rows as seen from the <code>AS</code> <code>OF</code> point. The database returns null for a row version if the transaction started before the first <code>BETWEEN</code> value or ended after the <code>AS</code> <code>OF</code> point. <subsubsect>VERSIONS PERIOD FOR</subsubsect> Specify <code>VERSIONS</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid during the specified time period. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use the <code>BETWEEN</code> clause to specify the time period during which rows are considered valid. Both expressions must evaluate to a timestamp value and cannot evaluate to NULL. <code>MINVALUE</code> resolves to the earliest date or timestamp in the start time column of <code>table</code>. <code>MAXVALUE</code> resolves to latest date or timestamp in the end time column of <code>table</code>. <subsubsect>AS OF PERIOD FOR</subsubsect> Specify <code>AS</code> <code>OF</code> <code>PERIOD</code> <code>FOR</code> to retrieve rows from <code>table</code> based on whether they are considered valid as of the specified time. In order to use this clause, <code>table</code> must support Temporal Validity. For <code>valid_time_column</code>, specify the name of the valid time dimension column for <code>table</code>. Use <code>expr</code> to specify the time as of which rows are considered valid. The expression must evaluate to a timestamp value and cannot evaluate to NULL. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS967) for more information on Temporal Validity <code>CREATE</code> <code>TABLE</code> period_definition(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-TABLE.html#GUID-F9CE0CC3-13AE-4744-A43C-EAC7A71AAAB6__CJADHJHB) to learn how to configure a table to support Temporal Validity and for information about the <code>valid_time_column</code>, start time column, and end time column <subsubsect>Note on Flashback Queries</subsubsect> When performing a flashback query, Oracle Database might not use query optimizations that it would use for other types of queries, which could have a negative impact on performance. In particular, this occurs when you specify multiple flashback queries in a hierarchical query. <subsubsect>Restrictions on Flashback Queries</subsubsect> These queries are subject to the following restrictions: You cannot specify a column expression or a subquery in the expression of the <code>AS</code> <code>OF</code> clause. You cannot specify the <code>AS</code> <code>OF</code> clause if you have specified the <code>for_update_clause</code>. You cannot use the <code>AS</code> <code>OF</code> clause in the defining query of a materialized view. You cannot use the <code>VERSIONS</code> clause in flashback queries to temporary or external tables, or tables that are part of a cluster. You cannot use the <code>VERSIONS</code> clause in flashback queries to views. However, you can use the <code>VERSIONS</code> syntax in the defining query of a view. You cannot specify the <code>flashback_query_clause</code> if you have specified <code>query_name</code> in the <code>query_table_expression</code>. See Also: Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01003) for more information on Oracle Flashback Query \"Using Flashback Queries: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2112847)\" Oracle Database Development Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADFNS01009) and Oracle Database PL/SQL Packages and Types Reference(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ARPLS142) for information about session-level Flashback using the <code>DBMS_FLASHBACK</code> package Oracle Database Administrator's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADMIN01513) and to the description of <code>FLASHBACK_TRANSACTION_QUERY</code>(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=REFRN23379) in the Oracle Database Reference for more information about transaction history<sep>[DEMO]: SELECT salary FROM employees AS OF TIMESTAMP SYSTIMESTAMP;",
        "example": [
            "SELECT salary FROM employees AS OF TIMESTAMP SYSTIMESTAMP;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "schema . table @ dblink",
        "tree": "(tableview_name @)",
        "description": "Use the <code>query_table_expression</code> clause to identify a subquery block, table, view, materialized view, analytic view, hierarchy, partition, or subpartition, or to specify a subquery that identifies the objects. In order to specify a subquery block, you must have specified the subquery block name (<code>query_name</code> in the <code>subquery_factoring_clause</code> or <code>subav_name</code> in the <code>subav_factoring_clause</code> ). The analytic view in the expression may be a transitory analytic view defined in the <code>with_clause</code> or a persistent analytic view. See Also: \"Using Subqueries: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130078)\" <subsubsect>LATERAL</subsubsect> Specify <code>LATERAL</code> to designate <code>subquery</code> as a lateral inline view. Within a lateral inline view, you can specify tables that appear to the left of the lateral inline view in the <code>FROM</code> clause of a query. You can specify this left correlation anywhere within <code>subquery</code> (such as the <code>SELECT</code>, <code>FROM</code>, and <code>WHERE</code> clauses) and at any nesting level. <subsubsect>Restrictions on LATERAL</subsubsect> Lateral inline views are subject to the following restrictions: If you specify <code>LATERAL</code>, then you cannot specify the <code>pivot_clause</code>, the <code>unpivot_clause</code>, or a pattern in the <code>table_reference</code> clause. If a lateral inline view contains the <code>query_partition_clause</code>, and it is the right side of a join clause, then it cannot contain a left correlation to the left table in the join clause. However, it can contain a left correlation to a table to its left in the <code>FROM</code> clause that is not the left table. A lateral inline view cannot contain a left correlation to the first table in a right outer join or full outer join. See Also: \"Using Lateral Inline Views: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABFDGIJ)\"",
        "detail": "[DESCRIPTION]: Use the <code>query_table_expression</code> clause to identify a subquery block, table, view, materialized view, analytic view, hierarchy, partition, or subpartition, or to specify a subquery that identifies the objects. In order to specify a subquery block, you must have specified the subquery block name (<code>query_name</code> in the <code>subquery_factoring_clause</code> or <code>subav_name</code> in the <code>subav_factoring_clause</code> ). The analytic view in the expression may be a transitory analytic view defined in the <code>with_clause</code> or a persistent analytic view. See Also: \"Using Subqueries: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130078)\" <subsubsect>LATERAL</subsubsect> Specify <code>LATERAL</code> to designate <code>subquery</code> as a lateral inline view. Within a lateral inline view, you can specify tables that appear to the left of the lateral inline view in the <code>FROM</code> clause of a query. You can specify this left correlation anywhere within <code>subquery</code> (such as the <code>SELECT</code>, <code>FROM</code>, and <code>WHERE</code> clauses) and at any nesting level. <subsubsect>Restrictions on LATERAL</subsubsect> Lateral inline views are subject to the following restrictions: If you specify <code>LATERAL</code>, then you cannot specify the <code>pivot_clause</code>, the <code>unpivot_clause</code>, or a pattern in the <code>table_reference</code> clause. If a lateral inline view contains the <code>query_partition_clause</code>, and it is the right side of a join clause, then it cannot contain a left correlation to the left table in the join clause. However, it can contain a left correlation to a table to its left in the <code>FROM</code> clause that is not the left table. A lateral inline view cannot contain a left correlation to the first table in a right outer join or full outer join. See Also: \"Using Lateral Inline Views: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABFDGIJ)\"<sep>[DEMO]: SELECT * FROM scott.emp @ remote_db;",
        "example": [
            "SELECT * FROM scott.emp @ remote_db;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "LATERAL ( subquery )",
        "tree": "(dml_table_expression_clause LATERAL ( ))",
        "description": "Use the <code>query_table_expression</code> clause to identify a subquery block, table, view, materialized view, analytic view, hierarchy, partition, or subpartition, or to specify a subquery that identifies the objects. In order to specify a subquery block, you must have specified the subquery block name (<code>query_name</code> in the <code>subquery_factoring_clause</code> or <code>subav_name</code> in the <code>subav_factoring_clause</code> ). The analytic view in the expression may be a transitory analytic view defined in the <code>with_clause</code> or a persistent analytic view. See Also: \"Using Subqueries: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130078)\" <subsubsect>LATERAL</subsubsect> Specify <code>LATERAL</code> to designate <code>subquery</code> as a lateral inline view. Within a lateral inline view, you can specify tables that appear to the left of the lateral inline view in the <code>FROM</code> clause of a query. You can specify this left correlation anywhere within <code>subquery</code> (such as the <code>SELECT</code>, <code>FROM</code>, and <code>WHERE</code> clauses) and at any nesting level. <subsubsect>Restrictions on LATERAL</subsubsect> Lateral inline views are subject to the following restrictions: If you specify <code>LATERAL</code>, then you cannot specify the <code>pivot_clause</code>, the <code>unpivot_clause</code>, or a pattern in the <code>table_reference</code> clause. If a lateral inline view contains the <code>query_partition_clause</code>, and it is the right side of a join clause, then it cannot contain a left correlation to the left table in the join clause. However, it can contain a left correlation to a table to its left in the <code>FROM</code> clause that is not the left table. A lateral inline view cannot contain a left correlation to the first table in a right outer join or full outer join. See Also: \"Using Lateral Inline Views: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABFDGIJ)\"",
        "detail": "[DESCRIPTION]: Use the <code>query_table_expression</code> clause to identify a subquery block, table, view, materialized view, analytic view, hierarchy, partition, or subpartition, or to specify a subquery that identifies the objects. In order to specify a subquery block, you must have specified the subquery block name (<code>query_name</code> in the <code>subquery_factoring_clause</code> or <code>subav_name</code> in the <code>subav_factoring_clause</code> ). The analytic view in the expression may be a transitory analytic view defined in the <code>with_clause</code> or a persistent analytic view. See Also: \"Using Subqueries: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130078)\" <subsubsect>LATERAL</subsubsect> Specify <code>LATERAL</code> to designate <code>subquery</code> as a lateral inline view. Within a lateral inline view, you can specify tables that appear to the left of the lateral inline view in the <code>FROM</code> clause of a query. You can specify this left correlation anywhere within <code>subquery</code> (such as the <code>SELECT</code>, <code>FROM</code>, and <code>WHERE</code> clauses) and at any nesting level. <subsubsect>Restrictions on LATERAL</subsubsect> Lateral inline views are subject to the following restrictions: If you specify <code>LATERAL</code>, then you cannot specify the <code>pivot_clause</code>, the <code>unpivot_clause</code>, or a pattern in the <code>table_reference</code> clause. If a lateral inline view contains the <code>query_partition_clause</code>, and it is the right side of a join clause, then it cannot contain a left correlation to the left table in the join clause. However, it can contain a left correlation to a table to its left in the <code>FROM</code> clause that is not the left table. A lateral inline view cannot contain a left correlation to the first table in a right outer join or full outer join. See Also: \"Using Lateral Inline Views: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABFDGIJ)\"<sep>[DEMO]: SELECT a.employee_id, b.department_name FROM employees a, LATERAL (SELECT department_name FROM departments WHERE department_id = a.department_id) b;",
        "example": [
            "SELECT a.employee_id, b.department_name FROM employees a, LATERAL (SELECT department_name FROM departments WHERE department_id = a.department_id) b;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PIVOT ( aggregate_function ( expr ) AS alias )",
        "tree": "(pivot_clause PIVOT ( (pivot_element ( ) (column_alias AS)) ))",
        "description": "The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both. The subclauses of the <code>pivot_clause</code> have the following semantics: <subsubsect>XML</subsubsect> The optional <code>XML</code> keyword generates XML output for the query. The <code>XML</code> keyword permits the <code>pivot_in_clause</code> to contain either a subquery or the wildcard keyword <code>ANY</code>. Subqueries and <code>ANY</code> wildcards are useful when the <code>pivot_in_clause</code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code>XML</code> when you specify explicit pivot values using expressions in the <code>pivot_in_clause</code>. When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code>XMLType</code> containing an XML string for all value and measure pairs. <subsubsect>expr</subsubsect> For <code>expr</code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier. <subsubsect>subquery</subsubsect> A subquery is used only in conjunction with the <code>XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data. The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code>DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values. <subsubsect>ANY</subsubsect> The <code>ANY</code> keyword is used only in conjunction with the <code>XML</code> keyword. The <code>ANY</code> keyword acts as a wildcard and is similar in effect to <code>subquery</code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the <code>ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. However, in contrast to the behavior when you specify <code>subquery</code>, the <code>ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0209) for more information about <code>PIVOT</code> and <code>UNPIVOT</code> and \"Using PIVOT and UNPIVOT: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__CHDFIIDD)\"",
        "detail": "[DESCRIPTION]: The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both. The subclauses of the <code>pivot_clause</code> have the following semantics: <subsubsect>XML</subsubsect> The optional <code>XML</code> keyword generates XML output for the query. The <code>XML</code> keyword permits the <code>pivot_in_clause</code> to contain either a subquery or the wildcard keyword <code>ANY</code>. Subqueries and <code>ANY</code> wildcards are useful when the <code>pivot_in_clause</code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code>XML</code> when you specify explicit pivot values using expressions in the <code>pivot_in_clause</code>. When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code>XMLType</code> containing an XML string for all value and measure pairs. <subsubsect>expr</subsubsect> For <code>expr</code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier. <subsubsect>subquery</subsubsect> A subquery is used only in conjunction with the <code>XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data. The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code>DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values. <subsubsect>ANY</subsubsect> The <code>ANY</code> keyword is used only in conjunction with the <code>XML</code> keyword. The <code>ANY</code> keyword acts as a wildcard and is similar in effect to <code>subquery</code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the <code>ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. However, in contrast to the behavior when you specify <code>subquery</code>, the <code>ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0209) for more information about <code>PIVOT</code> and <code>UNPIVOT</code> and \"Using PIVOT and UNPIVOT: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__CHDFIIDD)\"<sep>[DEMO]: SELECT * FROM ( SELECT department, salary FROM employees ) PIVOT ( AGGRFUNC (salary) AS col_a FOR department IN (ANY));",
        "example": [
            "SELECT * FROM ( SELECT department, salary FROM employees ) PIVOT ( AGGRFUNC (salary) AS col_a FOR department IN (ANY));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PIVOT XML ( aggregate_function ( expr ) AS alias )",
        "tree": "(pivot_clause PIVOT XML ( (pivot_element ( ) (column_alias AS)) ))",
        "description": "The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both. The subclauses of the <code>pivot_clause</code> have the following semantics: <subsubsect>XML</subsubsect> The optional <code>XML</code> keyword generates XML output for the query. The <code>XML</code> keyword permits the <code>pivot_in_clause</code> to contain either a subquery or the wildcard keyword <code>ANY</code>. Subqueries and <code>ANY</code> wildcards are useful when the <code>pivot_in_clause</code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code>XML</code> when you specify explicit pivot values using expressions in the <code>pivot_in_clause</code>. When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code>XMLType</code> containing an XML string for all value and measure pairs. <subsubsect>expr</subsubsect> For <code>expr</code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier. <subsubsect>subquery</subsubsect> A subquery is used only in conjunction with the <code>XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data. The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code>DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values. <subsubsect>ANY</subsubsect> The <code>ANY</code> keyword is used only in conjunction with the <code>XML</code> keyword. The <code>ANY</code> keyword acts as a wildcard and is similar in effect to <code>subquery</code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the <code>ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. However, in contrast to the behavior when you specify <code>subquery</code>, the <code>ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0209) for more information about <code>PIVOT</code> and <code>UNPIVOT</code> and \"Using PIVOT and UNPIVOT: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__CHDFIIDD)\"",
        "detail": "[DESCRIPTION]: The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both. The subclauses of the <code>pivot_clause</code> have the following semantics: <subsubsect>XML</subsubsect> The optional <code>XML</code> keyword generates XML output for the query. The <code>XML</code> keyword permits the <code>pivot_in_clause</code> to contain either a subquery or the wildcard keyword <code>ANY</code>. Subqueries and <code>ANY</code> wildcards are useful when the <code>pivot_in_clause</code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code>XML</code> when you specify explicit pivot values using expressions in the <code>pivot_in_clause</code>. When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code>XMLType</code> containing an XML string for all value and measure pairs. <subsubsect>expr</subsubsect> For <code>expr</code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier. <subsubsect>subquery</subsubsect> A subquery is used only in conjunction with the <code>XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data. The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code>DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values. <subsubsect>ANY</subsubsect> The <code>ANY</code> keyword is used only in conjunction with the <code>XML</code> keyword. The <code>ANY</code> keyword acts as a wildcard and is similar in effect to <code>subquery</code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the <code>ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. However, in contrast to the behavior when you specify <code>subquery</code>, the <code>ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0209) for more information about <code>PIVOT</code> and <code>UNPIVOT</code> and \"Using PIVOT and UNPIVOT: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__CHDFIIDD)\"<sep>[DEMO]: SELECT * FROM ( SELECT department, salary FROM employees ) PIVOT XML ( AGGRFUNC (salary) AS col_a FOR department IN (ANY));",
        "example": [
            "SELECT * FROM ( SELECT department, salary FROM employees ) PIVOT XML ( AGGRFUNC (salary) AS col_a FOR department IN (ANY));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PIVOT XML ( aggregate_function ( expr ) alias )",
        "tree": "(pivot_clause PIVOT XML ( (pivot_element ( )) ))",
        "description": "The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both. The subclauses of the <code>pivot_clause</code> have the following semantics: <subsubsect>XML</subsubsect> The optional <code>XML</code> keyword generates XML output for the query. The <code>XML</code> keyword permits the <code>pivot_in_clause</code> to contain either a subquery or the wildcard keyword <code>ANY</code>. Subqueries and <code>ANY</code> wildcards are useful when the <code>pivot_in_clause</code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code>XML</code> when you specify explicit pivot values using expressions in the <code>pivot_in_clause</code>. When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code>XMLType</code> containing an XML string for all value and measure pairs. <subsubsect>expr</subsubsect> For <code>expr</code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier. <subsubsect>subquery</subsubsect> A subquery is used only in conjunction with the <code>XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data. The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code>DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values. <subsubsect>ANY</subsubsect> The <code>ANY</code> keyword is used only in conjunction with the <code>XML</code> keyword. The <code>ANY</code> keyword acts as a wildcard and is similar in effect to <code>subquery</code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the <code>ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. However, in contrast to the behavior when you specify <code>subquery</code>, the <code>ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0209) for more information about <code>PIVOT</code> and <code>UNPIVOT</code> and \"Using PIVOT and UNPIVOT: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__CHDFIIDD)\"",
        "detail": "[DESCRIPTION]: The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both. The subclauses of the <code>pivot_clause</code> have the following semantics: <subsubsect>XML</subsubsect> The optional <code>XML</code> keyword generates XML output for the query. The <code>XML</code> keyword permits the <code>pivot_in_clause</code> to contain either a subquery or the wildcard keyword <code>ANY</code>. Subqueries and <code>ANY</code> wildcards are useful when the <code>pivot_in_clause</code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code>XML</code> when you specify explicit pivot values using expressions in the <code>pivot_in_clause</code>. When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code>XMLType</code> containing an XML string for all value and measure pairs. <subsubsect>expr</subsubsect> For <code>expr</code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier. <subsubsect>subquery</subsubsect> A subquery is used only in conjunction with the <code>XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data. The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code>DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values. <subsubsect>ANY</subsubsect> The <code>ANY</code> keyword is used only in conjunction with the <code>XML</code> keyword. The <code>ANY</code> keyword acts as a wildcard and is similar in effect to <code>subquery</code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the <code>ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. However, in contrast to the behavior when you specify <code>subquery</code>, the <code>ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0209) for more information about <code>PIVOT</code> and <code>UNPIVOT</code> and \"Using PIVOT and UNPIVOT: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__CHDFIIDD)\"<sep>[DEMO]: SELECT * FROM ( SELECT department, salary FROM employees ) PIVOT XML ( AGGRFUNC (salary) col_a FOR department IN (ANY));",
        "example": [
            "SELECT * FROM ( SELECT department, salary FROM employees ) PIVOT XML ( AGGRFUNC (salary) col_a FOR department IN (ANY));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PIVOT ( aggregate_function ( expr ) alias )",
        "tree": "(pivot_clause PIVOT ( (pivot_element ( )) ))",
        "description": "The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both. The subclauses of the <code>pivot_clause</code> have the following semantics: <subsubsect>XML</subsubsect> The optional <code>XML</code> keyword generates XML output for the query. The <code>XML</code> keyword permits the <code>pivot_in_clause</code> to contain either a subquery or the wildcard keyword <code>ANY</code>. Subqueries and <code>ANY</code> wildcards are useful when the <code>pivot_in_clause</code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code>XML</code> when you specify explicit pivot values using expressions in the <code>pivot_in_clause</code>. When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code>XMLType</code> containing an XML string for all value and measure pairs. <subsubsect>expr</subsubsect> For <code>expr</code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier. <subsubsect>subquery</subsubsect> A subquery is used only in conjunction with the <code>XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data. The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code>DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values. <subsubsect>ANY</subsubsect> The <code>ANY</code> keyword is used only in conjunction with the <code>XML</code> keyword. The <code>ANY</code> keyword acts as a wildcard and is similar in effect to <code>subquery</code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the <code>ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. However, in contrast to the behavior when you specify <code>subquery</code>, the <code>ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0209) for more information about <code>PIVOT</code> and <code>UNPIVOT</code> and \"Using PIVOT and UNPIVOT: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__CHDFIIDD)\"",
        "detail": "[DESCRIPTION]: The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both. The subclauses of the <code>pivot_clause</code> have the following semantics: <subsubsect>XML</subsubsect> The optional <code>XML</code> keyword generates XML output for the query. The <code>XML</code> keyword permits the <code>pivot_in_clause</code> to contain either a subquery or the wildcard keyword <code>ANY</code>. Subqueries and <code>ANY</code> wildcards are useful when the <code>pivot_in_clause</code> values are not known in advance. With XML output, the values of the pivot column are evaluated at execution time. You cannot specify <code>XML</code> when you specify explicit pivot values using expressions in the <code>pivot_in_clause</code>. When XML output is generated, the aggregate function is applied to each distinct pivot value, and the database returns a column of <code>XMLType</code> containing an XML string for all value and measure pairs. <subsubsect>expr</subsubsect> For <code>expr</code>, specify an expression that evaluates to a constant value of a pivot column. You can optionally provide an alias for each pivot column value. If there is no alias, the column heading becomes a quoted identifier. <subsubsect>subquery</subsubsect> A subquery is used only in conjunction with the <code>XML</code> keyword. When you specify a subquery, all values found by the subquery are used for pivoting. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the subquery produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. The XML string for each output row includes all pivot values found by the subquery, even if there are no corresponding rows in the input data. The subquery must return a list of unique values at the execution time of the pivot query. If the subquery does not return a unique value, then Oracle Database raises a run-time error. Use the <code>DISTINCT</code> keyword in the subquery if you are not sure the query will return unique values. <subsubsect>ANY</subsubsect> The <code>ANY</code> keyword is used only in conjunction with the <code>XML</code> keyword. The <code>ANY</code> keyword acts as a wildcard and is similar in effect to <code>subquery</code>. The output is not the same cross-tabular format returned by non-XML pivot queries. Instead of multiple columns specified in the <code>pivot_in_clause</code>, the <code>ANY</code> keyword produces a single XML string column. The XML string for each row holds aggregated data corresponding to the implicit <code>GROUP</code> <code>BY</code> value of that row. However, in contrast to the behavior when you specify <code>subquery</code>, the <code>ANY</code> wildcard produces an XML string for each output row that includes only the pivot values found in the input data corresponding to that row. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0209) for more information about <code>PIVOT</code> and <code>UNPIVOT</code> and \"Using PIVOT and UNPIVOT: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__CHDFIIDD)\"<sep>[DEMO]: SELECT * FROM ( SELECT department, salary FROM employees ) PIVOT ( AGGRFUNC (salary) col_a FOR department IN (ANY));",
        "example": [
            "SELECT * FROM ( SELECT department, salary FROM employees ) PIVOT ( AGGRFUNC (salary) col_a FOR department IN (ANY));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "UNPIVOT ( column )",
        "tree": "(unpivot_clause UNPIVOT ( ))",
        "description": "The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>pivot_for_clause</code>, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.",
        "detail": "[DESCRIPTION]: The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>pivot_for_clause</code>, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.<sep>[DEMO]: SELECT * FROM (SELECT employee_id, Q1_sales, Q2_sales, Q3_sales, Q4_sales FROM sales_data) UNPIVOT (sales_amount FOR quarter IN (Q1_sales AS 'Q1', Q2_sales AS 'Q2', Q3_sales AS 'Q3', Q4_sales AS 'Q4'));",
        "example": [
            "SELECT * FROM (SELECT employee_id, Q1_sales, Q2_sales, Q3_sales, Q4_sales FROM sales_data) UNPIVOT (sales_amount FOR quarter IN (Q1_sales AS 'Q1', Q2_sales AS 'Q2', Q3_sales AS 'Q3', Q4_sales AS 'Q4'));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "UNPIVOT EXCLUDE NULLS ( column )",
        "tree": "(unpivot_clause UNPIVOT EXCLUDE NULLS ( ))",
        "description": "The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>pivot_for_clause</code>, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.",
        "detail": "[DESCRIPTION]: The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>pivot_for_clause</code>, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.<sep>[DEMO]: SELECT * FROM (SELECT employee_id, Q1_sales, Q2_sales, Q3_sales, Q4_sales FROM sales_data) UNPIVOT EXCLUDE NULLS (sales_quantity FOR quarter IN (Q1_sales AS 'Q1', Q2_sales AS 'Q2', Q3_sales AS 'Q3', Q4_sales AS 'Q4'));",
        "example": [
            "SELECT * FROM (SELECT employee_id, Q1_sales, Q2_sales, Q3_sales, Q4_sales FROM sales_data) UNPIVOT EXCLUDE NULLS (sales_quantity FOR quarter IN (Q1_sales AS 'Q1', Q2_sales AS 'Q2', Q3_sales AS 'Q3', Q4_sales AS 'Q4'));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "UNPIVOT INCLUDE NULLS ( column )",
        "tree": "(unpivot_clause UNPIVOT INCLUDE NULLS ( ))",
        "description": "The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>pivot_for_clause</code>, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.",
        "detail": "[DESCRIPTION]: The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>pivot_for_clause</code>, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.<sep>[DEMO]: SELECT * FROM (SELECT employee_id, Q1_sales, Q2_sales, Q3_sales, Q4_sales FROM sales_data) UNPIVOT INCLUDE NULLS (sales_quantity FOR quarter IN (Q1_sales AS 'Q1', Q2_sales AS 'Q2', Q3_sales AS 'Q3', Q4_sales AS 'Q4'));",
        "example": [
            "SELECT * FROM (SELECT employee_id, Q1_sales, Q2_sales, Q3_sales, Q4_sales FROM sales_data) UNPIVOT INCLUDE NULLS (sales_quantity FOR quarter IN (Q1_sales AS 'Q1', Q2_sales AS 'Q2', Q3_sales AS 'Q3', Q4_sales AS 'Q4'));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SAMPLE ( sample_percent )",
        "tree": "(sample_clause SAMPLE ( ))",
        "description": "The <code>sample_clause</code> lets you instruct the database to select from a random sample of data from the table, rather than from the entire table. See Also: \"Selecting a Sample: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105143)\" <subsubsect>BLOCK</subsubsect> <code>BLOCK</code> instructs the database to attempt to perform random block sampling instead of random row sampling. Block sampling is possible only during full table scans or index fast full scans. If a more efficient execution path exists, then Oracle Database does not perform block sampling. If you want to guarantee block sampling for a particular table or index, then use the <code>FULL</code> or <code>INDEX_FFS</code> hint. Beginning with Oracle Database 12c Release 2 (12.2.), you can specify block sampling for external tables. In earlier releases, specifying block sampling for external tables had no effect; row sampling was performed. <subsubsect>sample_percent</subsubsect> For <code>sample_percent</code>, specify the percentage of the total row or block count to be included in the sample. The value must be in the range .000001 to, but not including, 100. This percentage indicates the probability of each row, or each cluster of rows in the case of block sampling, being selected as part of the sample. It does not mean that the database will retrieve exactly <code>sample_percent</code> of the rows of <code>table</code>. WARNING: The use of statistically incorrect assumptions when using this feature can lead to incorrect or undesirable results. <subsubsect>SEED seed_value</subsubsect> Specify this clause to instruct the database to attempt to return the same sample from one execution to the next. The <code>seed_value</code> must be an integer between 0 and 4294967295. If you omit this clause, then the resulting sample will change from one execution to the next. <subsubsect>Restrictions on sample_clause</subsubsect> The following restrictions apply to the <code>SAMPLE</code> clause: You cannot specify the <code>SAMPLE</code> clause in a subquery in a DML statement. You can specify the <code>SAMPLE</code> clause in a query on a base table, a container table of a materialized view, or a view that is key preserving. You cannot specify this clause on a view that is not key preserving.",
        "detail": "[DESCRIPTION]: The <code>sample_clause</code> lets you instruct the database to select from a random sample of data from the table, rather than from the entire table. See Also: \"Selecting a Sample: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105143)\" <subsubsect>BLOCK</subsubsect> <code>BLOCK</code> instructs the database to attempt to perform random block sampling instead of random row sampling. Block sampling is possible only during full table scans or index fast full scans. If a more efficient execution path exists, then Oracle Database does not perform block sampling. If you want to guarantee block sampling for a particular table or index, then use the <code>FULL</code> or <code>INDEX_FFS</code> hint. Beginning with Oracle Database 12c Release 2 (12.2.), you can specify block sampling for external tables. In earlier releases, specifying block sampling for external tables had no effect; row sampling was performed. <subsubsect>sample_percent</subsubsect> For <code>sample_percent</code>, specify the percentage of the total row or block count to be included in the sample. The value must be in the range .000001 to, but not including, 100. This percentage indicates the probability of each row, or each cluster of rows in the case of block sampling, being selected as part of the sample. It does not mean that the database will retrieve exactly <code>sample_percent</code> of the rows of <code>table</code>. WARNING: The use of statistically incorrect assumptions when using this feature can lead to incorrect or undesirable results. <subsubsect>SEED seed_value</subsubsect> Specify this clause to instruct the database to attempt to return the same sample from one execution to the next. The <code>seed_value</code> must be an integer between 0 and 4294967295. If you omit this clause, then the resulting sample will change from one execution to the next. <subsubsect>Restrictions on sample_clause</subsubsect> The following restrictions apply to the <code>SAMPLE</code> clause: You cannot specify the <code>SAMPLE</code> clause in a subquery in a DML statement. You can specify the <code>SAMPLE</code> clause in a query on a base table, a container table of a materialized view, or a view that is key preserving. You cannot specify this clause on a view that is not key preserving.<sep>[DEMO]: SELECT COUNT(*) * 10 FROM orders SAMPLE (10);",
        "example": [
            "SELECT COUNT(*) * 10 FROM orders SAMPLE (10);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SAMPLE BLOCK ( sample_percent )",
        "tree": "(sample_clause SAMPLE BLOCK ( ))",
        "description": "The <code>sample_clause</code> lets you instruct the database to select from a random sample of data from the table, rather than from the entire table. See Also: \"Selecting a Sample: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105143)\" <subsubsect>BLOCK</subsubsect> <code>BLOCK</code> instructs the database to attempt to perform random block sampling instead of random row sampling. Block sampling is possible only during full table scans or index fast full scans. If a more efficient execution path exists, then Oracle Database does not perform block sampling. If you want to guarantee block sampling for a particular table or index, then use the <code>FULL</code> or <code>INDEX_FFS</code> hint. Beginning with Oracle Database 12c Release 2 (12.2.), you can specify block sampling for external tables. In earlier releases, specifying block sampling for external tables had no effect; row sampling was performed. <subsubsect>sample_percent</subsubsect> For <code>sample_percent</code>, specify the percentage of the total row or block count to be included in the sample. The value must be in the range .000001 to, but not including, 100. This percentage indicates the probability of each row, or each cluster of rows in the case of block sampling, being selected as part of the sample. It does not mean that the database will retrieve exactly <code>sample_percent</code> of the rows of <code>table</code>. WARNING: The use of statistically incorrect assumptions when using this feature can lead to incorrect or undesirable results. <subsubsect>SEED seed_value</subsubsect> Specify this clause to instruct the database to attempt to return the same sample from one execution to the next. The <code>seed_value</code> must be an integer between 0 and 4294967295. If you omit this clause, then the resulting sample will change from one execution to the next. <subsubsect>Restrictions on sample_clause</subsubsect> The following restrictions apply to the <code>SAMPLE</code> clause: You cannot specify the <code>SAMPLE</code> clause in a subquery in a DML statement. You can specify the <code>SAMPLE</code> clause in a query on a base table, a container table of a materialized view, or a view that is key preserving. You cannot specify this clause on a view that is not key preserving.",
        "detail": "[DESCRIPTION]: The <code>sample_clause</code> lets you instruct the database to select from a random sample of data from the table, rather than from the entire table. See Also: \"Selecting a Sample: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105143)\" <subsubsect>BLOCK</subsubsect> <code>BLOCK</code> instructs the database to attempt to perform random block sampling instead of random row sampling. Block sampling is possible only during full table scans or index fast full scans. If a more efficient execution path exists, then Oracle Database does not perform block sampling. If you want to guarantee block sampling for a particular table or index, then use the <code>FULL</code> or <code>INDEX_FFS</code> hint. Beginning with Oracle Database 12c Release 2 (12.2.), you can specify block sampling for external tables. In earlier releases, specifying block sampling for external tables had no effect; row sampling was performed. <subsubsect>sample_percent</subsubsect> For <code>sample_percent</code>, specify the percentage of the total row or block count to be included in the sample. The value must be in the range .000001 to, but not including, 100. This percentage indicates the probability of each row, or each cluster of rows in the case of block sampling, being selected as part of the sample. It does not mean that the database will retrieve exactly <code>sample_percent</code> of the rows of <code>table</code>. WARNING: The use of statistically incorrect assumptions when using this feature can lead to incorrect or undesirable results. <subsubsect>SEED seed_value</subsubsect> Specify this clause to instruct the database to attempt to return the same sample from one execution to the next. The <code>seed_value</code> must be an integer between 0 and 4294967295. If you omit this clause, then the resulting sample will change from one execution to the next. <subsubsect>Restrictions on sample_clause</subsubsect> The following restrictions apply to the <code>SAMPLE</code> clause: You cannot specify the <code>SAMPLE</code> clause in a subquery in a DML statement. You can specify the <code>SAMPLE</code> clause in a query on a base table, a container table of a materialized view, or a view that is key preserving. You cannot specify this clause on a view that is not key preserving.<sep>[DEMO]: SELECT COUNT(*) * 10 FROM orders SAMPLE BLOCK (10);",
        "example": [
            "SELECT COUNT(*) * 10 FROM orders SAMPLE BLOCK (10);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SAMPLE ( sample_percent ) SEED ( seed_value )",
        "tree": "(sample_clause SAMPLE ( ) (seed_part SEED ( )))",
        "description": "The <code>sample_clause</code> lets you instruct the database to select from a random sample of data from the table, rather than from the entire table. See Also: \"Selecting a Sample: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105143)\" <subsubsect>BLOCK</subsubsect> <code>BLOCK</code> instructs the database to attempt to perform random block sampling instead of random row sampling. Block sampling is possible only during full table scans or index fast full scans. If a more efficient execution path exists, then Oracle Database does not perform block sampling. If you want to guarantee block sampling for a particular table or index, then use the <code>FULL</code> or <code>INDEX_FFS</code> hint. Beginning with Oracle Database 12c Release 2 (12.2.), you can specify block sampling for external tables. In earlier releases, specifying block sampling for external tables had no effect; row sampling was performed. <subsubsect>sample_percent</subsubsect> For <code>sample_percent</code>, specify the percentage of the total row or block count to be included in the sample. The value must be in the range .000001 to, but not including, 100. This percentage indicates the probability of each row, or each cluster of rows in the case of block sampling, being selected as part of the sample. It does not mean that the database will retrieve exactly <code>sample_percent</code> of the rows of <code>table</code>. WARNING: The use of statistically incorrect assumptions when using this feature can lead to incorrect or undesirable results. <subsubsect>SEED seed_value</subsubsect> Specify this clause to instruct the database to attempt to return the same sample from one execution to the next. The <code>seed_value</code> must be an integer between 0 and 4294967295. If you omit this clause, then the resulting sample will change from one execution to the next. <subsubsect>Restrictions on sample_clause</subsubsect> The following restrictions apply to the <code>SAMPLE</code> clause: You cannot specify the <code>SAMPLE</code> clause in a subquery in a DML statement. You can specify the <code>SAMPLE</code> clause in a query on a base table, a container table of a materialized view, or a view that is key preserving. You cannot specify this clause on a view that is not key preserving.",
        "detail": "[DESCRIPTION]: The <code>sample_clause</code> lets you instruct the database to select from a random sample of data from the table, rather than from the entire table. See Also: \"Selecting a Sample: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105143)\" <subsubsect>BLOCK</subsubsect> <code>BLOCK</code> instructs the database to attempt to perform random block sampling instead of random row sampling. Block sampling is possible only during full table scans or index fast full scans. If a more efficient execution path exists, then Oracle Database does not perform block sampling. If you want to guarantee block sampling for a particular table or index, then use the <code>FULL</code> or <code>INDEX_FFS</code> hint. Beginning with Oracle Database 12c Release 2 (12.2.), you can specify block sampling for external tables. In earlier releases, specifying block sampling for external tables had no effect; row sampling was performed. <subsubsect>sample_percent</subsubsect> For <code>sample_percent</code>, specify the percentage of the total row or block count to be included in the sample. The value must be in the range .000001 to, but not including, 100. This percentage indicates the probability of each row, or each cluster of rows in the case of block sampling, being selected as part of the sample. It does not mean that the database will retrieve exactly <code>sample_percent</code> of the rows of <code>table</code>. WARNING: The use of statistically incorrect assumptions when using this feature can lead to incorrect or undesirable results. <subsubsect>SEED seed_value</subsubsect> Specify this clause to instruct the database to attempt to return the same sample from one execution to the next. The <code>seed_value</code> must be an integer between 0 and 4294967295. If you omit this clause, then the resulting sample will change from one execution to the next. <subsubsect>Restrictions on sample_clause</subsubsect> The following restrictions apply to the <code>SAMPLE</code> clause: You cannot specify the <code>SAMPLE</code> clause in a subquery in a DML statement. You can specify the <code>SAMPLE</code> clause in a query on a base table, a container table of a materialized view, or a view that is key preserving. You cannot specify this clause on a view that is not key preserving.<sep>[DEMO]: SELECT COUNT(*) * 10 FROM orders SAMPLE (10) SEED (8);",
        "example": [
            "SELECT COUNT(*) * 10 FROM orders SAMPLE (10) SEED (8);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PARTITION ( partition )",
        "tree": "(partition_extension_clause PARTITION ( ))",
        "description": "For <code>PARTITION</code> or <code>SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code>table</code> from which you want to retrieve data. For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code>WHERE</code> clause that restricts the retrieval to one or more partitions of <code>table</code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code>WHERE</code> condition for hash-partitioned data. See Also: \"References to Partitioned Tables and Indexes(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#GUID-FED2E424-3F06-4B2B-88D2-DE043CA6E0E4)\" and \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"",
        "detail": "[DESCRIPTION]: For <code>PARTITION</code> or <code>SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code>table</code> from which you want to retrieve data. For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code>WHERE</code> clause that restricts the retrieval to one or more partitions of <code>table</code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code>WHERE</code> condition for hash-partitioned data. See Also: \"References to Partitioned Tables and Indexes(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#GUID-FED2E424-3F06-4B2B-88D2-DE043CA6E0E4)\" and \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"<sep>[DEMO]: SELECT * FROM sales PARTITION (sales_q2_2000) s;",
        "example": [
            "SELECT * FROM sales PARTITION (sales_q2_2000) s;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PARTITION FOR ( partition_key_value )",
        "tree": "(partition_extension_clause PARTITION FOR ( ))",
        "description": "For <code>PARTITION</code> or <code>SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code>table</code> from which you want to retrieve data. For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code>WHERE</code> clause that restricts the retrieval to one or more partitions of <code>table</code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code>WHERE</code> condition for hash-partitioned data. See Also: \"References to Partitioned Tables and Indexes(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#GUID-FED2E424-3F06-4B2B-88D2-DE043CA6E0E4)\" and \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"",
        "detail": "[DESCRIPTION]: For <code>PARTITION</code> or <code>SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code>table</code> from which you want to retrieve data. For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code>WHERE</code> clause that restricts the retrieval to one or more partitions of <code>table</code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code>WHERE</code> condition for hash-partitioned data. See Also: \"References to Partitioned Tables and Indexes(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#GUID-FED2E424-3F06-4B2B-88D2-DE043CA6E0E4)\" and \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"<sep>[DEMO]: SELECT * FROM sales PARTITION FOR (sales_q2_2000) s;",
        "example": [
            "SELECT * FROM sales PARTITION FOR (sales_q2_2000) s;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SUBPARTITION FOR ( subpartition_key_value )",
        "tree": "(partition_extension_clause SUBPARTITION FOR ( ))",
        "description": "For <code>PARTITION</code> or <code>SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code>table</code> from which you want to retrieve data. For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code>WHERE</code> clause that restricts the retrieval to one or more partitions of <code>table</code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code>WHERE</code> condition for hash-partitioned data. See Also: \"References to Partitioned Tables and Indexes(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#GUID-FED2E424-3F06-4B2B-88D2-DE043CA6E0E4)\" and \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"",
        "detail": "[DESCRIPTION]: For <code>PARTITION</code> or <code>SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code>table</code> from which you want to retrieve data. For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code>WHERE</code> clause that restricts the retrieval to one or more partitions of <code>table</code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code>WHERE</code> condition for hash-partitioned data. See Also: \"References to Partitioned Tables and Indexes(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#GUID-FED2E424-3F06-4B2B-88D2-DE043CA6E0E4)\" and \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"<sep>[DEMO]: SELECT * FROM sales SUBPARTITION FOR (sales_q2_2000) s;",
        "example": [
            "SELECT * FROM sales SUBPARTITION FOR (sales_q2_2000) s;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SUBPARTITION ( subpartition )",
        "tree": "(partition_extension_clause SUBPARTITION ( ))",
        "description": "For <code>PARTITION</code> or <code>SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code>table</code> from which you want to retrieve data. For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code>WHERE</code> clause that restricts the retrieval to one or more partitions of <code>table</code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code>WHERE</code> condition for hash-partitioned data. See Also: \"References to Partitioned Tables and Indexes(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#GUID-FED2E424-3F06-4B2B-88D2-DE043CA6E0E4)\" and \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"",
        "detail": "[DESCRIPTION]: For <code>PARTITION</code> or <code>SUBPARTITION</code>, specify the name or key value of the partition or subpartition within <code>table</code> from which you want to retrieve data. For range- and list-partitioned data, as an alternative to this clause, you can specify a condition in the <code>WHERE</code> clause that restricts the retrieval to one or more partitions of <code>table</code>. Oracle Database will interpret the condition and fetch data from only those partitions. It is not possible to formulate such a <code>WHERE</code> condition for hash-partitioned data. See Also: \"References to Partitioned Tables and Indexes(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Syntax-for-Schema-Objects-and-Parts-in-SQL-Statements.html#GUID-FED2E424-3F06-4B2B-88D2-DE043CA6E0E4)\" and \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"<sep>[DEMO]: SELECT * FROM sales SUBPARTITION (sales_q2_2000) s;",
        "example": [
            "SELECT * FROM sales SUBPARTITION (sales_q2_2000) s;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "WITH READ ONLY",
        "tree": "(subquery_restriction_clause WITH READ ONLY)",
        "description": "The <code>subquery_restriction_clause</code> lets you restrict the subquery in one of the following ways: <subsubsect>WITH READ ONLY</subsubsect> Specify <code>WITH READ ONLY</code> to indicate that the table or view cannot be updated. <subsubsect>WITH CHECK OPTION</subsubsect> Specify <code>WITH CHECK OPTION</code> to indicate that Oracle Database prohibits any changes to the table or view that would produce rows that are not included in the subquery. When used in the subquery of a DML statement, you can specify this clause in a subquery in the <code>FROM</code> clause but not in subquery in the <code>WHERE</code> clause. <subsubsect>CONSTRAINT constraint</subsubsect> Specify the name of the <code>CHECK OPTION</code> constraint. If you omit this identifier, then Oracle automatically assigns the constraint a name of the form <code>SYS_C</code><code>n</code>, where n is an integer that makes the constraint name unique within the database. See Also: \"Using the WITH CHECK OPTION Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066598)\"",
        "detail": "[DESCRIPTION]: The <code>subquery_restriction_clause</code> lets you restrict the subquery in one of the following ways: <subsubsect>WITH READ ONLY</subsubsect> Specify <code>WITH READ ONLY</code> to indicate that the table or view cannot be updated. <subsubsect>WITH CHECK OPTION</subsubsect> Specify <code>WITH CHECK OPTION</code> to indicate that Oracle Database prohibits any changes to the table or view that would produce rows that are not included in the subquery. When used in the subquery of a DML statement, you can specify this clause in a subquery in the <code>FROM</code> clause but not in subquery in the <code>WHERE</code> clause. <subsubsect>CONSTRAINT constraint</subsubsect> Specify the name of the <code>CHECK OPTION</code> constraint. If you omit this identifier, then Oracle automatically assigns the constraint a name of the form <code>SYS_C</code><code>n</code>, where n is an integer that makes the constraint name unique within the database. See Also: \"Using the WITH CHECK OPTION Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066598)\"<sep>[DEMO]: INSERT INTO (SELECT * FROM departments WHERE location_id < 2000 WITH READ ONLY) VALUES (9999, 'Entertainment', 2500);",
        "example": [
            "INSERT INTO (SELECT * FROM departments WHERE location_id < 2000 WITH READ ONLY) VALUES (9999, 'Entertainment', 2500);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "WITH CHECK OPTION CONSTRAINT constraint",
        "tree": "(subquery_restriction_clause WITH CHECK OPTION CONSTRAINT)",
        "description": "The <code>subquery_restriction_clause</code> lets you restrict the subquery in one of the following ways: <subsubsect>WITH READ ONLY</subsubsect> Specify <code>WITH READ ONLY</code> to indicate that the table or view cannot be updated. <subsubsect>WITH CHECK OPTION</subsubsect> Specify <code>WITH CHECK OPTION</code> to indicate that Oracle Database prohibits any changes to the table or view that would produce rows that are not included in the subquery. When used in the subquery of a DML statement, you can specify this clause in a subquery in the <code>FROM</code> clause but not in subquery in the <code>WHERE</code> clause. <subsubsect>CONSTRAINT constraint</subsubsect> Specify the name of the <code>CHECK OPTION</code> constraint. If you omit this identifier, then Oracle automatically assigns the constraint a name of the form <code>SYS_C</code><code>n</code>, where n is an integer that makes the constraint name unique within the database. See Also: \"Using the WITH CHECK OPTION Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066598)\"",
        "detail": "[DESCRIPTION]: The <code>subquery_restriction_clause</code> lets you restrict the subquery in one of the following ways: <subsubsect>WITH READ ONLY</subsubsect> Specify <code>WITH READ ONLY</code> to indicate that the table or view cannot be updated. <subsubsect>WITH CHECK OPTION</subsubsect> Specify <code>WITH CHECK OPTION</code> to indicate that Oracle Database prohibits any changes to the table or view that would produce rows that are not included in the subquery. When used in the subquery of a DML statement, you can specify this clause in a subquery in the <code>FROM</code> clause but not in subquery in the <code>WHERE</code> clause. <subsubsect>CONSTRAINT constraint</subsubsect> Specify the name of the <code>CHECK OPTION</code> constraint. If you omit this identifier, then Oracle automatically assigns the constraint a name of the form <code>SYS_C</code><code>n</code>, where n is an integer that makes the constraint name unique within the database. See Also: \"Using the WITH CHECK OPTION Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066598)\"<sep>[DEMO]: INSERT INTO (SELECT * FROM departments WHERE location_id < 2000 WITH CHECK OPTION CONSTRAINT cons_a) VALUES (9999, 'Entertainment', 2500);",
        "example": [
            "INSERT INTO (SELECT * FROM departments WHERE location_id < 2000 WITH CHECK OPTION CONSTRAINT cons_a) VALUES (9999, 'Entertainment', 2500);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "WITH CHECK OPTION",
        "tree": "(subquery_restriction_clause WITH CHECK OPTION)",
        "description": "The <code>subquery_restriction_clause</code> lets you restrict the subquery in one of the following ways: <subsubsect>WITH READ ONLY</subsubsect> Specify <code>WITH READ ONLY</code> to indicate that the table or view cannot be updated. <subsubsect>WITH CHECK OPTION</subsubsect> Specify <code>WITH CHECK OPTION</code> to indicate that Oracle Database prohibits any changes to the table or view that would produce rows that are not included in the subquery. When used in the subquery of a DML statement, you can specify this clause in a subquery in the <code>FROM</code> clause but not in subquery in the <code>WHERE</code> clause. <subsubsect>CONSTRAINT constraint</subsubsect> Specify the name of the <code>CHECK OPTION</code> constraint. If you omit this identifier, then Oracle automatically assigns the constraint a name of the form <code>SYS_C</code><code>n</code>, where n is an integer that makes the constraint name unique within the database. See Also: \"Using the WITH CHECK OPTION Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066598)\"",
        "detail": "[DESCRIPTION]: The <code>subquery_restriction_clause</code> lets you restrict the subquery in one of the following ways: <subsubsect>WITH READ ONLY</subsubsect> Specify <code>WITH READ ONLY</code> to indicate that the table or view cannot be updated. <subsubsect>WITH CHECK OPTION</subsubsect> Specify <code>WITH CHECK OPTION</code> to indicate that Oracle Database prohibits any changes to the table or view that would produce rows that are not included in the subquery. When used in the subquery of a DML statement, you can specify this clause in a subquery in the <code>FROM</code> clause but not in subquery in the <code>WHERE</code> clause. <subsubsect>CONSTRAINT constraint</subsubsect> Specify the name of the <code>CHECK OPTION</code> constraint. If you omit this identifier, then Oracle automatically assigns the constraint a name of the form <code>SYS_C</code><code>n</code>, where n is an integer that makes the constraint name unique within the database. See Also: \"Using the WITH CHECK OPTION Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066598)\"<sep>[DEMO]: INSERT INTO (SELECT * FROM departments WHERE location_id < 2000 WITH CHECK OPTION) VALUES (9999, 'Entertainment', 2500);",
        "example": [
            "INSERT INTO (SELECT * FROM departments WHERE location_id < 2000 WITH CHECK OPTION) VALUES (9999, 'Entertainment', 2500);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "TABLE ( collection_expression )",
        "tree": "(table_collection_expression TABLE ( ))",
        "description": "The <code>table_collection_expression</code> lets you inform Oracle that the value of <code>collection_expression</code> should be treated as a table for purposes of query and DML operations. The <code>collection_expression</code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value\u2014that is, a value whose type is nested table or varray. This process of extracting the elements of a collection is called collection unnesting. The optional plus (+) is relevant if you are joining the <code>TABLE</code> collection expression with the parent table. The + creates an outer join of the two, so that the query returns rows from the outer table even if the collection expression is null. Note: In earlier releases of Oracle, when <code>collection_expression</code> was a subquery, <code>table_collection_expression</code> was expressed as <code>THE</code> <code>subquery</code>. That usage is now deprecated. The <code>collection_expression</code> can reference columns of tables defined to its left in the <code>FROM</code> clause. This is called left correlation. Left correlation can occur only in <code>table_collection_expression</code>. Other subqueries cannot contains references to columns defined outside the subquery. The optional <code>(+)</code> lets you specify that <code>table_collection_expression</code> should return a row with all fields set to null if the collection is null or empty. The <code>(+)</code> is valid only if <code>collection_expression</code> uses left correlation. The result is similar to that of an outer join. When you use the <code>(+)</code> syntax in the <code>WHERE</code> clause of a subquery in an <code>UPDATE</code> or <code>DELETE</code> operation, you must specify two tables in the <code>FROM</code> clause of the subquery. Oracle Database ignores the outer join syntax unless there is a join in the subquery itself. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" \"Table Collections: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2071643)\" and \"Collection Unnesting: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2071637)\"",
        "detail": "[DESCRIPTION]: The <code>table_collection_expression</code> lets you inform Oracle that the value of <code>collection_expression</code> should be treated as a table for purposes of query and DML operations. The <code>collection_expression</code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value\u2014that is, a value whose type is nested table or varray. This process of extracting the elements of a collection is called collection unnesting. The optional plus (+) is relevant if you are joining the <code>TABLE</code> collection expression with the parent table. The + creates an outer join of the two, so that the query returns rows from the outer table even if the collection expression is null. Note: In earlier releases of Oracle, when <code>collection_expression</code> was a subquery, <code>table_collection_expression</code> was expressed as <code>THE</code> <code>subquery</code>. That usage is now deprecated. The <code>collection_expression</code> can reference columns of tables defined to its left in the <code>FROM</code> clause. This is called left correlation. Left correlation can occur only in <code>table_collection_expression</code>. Other subqueries cannot contains references to columns defined outside the subquery. The optional <code>(+)</code> lets you specify that <code>table_collection_expression</code> should return a row with all fields set to null if the collection is null or empty. The <code>(+)</code> is valid only if <code>collection_expression</code> uses left correlation. The result is similar to that of an outer join. When you use the <code>(+)</code> syntax in the <code>WHERE</code> clause of a subquery in an <code>UPDATE</code> or <code>DELETE</code> operation, you must specify two tables in the <code>FROM</code> clause of the subquery. Oracle Database ignores the outer join syntax unless there is a join in the subquery itself. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" \"Table Collections: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2071643)\" and \"Collection Unnesting: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2071637)\"<sep>[DEMO]: SELECT * FROM TABLE(SELECT CAST(COLLECT(employee_id) AS SYS.ODCINUMBERLIST) FROM employees);",
        "example": [
            "SELECT * FROM TABLE(SELECT CAST(COLLECT(employee_id) AS SYS.ODCINUMBERLIST) FROM employees);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "TABLE ( collection_expression ) ( + )",
        "tree": "(table_collection_expression TABLE ( (subquery (subquery_basic_elements (query_block (selected_list (select_list_elements (expression (logical_expression (unary_logical_expression (multiset_expression (relational_expression (compound_expression (concatenation (model_expression (unary_expression (standard_function (other_function (concatenation (model_expression (unary_expression (atom (general_element (general_element_part (function_argument )))) (outer_join_sign ( + )))))))))))))))))))))))",
        "description": "The <code>table_collection_expression</code> lets you inform Oracle that the value of <code>collection_expression</code> should be treated as a table for purposes of query and DML operations. The <code>collection_expression</code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value\u2014that is, a value whose type is nested table or varray. This process of extracting the elements of a collection is called collection unnesting. The optional plus (+) is relevant if you are joining the <code>TABLE</code> collection expression with the parent table. The + creates an outer join of the two, so that the query returns rows from the outer table even if the collection expression is null. Note: In earlier releases of Oracle, when <code>collection_expression</code> was a subquery, <code>table_collection_expression</code> was expressed as <code>THE</code> <code>subquery</code>. That usage is now deprecated. The <code>collection_expression</code> can reference columns of tables defined to its left in the <code>FROM</code> clause. This is called left correlation. Left correlation can occur only in <code>table_collection_expression</code>. Other subqueries cannot contains references to columns defined outside the subquery. The optional <code>(+)</code> lets you specify that <code>table_collection_expression</code> should return a row with all fields set to null if the collection is null or empty. The <code>(+)</code> is valid only if <code>collection_expression</code> uses left correlation. The result is similar to that of an outer join. When you use the <code>(+)</code> syntax in the <code>WHERE</code> clause of a subquery in an <code>UPDATE</code> or <code>DELETE</code> operation, you must specify two tables in the <code>FROM</code> clause of the subquery. Oracle Database ignores the outer join syntax unless there is a join in the subquery itself. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" \"Table Collections: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2071643)\" and \"Collection Unnesting: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2071637)\"",
        "detail": "[DESCRIPTION]: The <code>table_collection_expression</code> lets you inform Oracle that the value of <code>collection_expression</code> should be treated as a table for purposes of query and DML operations. The <code>collection_expression</code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value\u2014that is, a value whose type is nested table or varray. This process of extracting the elements of a collection is called collection unnesting. The optional plus (+) is relevant if you are joining the <code>TABLE</code> collection expression with the parent table. The + creates an outer join of the two, so that the query returns rows from the outer table even if the collection expression is null. Note: In earlier releases of Oracle, when <code>collection_expression</code> was a subquery, <code>table_collection_expression</code> was expressed as <code>THE</code> <code>subquery</code>. That usage is now deprecated. The <code>collection_expression</code> can reference columns of tables defined to its left in the <code>FROM</code> clause. This is called left correlation. Left correlation can occur only in <code>table_collection_expression</code>. Other subqueries cannot contains references to columns defined outside the subquery. The optional <code>(+)</code> lets you specify that <code>table_collection_expression</code> should return a row with all fields set to null if the collection is null or empty. The <code>(+)</code> is valid only if <code>collection_expression</code> uses left correlation. The result is similar to that of an outer join. When you use the <code>(+)</code> syntax in the <code>WHERE</code> clause of a subquery in an <code>UPDATE</code> or <code>DELETE</code> operation, you must specify two tables in the <code>FROM</code> clause of the subquery. Oracle Database ignores the outer join syntax unless there is a join in the subquery itself. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" \"Table Collections: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2071643)\" and \"Collection Unnesting: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2071637)\"<sep>[DEMO]: SELECT * FROM TABLE(SELECT CAST(COLLECT(employee_id)(+) AS SYS.ODCINUMBERLIST) FROM employees);",
        "example": [
            "SELECT * FROM TABLE(SELECT CAST(COLLECT(employee_id)(+) AS SYS.ODCINUMBERLIST) FROM employees);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "JOIN table_reference ON condition",
        "tree": "(join_clause JOIN (join_on_part ON))",
        "description": "Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.",
        "detail": "[DESCRIPTION]: Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.<sep>[DEMO]: SELECT employees.name, departments.name FROM employees JOIN departments ON employees.department_id = departments.id;",
        "example": [
            "SELECT employees.name, departments.name FROM employees JOIN departments ON employees.department_id = departments.id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "NATURAL JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c NATURAL)))))) (join_clause JOIN))",
        "description": "Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.",
        "detail": "[DESCRIPTION]: Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.<sep>[DEMO]: SELECT employees.name, departments.name FROM employees NATURAL JOIN departments;",
        "example": [
            "SELECT employees.name, departments.name FROM employees NATURAL JOIN departments;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "NATURAL INNER JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c NATURAL)))))) (join_clause INNER JOIN))",
        "description": "Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.",
        "detail": "[DESCRIPTION]: Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.<sep>[DEMO]: SELECT employees.name, departments.name FROM employees NATURAL INNER JOIN departments;",
        "example": [
            "SELECT employees.name, departments.name FROM employees NATURAL INNER JOIN departments;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "CROSS JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c CROSS)))))) (join_clause JOIN))",
        "description": "Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.",
        "detail": "[DESCRIPTION]: Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.<sep>[DEMO]: SELECT employees.name, departments.name FROM employees CROSS JOIN departments;",
        "example": [
            "SELECT employees.name, departments.name FROM employees CROSS JOIN departments;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "INNER JOIN table_reference ON condition",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c INNER)))))) (join_clause JOIN (join_on_part ON)))",
        "description": "Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.",
        "detail": "[DESCRIPTION]: Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.<sep>[DEMO]: SELECT employees.name, departments.name FROM employees INNER JOIN departments ON employees.department_id = departments.id;",
        "example": [
            "SELECT employees.name, departments.name FROM employees INNER JOIN departments ON employees.department_id = departments.id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "INNER JOIN table_reference USING ( column )",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c INNER)))))) (join_clause JOIN (join_using_part USING (paren_column_list ( )))))",
        "description": "Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.",
        "detail": "[DESCRIPTION]: Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees INNER JOIN departments USING (department_id);",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees INNER JOIN departments USING (department_id);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "JOIN table_reference USING ( column )",
        "tree": "(join_clause JOIN (join_using_part USING (paren_column_list ( ))))",
        "description": "Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.",
        "detail": "[DESCRIPTION]: Inner joins return only those rows that satisfy the join condition. <subsubsect>INNER</subsubsect> Specify <code>INNER</code> to explicitly specify an inner join. <subsubsect>JOIN</subsubsect> The <code>JOIN</code> keyword explicitly states that a join is being performed. You can use this syntax to replace the comma-delimited table expressions used in <code>WHERE</code> clause joins with <code>FROM</code> clause join syntax. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>USING (column)</subsubsect> When you are specifying an equijoin of columns that have the same name in both tables, the <code>USING</code> <code>column</code> clause indicates the columns to be used. You can use this clause only if the join columns in both tables have the same name. Within this clause, do not qualify the column name with a table name or table alias. <subsubsect>CROSS</subsubsect> The <code>CROSS</code> keyword indicates that a cross join is being performed. A cross join produces the cross-product of two relations and is essentially the same as the comma-delimited Oracle Database notation. <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. Refer to NATURAL(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABHGCAE) for the full semantics of this clause.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees JOIN departments USING (department_id);",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees JOIN departments USING (department_id);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "RIGHT OUTER JOIN table_reference",
        "tree": "(join_clause (outer_join_type RIGHT OUTER) JOIN)",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT * FROM employees RIGHT OUTER JOIN departments USING (department_id);",
        "example": [
            "SELECT * FROM employees RIGHT OUTER JOIN departments USING (department_id);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "RIGHT JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c RIGHT)))))) (join_clause JOIN))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT * FROM employees RIGHT JOIN departments USING (department_id);",
        "example": [
            "SELECT * FROM employees RIGHT JOIN departments USING (department_id);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "RIGHT JOIN table_reference USING ( column )",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c RIGHT)))))) (join_clause JOIN (join_using_part USING (paren_column_list ( )))))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT * FROM employees RIGHT JOIN departments USING (department_id);",
        "example": [
            "SELECT * FROM employees RIGHT JOIN departments USING (department_id);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "LEFT JOIN table_reference USING ( column )",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c LEFT)))))) (join_clause JOIN (join_using_part USING (paren_column_list ( )))))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT * FROM employees LEFT JOIN departments USING (department_id);",
        "example": [
            "SELECT * FROM employees LEFT JOIN departments USING (department_id);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FULL JOIN table_reference USING ( column )",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c FULL)))))) (join_clause JOIN (join_using_part USING (paren_column_list ( )))))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT * FROM employees FULL JOIN departments USING (department_id);",
        "example": [
            "SELECT * FROM employees FULL JOIN departments USING (department_id);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FULL OUTER JOIN table_reference",
        "tree": "(join_clause (outer_join_type FULL OUTER) JOIN)",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees FULL OUTER JOIN departments ON employees.department_id = departments.id;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees FULL OUTER JOIN departments ON employees.department_id = departments.id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "LEFT JOIN table_reference ON condition",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c LEFT)))))) (join_clause JOIN (join_on_part ON)))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees LEFT JOIN departments ON employees.department_id = departments.id;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees LEFT JOIN departments ON employees.department_id = departments.id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "LEFT JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c LEFT)))))) (join_clause JOIN))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees LEFT JOIN departments ON employees.department_id = departments.id;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees LEFT JOIN departments ON employees.department_id = departments.id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "NATURAL FULL JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c NATURAL)))))) (join_clause (outer_join_type FULL) JOIN))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees NATURAL FULL JOIN departments;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees NATURAL FULL JOIN departments;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FULL JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c FULL)))))) (join_clause JOIN))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees LEFT OUTER JOIN departments;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees LEFT OUTER JOIN departments;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FULL JOIN table_reference ON condition",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c FULL)))))) (join_clause JOIN (join_on_part ON)))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees FULL JOIN departments ON employees.department_id = departments.id;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees FULL JOIN departments ON employees.department_id = departments.id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "RIGHT JOIN table_reference ON condition",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c RIGHT)))))) (join_clause JOIN (join_on_part ON)))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees RIGHT JOIN departments ON employees.department_id = departments.id;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees RIGHT JOIN departments ON employees.department_id = departments.id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "NATURAL RIGHT JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c NATURAL)))))) (join_clause (outer_join_type RIGHT) JOIN))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees NATURAL RIGHT JOIN departments;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees NATURAL RIGHT JOIN departments;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "NATURAL LEFT JOIN table_reference",
        "tree": "(table_ref (table_ref_aux (table_alias (identifier (id_expression (regular_id (non_reserved_keywords_pre12c NATURAL)))))) (join_clause (outer_join_type LEFT) JOIN))",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees NATURAL LEFT JOIN departments;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees NATURAL LEFT JOIN departments;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "LEFT OUTER JOIN table_reference",
        "tree": "(join_clause (outer_join_type LEFT OUTER) JOIN)",
        "description": "Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.",
        "detail": "[DESCRIPTION]: Outer joins return all rows that satisfy the join condition and also return some or all of those rows from one table for which no rows from the other satisfy the join condition. You can specify two types of outer joins: a conventional outer join using the <code>table_reference</code> syntax on both sides of the join, or a partitioned outer join using the <code>query_partition_clause</code> on one side or the other. A partitioned outer join is similar to a conventional outer join except that the join takes place between the outer table and each partition of the inner table. This type of join lets you selectively make sparse data more dense along the dimensions of interest. This process is called data densification. <subsubsect>query_partition_clause</subsubsect> The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses). <subsubsect>Restrictions on Partitioned Outer Joins</subsubsect> Partitioned outer joins are subject to the following restrictions: You can specify the <code>query_partition_clause</code> on either the right or left side of the join, but not both. You cannot specify a <code>FULL</code> partitioned outer join. If you specify the <code>query_partition_clause</code> in an outer join with an <code>ON</code> clause, then you cannot specify a subquery in the <code>ON</code> condition. See Also: \"Using Partitioned Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2177515)\" <subsubsect>NATURAL</subsubsect> The <code>NATURAL</code> keyword indicates that a natural join is being performed. A natural join is based on all columns in the two tables that have the same name. It selects rows from the two tables that have equal values in the relevant columns. If two columns with the same name do not have compatible data types, then an error is raised. When specifying columns that are involved in the natural join, do not qualify the column name with a table name or table alias. On occasion, the table pairings in natural or cross joins may be ambiguous. For example, consider the following join syntax:<code>a NATURAL LEFT JOIN b LEFT JOIN c ON b.c1 = c.c1 </code>This example can be interpreted in either of the following ways:<code> a NATURAL LEFT JOIN (b LEFT JOIN c ON b.c1 = c.c1) (a NATURAL LEFT JOIN b) LEFT JOIN c ON b.c1 = c.c1 </code>To avoid this ambiguity, you can use parentheses to specify the pairings of joined tables. In the absence of such parentheses, the database uses left associativity, pairing the tables from left to right. <subsubsect>Restriction on Natural Joins</subsubsect> You cannot specify a LOB column, columns of <code>ANYTYPE</code>, <code>ANYDATA</code>, or <code>ANYDATASET</code>, or a collection column as part of a natural join. <subsubsect>outer_join_type</subsubsect> The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed. <subsubsect>ON condition</subsubsect> Use the <code>ON</code> clause to specify a join condition. Doing so lets you specify join conditions separate from any search or filter conditions in the <code>WHERE</code> clause. <subsubsect>Restriction on the ON condition Clause</subsubsect> You cannot specify this clause with a <code>NATURAL</code> outer join. <subsubsect>USING column</subsubsect> In an outer join with the <code>USING</code> clause, the query returns a single column that coalesces the two matching columns in the join. The coalesce function is as follows: <code>COALESCE (a, b) = a if a NOT NULL, else b. </code>Therefore: A left outer join returns all the common column values from the left table in the <code>FROM</code> clause. A right outer join returns all the common column values from the right table in the <code>FROM</code> clause. A full outer join returns all the common column values from both joined tables. <subsubsect>Restriction on the USING column Clause</subsubsect> The <code>USING</code> <code>column</code> clause is subject to the following restrictions: Within this clause, do not qualify the column name with a table name or table alias. You cannot specify a LOB column or a collection column in the <code>USING</code> <code>column</code> clause. You cannot specify this clause with a <code>NATURAL</code> outer join. See Also: \"Outer Joins(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Joins.html#GUID-29A4584C-0741-4E6A-A89B-DCFAA222994A)\" for additional rules and restrictions pertaining to outer joins Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG02013) for a complete discussion of partitioned outer joins and data densification \"Using Outer Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2107296)\". The <code>outer_join_type</code> indicates the kind of outer join being performed: Specify <code>RIGHT</code> to indicate a right outer join. Specify <code>LEFT</code> to indicate a left outer join. Specify <code>FULL</code> to indicate a full or two-sided outer join. In addition to the inner join, rows from both tables that have not been returned in the result of the inner join will be preserved and extended with nulls. You can specify the optional <code>OUTER</code> keyword following <code>RIGHT</code>, <code>LEFT</code>, or <code>FULL</code> to explicitly clarify that an outer join is being performed.<sep>[DEMO]: SELECT employees.name, departments.department_name FROM employees LEFT OUTER JOIN departments ON employees.department_id = departments.id;",
        "example": [
            "SELECT employees.name, departments.department_name FROM employees LEFT OUTER JOIN departments ON employees.department_id = departments.id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PARTITION BY expr",
        "tree": "(query_partition_clause PARTITION BY)",
        "description": "The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses).",
        "detail": "[DESCRIPTION]: The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses).<sep>[DEMO]: SELECT department_id, last_name, salary, AVG(salary) OVER (PARTITION BY department_id) AS dept_avg_salary FROM employees;",
        "example": [
            "SELECT department_id, last_name, salary, AVG(salary) OVER (PARTITION BY department_id) AS dept_avg_salary FROM employees;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PARTITION BY ( expr )",
        "tree": "(query_partition_clause PARTITION BY ( ))",
        "description": "The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses).",
        "detail": "[DESCRIPTION]: The <code>query_partition_clause</code> lets you define a partitioned outer join. Such a join extends the conventional outer join syntax by applying the outer join to partitions returned by the query. Oracle Database creates a partition of rows for each expression you specify in the <code>PARTITION</code> <code>BY</code> clause. The rows in each query partition have same value for the <code>PARTITION</code> <code>BY</code> expression. The <code>query_partition_clause</code> can be on either side of the outer join. The result of a partitioned outer join is a <code>UNION</code> of the outer joins of each of the partitions in the partitioned result set and the table on the other side of the join. This type of result is useful for filling gaps in sparse data, which simplifies analytic calculations. If you omit this clause, then the database treats the entire table expression\u2014everything specified in <code>table_reference</code>\u2014as a single partition, resulting in a conventional outer join. To use the <code>query_partition_clause</code> in an analytic function, use the upper branch of the syntax (without parentheses). To use this clause in a model query (in the <code>model_column_clauses</code>) or a partitioned outer join (in the <code>outer_join_clause</code>), use the lower branch of the syntax (with parentheses).<sep>[DEMO]: SELECT department_id, last_name, salary, AVG(salary) OVER (PARTITION BY (department_id)) AS dept_avg_salary FROM employees;",
        "example": [
            "SELECT department_id, last_name, salary, AVG(salary) OVER (PARTITION BY (department_id)) AS dept_avg_salary FROM employees;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "CROSS APPLY table_reference",
        "tree": "(join_clause CROSS APPLY)",
        "description": "This clause allows you to perform a variation of an ANSI <code>CROSS</code> <code>JOIN</code> or an ANSI <code>LEFT</code> <code>OUTER</code> <code>JOIN</code> with left correlation support. You can specify a <code>table_reference</code> or <code>collection_expression</code> to the right of the <code>APPLY</code> keyword. The <code>table_reference</code> can be a table, inline view, or <code>TABLE</code> collection expression. The <code>collection_expression</code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value\u2014that is, a value whose type is nested table or varray. The <code>table_reference</code> or <code>collection_expression</code> can reference columns of tables defined in the <code>FROM</code> clause to the left of the <code>APPLY</code> keyword. This is called left correlation. Specify <code>CROSS</code> <code>APPLY</code> to perform a variation of an ANSI <code>CROSS</code> <code>JOIN</code>. Only rows from the table on the left side of the join that produce a result set from <code>table_reference</code> or <code>collection_expression</code> are returned. Specify <code>OUTER</code> <code>APPLY</code> to perform a variation of an ANSI <code>LEFT</code> <code>OUTER</code> <code>JOIN</code>. All rows from the table on the left side of the join are returned. Rows that do not produce a result set from <code>table_reference</code> or <code>collection_expression</code> have the NULL value in the corresponding column(s). <subsubsect>Restriction on the cross_outer_apply_clause</subsubsect> The <code>table_reference</code> cannot be a lateral inline view. See Also: Using CROSS APPLY and OUTER APPLY Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABDADCJ)",
        "detail": "[DESCRIPTION]: This clause allows you to perform a variation of an ANSI <code>CROSS</code> <code>JOIN</code> or an ANSI <code>LEFT</code> <code>OUTER</code> <code>JOIN</code> with left correlation support. You can specify a <code>table_reference</code> or <code>collection_expression</code> to the right of the <code>APPLY</code> keyword. The <code>table_reference</code> can be a table, inline view, or <code>TABLE</code> collection expression. The <code>collection_expression</code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value\u2014that is, a value whose type is nested table or varray. The <code>table_reference</code> or <code>collection_expression</code> can reference columns of tables defined in the <code>FROM</code> clause to the left of the <code>APPLY</code> keyword. This is called left correlation. Specify <code>CROSS</code> <code>APPLY</code> to perform a variation of an ANSI <code>CROSS</code> <code>JOIN</code>. Only rows from the table on the left side of the join that produce a result set from <code>table_reference</code> or <code>collection_expression</code> are returned. Specify <code>OUTER</code> <code>APPLY</code> to perform a variation of an ANSI <code>LEFT</code> <code>OUTER</code> <code>JOIN</code>. All rows from the table on the left side of the join are returned. Rows that do not produce a result set from <code>table_reference</code> or <code>collection_expression</code> have the NULL value in the corresponding column(s). <subsubsect>Restriction on the cross_outer_apply_clause</subsubsect> The <code>table_reference</code> cannot be a lateral inline view. See Also: Using CROSS APPLY and OUTER APPLY Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABDADCJ)<sep>[DEMO]: SELECT * FROM departments CROSS APPLY (SELECT * FROM employees e) v;",
        "example": [
            "SELECT * FROM departments CROSS APPLY (SELECT * FROM employees e) v;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "OUTER APPLY table_reference",
        "tree": "(join_clause OUTER APPLY)",
        "description": "This clause allows you to perform a variation of an ANSI <code>CROSS</code> <code>JOIN</code> or an ANSI <code>LEFT</code> <code>OUTER</code> <code>JOIN</code> with left correlation support. You can specify a <code>table_reference</code> or <code>collection_expression</code> to the right of the <code>APPLY</code> keyword. The <code>table_reference</code> can be a table, inline view, or <code>TABLE</code> collection expression. The <code>collection_expression</code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value\u2014that is, a value whose type is nested table or varray. The <code>table_reference</code> or <code>collection_expression</code> can reference columns of tables defined in the <code>FROM</code> clause to the left of the <code>APPLY</code> keyword. This is called left correlation. Specify <code>CROSS</code> <code>APPLY</code> to perform a variation of an ANSI <code>CROSS</code> <code>JOIN</code>. Only rows from the table on the left side of the join that produce a result set from <code>table_reference</code> or <code>collection_expression</code> are returned. Specify <code>OUTER</code> <code>APPLY</code> to perform a variation of an ANSI <code>LEFT</code> <code>OUTER</code> <code>JOIN</code>. All rows from the table on the left side of the join are returned. Rows that do not produce a result set from <code>table_reference</code> or <code>collection_expression</code> have the NULL value in the corresponding column(s). <subsubsect>Restriction on the cross_outer_apply_clause</subsubsect> The <code>table_reference</code> cannot be a lateral inline view. See Also: Using CROSS APPLY and OUTER APPLY Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABDADCJ)",
        "detail": "[DESCRIPTION]: This clause allows you to perform a variation of an ANSI <code>CROSS</code> <code>JOIN</code> or an ANSI <code>LEFT</code> <code>OUTER</code> <code>JOIN</code> with left correlation support. You can specify a <code>table_reference</code> or <code>collection_expression</code> to the right of the <code>APPLY</code> keyword. The <code>table_reference</code> can be a table, inline view, or <code>TABLE</code> collection expression. The <code>collection_expression</code> can be a subquery, a column, a function, or a collection constructor. Regardless of its form, it must return a collection value\u2014that is, a value whose type is nested table or varray. The <code>table_reference</code> or <code>collection_expression</code> can reference columns of tables defined in the <code>FROM</code> clause to the left of the <code>APPLY</code> keyword. This is called left correlation. Specify <code>CROSS</code> <code>APPLY</code> to perform a variation of an ANSI <code>CROSS</code> <code>JOIN</code>. Only rows from the table on the left side of the join that produce a result set from <code>table_reference</code> or <code>collection_expression</code> are returned. Specify <code>OUTER</code> <code>APPLY</code> to perform a variation of an ANSI <code>LEFT</code> <code>OUTER</code> <code>JOIN</code>. All rows from the table on the left side of the join are returned. Rows that do not produce a result set from <code>table_reference</code> or <code>collection_expression</code> have the NULL value in the corresponding column(s). <subsubsect>Restriction on the cross_outer_apply_clause</subsubsect> The <code>table_reference</code> cannot be a lateral inline view. See Also: Using CROSS APPLY and OUTER APPLY Joins: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__BABDADCJ)<sep>[DEMO]: SELECT * FROM departments OUTER APPLY (SELECT * FROM employees e) v;",
        "example": [
            "SELECT * FROM departments OUTER APPLY (SELECT * FROM employees e) v;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ANALYTIC VIEW AS ( sub_av_clause )",
        "tree": "(subav_factoring_clause ANALYTIC VIEW AS ( ))",
        "description": "An inline analytic view is a transitory analytic view that is specified in the <code>FROM</code> clause. To create an inline analytic view, use the <code>ANALYTIC</code> <code>VIEW</code> keyword and specify a <code>subav_clause</code> that defines the analytic view. Optionally, you may specify an <code>inline_av_alias</code>, which is an alias for the inline analytic view. The rules for the <code>inline_av_alias</code> are the same as the rules for an inline view alias. See Also: Analytic Views: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__P-1314421-F3347731)",
        "detail": "[DESCRIPTION]: An inline analytic view is a transitory analytic view that is specified in the <code>FROM</code> clause. To create an inline analytic view, use the <code>ANALYTIC</code> <code>VIEW</code> keyword and specify a <code>subav_clause</code> that defines the analytic view. Optionally, you may specify an <code>inline_av_alias</code>, which is an alias for the inline analytic view. The rules for the <code>inline_av_alias</code> are the same as the rules for an inline view alias. See Also: Analytic Views: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__P-1314421-F3347731)<sep>[DEMO]: WITH  my_av ANALYTIC VIEW AS (    USING sales_av HIERARCHIES (time_hier)    FILTER FACT (      time_hier TO quarter_of_year IN (1, 2)         AND year_name IN ('CY2011', 'CY2012')    )  )SELECT time_hier.member_name time, sales  FROM my_av HIERARCHIES (time_hier)  WHERE time_hier.level_name IN ('YEAR', 'QUARTER')  ORDER BY time_hier.hier_order;",
        "example": [
            "WITH  my_av ANALYTIC VIEW AS (    USING sales_av HIERARCHIES (time_hier)    FILTER FACT (      time_hier TO quarter_of_year IN (1, 2)         AND year_name IN ('CY2011', 'CY2012')    )  )SELECT time_hier.member_name time, sales  FROM my_av HIERARCHIES (time_hier)  WHERE time_hier.level_name IN ('YEAR', 'QUARTER')  ORDER BY time_hier.hier_order;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ANALYTIC VIEW",
        "tree": "(subav_factoring_clause ANALYTIC VIEW)",
        "description": "An inline analytic view is a transitory analytic view that is specified in the <code>FROM</code> clause. To create an inline analytic view, use the <code>ANALYTIC</code> <code>VIEW</code> keyword and specify a <code>subav_clause</code> that defines the analytic view. Optionally, you may specify an <code>inline_av_alias</code>, which is an alias for the inline analytic view. The rules for the <code>inline_av_alias</code> are the same as the rules for an inline view alias. See Also: Analytic Views: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__P-1314421-F3347731)",
        "detail": "[DESCRIPTION]: An inline analytic view is a transitory analytic view that is specified in the <code>FROM</code> clause. To create an inline analytic view, use the <code>ANALYTIC</code> <code>VIEW</code> keyword and specify a <code>subav_clause</code> that defines the analytic view. Optionally, you may specify an <code>inline_av_alias</code>, which is an alias for the inline analytic view. The rules for the <code>inline_av_alias</code> are the same as the rules for an inline view alias. See Also: Analytic Views: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__P-1314421-F3347731)<sep>[DEMO]: WITH  my_av ANALYTIC VIEW AS (    USING sales_av HIERARCHIES (time_hier)    FILTER FACT (      time_hier TO quarter_of_year IN (1, 2)         AND year_name IN ('CY2011', 'CY2012')    )  )SELECT time_hier.member_name time, sales  FROM my_av HIERARCHIES (time_hier)  WHERE time_hier.level_name IN ('YEAR', 'QUARTER')  ORDER BY time_hier.hier_order;",
        "example": [
            "WITH  my_av ANALYTIC VIEW AS (    USING sales_av HIERARCHIES (time_hier)    FILTER FACT (      time_hier TO quarter_of_year IN (1, 2)         AND year_name IN ('CY2011', 'CY2012')    )  )SELECT time_hier.member_name time, sales  FROM my_av HIERARCHIES (time_hier)  WHERE time_hier.level_name IN ('YEAR', 'QUARTER')  ORDER BY time_hier.hier_order;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "WHERE condition",
        "tree": "(where_clause WHERE)",
        "description": "The <code>WHERE</code> condition lets you restrict the rows selected to those that satisfy one or more conditions. For <code>condition</code>, specify any valid SQL condition. If you omit this clause, then the database returns all rows from the tables, views, or materialized views in the <code>FROM</code> clause. Note: If this clause refers to a <code>DATE</code> column of a partitioned table or index, then the database performs partition pruning only if: You created the table or index partitions by fully specifying the year using the <code>TO_DATE</code> function with a 4-digit format mask, and You specify the date in the <code>where_clause</code> of the query using the <code>TO_DATE</code> function and either a 2- or 4-digit format mask. See Also: Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8) for the syntax description of <code>condition</code> \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"",
        "detail": "[DESCRIPTION]: The <code>WHERE</code> condition lets you restrict the rows selected to those that satisfy one or more conditions. For <code>condition</code>, specify any valid SQL condition. If you omit this clause, then the database returns all rows from the tables, views, or materialized views in the <code>FROM</code> clause. Note: If this clause refers to a <code>DATE</code> column of a partitioned table or index, then the database performs partition pruning only if: You created the table or index partitions by fully specifying the year using the <code>TO_DATE</code> function with a 4-digit format mask, and You specify the date in the <code>where_clause</code> of the query using the <code>TO_DATE</code> function and either a 2- or 4-digit format mask. See Also: Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8) for the syntax description of <code>condition</code> \"Selecting from a Partition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2105152)\"<sep>[DEMO]: SELECT * FROM temp WHERE a > 0;",
        "example": [
            "SELECT * FROM temp WHERE a > 0;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "CONNECT BY condition START WITH condition",
        "tree": "(hierarchical_query_clause CONNECT BY (start_part START WITH))",
        "description": "The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"",
        "detail": "[DESCRIPTION]: The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"<sep>[DEMO]: SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nCONNECT BY PRIOR employee_id = manager_id START WITH manager_id IS NULL;",
        "example": [
            "SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nCONNECT BY PRIOR employee_id = manager_id START WITH manager_id IS NULL;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "START WITH condition CONNECT BY condition",
        "tree": "(hierarchical_query_clause (start_part START WITH) CONNECT BY)",
        "description": "The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"",
        "detail": "[DESCRIPTION]: The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"<sep>[DEMO]: SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;",
        "example": [
            "SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "CONNECT BY NOCYCLE condition",
        "tree": "(hierarchical_query_clause CONNECT BY NOCYCLE)",
        "description": "The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"",
        "detail": "[DESCRIPTION]: The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"<sep>[DEMO]: SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY NOCYCLE PRIOR employee_id = manager_id;",
        "example": [
            "SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY NOCYCLE PRIOR employee_id = manager_id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "START WITH condition CONNECT BY NOCYCLE condition",
        "tree": "(hierarchical_query_clause (start_part START WITH) CONNECT BY NOCYCLE)",
        "description": "The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"",
        "detail": "[DESCRIPTION]: The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"<sep>[DEMO]: SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY NOCYCLE PRIOR employee_id = manager_id;",
        "example": [
            "SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY NOCYCLE PRIOR employee_id = manager_id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "CONNECT BY condition",
        "tree": "(hierarchical_query_clause CONNECT BY)",
        "description": "The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"",
        "detail": "[DESCRIPTION]: The <code>hierarchical_query_clause</code> lets you select rows in a hierarchical order. <code>SELECT</code> statements that contain hierarchical queries can contain the <code>LEVEL</code> pseudocolumn in the select list. <code>LEVEL</code> returns the value 1 for a root node, 2 for a child node of a root node, 3 for a grandchild, and so on. The number of levels returned by a hierarchical query may be limited by available user memory. Oracle processes hierarchical queries as follows: A join, if present, is evaluated first, whether the join is specified in the <code>FROM</code> clause or with <code>WHERE</code> clause predicates. The <code>CONNECT</code> <code>BY</code> condition is evaluated. Any remaining <code>WHERE</code> clause predicates are evaluated. If you specify this clause, then do not specify either <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, because they will destroy the hierarchical order of the <code>CONNECT</code> <code>BY</code> results. If you want to order rows of siblings of the same parent, then use the <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> clause. See Also: \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for a discussion of hierarchical queries and \"Using the LEVEL Pseudocolumn: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130122)\" <subsubsect>START WITH Clause</subsubsect> Specify a condition that identifies the row(s) to be used as the root(s) of a hierarchical query. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). Oracle Database uses as root(s) all rows that satisfy this condition. If you omit this clause, then the database uses all rows in the table as root rows. <subsubsect>CONNECT BY Clause</subsubsect> Specify a condition that identifies the relationship between parent rows and child rows of the hierarchy. The <code>condition</code> can be any condition as described in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8). However, it must use the <code>PRIOR</code> operator to refer to the parent row. See Also: Pseudocolumns(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Pseudocolumns.html#GUID-6C65C788-76AA-4A51-B011-51D53DD2521D) for more information on <code>LEVEL</code> \"Hierarchical Queries(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E)\" for general information on hierarchical queries \"Hierarchical Query Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130004)\"<sep>[DEMO]: SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY employee_id = manager_id;",
        "example": [
            "SELECT employee_id, manager_id, employee_name, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY employee_id = manager_id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "GROUP BY expr HAVING condition",
        "tree": "(group_by_clause GROUP BY (having_clause HAVING))",
        "description": "Specify the <code>GROUP</code> <code>BY</code> clause if you want the database to group the selected rows based on the value of <code>expr</code>(s) for each row and return a single row of summary information for each group. If this clause contains <code>CUBE</code> or <code>ROLLUP</code> extensions, then the database produces superaggregate groupings in addition to the regular groupings. Expressions in the <code>GROUP</code> <code>BY</code> clause can contain any columns of the tables, views, or materialized views in the <code>FROM</code> clause, regardless of whether the columns appear in the select list. The <code>GROUP</code> <code>BY</code> clause groups rows but does not guarantee the order of the result set. To order the groupings, use the <code>ORDER</code> <code>BY</code> clause. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG020) for an expanded discussion and examples of using SQL grouping syntax for data aggregation the GROUP_ID(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUP_ID.html#GUID-3A5A9C15-1B67-4FD7-AC41-EE8349B2E834), GROUPING(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUPING.html#GUID-82E6084A-0BDF-4587-A40E-36899783F073), and GROUPING_ID(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUPING_ID.html#GUID-E20A5B8E-73B6-42FD-8AFB-DD3CD6D6DC61) functions for examples \"Using the GROUP BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066419)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>GROUP</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>GROUP</code> <code>BY</code> clause <subsubsect>ROLLUP</subsubsect> The <code>ROLLUP</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of the first n, n-1, n-2, ... 0 expressions in the <code>GROUP</code> <code>BY</code> specification, and returns a single row of summary for each group. You can use the <code>ROLLUP</code> operation to produce subtotal values by using it with the <code>SUM</code> function. When used with <code>SUM</code>, <code>ROLLUP</code> generates subtotals from the most detailed level to the grand total. Aggregate functions such as <code>COUNT</code> can be used to produce other kinds of superaggregates. For example, given three expressions (n=3) in the <code>ROLLUP</code> clause of the <code>simple_grouping_clause</code>, the operation results in n+1 = 3+1 = 4 groupings. Rows grouped on the values of the first <code>n</code> expressions are called regular rows, and the others are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>ROLLUP</code> with materialized views <subsubsect>CUBE</subsubsect> The <code>CUBE</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of all possible combinations of expressions in the specification. It returns a single row of summary information for each group. You can use the <code>CUBE</code> operation to produce cross-tabulation values. For example, given three expressions (n=3) in the <code>CUBE</code> clause of the <code>simple_grouping_clause</code>, the operation results in 2n = 23 = 8 groupings. Rows grouped on the values of <code>n</code> expressions are called regular rows, and the rest are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>CUBE</code> with materialized views \"Using the GROUP BY CUBE Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066443)\" <subsubsect>GROUPING SETS</subsubsect> <code>GROUPING</code> <code>SETS</code> are a further extension of the <code>GROUP</code> <code>BY</code> clause that let you specify multiple groupings of data. Doing so facilitates efficient aggregation by pruning the aggregates you do not need. You specify just the desired groups, and the database does not need to perform the full set of aggregations generated by <code>CUBE</code> or <code>ROLLUP</code>. Oracle Database computes all groupings specified in the <code>GROUPING</code> <code>SETS</code> clause and combines the results of individual groupings with a <code>UNION</code> <code>ALL</code> operation. The <code>UNION</code> <code>ALL</code> means that the result set can include duplicate rows. Within the <code>GROUP</code> <code>BY</code> clause, you can combine expressions in various ways: To specify composite columns, group columns within parentheses so that the database treats them as a unit while computing <code>ROLLUP</code> or <code>CUBE</code> operations. To specify concatenated grouping sets, separate multiple grouping sets, <code>ROLLUP</code>, and <code>CUBE</code> operations with commas so that the database combines them into a single <code>GROUP</code> <code>BY</code> clause. The result is a cross-product of groupings from each grouping set. See Also: \"Using the GROUPING SETS Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2091446)\" <subsubsect>HAVING Clause</subsubsect> Use the <code>HAVING</code> clause to restrict the groups of returned rows to those groups for which the specified <code>condition</code> is <code>TRUE</code>. If you omit this clause, then the database returns summary rows for all groups. Specify <code>GROUP</code> <code>BY</code> and <code>HAVING</code> after the <code>where_clause</code> and <code>hierarchical_query_clause</code>. If you specify both <code>GROUP</code> <code>BY</code> and <code>HAVING</code>, then they can appear in either order. See Also: \"Using the HAVING Condition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130020)\" <subsubsect>Restrictions on the GROUP BY Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify LOB columns, nested tables, or varrays as part of <code>expr</code>. The expressions can be of any form except scalar subquery expressions. If the <code>group_by_clause</code> references any object type columns, then the query will not be parallelized.",
        "detail": "[DESCRIPTION]: Specify the <code>GROUP</code> <code>BY</code> clause if you want the database to group the selected rows based on the value of <code>expr</code>(s) for each row and return a single row of summary information for each group. If this clause contains <code>CUBE</code> or <code>ROLLUP</code> extensions, then the database produces superaggregate groupings in addition to the regular groupings. Expressions in the <code>GROUP</code> <code>BY</code> clause can contain any columns of the tables, views, or materialized views in the <code>FROM</code> clause, regardless of whether the columns appear in the select list. The <code>GROUP</code> <code>BY</code> clause groups rows but does not guarantee the order of the result set. To order the groupings, use the <code>ORDER</code> <code>BY</code> clause. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG020) for an expanded discussion and examples of using SQL grouping syntax for data aggregation the GROUP_ID(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUP_ID.html#GUID-3A5A9C15-1B67-4FD7-AC41-EE8349B2E834), GROUPING(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUPING.html#GUID-82E6084A-0BDF-4587-A40E-36899783F073), and GROUPING_ID(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUPING_ID.html#GUID-E20A5B8E-73B6-42FD-8AFB-DD3CD6D6DC61) functions for examples \"Using the GROUP BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066419)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>GROUP</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>GROUP</code> <code>BY</code> clause <subsubsect>ROLLUP</subsubsect> The <code>ROLLUP</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of the first n, n-1, n-2, ... 0 expressions in the <code>GROUP</code> <code>BY</code> specification, and returns a single row of summary for each group. You can use the <code>ROLLUP</code> operation to produce subtotal values by using it with the <code>SUM</code> function. When used with <code>SUM</code>, <code>ROLLUP</code> generates subtotals from the most detailed level to the grand total. Aggregate functions such as <code>COUNT</code> can be used to produce other kinds of superaggregates. For example, given three expressions (n=3) in the <code>ROLLUP</code> clause of the <code>simple_grouping_clause</code>, the operation results in n+1 = 3+1 = 4 groupings. Rows grouped on the values of the first <code>n</code> expressions are called regular rows, and the others are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>ROLLUP</code> with materialized views <subsubsect>CUBE</subsubsect> The <code>CUBE</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of all possible combinations of expressions in the specification. It returns a single row of summary information for each group. You can use the <code>CUBE</code> operation to produce cross-tabulation values. For example, given three expressions (n=3) in the <code>CUBE</code> clause of the <code>simple_grouping_clause</code>, the operation results in 2n = 23 = 8 groupings. Rows grouped on the values of <code>n</code> expressions are called regular rows, and the rest are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>CUBE</code> with materialized views \"Using the GROUP BY CUBE Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066443)\" <subsubsect>GROUPING SETS</subsubsect> <code>GROUPING</code> <code>SETS</code> are a further extension of the <code>GROUP</code> <code>BY</code> clause that let you specify multiple groupings of data. Doing so facilitates efficient aggregation by pruning the aggregates you do not need. You specify just the desired groups, and the database does not need to perform the full set of aggregations generated by <code>CUBE</code> or <code>ROLLUP</code>. Oracle Database computes all groupings specified in the <code>GROUPING</code> <code>SETS</code> clause and combines the results of individual groupings with a <code>UNION</code> <code>ALL</code> operation. The <code>UNION</code> <code>ALL</code> means that the result set can include duplicate rows. Within the <code>GROUP</code> <code>BY</code> clause, you can combine expressions in various ways: To specify composite columns, group columns within parentheses so that the database treats them as a unit while computing <code>ROLLUP</code> or <code>CUBE</code> operations. To specify concatenated grouping sets, separate multiple grouping sets, <code>ROLLUP</code>, and <code>CUBE</code> operations with commas so that the database combines them into a single <code>GROUP</code> <code>BY</code> clause. The result is a cross-product of groupings from each grouping set. See Also: \"Using the GROUPING SETS Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2091446)\" <subsubsect>HAVING Clause</subsubsect> Use the <code>HAVING</code> clause to restrict the groups of returned rows to those groups for which the specified <code>condition</code> is <code>TRUE</code>. If you omit this clause, then the database returns summary rows for all groups. Specify <code>GROUP</code> <code>BY</code> and <code>HAVING</code> after the <code>where_clause</code> and <code>hierarchical_query_clause</code>. If you specify both <code>GROUP</code> <code>BY</code> and <code>HAVING</code>, then they can appear in either order. See Also: \"Using the HAVING Condition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130020)\" <subsubsect>Restrictions on the GROUP BY Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify LOB columns, nested tables, or varrays as part of <code>expr</code>. The expressions can be of any form except scalar subquery expressions. If the <code>group_by_clause</code> references any object type columns, then the query will not be parallelized.<sep>[DEMO]: SELECT department, AVG(salary) AS average_salary FROM employees GROUP BY department HAVING AVG(salary) > 5000;",
        "example": [
            "SELECT department, AVG(salary) AS average_salary FROM employees GROUP BY department HAVING AVG(salary) > 5000;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "GROUP BY expr",
        "tree": "(group_by_clause GROUP BY)",
        "description": "Specify the <code>GROUP</code> <code>BY</code> clause if you want the database to group the selected rows based on the value of <code>expr</code>(s) for each row and return a single row of summary information for each group. If this clause contains <code>CUBE</code> or <code>ROLLUP</code> extensions, then the database produces superaggregate groupings in addition to the regular groupings. Expressions in the <code>GROUP</code> <code>BY</code> clause can contain any columns of the tables, views, or materialized views in the <code>FROM</code> clause, regardless of whether the columns appear in the select list. The <code>GROUP</code> <code>BY</code> clause groups rows but does not guarantee the order of the result set. To order the groupings, use the <code>ORDER</code> <code>BY</code> clause. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG020) for an expanded discussion and examples of using SQL grouping syntax for data aggregation the GROUP_ID(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUP_ID.html#GUID-3A5A9C15-1B67-4FD7-AC41-EE8349B2E834), GROUPING(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUPING.html#GUID-82E6084A-0BDF-4587-A40E-36899783F073), and GROUPING_ID(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUPING_ID.html#GUID-E20A5B8E-73B6-42FD-8AFB-DD3CD6D6DC61) functions for examples \"Using the GROUP BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066419)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>GROUP</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>GROUP</code> <code>BY</code> clause <subsubsect>ROLLUP</subsubsect> The <code>ROLLUP</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of the first n, n-1, n-2, ... 0 expressions in the <code>GROUP</code> <code>BY</code> specification, and returns a single row of summary for each group. You can use the <code>ROLLUP</code> operation to produce subtotal values by using it with the <code>SUM</code> function. When used with <code>SUM</code>, <code>ROLLUP</code> generates subtotals from the most detailed level to the grand total. Aggregate functions such as <code>COUNT</code> can be used to produce other kinds of superaggregates. For example, given three expressions (n=3) in the <code>ROLLUP</code> clause of the <code>simple_grouping_clause</code>, the operation results in n+1 = 3+1 = 4 groupings. Rows grouped on the values of the first <code>n</code> expressions are called regular rows, and the others are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>ROLLUP</code> with materialized views <subsubsect>CUBE</subsubsect> The <code>CUBE</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of all possible combinations of expressions in the specification. It returns a single row of summary information for each group. You can use the <code>CUBE</code> operation to produce cross-tabulation values. For example, given three expressions (n=3) in the <code>CUBE</code> clause of the <code>simple_grouping_clause</code>, the operation results in 2n = 23 = 8 groupings. Rows grouped on the values of <code>n</code> expressions are called regular rows, and the rest are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>CUBE</code> with materialized views \"Using the GROUP BY CUBE Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066443)\" <subsubsect>GROUPING SETS</subsubsect> <code>GROUPING</code> <code>SETS</code> are a further extension of the <code>GROUP</code> <code>BY</code> clause that let you specify multiple groupings of data. Doing so facilitates efficient aggregation by pruning the aggregates you do not need. You specify just the desired groups, and the database does not need to perform the full set of aggregations generated by <code>CUBE</code> or <code>ROLLUP</code>. Oracle Database computes all groupings specified in the <code>GROUPING</code> <code>SETS</code> clause and combines the results of individual groupings with a <code>UNION</code> <code>ALL</code> operation. The <code>UNION</code> <code>ALL</code> means that the result set can include duplicate rows. Within the <code>GROUP</code> <code>BY</code> clause, you can combine expressions in various ways: To specify composite columns, group columns within parentheses so that the database treats them as a unit while computing <code>ROLLUP</code> or <code>CUBE</code> operations. To specify concatenated grouping sets, separate multiple grouping sets, <code>ROLLUP</code>, and <code>CUBE</code> operations with commas so that the database combines them into a single <code>GROUP</code> <code>BY</code> clause. The result is a cross-product of groupings from each grouping set. See Also: \"Using the GROUPING SETS Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2091446)\" <subsubsect>HAVING Clause</subsubsect> Use the <code>HAVING</code> clause to restrict the groups of returned rows to those groups for which the specified <code>condition</code> is <code>TRUE</code>. If you omit this clause, then the database returns summary rows for all groups. Specify <code>GROUP</code> <code>BY</code> and <code>HAVING</code> after the <code>where_clause</code> and <code>hierarchical_query_clause</code>. If you specify both <code>GROUP</code> <code>BY</code> and <code>HAVING</code>, then they can appear in either order. See Also: \"Using the HAVING Condition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130020)\" <subsubsect>Restrictions on the GROUP BY Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify LOB columns, nested tables, or varrays as part of <code>expr</code>. The expressions can be of any form except scalar subquery expressions. If the <code>group_by_clause</code> references any object type columns, then the query will not be parallelized.",
        "detail": "[DESCRIPTION]: Specify the <code>GROUP</code> <code>BY</code> clause if you want the database to group the selected rows based on the value of <code>expr</code>(s) for each row and return a single row of summary information for each group. If this clause contains <code>CUBE</code> or <code>ROLLUP</code> extensions, then the database produces superaggregate groupings in addition to the regular groupings. Expressions in the <code>GROUP</code> <code>BY</code> clause can contain any columns of the tables, views, or materialized views in the <code>FROM</code> clause, regardless of whether the columns appear in the select list. The <code>GROUP</code> <code>BY</code> clause groups rows but does not guarantee the order of the result set. To order the groupings, use the <code>ORDER</code> <code>BY</code> clause. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG020) for an expanded discussion and examples of using SQL grouping syntax for data aggregation the GROUP_ID(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUP_ID.html#GUID-3A5A9C15-1B67-4FD7-AC41-EE8349B2E834), GROUPING(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUPING.html#GUID-82E6084A-0BDF-4587-A40E-36899783F073), and GROUPING_ID(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/GROUPING_ID.html#GUID-E20A5B8E-73B6-42FD-8AFB-DD3CD6D6DC61) functions for examples \"Using the GROUP BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066419)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>GROUP</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>GROUP</code> <code>BY</code> clause <subsubsect>ROLLUP</subsubsect> The <code>ROLLUP</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of the first n, n-1, n-2, ... 0 expressions in the <code>GROUP</code> <code>BY</code> specification, and returns a single row of summary for each group. You can use the <code>ROLLUP</code> operation to produce subtotal values by using it with the <code>SUM</code> function. When used with <code>SUM</code>, <code>ROLLUP</code> generates subtotals from the most detailed level to the grand total. Aggregate functions such as <code>COUNT</code> can be used to produce other kinds of superaggregates. For example, given three expressions (n=3) in the <code>ROLLUP</code> clause of the <code>simple_grouping_clause</code>, the operation results in n+1 = 3+1 = 4 groupings. Rows grouped on the values of the first <code>n</code> expressions are called regular rows, and the others are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>ROLLUP</code> with materialized views <subsubsect>CUBE</subsubsect> The <code>CUBE</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of all possible combinations of expressions in the specification. It returns a single row of summary information for each group. You can use the <code>CUBE</code> operation to produce cross-tabulation values. For example, given three expressions (n=3) in the <code>CUBE</code> clause of the <code>simple_grouping_clause</code>, the operation results in 2n = 23 = 8 groupings. Rows grouped on the values of <code>n</code> expressions are called regular rows, and the rest are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>CUBE</code> with materialized views \"Using the GROUP BY CUBE Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066443)\" <subsubsect>GROUPING SETS</subsubsect> <code>GROUPING</code> <code>SETS</code> are a further extension of the <code>GROUP</code> <code>BY</code> clause that let you specify multiple groupings of data. Doing so facilitates efficient aggregation by pruning the aggregates you do not need. You specify just the desired groups, and the database does not need to perform the full set of aggregations generated by <code>CUBE</code> or <code>ROLLUP</code>. Oracle Database computes all groupings specified in the <code>GROUPING</code> <code>SETS</code> clause and combines the results of individual groupings with a <code>UNION</code> <code>ALL</code> operation. The <code>UNION</code> <code>ALL</code> means that the result set can include duplicate rows. Within the <code>GROUP</code> <code>BY</code> clause, you can combine expressions in various ways: To specify composite columns, group columns within parentheses so that the database treats them as a unit while computing <code>ROLLUP</code> or <code>CUBE</code> operations. To specify concatenated grouping sets, separate multiple grouping sets, <code>ROLLUP</code>, and <code>CUBE</code> operations with commas so that the database combines them into a single <code>GROUP</code> <code>BY</code> clause. The result is a cross-product of groupings from each grouping set. See Also: \"Using the GROUPING SETS Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2091446)\" <subsubsect>HAVING Clause</subsubsect> Use the <code>HAVING</code> clause to restrict the groups of returned rows to those groups for which the specified <code>condition</code> is <code>TRUE</code>. If you omit this clause, then the database returns summary rows for all groups. Specify <code>GROUP</code> <code>BY</code> and <code>HAVING</code> after the <code>where_clause</code> and <code>hierarchical_query_clause</code>. If you specify both <code>GROUP</code> <code>BY</code> and <code>HAVING</code>, then they can appear in either order. See Also: \"Using the HAVING Condition: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130020)\" <subsubsect>Restrictions on the GROUP BY Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify LOB columns, nested tables, or varrays as part of <code>expr</code>. The expressions can be of any form except scalar subquery expressions. If the <code>group_by_clause</code> references any object type columns, then the query will not be parallelized.<sep>[DEMO]: SELECT department, AVG(salary) AS average_salary FROM employees GROUP BY department;",
        "example": [
            "SELECT department, AVG(salary) AS average_salary FROM employees GROUP BY department;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "MODEL main_model",
        "tree": "(model_clause MODEL)",
        "description": "The <code>model_clause</code> lets you view selected rows as a multidimensional array and randomly access cells within that array. Using the <code>model_clause</code>, you can specify a series of cell assignments, referred to as rules, that invoke calculations on individual cells and ranges of cells. These rules operate on the results of a query and do not update any database tables. When using the <code>model_clause</code> in a query, the <code>SELECT</code> and <code>ORDER</code> <code>BY</code> clauses must refer only to those columns defined in the <code>model_column_clauses</code>. See Also: The syntax description of <code>expr</code> in \"About SQL Expressions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/About-SQL-Expressions.html#GUID-68789A5C-B142-496F-ADEE-837F75F95B2B)\" and the syntax description of <code>condition</code> in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8) Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG022) for an expanded discussion and examples \"The MODEL clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2171160)\" <subsubsect>main_model</subsubsect> The <code>main_model</code> clause defines how the selected rows will be viewed in a multidimensional array and what rules will operate on which cells in that array. <subsubsect>model_column_clauses</subsubsect> The <code>model_column_clauses</code> define and classify the columns of a query into three groups: partition columns, dimension columns, and measure columns. For <code>expr</code>, you can specify a column, constant, host variable, single-row function, aggregate function, or any expression involving them. If <code>expr</code> is a column, then the column alias (<code>c_alias</code>) is optional. If <code>expr</code> is not a column, then the column alias is required. If you specify a column alias, then you must use the alias to refer to the column in the <code>model_rules_clause</code>, <code>SELECT</code> list, and the query <code>ORDER</code> <code>BY</code> clauses. <subsubsect>PARTITION BY</subsubsect> The <code>PARTITION</code> <code>BY</code> clause specifies the columns that will be used to divide the selected rows into partitions based on the values of the specified columns. <subsubsect>DIMENSION BY</subsubsect> The <code>DIMENSION</code> <code>BY</code> clause specifies the columns that will identify a row within a partition. The values of the dimension columns, along with those of the partition columns, serve as array indexes to the measure columns within a row. <subsubsect>MEASURES</subsubsect> The <code>MEASURES</code> clause identifies the columns on which the calculations can be performed. Measure columns in individual rows are treated like cells that you can reference, by specifying the values for the partition and dimension columns, and update. <subsubsect>cell_reference_options</subsubsect> Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained. <subsubsect>IGNORE NAV</subsubsect> When you specify <code>IGNORE</code> <code>NAV</code>, the database returns the following values for the null and absent values of the data type specified: Zero for numeric data types 01-JAN-2000 for datetime data types An empty string for character data types Null for all other data types <subsubsect>KEEP NAV</subsubsect> When you specify <code>KEEP</code> <code>NAV</code>, the database returns null for both null and absent cell values. <code>KEEP</code> <code>NAV</code> is the default. <subsubsect>UNIQUE SINGLE REFERENCE</subsubsect> When you specify <code>UNIQUE</code> <code>SINGLE</code> <code>REFERENCE</code>, the database checks only single-cell references on the right-hand side of the rule for uniqueness, not the entire query result set. <subsubsect>UNIQUE DIMENSION</subsubsect> When you specify <code>UNIQUE</code> <code>DIMENSION</code>, the database checks that the <code>PARTITION</code> <code>BY</code> and <code>DIMENSION</code> <code>BY</code> columns form a unique key to the query. <code>UNIQUE</code> <code>DIMENSION</code> is the default. <subsubsect>model_rules_clause</subsubsect> Use the <code>model_rules_clause</code> to specify the cells to be updated, the rules for updating those cells, and optionally, how the rules are to be applied and processed. Each rule represents an assignment and consists of a left-hand side and right-hand side. The left-hand side of the rule identifies the cells to be updated by the right-hand side of the rule. The right-hand side of the rule evaluates to the values to be assigned to the cells specified on the left-hand side of the rule. UPSERT ALL <code>UPSERT</code> <code>ALL</code> allows <code>UPSERT</code> behavior for a rule with both positional and symbolic references on the left-hand side of the rule. When evaluating an <code>UPSERT</code> <code>ALL</code> rule, Oracle performs the following steps to create a list of cell references to be upserted: Find the existing cells that satisfy all the symbolic predicates of the cell reference. Using just the dimensions that have symbolic references, find the distinct dimension value combinations of these cells. Perform a cross product of these value combinations with the dimension values specified by way of positional references. Refer to Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0222) for more information on the semantics of <code>UPSERT</code> <code>ALL</code>. <subsubsect>UPSERT</subsubsect> When you specify <code>UPSERT</code>, the database applies the rules to those cells referenced on the left-hand side of the rule that exist in the multidimensional array, and inserts new rows for those that do not exist. <code>UPSERT</code> behavior applies only when positional referencing is used on the left-hand side and a single cell is referenced. <code>UPSERT</code> is the default. Refer to cell_assignment(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168603) for more information on positional referencing and single-cell references. <code>UPDATE</code> and <code>UPSERT</code> can be specified for individual rules as well. When either <code>UPDATE</code> or <code>UPSERT</code> is specified for a specific rule, it takes precedence over the option specified in the <code>RULES</code> clause. Note: If an <code>UPSERT</code> <code>ALL</code>, <code>UPSERT</code>, or <code>UPDATE</code> rule does not contain the appropriate predicates, then the database may implicitly convert it to a different type of rule: If an <code>UPSERT</code> rule contains an existential predicate, then the rule is treated as an <code>UPDATE</code> rule. An <code>UPSERT</code> <code>ALL</code> rule must have at least one existential predicate and one qualified predicate on its left side. If it has no existential predicate, then it is treated as an <code>UPSERT</code> rule. If it has no qualified predicate, then it is treated as an <code>UPDATE</code> rule <subsubsect>UPDATE</subsubsect> When you specify <code>UPDATE</code>, the database applies the rules to those cells referenced on the left-hand side of the rule that exist in the multidimensional array. If the cells do not exist, then the assignment is ignored. <subsubsect>AUTOMATIC ORDER</subsubsect> When you specify <code>AUTOMATIC</code> <code>ORDER</code>, the database evaluates the rules based on their dependency order. In this case, a cell can be assigned a value once only. <subsubsect>SEQUENTIAL ORDER</subsubsect> When you specify <code>SEQUENTIAL</code> <code>ORDER</code>, the database evaluates the rules in the order they appear. In this case, a cell can be assigned a value more than once. <code>SEQUENTIAL</code> <code>ORDER</code> is the default. <subsubsect>ITERATE ... [UNTIL]</subsubsect> Use <code>ITERATE</code> ... [<code>UNTIL</code>] to specify the number of times to cycle through the rules and, optionally, an early termination condition. The parentheses around the <code>UNTIL</code> condition are optional. When you specify <code>ITERATE</code> ... [<code>UNTIL</code>], rules are evaluated in the order in which they appear. Oracle Database returns an error if both <code>AUTOMATIC</code> <code>ORDER</code> and <code>ITERATE</code> ... <code>[UNTIL]</code> are specified in the <code>model_rules_clause</code>. <subsubsect>cell_assignment</subsubsect> The <code>cell_assignment</code> clause, which is the left-hand side of the rule, specifies one or more cells to be updated. When a <code>cell_assignment</code> references a single cell, it is called a single-cell reference. When more than one cell is referenced, it is called a multiple-cell reference. All dimension columns defined in the <code>model_clause</code> must be qualified in the <code>cell_assignment</code> clause. A dimension can be qualified using either symbolic or positional referencing. A symbolic reference qualifies a single dimension column using a Boolean condition like <code>dimension_column</code><code>=</code><code>constant</code>. A positional reference is one where the dimension column is implied by its position in the <code>DIMENSION</code> <code>BY</code> clause. The only difference between symbolic references and positional references is in the treatment of nulls. Using a single-cell symbolic reference such as <code>a[x=null,y=2000]</code>, no cells qualify because <code>x=null</code> evaluates to <code>FALSE</code>. However, using a single-cell positional reference such as <code>a[null,2000]</code>, a cell where <code>x</code> is null and <code>y</code> is 2000 qualifies because null = null evaluates to <code>TRUE</code>. With single-cell positional referencing, you can reference, update, and insert cells where dimension columns are null. You can specify a condition or an expression representing a dimension column value using either symbolic or positional referencing. <code>condition</code> cannot contain aggregate functions or the <code>CV</code> function, and <code>condition</code> must reference a single dimension column. <code>expr</code> cannot contain a subquery. Refer to \"Model Expressions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Model-Expressions.html#GUID-83D3FD56-8346-4D3F-A49E-5FE41FE19257)\" for information on model expressions. <subsubsect>single_column_for_loop</subsubsect> The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause. <subsubsect>multi_column_for_loop</subsubsect> The <code>multi_column_for_loop</code> clause lets you specify a range of cells to be updated across multiple dimension columns. The <code>IN</code> clause lets you specify the values of the dimension columns as either multiple lists of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0223) for more information about using <code>FOR</code> loops in the <code>MODEL</code> clause <subsubsect>order_by_clause</subsubsect> Use the <code>ORDER</code> <code>BY</code> clause to specify the order in which cells on the left-hand side of the rule are to be evaluated. The <code>expr</code> must resolve to a dimension or measure column. If the <code>ORDER</code> <code>BY</code> clause is not specified, then the order defaults to the order of the columns as specified in the <code>DIMENSION</code> <code>BY</code> clause. See order_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2171079) for more information. <subsubsect>Restrictions on the order_by_clause</subsubsect> Use of the <code>ORDER</code> <code>BY</code> clause in the model rule is subject to the following restrictions: You cannot specify <code>SIBLINGS</code>, <code>position</code>, or <code>c_alias</code> in the <code>order_by_clause</code> of the <code>model_clause</code>. You cannot specify this clause on the left-hand side of the model rule and also specify a <code>FOR</code> loop on the right-hand side of the rule. <subsubsect>expr</subsubsect> Specify an expression representing the value or values of the cell or cells specified on the right-hand side of the rule. <code>expr</code> cannot contain a subquery. Refer to \"Model Expressions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Model-Expressions.html#GUID-83D3FD56-8346-4D3F-A49E-5FE41FE19257)\" for information on model expressions. <subsubsect>return_rows_clause</subsubsect> The <code>return_rows_clause</code> lets you specify whether to return all rows selected or only those rows updated by the model rules. <code>ALL</code> is the default. <subsubsect>reference_model</subsubsect> Use the <code>reference_model</code> clause when you need to access multiple arrays from inside the <code>model_clause</code>. This clause defines a read-only multidimensional array based on the results of a query. The subclauses of the <code>reference_model</code> clause have the same semantics as for the <code>main_model</code> clause. Refer to model_column_clauses(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168561) and cell_reference_options(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168572). <subsubsect>Restrictions on the reference_model Clause</subsubsect> This clause is subject to the following restrictions: <code>PARTITION</code> <code>BY</code> columns cannot be specified for reference models. The subquery of the reference model cannot refer to columns in an outer subquery.",
        "detail": "[DESCRIPTION]: The <code>model_clause</code> lets you view selected rows as a multidimensional array and randomly access cells within that array. Using the <code>model_clause</code>, you can specify a series of cell assignments, referred to as rules, that invoke calculations on individual cells and ranges of cells. These rules operate on the results of a query and do not update any database tables. When using the <code>model_clause</code> in a query, the <code>SELECT</code> and <code>ORDER</code> <code>BY</code> clauses must refer only to those columns defined in the <code>model_column_clauses</code>. See Also: The syntax description of <code>expr</code> in \"About SQL Expressions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/About-SQL-Expressions.html#GUID-68789A5C-B142-496F-ADEE-837F75F95B2B)\" and the syntax description of <code>condition</code> in Conditions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8) Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG022) for an expanded discussion and examples \"The MODEL clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2171160)\" <subsubsect>main_model</subsubsect> The <code>main_model</code> clause defines how the selected rows will be viewed in a multidimensional array and what rules will operate on which cells in that array. <subsubsect>model_column_clauses</subsubsect> The <code>model_column_clauses</code> define and classify the columns of a query into three groups: partition columns, dimension columns, and measure columns. For <code>expr</code>, you can specify a column, constant, host variable, single-row function, aggregate function, or any expression involving them. If <code>expr</code> is a column, then the column alias (<code>c_alias</code>) is optional. If <code>expr</code> is not a column, then the column alias is required. If you specify a column alias, then you must use the alias to refer to the column in the <code>model_rules_clause</code>, <code>SELECT</code> list, and the query <code>ORDER</code> <code>BY</code> clauses. <subsubsect>PARTITION BY</subsubsect> The <code>PARTITION</code> <code>BY</code> clause specifies the columns that will be used to divide the selected rows into partitions based on the values of the specified columns. <subsubsect>DIMENSION BY</subsubsect> The <code>DIMENSION</code> <code>BY</code> clause specifies the columns that will identify a row within a partition. The values of the dimension columns, along with those of the partition columns, serve as array indexes to the measure columns within a row. <subsubsect>MEASURES</subsubsect> The <code>MEASURES</code> clause identifies the columns on which the calculations can be performed. Measure columns in individual rows are treated like cells that you can reference, by specifying the values for the partition and dimension columns, and update. <subsubsect>cell_reference_options</subsubsect> Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained. <subsubsect>IGNORE NAV</subsubsect> When you specify <code>IGNORE</code> <code>NAV</code>, the database returns the following values for the null and absent values of the data type specified: Zero for numeric data types 01-JAN-2000 for datetime data types An empty string for character data types Null for all other data types <subsubsect>KEEP NAV</subsubsect> When you specify <code>KEEP</code> <code>NAV</code>, the database returns null for both null and absent cell values. <code>KEEP</code> <code>NAV</code> is the default. <subsubsect>UNIQUE SINGLE REFERENCE</subsubsect> When you specify <code>UNIQUE</code> <code>SINGLE</code> <code>REFERENCE</code>, the database checks only single-cell references on the right-hand side of the rule for uniqueness, not the entire query result set. <subsubsect>UNIQUE DIMENSION</subsubsect> When you specify <code>UNIQUE</code> <code>DIMENSION</code>, the database checks that the <code>PARTITION</code> <code>BY</code> and <code>DIMENSION</code> <code>BY</code> columns form a unique key to the query. <code>UNIQUE</code> <code>DIMENSION</code> is the default. <subsubsect>model_rules_clause</subsubsect> Use the <code>model_rules_clause</code> to specify the cells to be updated, the rules for updating those cells, and optionally, how the rules are to be applied and processed. Each rule represents an assignment and consists of a left-hand side and right-hand side. The left-hand side of the rule identifies the cells to be updated by the right-hand side of the rule. The right-hand side of the rule evaluates to the values to be assigned to the cells specified on the left-hand side of the rule. UPSERT ALL <code>UPSERT</code> <code>ALL</code> allows <code>UPSERT</code> behavior for a rule with both positional and symbolic references on the left-hand side of the rule. When evaluating an <code>UPSERT</code> <code>ALL</code> rule, Oracle performs the following steps to create a list of cell references to be upserted: Find the existing cells that satisfy all the symbolic predicates of the cell reference. Using just the dimensions that have symbolic references, find the distinct dimension value combinations of these cells. Perform a cross product of these value combinations with the dimension values specified by way of positional references. Refer to Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0222) for more information on the semantics of <code>UPSERT</code> <code>ALL</code>. <subsubsect>UPSERT</subsubsect> When you specify <code>UPSERT</code>, the database applies the rules to those cells referenced on the left-hand side of the rule that exist in the multidimensional array, and inserts new rows for those that do not exist. <code>UPSERT</code> behavior applies only when positional referencing is used on the left-hand side and a single cell is referenced. <code>UPSERT</code> is the default. Refer to cell_assignment(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168603) for more information on positional referencing and single-cell references. <code>UPDATE</code> and <code>UPSERT</code> can be specified for individual rules as well. When either <code>UPDATE</code> or <code>UPSERT</code> is specified for a specific rule, it takes precedence over the option specified in the <code>RULES</code> clause. Note: If an <code>UPSERT</code> <code>ALL</code>, <code>UPSERT</code>, or <code>UPDATE</code> rule does not contain the appropriate predicates, then the database may implicitly convert it to a different type of rule: If an <code>UPSERT</code> rule contains an existential predicate, then the rule is treated as an <code>UPDATE</code> rule. An <code>UPSERT</code> <code>ALL</code> rule must have at least one existential predicate and one qualified predicate on its left side. If it has no existential predicate, then it is treated as an <code>UPSERT</code> rule. If it has no qualified predicate, then it is treated as an <code>UPDATE</code> rule <subsubsect>UPDATE</subsubsect> When you specify <code>UPDATE</code>, the database applies the rules to those cells referenced on the left-hand side of the rule that exist in the multidimensional array. If the cells do not exist, then the assignment is ignored. <subsubsect>AUTOMATIC ORDER</subsubsect> When you specify <code>AUTOMATIC</code> <code>ORDER</code>, the database evaluates the rules based on their dependency order. In this case, a cell can be assigned a value once only. <subsubsect>SEQUENTIAL ORDER</subsubsect> When you specify <code>SEQUENTIAL</code> <code>ORDER</code>, the database evaluates the rules in the order they appear. In this case, a cell can be assigned a value more than once. <code>SEQUENTIAL</code> <code>ORDER</code> is the default. <subsubsect>ITERATE ... [UNTIL]</subsubsect> Use <code>ITERATE</code> ... [<code>UNTIL</code>] to specify the number of times to cycle through the rules and, optionally, an early termination condition. The parentheses around the <code>UNTIL</code> condition are optional. When you specify <code>ITERATE</code> ... [<code>UNTIL</code>], rules are evaluated in the order in which they appear. Oracle Database returns an error if both <code>AUTOMATIC</code> <code>ORDER</code> and <code>ITERATE</code> ... <code>[UNTIL]</code> are specified in the <code>model_rules_clause</code>. <subsubsect>cell_assignment</subsubsect> The <code>cell_assignment</code> clause, which is the left-hand side of the rule, specifies one or more cells to be updated. When a <code>cell_assignment</code> references a single cell, it is called a single-cell reference. When more than one cell is referenced, it is called a multiple-cell reference. All dimension columns defined in the <code>model_clause</code> must be qualified in the <code>cell_assignment</code> clause. A dimension can be qualified using either symbolic or positional referencing. A symbolic reference qualifies a single dimension column using a Boolean condition like <code>dimension_column</code><code>=</code><code>constant</code>. A positional reference is one where the dimension column is implied by its position in the <code>DIMENSION</code> <code>BY</code> clause. The only difference between symbolic references and positional references is in the treatment of nulls. Using a single-cell symbolic reference such as <code>a[x=null,y=2000]</code>, no cells qualify because <code>x=null</code> evaluates to <code>FALSE</code>. However, using a single-cell positional reference such as <code>a[null,2000]</code>, a cell where <code>x</code> is null and <code>y</code> is 2000 qualifies because null = null evaluates to <code>TRUE</code>. With single-cell positional referencing, you can reference, update, and insert cells where dimension columns are null. You can specify a condition or an expression representing a dimension column value using either symbolic or positional referencing. <code>condition</code> cannot contain aggregate functions or the <code>CV</code> function, and <code>condition</code> must reference a single dimension column. <code>expr</code> cannot contain a subquery. Refer to \"Model Expressions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Model-Expressions.html#GUID-83D3FD56-8346-4D3F-A49E-5FE41FE19257)\" for information on model expressions. <subsubsect>single_column_for_loop</subsubsect> The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause. <subsubsect>multi_column_for_loop</subsubsect> The <code>multi_column_for_loop</code> clause lets you specify a range of cells to be updated across multiple dimension columns. The <code>IN</code> clause lets you specify the values of the dimension columns as either multiple lists of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0223) for more information about using <code>FOR</code> loops in the <code>MODEL</code> clause <subsubsect>order_by_clause</subsubsect> Use the <code>ORDER</code> <code>BY</code> clause to specify the order in which cells on the left-hand side of the rule are to be evaluated. The <code>expr</code> must resolve to a dimension or measure column. If the <code>ORDER</code> <code>BY</code> clause is not specified, then the order defaults to the order of the columns as specified in the <code>DIMENSION</code> <code>BY</code> clause. See order_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2171079) for more information. <subsubsect>Restrictions on the order_by_clause</subsubsect> Use of the <code>ORDER</code> <code>BY</code> clause in the model rule is subject to the following restrictions: You cannot specify <code>SIBLINGS</code>, <code>position</code>, or <code>c_alias</code> in the <code>order_by_clause</code> of the <code>model_clause</code>. You cannot specify this clause on the left-hand side of the model rule and also specify a <code>FOR</code> loop on the right-hand side of the rule. <subsubsect>expr</subsubsect> Specify an expression representing the value or values of the cell or cells specified on the right-hand side of the rule. <code>expr</code> cannot contain a subquery. Refer to \"Model Expressions(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Model-Expressions.html#GUID-83D3FD56-8346-4D3F-A49E-5FE41FE19257)\" for information on model expressions. <subsubsect>return_rows_clause</subsubsect> The <code>return_rows_clause</code> lets you specify whether to return all rows selected or only those rows updated by the model rules. <code>ALL</code> is the default. <subsubsect>reference_model</subsubsect> Use the <code>reference_model</code> clause when you need to access multiple arrays from inside the <code>model_clause</code>. This clause defines a read-only multidimensional array based on the results of a query. The subclauses of the <code>reference_model</code> clause have the same semantics as for the <code>main_model</code> clause. Refer to model_column_clauses(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168561) and cell_reference_options(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168572). <subsubsect>Restrictions on the reference_model Clause</subsubsect> This clause is subject to the following restrictions: <code>PARTITION</code> <code>BY</code> columns cannot be specified for reference models. The subquery of the reference model cannot refer to columns in an outer subquery.<sep>[DEMO]: SELECT country, year, sale, csum FROM (SELECT country, year, SUM(sale) sale FROM sales_view_ref  GROUP BY country, year   )   MODEL DIMENSION BY (country, year)         MEASURES (sale, 0 csum)          RULES (csum[any, any]=                   SUM(sale) OVER (PARTITION BY country                                   ORDER BY year                                   ROWS UNBOUNDED PRECEDING)                 )   ORDER BY country, year;",
        "example": [
            "SELECT country, year, sale, csum FROM (SELECT country, year, SUM(sale) sale FROM sales_view_ref  GROUP BY country, year   )   MODEL DIMENSION BY (country, year)         MEASURES (sale, 0 csum)          RULES (csum[any, any]=                   SUM(sale) OVER (PARTITION BY country                                   ORDER BY year                                   ROWS UNBOUNDED PRECEDING)                 )   ORDER BY country, year;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "IGNORE NAV",
        "tree": "(cell_reference_options IGNORE NAV)",
        "description": "Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.",
        "detail": "[DESCRIPTION]: Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.<sep>[DEMO]: SELECT * FROM sales_data MODEL IGNORE NAV MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);",
        "example": [
            "SELECT * FROM sales_data MODEL IGNORE NAV MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "KEEP NAV",
        "tree": "(cell_reference_options KEEP NAV)",
        "description": "Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.",
        "detail": "[DESCRIPTION]: Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.<sep>[DEMO]: SELECT * FROM sales_data MODEL KEEP NAV MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);",
        "example": [
            "SELECT * FROM sales_data MODEL KEEP NAV MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "UNIQUE DIMENSION",
        "tree": "(cell_reference_options UNIQUE DIMENSION)",
        "description": "Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.",
        "detail": "[DESCRIPTION]: Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.<sep>[DEMO]: SELECT * FROM sales_data MODEL UNIQUE DIMENSION MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);",
        "example": [
            "SELECT * FROM sales_data MODEL UNIQUE DIMENSION MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "UNIQUE SINGLE REFERENCE",
        "tree": "(cell_reference_options UNIQUE SINGLE REFERENCE)",
        "description": "Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.",
        "detail": "[DESCRIPTION]: Use the <code>cell_reference_options</code> clause to specify how null and absent values are treated in rules and how column uniqueness is constrained.<sep>[DEMO]: SELECT * FROM sales_data MODEL UNIQUE SINGLE REFERENCE MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);",
        "example": [
            "SELECT * FROM sales_data MODEL UNIQUE SINGLE REFERENCE MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "RETURN ALL ROWS",
        "tree": "(return_rows_clause RETURN ALL ROWS)",
        "description": "The <code>return_rows_clause</code> lets you specify whether to return all rows selected or only those rows updated by the model rules. <code>ALL</code> is the default.",
        "detail": "[DESCRIPTION]: The <code>return_rows_clause</code> lets you specify whether to return all rows selected or only those rows updated by the model rules. <code>ALL</code> is the default.<sep>[DEMO]: SELECT * FROM sales_data MODEL RETURN ALL ROWS MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);",
        "example": [
            "SELECT * FROM sales_data MODEL RETURN ALL ROWS MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "RETURN UPDATED ROWS",
        "tree": "(return_rows_clause RETURN UPDATED ROWS)",
        "description": "The <code>return_rows_clause</code> lets you specify whether to return all rows selected or only those rows updated by the model rules. <code>ALL</code> is the default.",
        "detail": "[DESCRIPTION]: The <code>return_rows_clause</code> lets you specify whether to return all rows selected or only those rows updated by the model rules. <code>ALL</code> is the default.<sep>[DEMO]: SELECT * FROM sales_data MODEL RETURN UPDATED ROWS MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);",
        "example": [
            "SELECT * FROM sales_data MODEL RETURN UPDATED ROWS MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "REFERENCE reference_model_name ON ( subquery ) model_column_clauses",
        "tree": "(reference_model REFERENCE ON ( ))",
        "description": "Use the <code>reference_model</code> clause when you need to access multiple arrays from inside the <code>model_clause</code>. This clause defines a read-only multidimensional array based on the results of a query. The subclauses of the <code>reference_model</code> clause have the same semantics as for the <code>main_model</code> clause. Refer to model_column_clauses(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168561) and cell_reference_options(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168572).",
        "detail": "[DESCRIPTION]: Use the <code>reference_model</code> clause when you need to access multiple arrays from inside the <code>model_clause</code>. This clause defines a read-only multidimensional array based on the results of a query. The subclauses of the <code>reference_model</code> clause have the same semantics as for the <code>main_model</code> clause. Refer to model_column_clauses(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168561) and cell_reference_options(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2168572).<sep>[DEMO]: SELECT department_id, employee_id, salary\nFROM employees\nMODEL \n  REFERENCE ref_model ON (department_id = 10)\n  DIMENSION BY (employee_id)\n  MEASURES (salary)\n  RULES (\n    salary[ANY] = ref_model.salary[CV()] + 500\n  );\n",
        "example": [
            "SELECT department_id, employee_id, salary\nFROM employees\nMODEL \n  REFERENCE ref_model ON (department_id = 10)\n  DIMENSION BY (employee_id)\n  MEASURES (salary)\n  RULES (\n    salary[ANY] = ref_model.salary[CV()] + 500\n  );\n"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "MAIN main_model_name",
        "tree": "(main_model MAIN)",
        "description": "The <code>main_model</code> clause defines how the selected rows will be viewed in a multidimensional array and what rules will operate on which cells in that array.",
        "detail": "[DESCRIPTION]: The <code>main_model</code> clause defines how the selected rows will be viewed in a multidimensional array and what rules will operate on which cells in that array.<sep>[DEMO]: SELECT * FROM sales_data MODEL MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);",
        "example": [
            "SELECT * FROM sales_data MODEL MAIN sales_main PARTITION BY (region) DIMENSION BY (year, quarter) MEASURES (sales) RULES ( sales[year = 2023, quarter] = sales[year = 2022, quarter] * 1.1);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "PARTITION BY ( expr ) DIMENSION BY ( expr ) MEASURES ( expr )",
        "tree": "(model_column_clauses (model_column_partition_part PARTITION BY (model_column_list ( ))) DIMENSION BY (model_column_list ( )) MEASURES (model_column_list ( )))",
        "description": "The <code>model_column_clauses</code> define and classify the columns of a query into three groups: partition columns, dimension columns, and measure columns. For <code>expr</code>, you can specify a column, constant, host variable, single-row function, aggregate function, or any expression involving them. If <code>expr</code> is a column, then the column alias (<code>c_alias</code>) is optional. If <code>expr</code> is not a column, then the column alias is required. If you specify a column alias, then you must use the alias to refer to the column in the <code>model_rules_clause</code>, <code>SELECT</code> list, and the query <code>ORDER</code> <code>BY</code> clauses.",
        "detail": "[DESCRIPTION]: The <code>model_column_clauses</code> define and classify the columns of a query into three groups: partition columns, dimension columns, and measure columns. For <code>expr</code>, you can specify a column, constant, host variable, single-row function, aggregate function, or any expression involving them. If <code>expr</code> is a column, then the column alias (<code>c_alias</code>) is optional. If <code>expr</code> is not a column, then the column alias is required. If you specify a column alias, then you must use the alias to refer to the column in the <code>model_rules_clause</code>, <code>SELECT</code> list, and the query <code>ORDER</code> <code>BY</code> clauses.<sep>[DEMO]: SELECT country, year, sale, csum   FROM    (SELECT country, year, SUM(sale) sale    FROM sales_view_ref    GROUP BY country, year   )   MODEL PARTITION BY (country) DIMENSION BY (country, year)         MEASURES (sale, 0 csum)          RULES (csum[any, any]=                   SUM(sale) OVER (PARTITION BY country                                   ORDER BY year                                   ROWS UNBOUNDED PRECEDING)                 )   ORDER BY country, year;",
        "example": [
            "SELECT country, year, sale, csum   FROM    (SELECT country, year, SUM(sale) sale    FROM sales_view_ref    GROUP BY country, year   )   MODEL PARTITION BY (country) DIMENSION BY (country, year)         MEASURES (sale, 0 csum)          RULES (csum[any, any]=                   SUM(sale) OVER (PARTITION BY country                                   ORDER BY year                                   ROWS UNBOUNDED PRECEDING)                 )   ORDER BY country, year;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "DIMENSION BY ( expr ) MEASURES ( expr )",
        "tree": "(model_column_clauses DIMENSION BY (model_column_list ( )) MEASURES (model_column_list ( )))",
        "description": "The <code>model_column_clauses</code> define and classify the columns of a query into three groups: partition columns, dimension columns, and measure columns. For <code>expr</code>, you can specify a column, constant, host variable, single-row function, aggregate function, or any expression involving them. If <code>expr</code> is a column, then the column alias (<code>c_alias</code>) is optional. If <code>expr</code> is not a column, then the column alias is required. If you specify a column alias, then you must use the alias to refer to the column in the <code>model_rules_clause</code>, <code>SELECT</code> list, and the query <code>ORDER</code> <code>BY</code> clauses.",
        "detail": "[DESCRIPTION]: The <code>model_column_clauses</code> define and classify the columns of a query into three groups: partition columns, dimension columns, and measure columns. For <code>expr</code>, you can specify a column, constant, host variable, single-row function, aggregate function, or any expression involving them. If <code>expr</code> is a column, then the column alias (<code>c_alias</code>) is optional. If <code>expr</code> is not a column, then the column alias is required. If you specify a column alias, then you must use the alias to refer to the column in the <code>model_rules_clause</code>, <code>SELECT</code> list, and the query <code>ORDER</code> <code>BY</code> clauses.<sep>[DEMO]: SELECT country, year, sale, csum   FROM    (SELECT country, year, SUM(sale) sale    FROM sales_view_ref    GROUP BY country, year   )   MODEL DIMENSION BY (country, year)         MEASURES (sale, 0 csum)          RULES (csum[any, any]=                   SUM(sale) OVER (PARTITION BY country                                   ORDER BY year                                   ROWS UNBOUNDED PRECEDING)                 )   ORDER BY country, year;",
        "example": [
            "SELECT country, year, sale, csum   FROM    (SELECT country, year, SUM(sale) sale    FROM sales_view_ref    GROUP BY country, year   )   MODEL DIMENSION BY (country, year)         MEASURES (sale, 0 csum)          RULES (csum[any, any]=                   SUM(sale) OVER (PARTITION BY country                                   ORDER BY year                                   ROWS UNBOUNDED PRECEDING)                 )   ORDER BY country, year;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR dimension_column FROM literal TO literal INCREMENT literal",
        "tree": "(single_column_for_loop FOR FROM TO INCREMENT)",
        "description": "The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.",
        "detail": "[DESCRIPTION]: The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.<sep>[DEMO]: WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month FROM 1 TO 3 INCREMENT 1] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );",
        "example": [
            "WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month FROM 1 TO 3 INCREMENT 1] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR dimension_column IN ( literal )",
        "tree": "(single_column_for_loop FOR IN ( ))",
        "description": "The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.",
        "detail": "[DESCRIPTION]: The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.<sep>[DEMO]: WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month IN (1) ] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );",
        "example": [
            "WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month IN (1) ] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR dimension_column FROM literal TO literal DECREMENT literal",
        "tree": "(single_column_for_loop FOR FROM TO DECREMENT)",
        "description": "The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.",
        "detail": "[DESCRIPTION]: The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.<sep>[DEMO]: WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month FROM 3 TO 1 DECREMENT 1] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );",
        "example": [
            "WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month FROM 3 TO 1 DECREMENT 1] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR dimension_column LIKE pattern FROM literal TO literal INCREMENT literal",
        "tree": "(single_column_for_loop FOR LIKE FROM TO INCREMENT)",
        "description": "The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.",
        "detail": "[DESCRIPTION]: The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.<sep>[DEMO]: WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month LIKE 1 FROM 1 TO 3 INCREMENT 1] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );",
        "example": [
            "WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month LIKE 1 FROM 1 TO 3 INCREMENT 1] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR dimension_column LIKE pattern FROM literal TO literal DECREMENT literal",
        "tree": "(single_column_for_loop FOR LIKE FROM TO DECREMENT)",
        "description": "The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.",
        "detail": "[DESCRIPTION]: The <code>single_column_for_loop</code> clause lets you specify a range of cells to be updated within a single dimension column. The <code>IN</code> clause lets you specify the values of the dimension column as either a list of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause The <code>FROM</code> clause lets you specify a range of values for a dimension column with discrete increments within the range. The <code>FROM</code> clause can only be used for those columns with a data type for which addition and subtraction is supported. The <code>INCREMENT</code> and <code>DECREMENT</code> values must be positive. Optionally, you can specify the <code>LIKE</code> clause within the <code>FROM</code> clause. In the <code>LIKE</code> clause, <code>pattern</code> is a character string containing a single pattern-matching character <code>%</code>. This character is replaced during execution with the current incremented or decremented value in the <code>FROM</code> clause. If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause.<sep>[DEMO]: WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month LIKE 1 FROM 3 TO 1 DECREMENT 1] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );",
        "example": [
            "WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR month LIKE 1 FROM 3 TO 1 DECREMENT 1] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR ( dimension_column ) IN ( subquery )",
        "tree": "(multi_column_for_loop FOR (paren_column_list ( )) IN ( ))",
        "description": "The <code>multi_column_for_loop</code> clause lets you specify a range of cells to be updated across multiple dimension columns. The <code>IN</code> clause lets you specify the values of the dimension columns as either multiple lists of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0223) for more information about using <code>FOR</code> loops in the <code>MODEL</code> clause",
        "detail": "[DESCRIPTION]: The <code>multi_column_for_loop</code> clause lets you specify a range of cells to be updated across multiple dimension columns. The <code>IN</code> clause lets you specify the values of the dimension columns as either multiple lists of values or as a subquery. When using <code>subquery</code>, it cannot: Be a correlated query Return more than 10,000 rows Be a query defined in the <code>WITH</code> clause If all dimensions other than those used by a <code>FOR</code> loop involve a single-cell reference, then the expressions can insert new rows. The number of dimension value combinations generated by <code>FOR</code> loops is counted as part of the 10,000 row limit of the <code>MODEL</code> clause. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG0223) for more information about using <code>FOR</code> loops in the <code>MODEL</code> clause<sep>[DEMO]: WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR (region_id) IN (SELECT region_id FROM regions)] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );",
        "example": [
            "WITH regions AS ( SELECT region_id FROM sales ) SELECT * FROM sales MODEL DIMENSION BY (region_id) MEASURES (amount) RULES ( amount[FOR (region_id) IN (SELECT region_id FROM regions)] = SUM(amount[CV()]) OVER (PARTITION BY region_id) );"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ORDER BY expr DESC",
        "tree": "(order_by_clause ORDER BY (order_by_elements DESC))",
        "description": "Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause",
        "detail": "[DESCRIPTION]: Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause<sep>[DEMO]: SELECT employee_id, name, salary FROM employees ORDER BY salary DESC;",
        "example": [
            "SELECT employee_id, name, salary FROM employees ORDER BY salary DESC;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ORDER BY expr ASC",
        "tree": "(order_by_clause ORDER BY (order_by_elements ASC))",
        "description": "Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause",
        "detail": "[DESCRIPTION]: Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause<sep>[DEMO]: SELECT employee_id, name, salary FROM employees ORDER BY salary ASC;",
        "example": [
            "SELECT employee_id, name, salary FROM employees ORDER BY salary ASC;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ORDER BY expr NULLS FIRST",
        "tree": "(order_by_clause ORDER BY (order_by_elements NULLS FIRST))",
        "description": "Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause",
        "detail": "[DESCRIPTION]: Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause<sep>[DEMO]: SELECT employee_id, name, salary FROM employees ORDER BY salary NULLS FIRST;",
        "example": [
            "SELECT employee_id, name, salary FROM employees ORDER BY salary NULLS FIRST;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ORDER BY expr",
        "tree": "(order_by_clause ORDER BY)",
        "description": "Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause",
        "detail": "[DESCRIPTION]: Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause<sep>[DEMO]: SELECT employee_id, name, salary FROM employees ORDER BY salary;",
        "example": [
            "SELECT employee_id, name, salary FROM employees ORDER BY salary;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ORDER SIBLINGS BY expr",
        "tree": "(order_by_clause ORDER SIBLINGS BY)",
        "description": "Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause",
        "detail": "[DESCRIPTION]: Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause<sep>[DEMO]: SELECT employee_id, name, salary FROM employees ORDER SIBLINGS BY salary;",
        "example": [
            "SELECT employee_id, name, salary FROM employees ORDER SIBLINGS BY salary;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ORDER BY expr NULLS LAST",
        "tree": "(order_by_clause ORDER BY (order_by_elements NULLS LAST))",
        "description": "Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause",
        "detail": "[DESCRIPTION]: Use the <code>ORDER</code> <code>BY</code> clause to order rows returned by the statement. Without an <code>order_by_clause</code>, no guarantee exists that the same query executed more than once will retrieve rows in the same order. <subsubsect>SIBLINGS</subsubsect> The <code>SIBLINGS</code> keyword is valid only if you also specify the <code>hierarchical_query_clause</code> (<code>CONNECT</code> <code>BY</code>). <code>ORDER</code> <code>SIBLINGS</code> <code>BY</code> preserves any ordering specified in the hierarchical query clause and then applies the <code>order_by_clause</code> to the siblings of the hierarchy. <subsubsect>expr</subsubsect> <code>expr</code> orders rows based on their value for <code>expr</code>. The expression is based on columns in the select list or columns in the tables, views, or materialized views in the <code>FROM</code> clause. <subsubsect>position</subsubsect> Specify <code>position</code> to order rows based on their value for the expression in this position of the select list. The <code>position</code> value must be an integer. You can specify multiple expressions in the <code>order_by_clause</code>. Oracle Database first sorts rows based on their values for the first expression. Rows with the same value for the first expression are then sorted based on their values for the second expression, and so on. The database sorts nulls following all others in ascending order and preceding all others in descending order. Refer to \"Sorting Query Results(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Sorting-Query-Results.html#GUID-E45EF993-20AC-4552-860C-4D74EADB5BF2)\" for a discussion of ordering query results. <subsubsect>ASC | DESC</subsubsect> Specify whether the ordering sequence is ascending or descending. <code>ASC</code> is the default. <subsubsect>NULLS FIRST | NULLS LAST</subsubsect> Specify whether returned rows containing null values should appear first or last in the ordering sequence. <code>NULLS</code> <code>LAST</code> is the default for ascending order, and <code>NULLS</code> <code>FIRST</code> is the default for descending order. <subsubsect>Restrictions on the ORDER BY Clause</subsubsect> The following restrictions apply to the <code>ORDER</code> <code>BY</code> clause: If you have specified the <code>DISTINCT</code> operator in this statement, then this clause cannot refer to columns unless they appear in the select list. An <code>order_by_clause</code> can contain no more than 255 expressions. You cannot order by a LOB, <code>LONG</code>, or <code>LONG</code> <code>RAW</code> column, nested table, or varray. If you specify a group_by_clause(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2182483) in the same statement, then this <code>order_by_clause</code> is restricted to the following expressions: Constants Aggregate functions Analytic functions The functions <code>USER</code>, <code>UID</code>, and <code>SYSDATE</code> Expressions identical to those in the <code>group_by_clause</code> Expressions comprising the preceding expressions that evaluate to the same value for all rows in a group See Also: \"Using the ORDER BY Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130036)\" Restrictions for Linguistic Collations(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Type-Comparison-Rules.html#GUID-A114F1F4-A08D-4107-B679-323DC7FEA31C__P-13310-66248F0B) for information on implications of how <code>ORDER</code> <code>BY</code> character values are compared linguistically Appendix C in Oracle Database Globalization Support Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=NLSPG-GUID-AFCE41ED-775B-4A00-AF38-C436776AE0C5) for the collation determination rules for the expressions in the <code>ORDER</code> <code>BY</code> clause<sep>[DEMO]: SELECT employee_id, name, salary FROM employees ORDER BY salary NULLS LAST;",
        "example": [
            "SELECT employee_id, name, salary FROM employees ORDER BY salary NULLS LAST;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR UPDATE OF schema",
        "tree": "(for_update_clause FOR UPDATE (for_update_of_part OF))",
        "description": "The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.",
        "detail": "[DESCRIPTION]: The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.<sep>[DEMO]: SELECT * FROM employees WHERE department_id = 10 FOR UPDATE OF salary;",
        "example": [
            "SELECT * FROM employees WHERE department_id = 10 FOR UPDATE OF salary;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR UPDATE OF column WAIT integer",
        "tree": "(for_update_clause FOR UPDATE (for_update_of_part OF) (for_update_options WAIT))",
        "description": "The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.",
        "detail": "[DESCRIPTION]: The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.<sep>[DEMO]: SELECT * FROM employees WHERE department_id = 10 FOR UPDATE OF salary WAIT 1;",
        "example": [
            "SELECT * FROM employees WHERE department_id = 10 FOR UPDATE OF salary WAIT 1;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR UPDATE OF column SKIP LOCKED",
        "tree": "(for_update_clause FOR UPDATE (for_update_of_part OF) (for_update_options SKIP LOCKED))",
        "description": "The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.",
        "detail": "[DESCRIPTION]: The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.<sep>[DEMO]: SELECT * FROM employees WHERE department_id = 10 FOR UPDATE OF salary SKIP LOCKED;",
        "example": [
            "SELECT * FROM employees WHERE department_id = 10 FOR UPDATE OF salary SKIP LOCKED;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR UPDATE OF column NOWAIT",
        "tree": "(for_update_clause FOR UPDATE (for_update_of_part OF) (for_update_options NOWAIT))",
        "description": "The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.",
        "detail": "[DESCRIPTION]: The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.<sep>[DEMO]: SELECT * FROM employees WHERE department_id = 10 FOR UPDATE OF salary NOWAIT;",
        "example": [
            "SELECT * FROM employees WHERE department_id = 10 FOR UPDATE OF salary NOWAIT;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR UPDATE",
        "tree": "(for_update_clause FOR UPDATE)",
        "description": "The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.",
        "detail": "[DESCRIPTION]: The <code>FOR</code> <code>UPDATE</code> clause lets you lock the selected rows so that other users cannot lock or update the rows until you end your transaction. You can specify this clause only in a top-level <code>SELECT</code> statement, not in subqueries. Note: Prior to updating a LOB value, you must lock the row containing the LOB. One way to lock the row is with an embedded <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> statement. You can do this using one of the programmatic languages or <code>DBMS_LOB</code> package. For more information on lock rows before writing to a LOB, see Oracle Database SecureFiles and Large Objects Developer's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADLOB1004). Nested table rows are not locked as a result of locking the parent table rows. If you want the nested table rows to be locked, then you must lock them explicitly. <subsubsect>Restrictions on the FOR UPDATE Clause</subsubsect> This clause is subject to the following restrictions: You cannot specify this clause with the following other constructs: the <code>DISTINCT</code> operator, <code>CURSOR</code> expression, set operators, <code>group_by_clause</code>, or aggregate functions. The tables locked by this clause must all be located on the same database and on the same database as any <code>LONG</code> columns and sequences referenced in the same statement. See Also: \"Using the FOR UPDATE Clause: Examples(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2130052)\" <subsubsect>Using the FOR UPDATE Clause on Views</subsubsect> In general, this clause is not supported on views. However, in some cases, a <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> query on a view can succeed without any errors. This occurs when the view has been merged to its containing query block internally by the query optimizer, and <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> succeeds on the internally transformed query. The examples in this section illustrate when using the <code>FOR</code> <code>UPDATE</code> clause on a view can succeed or fail. Using the <code>FOR</code> <code>UPDATE</code> clause on merged views An error can occur when you use the <code>FOR</code> <code>UPDATE</code> clause on a merged view if both of the following conditions apply: The underlying column of the view is an expression The <code>FOR</code> <code>UPDATE</code> clause applies to a column list The following statement succeeds because the underlying column of the view is not an expression:<code>SELECT employee_id FROM (SELECT * FROM employees) FOR UPDATE OF employee_id; </code>The following statement succeeds because, while the underlying column of the view is an expression, the <code>FOR</code> <code>UPDATE</code> clause does not apply to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE; </code>The following statement fails because the underlying column of the view is an expression and the <code>FOR</code> <code>UPDATE</code> clause applies to a column list: <code>SELECT employee_id FROM (SELECT employee_id+1 AS employee_id FROM employees) FOR UPDATE OF employee_id; * Error at line 2: ORA-01733: virtual column not allowed here </code> Using the <code>FOR</code> <code>UPDATE</code> clause on non-merged views Since the <code>FOR</code> <code>UPDATE</code> clause is not supported on views, anything that prevents view merging, such as the <code>NO_MERGE</code> hint, parameters that disallow view merging, or something in the query structure that prevents view merging, will result in an <code>ORA-02014</code> error. In the following example, the <code>GROUP</code> <code>BY</code> statement prevents view merging, which causes an error: <code>SELECT avgsal FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) FOR UPDATE; FROM (SELECT AVG(salary) AS avgsal FROM employees GROUP BY job_id) * ERROR at line 2: ORA-02014: cannot select FOR UPDATE from view with DISTINCT, GROUP BY, etc.</code> Note: Due to the complexity of the view merging mechanism, Oracle recommends against using the <code>FOR</code> <code>UPDATE</code> clause on views. <subsubsect>OF ... column</subsubsect> Use the <code>OF</code> ... <code>column</code> clause to lock the select rows only for a particular table or view in a join. The columns in the <code>OF</code> clause only indicate which table or view rows are locked. The specific columns that you specify are not significant. However, you must specify an actual column name, not a column alias. If you omit this clause, then the database locks the selected rows from all the tables in the query. <subsubsect>NOWAIT | WAIT</subsubsect> The <code>NOWAIT</code> and <code>WAIT</code> clauses let you tell the database how to proceed if the <code>SELECT</code> statement attempts to lock a row that is locked by another user. Specify <code>NOWAIT</code> to return control to you immediately if a lock exists. Specify <code>WAIT</code> to instruct the database to wait <code>integer</code> seconds for the row to become available and then return control to you. If you specify neither <code>WAIT</code> nor <code>NOWAIT</code>, then the database waits until the row is available and then returns the results of the <code>SELECT</code> statement. <subsubsect>SKIP LOCKED</subsubsect> <code>SKIP</code> <code>LOCKED</code> is an alternative way to handle a contending transaction that is locking some rows of interest. Specify <code>SKIP</code> <code>LOCKED</code> to instruct the database to attempt to lock the rows specified by the <code>WHERE</code> clause and to skip any rows that are found to be already locked by another transaction. This feature is designed for use in multiconsumer queue environments. It enables queue consumers to skip rows that are locked by other consumers and obtain unlocked rows without waiting for the other consumers to finish. Refer to Oracle Database Advanced Queuing User's Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=ADQUE2835) for more information. <subsubsect>Note on the WAIT and SKIP LOCKED Clauses</subsubsect> If you specify <code>WAIT</code> or <code>SKIP</code> <code>LOCKED</code> and the table is locked in exclusive mode, then the database will not return the results of the <code>SELECT</code> statement until the lock on the table is released. In the case of <code>WAIT</code>, the <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> clause is blocked regardless of the wait time specified.<sep>[DEMO]: SELECT * FROM employees WHERE department_id = 10 FOR UPDATE;",
        "example": [
            "SELECT * FROM employees WHERE department_id = 10 FOR UPDATE;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SELECT UNIQUE",
        "tree": "(query_block SELECT UNIQUE)",
        "description": "Specify <code>DISTINCT</code> or <code>UNIQUE</code> if you want the database to return only one copy of each set of duplicate rows selected. These two keywords are synonymous. Duplicate rows are those with matching values for each expression in the select list. <subsubsect>Restrictions on DISTINCT and UNIQUE Queries</subsubsect> These types of queries are subject to the following restrictions: When you specify <code>DISTINCT</code> or <code>UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code>DB_BLOCK_SIZE</code>. You cannot specify <code>DISTINCT</code> if the <code>select_list</code> contains LOB columns.\",\n    \"Restrictions on DISTINCT and UNIQUE Queries\": \"These types of queries are subject to the following restrictions: When you specify <code>DISTINCT</code> or <code>UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code>DB_BLOCK_SIZE</code>. You cannot specify <code>DISTINCT</code> if the <code>select_list</code> contains LOB columns.\"",
        "detail": "[DESCRIPTION]: Specify <code>DISTINCT</code> or <code>UNIQUE</code> if you want the database to return only one copy of each set of duplicate rows selected. These two keywords are synonymous. Duplicate rows are those with matching values for each expression in the select list. <subsubsect>Restrictions on DISTINCT and UNIQUE Queries</subsubsect> These types of queries are subject to the following restrictions: When you specify <code>DISTINCT</code> or <code>UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code>DB_BLOCK_SIZE</code>. You cannot specify <code>DISTINCT</code> if the <code>select_list</code> contains LOB columns.\",\n    \"Restrictions on DISTINCT and UNIQUE Queries\": \"These types of queries are subject to the following restrictions: When you specify <code>DISTINCT</code> or <code>UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code>DB_BLOCK_SIZE</code>. You cannot specify <code>DISTINCT</code> if the <code>select_list</code> contains LOB columns.\"<sep>[DEMO]: SELECT UNIQUE department_id, salary FROM employees;",
        "example": [
            "SELECT UNIQUE department_id, salary FROM employees;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SELECT DISTINCT",
        "tree": "(query_block SELECT DISTINCT)",
        "description": "Specify <code>DISTINCT</code> or <code>UNIQUE</code> if you want the database to return only one copy of each set of duplicate rows selected. These two keywords are synonymous. Duplicate rows are those with matching values for each expression in the select list. <subsubsect>Restrictions on DISTINCT and UNIQUE Queries</subsubsect> These types of queries are subject to the following restrictions: When you specify <code>DISTINCT</code> or <code>UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code>DB_BLOCK_SIZE</code>. You cannot specify <code>DISTINCT</code> if the <code>select_list</code> contains LOB columns.\",\n    \"Restrictions on DISTINCT and UNIQUE Queries\": \"These types of queries are subject to the following restrictions: When you specify <code>DISTINCT</code> or <code>UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code>DB_BLOCK_SIZE</code>. You cannot specify <code>DISTINCT</code> if the <code>select_list</code> contains LOB columns.\"",
        "detail": "[DESCRIPTION]: Specify <code>DISTINCT</code> or <code>UNIQUE</code> if you want the database to return only one copy of each set of duplicate rows selected. These two keywords are synonymous. Duplicate rows are those with matching values for each expression in the select list. <subsubsect>Restrictions on DISTINCT and UNIQUE Queries</subsubsect> These types of queries are subject to the following restrictions: When you specify <code>DISTINCT</code> or <code>UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code>DB_BLOCK_SIZE</code>. You cannot specify <code>DISTINCT</code> if the <code>select_list</code> contains LOB columns.\",\n    \"Restrictions on DISTINCT and UNIQUE Queries\": \"These types of queries are subject to the following restrictions: When you specify <code>DISTINCT</code> or <code>UNIQUE</code>, the total number of bytes in all select list expressions is limited to the size of a data block minus some overhead. This size is specified by the initialization parameter <code>DB_BLOCK_SIZE</code>. You cannot specify <code>DISTINCT</code> if the <code>select_list</code> contains LOB columns.\"<sep>[DEMO]: SELECT DISTINCT department_id, salary FROM employees;",
        "example": [
            "SELECT DISTINCT department_id, salary FROM employees;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "SELECT ALL",
        "tree": "(query_block SELECT ALL)",
        "description": "Specify <code>ALL</code> if you want the database to return all rows selected, including all copies of duplicates. The default is <code>ALL</code>.",
        "detail": "[DESCRIPTION]: Specify <code>ALL</code> if you want the database to return all rows selected, including all copies of duplicates. The default is <code>ALL</code>.<sep>[DEMO]: SELECT ALL department_id, salary FROM employees;",
        "example": [
            "SELECT ALL department_id, salary FROM employees;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ONLY ( query_table_expression )",
        "tree": "(table_ref_aux_internal ONLY ( ))",
        "description": "The <code>ONLY</code> clause applies only to views. Specify <code>ONLY</code> if the view in the <code>FROM</code> clause is a view belonging to a hierarchy and you do not want to include rows from any of its subviews.",
        "detail": "[DESCRIPTION]: The <code>ONLY</code> clause applies only to views. Specify <code>ONLY</code> if the view in the <code>FROM</code> clause is a view belonging to a hierarchy and you do not want to include rows from any of its subviews.<sep>[DEMO]: SELECT * FROM employee_hierarchy ONLY ( SELECT * FROM TEMP );",
        "example": [
            "SELECT * FROM employee_hierarchy ONLY ( SELECT * FROM TEMP );"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR column",
        "tree": "(pivot_for_clause FOR)",
        "description": "In the pivot_for_clause, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns.",
        "detail": "[DESCRIPTION]: In the pivot_for_clause, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns.<sep>[DEMO]: SELECT *\nFROM (\n  SELECT year, quarter, amount, order_count\n  FROM sales_summary\n)\nPIVOT (\n  SUM(amount) AS total_amount,\n  SUM(order_count) AS total_orders\n  FOR quarter IN (Q1, Q2, Q3, Q4)\n);",
        "example": [
            "SELECT *\nFROM (\n  SELECT year, quarter, amount, order_count\n  FROM sales_summary\n)\nPIVOT (\n  SUM(amount) AS total_amount,\n  SUM(order_count) AS total_orders\n  FOR quarter IN (Q1, Q2, Q3, Q4)\n);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "FOR ( column )",
        "tree": "(pivot_for_clause FOR (paren_column_list ( )))",
        "description": "In the pivot_for_clause, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns.",
        "detail": "[DESCRIPTION]: In the pivot_for_clause, specify a name for each output column that will hold descriptor values, such as quarter or product. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns.<sep>[DEMO]: SELECT *\nFROM (\n  SELECT year, quarter, amount, order_count\n  FROM sales_summary\n)\nPIVOT (\n  SUM(amount) AS total_amount,\n  SUM(order_count) AS total_orders\n  FOR (quarter) IN (Q1, Q2, Q3, Q4)\n);\n",
        "example": [
            "SELECT *\nFROM (\n  SELECT year, quarter, amount, order_count\n  FROM sales_summary\n)\nPIVOT (\n  SUM(amount) AS total_amount,\n  SUM(order_count) AS total_orders\n  FOR (quarter) IN (Q1, Q2, Q3, Q4)\n);\n"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "IN ( expr )",
        "tree": "(pivot_in_clause IN ( ))",
        "description": "The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both.",
        "detail": "[DESCRIPTION]: The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both.<sep>[DEMO]: SELECT * FROM sales PIVOT (  SUM(amount) \n  FOR quarter IN (Q1, Q2, Q3, Q4)\n);",
        "example": [
            "SELECT * FROM sales PIVOT (  SUM(amount) \n  FOR quarter IN (Q1, Q2, Q3, Q4)\n);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "IN ( ANY )",
        "tree": "(pivot_in_clause IN ( ANY ))",
        "description": "The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both.",
        "detail": "[DESCRIPTION]: The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both.<sep>[DEMO]: SELECT *\nFROM sales\nPIVOT (\n  SUM(amount) \n  FOR quarter IN (ANY)\n);",
        "example": [
            "SELECT *\nFROM sales\nPIVOT (\n  SUM(amount) \n  FOR quarter IN (ANY)\n);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "IN ( expr AS alias )",
        "tree": "(pivot_in_clause IN ( (pivot_in_clause_element (column_alias AS)) ))",
        "description": "The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both.",
        "detail": "[DESCRIPTION]: The <code>pivot_clause</code> lets you write cross-tabulation queries that rotate rows into columns, aggregating data in the process of the rotation. The output of a pivot operation typically includes more columns and fewer rows than the starting data set. The <code>pivot_clause</code> performs the following steps: The <code>pivot_clause</code> computes the aggregation functions specified at the beginning of the clause. Aggregation functions must specify a <code>GROUP</code> <code>BY</code> clause to return multiple values, yet the <code>pivot_clause</code> does not contain an explicit <code>GROUP</code> <code>BY</code> clause. Instead, the <code>pivot_clause</code> performs an implicit <code>GROUP</code> <code>BY</code>. The implicit grouping is based on all the columns not referred to in the <code>pivot_clause</code>, along with the set of values specified in the <code>pivot_in_clause</code>.). If you specify more than one aggregation function, then you must provide aliases for at least all but one of the aggregation functions. The grouping columns and aggregated values calculated in Step 1 are configured to produce the following cross-tabular output: All the implicit grouping columns not referred to in the <code>pivot_clause</code>, followed by New columns corresponding to values in the <code>pivot_in_clause</code>. Each aggregated value is transposed to the appropriate new column in the cross-tabulation. If you specify the <code>XML</code> keyword, then the result is a single new column that expresses the data as an XML string. The database generates a name for each new column. If you do not provide an alias for an aggregation function, then the database uses each pivot column value as the name for each new column to which that aggregated value is transposed. If you provide an alias for an aggregation function, then the database generates a name for each new column to which that aggregated value is transposed by concatenating the pivot column name, the underscore character (_), and the aggregation function alias. If a generated column name exceeds the maximum length of a column name, then an ORA-00918 error is returned. To avoid this issue, specify a shorter alias for the pivot column heading, the aggregation function, or both.<sep>[DEMO]: SELECT *\nFROM sales\nPIVOT (\n  SUM(amount) \n  FOR quarter IN (\n    Q1 AS \"Q1 Sales\",\n    Q2 AS \"Q2 Sales\",\n    Q3 AS \"Q3 Sales\",\n    Q4 AS \"Q4 Sales\"\n  )\n);\n",
        "example": [
            "SELECT *\nFROM sales\nPIVOT (\n  SUM(amount) \n  FOR quarter IN (\n    Q1 AS \"Q1 Sales\",\n    Q2 AS \"Q2 Sales\",\n    Q3 AS \"Q3 Sales\",\n    Q4 AS \"Q4 Sales\"\n  )\n);\n"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "IN ( column AS literal )",
        "tree": "(unpivot_in_clause IN ( (unpivot_in_elements AS) ))",
        "description": "The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.",
        "detail": "[DESCRIPTION]: The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.<sep>[DEMO]: SELECT * FROM sales_data UNPIVOT (sales FOR quarter IN (q1 AS 'Q1'));",
        "example": [
            "SELECT * FROM sales_data UNPIVOT (sales FOR quarter IN (q1 AS 'Q1'));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "IN ( column )",
        "tree": "(unpivot_in_clause IN ( ))",
        "description": "The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.",
        "detail": "[DESCRIPTION]: The <code>unpivot_clause</code> rotates columns into rows. The <code>INCLUDE</code> | <code>EXCLUDE</code> <code>NULLS</code> clause gives you the option of including or excluding null-valued rows. <code>INCLUDE</code> <code>NULLS</code> causes the unpivot operation to include null-valued rows; <code>EXCLUDE</code> <code>NULLS</code> eliminates null-values rows from the return set. If you omit this clause, then the unpivot operation excludes nulls. For <code>column</code>, specify a name for each output column that will hold measure values, such as <code>sales_quantity</code>. In the <code>unpivot_in_clause</code>, specify the input data columns whose names will become values in the output columns of the <code>pivot_for_clause</code>. These input data columns have names specifying a category value, such as Q1, Q2, Q3, Q4. The optional <code>AS</code> clause lets you map the input data column names to the specified <code>literal</code> values in the output columns. The unpivot operation turns a set of value columns into one column. Therefore, the data types of all the value columns must be in the same data type group, such as numeric or character. If all the value columns are <code>CHAR</code>, then the unpivoted column is <code>CHAR</code>. If any value column is <code>VARCHAR2</code>, then the unpivoted column is <code>VARCHAR2</code>. If all the value columns are <code>NUMBER</code>, then the unpivoted column is <code>NUMBER</code>. If any value column is <code>BINARY_DOUBLE</code>, then the unpivoted column is <code>BINARY_DOUBLE</code>. If no value column is <code>BINARY_DOUBLE</code> but any value column is <code>BINARY_FLOAT</code>, then the unpivoted column is <code>BINARY_FLOAT</code>.<sep>[DEMO]: SELECT * FROM sales_data UNPIVOT (sales FOR quarter IN (q1));",
        "example": [
            "SELECT * FROM sales_data UNPIVOT (sales FOR quarter IN (q1));"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ROLLUP ( grouping_expression_list )",
        "tree": "(rollup_cube_clause ROLLUP ( ))",
        "description": "The <code>ROLLUP</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of the first n, n-1, n-2, ... 0 expressions in the <code>GROUP</code> <code>BY</code> specification, and returns a single row of summary for each group. You can use the <code>ROLLUP</code> operation to produce subtotal values by using it with the <code>SUM</code> function. When used with <code>SUM</code>, <code>ROLLUP</code> generates subtotals from the most detailed level to the grand total. Aggregate functions such as <code>COUNT</code> can be used to produce other kinds of superaggregates. For example, given three expressions (n=3) in the <code>ROLLUP</code> clause of the <code>simple_grouping_clause</code>, the operation results in n+1 = 3+1 = 4 groupings. Rows grouped on the values of the first <code>n</code> expressions are called regular rows, and the others are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>ROLLUP</code> with materialized views",
        "detail": "[DESCRIPTION]: The <code>ROLLUP</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of the first n, n-1, n-2, ... 0 expressions in the <code>GROUP</code> <code>BY</code> specification, and returns a single row of summary for each group. You can use the <code>ROLLUP</code> operation to produce subtotal values by using it with the <code>SUM</code> function. When used with <code>SUM</code>, <code>ROLLUP</code> generates subtotals from the most detailed level to the grand total. Aggregate functions such as <code>COUNT</code> can be used to produce other kinds of superaggregates. For example, given three expressions (n=3) in the <code>ROLLUP</code> clause of the <code>simple_grouping_clause</code>, the operation results in n+1 = 3+1 = 4 groupings. Rows grouped on the values of the first <code>n</code> expressions are called regular rows, and the others are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>ROLLUP</code> with materialized views<sep>[DEMO]: SELECT department_id, job_id, SUM(salary) AS total_salary FROM employees GROUP BY ROLLUP (department_id, job_id);",
        "example": [
            "SELECT department_id, job_id, SUM(salary) AS total_salary FROM employees GROUP BY ROLLUP (department_id, job_id);"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "CUBE ( grouping_expression_list )",
        "tree": "(rollup_cube_clause CUBE ( ))",
        "description": "The <code>CUBE</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of all possible combinations of expressions in the specification. It returns a single row of summary information for each group. You can use the <code>CUBE</code> operation to produce cross-tabulation values. For example, given three expressions (n=3) in the <code>CUBE</code> clause of the <code>simple_grouping_clause</code>, the operation results in 2n = 23 = 8 groupings. Rows grouped on the values of <code>n</code> expressions are called regular rows, and the rest are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>CUBE</code> with materialized views \"Using the GROUP BY CUBE Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066443)\"",
        "detail": "[DESCRIPTION]: The <code>CUBE</code> operation in the <code>simple_grouping_clause</code> groups the selected rows based on the values of all possible combinations of expressions in the specification. It returns a single row of summary information for each group. You can use the <code>CUBE</code> operation to produce cross-tabulation values. For example, given three expressions (n=3) in the <code>CUBE</code> clause of the <code>simple_grouping_clause</code>, the operation results in 2n = 23 = 8 groupings. Rows grouped on the values of <code>n</code> expressions are called regular rows, and the rest are called superaggregate rows. See Also: Oracle Database Data Warehousing Guide(https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sqlrf&id=DWHSG021) for information on using <code>CUBE</code> with materialized views \"Using the GROUP BY CUBE Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2066443)\"<sep>[DEMO]: SELECT department_id, job_id, SUM(salary) AS total_salary FROM employees GROUP BY CUBE (department_id, job_id) ORDER BY department_id, job_id;",
        "example": [
            "SELECT department_id, job_id, SUM(salary) AS total_salary FROM employees GROUP BY CUBE (department_id, job_id) ORDER BY department_id, job_id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "GROUP BY GROUPING SETS ( grouping_expression_list )",
        "tree": "(group_by_clause GROUP BY (group_by_elements (grouping_sets_clause GROUPING SETS ( ))))",
        "description": "<code>GROUPING</code> <code>SETS</code> are a further extension of the <code>GROUP</code> <code>BY</code> clause that let you specify multiple groupings of data. Doing so facilitates efficient aggregation by pruning the aggregates you do not need. You specify just the desired groups, and the database does not need to perform the full set of aggregations generated by <code>CUBE</code> or <code>ROLLUP</code>. Oracle Database computes all groupings specified in the <code>GROUPING</code> <code>SETS</code> clause and combines the results of individual groupings with a <code>UNION</code> <code>ALL</code> operation. The <code>UNION</code> <code>ALL</code> means that the result set can include duplicate rows. Within the <code>GROUP</code> <code>BY</code> clause, you can combine expressions in various ways: To specify composite columns, group columns within parentheses so that the database treats them as a unit while computing <code>ROLLUP</code> or <code>CUBE</code> operations. To specify concatenated grouping sets, separate multiple grouping sets, <code>ROLLUP</code>, and <code>CUBE</code> operations with commas so that the database combines them into a single <code>GROUP</code> <code>BY</code> clause. The result is a cross-product of groupings from each grouping set. See Also: \"Using the GROUPING SETS Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2091446)\"",
        "detail": "[DESCRIPTION]: <code>GROUPING</code> <code>SETS</code> are a further extension of the <code>GROUP</code> <code>BY</code> clause that let you specify multiple groupings of data. Doing so facilitates efficient aggregation by pruning the aggregates you do not need. You specify just the desired groups, and the database does not need to perform the full set of aggregations generated by <code>CUBE</code> or <code>ROLLUP</code>. Oracle Database computes all groupings specified in the <code>GROUPING</code> <code>SETS</code> clause and combines the results of individual groupings with a <code>UNION</code> <code>ALL</code> operation. The <code>UNION</code> <code>ALL</code> means that the result set can include duplicate rows. Within the <code>GROUP</code> <code>BY</code> clause, you can combine expressions in various ways: To specify composite columns, group columns within parentheses so that the database treats them as a unit while computing <code>ROLLUP</code> or <code>CUBE</code> operations. To specify concatenated grouping sets, separate multiple grouping sets, <code>ROLLUP</code>, and <code>CUBE</code> operations with commas so that the database combines them into a single <code>GROUP</code> <code>BY</code> clause. The result is a cross-product of groupings from each grouping set. See Also: \"Using the GROUPING SETS Clause: Example(https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2091446)\"<sep>[DEMO]: SELECT department_id, job_id, SUM(salary) AS total_salary FROM employees GROUP BY GROUPING SETS ((department_id), (job_id), ()) ORDER BY department_id, job_id;",
        "example": [
            "SELECT department_id, job_id, SUM(salary) AS total_salary FROM employees GROUP BY GROUPING SETS ((department_id), (job_id), ()) ORDER BY department_id, job_id;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ITERATE ( number ) UNTIL ( condition )",
        "tree": "(model_iterate_clause ITERATE ( ) (until_part UNTIL ( )))",
        "description": "Use <code>ITERATE</code> ... [<code>UNTIL</code>] to specify the number of times to cycle through the rules and, optionally, an early termination condition. The parentheses around the <code>UNTIL</code> condition are optional. When you specify <code>ITERATE</code> ... [<code>UNTIL</code>], rules are evaluated in the order in which they appear. Oracle Database returns an error if both <code>AUTOMATIC</code> <code>ORDER</code> and <code>ITERATE</code> ... <code>[UNTIL]</code> are specified in the <code>model_rules_clause</code>.",
        "detail": "[DESCRIPTION]: Use <code>ITERATE</code> ... [<code>UNTIL</code>] to specify the number of times to cycle through the rules and, optionally, an early termination condition. The parentheses around the <code>UNTIL</code> condition are optional. When you specify <code>ITERATE</code> ... [<code>UNTIL</code>], rules are evaluated in the order in which they appear. Oracle Database returns an error if both <code>AUTOMATIC</code> <code>ORDER</code> and <code>ITERATE</code> ... <code>[UNTIL]</code> are specified in the <code>model_rules_clause</code>.<sep>[DEMO]: SELECT country, year, sale, csum FROM (SELECT country, year, SUM(sale) sale FROM sales_view_ref GROUP BY country, year ) MODEL DIMENSION BY (country, year) MEASURES (sale, 0 csum) RULES ITERATE (5) UNTIL (sales[ANY] > 5000) (csum[any, any]= SUM(sale) OVER (PARTITION BY country ORDER BY year ROWS UNBOUNDED PRECEDING) ) ORDER BY country, year;",
        "example": [
            "SELECT country, year, sale, csum FROM (SELECT country, year, SUM(sale) sale FROM sales_view_ref GROUP BY country, year ) MODEL DIMENSION BY (country, year) MEASURES (sale, 0 csum) RULES ITERATE (5) UNTIL (sales[ANY] > 5000) (csum[any, any]= SUM(sale) OVER (PARTITION BY country ORDER BY year ROWS UNBOUNDED PRECEDING) ) ORDER BY country, year;"
        ],
        "link": []
    },
    {
        "type": "keyword",
        "keyword": "ITERATE ( number )",
        "tree": "(model_iterate_clause ITERATE ( ))",
        "description": "Use <code>ITERATE</code> ... [<code>UNTIL</code>] to specify the number of times to cycle through the rules and, optionally, an early termination condition. The parentheses around the <code>UNTIL</code> condition are optional. When you specify <code>ITERATE</code> ... [<code>UNTIL</code>], rules are evaluated in the order in which they appear. Oracle Database returns an error if both <code>AUTOMATIC</code> <code>ORDER</code> and <code>ITERATE</code> ... <code>[UNTIL]</code> are specified in the <code>model_rules_clause</code>.",
        "detail": "[DESCRIPTION]: Use <code>ITERATE</code> ... [<code>UNTIL</code>] to specify the number of times to cycle through the rules and, optionally, an early termination condition. The parentheses around the <code>UNTIL</code> condition are optional. When you specify <code>ITERATE</code> ... [<code>UNTIL</code>], rules are evaluated in the order in which they appear. Oracle Database returns an error if both <code>AUTOMATIC</code> <code>ORDER</code> and <code>ITERATE</code> ... <code>[UNTIL]</code> are specified in the <code>model_rules_clause</code>.<sep>[DEMO]: SELECT country, year, sale, csum   FROM    (SELECT country, year, SUM(sale) sale    FROM sales_view_ref    GROUP BY country, year   )   MODEL DIMENSION BY (country, year)         MEASURES (sale, 0 csum) RULES ITERATE (5) (csum[any, any]= SUM(sale) OVER (PARTITION BY country ORDER BY year ROWS UNBOUNDED PRECEDING) ) ORDER BY country, year;",
        "example": [
            "SELECT country, year, sale, csum   FROM    (SELECT country, year, SUM(sale) sale    FROM sales_view_ref    GROUP BY country, year   )   MODEL DIMENSION BY (country, year)         MEASURES (sale, 0 csum) RULES ITERATE (5) (csum[any, any]= SUM(sale) OVER (PARTITION BY country ORDER BY year ROWS UNBOUNDED PRECEDING) ) ORDER BY country, year;"
        ],
        "link": []
    },
    {
        "type": "type",
        "keyword": "VARCHAR2 (size [BYTE |CHAR ])",
        "tree": "(native_datatype_element VARCHAR2)",
        "description": "Variable-length character string having maximum length<code>size</code>bytes or characters. Maximum<code>size</code>is 4000 bytes or characters, and minimum is 1 byte or 1 character. You must specify<code>size</code>for<code>VARCHAR2</code>.<code>BYTE</code>indicates that the column will have byte length semantics.<code>CHAR</code>indicates that the column will have character semantics.",
        "detail": "[DESCRIPTION]: Variable-length character string having maximum length<code>size</code>bytes or characters. Maximum<code>size</code>is 4000 bytes or characters, and minimum is 1 byte or 1 character. You must specify<code>size</code>for<code>VARCHAR2</code>.<code>BYTE</code>indicates that the column will have byte length semantics.<code>CHAR</code>indicates that the column will have character semantics.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "NVARCHAR2 (size )",
        "tree": "(native_datatype_element NVARCHAR2)",
        "description": "Variable-length Unicode character string having maximum length<code>size</code>characters. The number of bytes can be up to two times<code>size</code>for<code>AL16UTF16</code>encoding and three times<code>size</code>for<code>UTF8</code>encoding. Maximum<code>size</code>is determined by the national character set definition, with an upper limit of 4000 bytes. You must specify<code>size</code>for<code>NVARCHAR2</code>.",
        "detail": "[DESCRIPTION]: Variable-length Unicode character string having maximum length<code>size</code>characters. The number of bytes can be up to two times<code>size</code>for<code>AL16UTF16</code>encoding and three times<code>size</code>for<code>UTF8</code>encoding. Maximum<code>size</code>is determined by the national character set definition, with an upper limit of 4000 bytes. You must specify<code>size</code>for<code>NVARCHAR2</code>.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "NUMBER [ (p [,s ]) ]",
        "tree": "(native_datatype_element NUMBER)",
        "description": "Number having precision<code>p</code>and scale<code>s</code>. The precision<code>p</code>can range from 1 to 38. The scale<code>s</code>can range from -84 to 127. Both precision and scale are in decimal digits. A<code>NUMBER</code>value requires from 1 to 22 bytes.",
        "detail": "[DESCRIPTION]: Number having precision<code>p</code>and scale<code>s</code>. The precision<code>p</code>can range from 1 to 38. The scale<code>s</code>can range from -84 to 127. Both precision and scale are in decimal digits. A<code>NUMBER</code>value requires from 1 to 22 bytes.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "FLOAT [(p )]",
        "tree": "(native_datatype_element FLOAT)",
        "description": "A subtype of the<code>NUMBER</code>Type having precision<code>p</code>. A<code>FLOAT</code>value is represented internally as<code>NUMBER</code>. The precision<code>p</code>can range from 1 to 126 binary digits. A<code>FLOAT</code>value requires from 1 to 22 bytes.",
        "detail": "[DESCRIPTION]: A subtype of the<code>NUMBER</code>Type having precision<code>p</code>. A<code>FLOAT</code>value is represented internally as<code>NUMBER</code>. The precision<code>p</code>can range from 1 to 126 binary digits. A<code>FLOAT</code>value requires from 1 to 22 bytes.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "LONG",
        "tree": "(native_datatype_element LONG)",
        "description": "Character data of variable length up to 2 gigabytes, or 231-1 bytes. Provided for backward compatibility.",
        "detail": "[DESCRIPTION]: Character data of variable length up to 2 gigabytes, or 231-1 bytes. Provided for backward compatibility.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "DATE",
        "tree": "(native_datatype_element DATE)",
        "description": "Valid date range from January 1, 4712 BC, to December 31, 9999 AD. The default format is determined explicitly by the<code>NLS_DATE_FORMAT</code>parameter or implicitly by the<code>NLS_TERRITORY</code>parameter. The size is fixed at 7 bytes. This Type contains the datetime fields<code>YEAR</code>,<code>MONTH</code>,<code>DAY</code>,<code>HOUR</code>,<code>MINUTE</code>, and<code>SECOND</code>. It does not have fractional seconds or a time zone.",
        "detail": "[DESCRIPTION]: Valid date range from January 1, 4712 BC, to December 31, 9999 AD. The default format is determined explicitly by the<code>NLS_DATE_FORMAT</code>parameter or implicitly by the<code>NLS_TERRITORY</code>parameter. The size is fixed at 7 bytes. This Type contains the datetime fields<code>YEAR</code>,<code>MONTH</code>,<code>DAY</code>,<code>HOUR</code>,<code>MINUTE</code>, and<code>SECOND</code>. It does not have fractional seconds or a time zone.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "BINARY_FLOAT",
        "tree": "(native_datatype_element BINARY_FLOAT)",
        "description": "32-bit floating point number. This Type requires 4 bytes.",
        "detail": "[DESCRIPTION]: 32-bit floating point number. This Type requires 4 bytes.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "BINARY_DOUBLE",
        "tree": "(native_datatype_element BINARY_DOUBLE)",
        "description": "64-bit floating point number. This Type requires 8 bytes.",
        "detail": "[DESCRIPTION]: 64-bit floating point number. This Type requires 8 bytes.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "TIMESTAMP [(fractional_seconds_precision )]",
        "tree": "(native_datatype_element TIMESTAMP)",
        "description": "Year, month, and day values of date, as well as hour, minute, and second values of time, where<code>fractional_seconds_precision</code>is the number of digits in the fractional part of the<code>SECOND</code>datetime field. Accepted values of<code>fractional_seconds_precision</code>are 0 to 9. The default is 6. The default format is determined explicitly by the<code>NLS_TIMESTAMP_FORMAT</code>parameter or implicitly by the<code>NLS_TERRITORY</code>parameter. The size is 7 or 11 bytes, depending on the precision. This Type contains the datetime fields<code>YEAR</code>,<code>MONTH</code>,<code>DAY</code>,<code>HOUR</code>,<code>MINUTE</code>, and<code>SECOND</code>. It contains fractional seconds but does not have a time zone.",
        "detail": "[DESCRIPTION]: Year, month, and day values of date, as well as hour, minute, and second values of time, where<code>fractional_seconds_precision</code>is the number of digits in the fractional part of the<code>SECOND</code>datetime field. Accepted values of<code>fractional_seconds_precision</code>are 0 to 9. The default is 6. The default format is determined explicitly by the<code>NLS_TIMESTAMP_FORMAT</code>parameter or implicitly by the<code>NLS_TERRITORY</code>parameter. The size is 7 or 11 bytes, depending on the precision. This Type contains the datetime fields<code>YEAR</code>,<code>MONTH</code>,<code>DAY</code>,<code>HOUR</code>,<code>MINUTE</code>, and<code>SECOND</code>. It contains fractional seconds but does not have a time zone.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "TIMESTAMP [(fractional_seconds_precision )]WITH TIME ZONE ",
        "tree": "(datatype (native_datatype_element TIMESTAMP) WITH TIME ZONE)",
        "description": "All values of<code>TIMESTAMP</code>as well as time zone displacement value, where<code>fractional_seconds_precision</code>is the number of digits in the fractional part of the<code>SECOND</code>datetime field. Accepted values are 0 to 9. The default is 6. The default format is determined explicitly by the<code>NLS_TIMESTAMP_FORMAT</code>parameter or implicitly by the<code>NLS_TERRITORY</code>parameter. The size is fixed at 13 bytes. This Type contains the datetime fields<code>YEAR</code>,<code>MONTH</code>,<code>DAY</code>,<code>HOUR</code>,<code>MINUTE</code>,<code>SECOND</code>,<code>TIMEZONE_HOUR</code>, and<code>TIMEZONE_MINUTE</code>. It has fractional seconds and an explicit time zone.",
        "detail": "[DESCRIPTION]: All values of<code>TIMESTAMP</code>as well as time zone displacement value, where<code>fractional_seconds_precision</code>is the number of digits in the fractional part of the<code>SECOND</code>datetime field. Accepted values are 0 to 9. The default is 6. The default format is determined explicitly by the<code>NLS_TIMESTAMP_FORMAT</code>parameter or implicitly by the<code>NLS_TERRITORY</code>parameter. The size is fixed at 13 bytes. This Type contains the datetime fields<code>YEAR</code>,<code>MONTH</code>,<code>DAY</code>,<code>HOUR</code>,<code>MINUTE</code>,<code>SECOND</code>,<code>TIMEZONE_HOUR</code>, and<code>TIMEZONE_MINUTE</code>. It has fractional seconds and an explicit time zone.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "TIMESTAMP [(fractional_seconds_precision )]WITH LOCAL TIME ZONE ",
        "tree": "(datatype (native_datatype_element TIMESTAMP) WITH LOCAL TIME ZONE)",
        "description": "All values of<code>TIMESTAMP</code><code>WITH</code><code>TIME</code><code>ZONE</code>, with the following exceptions:Data is normalized to the database time zone when it is stored in the database.When the data is retrieved, users see the data in the session time zone.The default format is determined explicitly by the<code>NLS_TIMESTAMP_FORMAT</code>parameter or implicitly by the<code>NLS_TERRITORY</code>parameter. The size is 7 or 11 bytes, depending on the precision.",
        "detail": "[DESCRIPTION]: All values of<code>TIMESTAMP</code><code>WITH</code><code>TIME</code><code>ZONE</code>, with the following exceptions:Data is normalized to the database time zone when it is stored in the database.When the data is retrieved, users see the data in the session time zone.The default format is determined explicitly by the<code>NLS_TIMESTAMP_FORMAT</code>parameter or implicitly by the<code>NLS_TERRITORY</code>parameter. The size is 7 or 11 bytes, depending on the precision.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "INTERVAL YEAR [(year_precision )]TO MONTH",
        "tree": "(datatype INTERVAL YEAR TO MONTH)",
        "description": "Stores a period of time in years and months, where<code>year_precision</code>is the number of digits in the<code>YEAR</code>datetime field. Accepted values are 0 to 9. The default is 2. The size is fixed at 5 bytes.",
        "detail": "[DESCRIPTION]: Stores a period of time in years and months, where<code>year_precision</code>is the number of digits in the<code>YEAR</code>datetime field. Accepted values are 0 to 9. The default is 2. The size is fixed at 5 bytes.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "INTERVAL DAY [(day_precision )]TO SECOND [(fractional_seconds_precision )]",
        "tree": "(datatype INTERVAL DAY TO SECOND)",
        "description": "Stores a period of time in days, hours, minutes, and seconds, where<code>day_precision</code>is the maximum number of digits in the<code>DAY</code>datetime field. Accepted values are 0 to 9. The default is 2.<code>fractional_seconds_precision</code>is the number of digits in the fractional part of the<code>SECOND</code>field. Accepted values are 0 to 9. The default is 6.The size is fixed at 11 bytes.",
        "detail": "[DESCRIPTION]: Stores a period of time in days, hours, minutes, and seconds, where<code>day_precision</code>is the maximum number of digits in the<code>DAY</code>datetime field. Accepted values are 0 to 9. The default is 2.<code>fractional_seconds_precision</code>is the number of digits in the fractional part of the<code>SECOND</code>field. Accepted values are 0 to 9. The default is 6.The size is fixed at 11 bytes.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "RAW (size )",
        "tree": "(native_datatype_element RAW)",
        "description": "Raw binary data of length<code>size</code>bytes. Maximum<code>size</code>is 2000 bytes. You must specify<code>size</code>for a<code>RAW</code>value.",
        "detail": "[DESCRIPTION]: Raw binary data of length<code>size</code>bytes. Maximum<code>size</code>is 2000 bytes. You must specify<code>size</code>for a<code>RAW</code>value.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "LONG RAW",
        "tree": "(native_datatype_element LONG RAW)",
        "description": "Raw binary data of variable length up to 2 gigabytes.",
        "detail": "[DESCRIPTION]: Raw binary data of variable length up to 2 gigabytes.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "ROWID",
        "tree": "(native_datatype_element ROWID)",
        "description": "Base 64 string representing the unique address of a row in its table. This Type is primarily for values returned by the<code>ROWID</code>pseudocolumn.",
        "detail": "[DESCRIPTION]: Base 64 string representing the unique address of a row in its table. This Type is primarily for values returned by the<code>ROWID</code>pseudocolumn.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "UROWID [(size )]",
        "tree": "(native_datatype_element UROWID)",
        "description": "Base 64 string representing the logical address of a row of an index-organized table. The optional<code>size</code>is the size of a column of type<code>UROWID</code>. The maximum size and default is 4000 bytes.",
        "detail": "[DESCRIPTION]: Base 64 string representing the logical address of a row of an index-organized table. The optional<code>size</code>is the size of a column of type<code>UROWID</code>. The maximum size and default is 4000 bytes.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "CHAR [(size [BYTE |CHAR ])]",
        "tree": "(native_datatype_element CHAR)",
        "description": "Fixed-length character data of length<code>size</code>bytes or characters. Maximum<code>size</code>is 2000 bytes or characters. Default and minimum<code>size</code>is 1 byte.<code>BYTE</code>and<code>CHAR</code>have the same semantics as for<code>VARCHAR2</code>.",
        "detail": "[DESCRIPTION]: Fixed-length character data of length<code>size</code>bytes or characters. Maximum<code>size</code>is 2000 bytes or characters. Default and minimum<code>size</code>is 1 byte.<code>BYTE</code>and<code>CHAR</code>have the same semantics as for<code>VARCHAR2</code>.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "NCHAR [(size )]",
        "tree": "(native_datatype_element NCHAR)",
        "description": "Fixed-length character data of length<code>size</code>characters. The number of bytes can be up to two times<code>size</code>for<code>AL16UTF16</code>encoding and three times<code>size</code>for<code>UTF8</code>encoding. Maximum<code>size</code>is determined by the national character set definition, with an upper limit of 2000 bytes. Default and minimum<code>size</code>is 1 character.",
        "detail": "[DESCRIPTION]: Fixed-length character data of length<code>size</code>characters. The number of bytes can be up to two times<code>size</code>for<code>AL16UTF16</code>encoding and three times<code>size</code>for<code>UTF8</code>encoding. Maximum<code>size</code>is determined by the national character set definition, with an upper limit of 2000 bytes. Default and minimum<code>size</code>is 1 character.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "CLOB",
        "tree": "(native_datatype_element CLOB)",
        "description": "A character large object containing single-byte or multibyte characters. Both fixed-width and variable-width character sets are supported, both using the database character set. Maximum size is (4 gigabytes - 1) * (database block size).",
        "detail": "[DESCRIPTION]: A character large object containing single-byte or multibyte characters. Both fixed-width and variable-width character sets are supported, both using the database character set. Maximum size is (4 gigabytes - 1) * (database block size).",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "NCLOB",
        "tree": "(native_datatype_element NCLOB)",
        "description": "A character large object containing Unicode characters. Both fixed-width and variable-width character sets are supported, both using the database national character set. Maximum size is (4 gigabytes - 1) * (database block size). Stores national character set data.",
        "detail": "[DESCRIPTION]: A character large object containing Unicode characters. Both fixed-width and variable-width character sets are supported, both using the database national character set. Maximum size is (4 gigabytes - 1) * (database block size). Stores national character set data.",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "BLOB",
        "tree": "(native_datatype_element BLOB)",
        "description": "A binary large object. Maximum size is (4 gigabytes - 1) * (database block size).",
        "detail": "[DESCRIPTION]: A binary large object. Maximum size is (4 gigabytes - 1) * (database block size).",
        "link": [],
        "example": []
    },
    {
        "type": "type",
        "keyword": "BFILE",
        "tree": "(native_datatype_element BFILE)",
        "description": "Contains a locator to a large binary file stored outside the database. Enables byte stream I/O access to external LOBs residing on the database server. Maximum size is 4 gigabytes.",
        "detail": "[DESCRIPTION]: Contains a locator to a large binary file stored outside the database. Enables byte stream I/O access to external LOBs residing on the database server. Maximum size is 4 gigabytes.",
        "link": [],
        "example": []
    },
    {
        "type": "function",
        "keyword": "TRIM",
        "tree": "(string_function TRIM ( ))",
        "description": "The Syntax is: \n <eps> TRIM([ { { LEADING | TRAILING | BOTH } [ trim_character ] | trim_character } FROM ] trim_source ) </eps> \n The Purpose is: \n <code>TRIM</code> enables you to trim leading or trailing characters (or both) from a character string. If <code>trim_character</code> or <code>trim_source</code> is a character literal, then you must enclose it in single quotation marks. If you specify <code>LEADING</code>, then Oracle Database removes any leading characters equal to <code>trim_character</code>. If you specify <code>TRAILING</code>, then Oracle removes any trailing characters equal to <code>trim_character</code>. If you specify <code>BOTH</code> or none of the three, then Oracle removes leading and trailing characters equal to <code>trim_character</code>. If you do not specify <code>trim_character</code>, then the default value is a blank space. If you specify only <code>trim_source</code>, then Oracle removes leading and trailing blank spaces. The function returns a value with data type <code>VARCHAR2</code>. The maximum length of the value is the length of <code>trim_source</code>. If either <code>trim_source</code> or <code>trim_character</code> is null, then the <code>TRIM</code> function returns null. Both <code>trim_character</code> and <code>trim_source</code> can be <code>VARCHAR2</code> or any data type that can be implicitly converted to <code>VARCHAR2</code>. The string returned is a <code>VARCHAR2</code> (<code>NVARCHAR2</code>) data type if <code>trim_source</code> is a <code>CHAR</code> or <code>VARCHAR2</code> (<code>NCHAR</code> or <code>NVARCHAR2</code>) data type, and a <code>CLOB</code> if <code>trim_source</code> is a <code>CLOB</code> data type. The return string is in the same character set as <code>trim_source</code>. \n The Examples is: \n This example trims leading zeros from the hire date of the employees in the <code>hr</code> schema: <code>SELECT employee_id, TO_CHAR(TRIM(LEADING 0 FROM hire_date)) FROM employees WHERE department_id = 60 ORDER BY employee_id; EMPLOYEE_ID TO_CHAR(T ----------- --------- 103 20-MAY-08 104 21-MAY-07 105 25-JUN-05 106 5-FEB-06 107 7-FEB-07 </code> ",
        "detail": "The Syntax is: \n <eps> TRIM([ { { LEADING | TRAILING | BOTH } [ trim_character ] | trim_character } FROM ] trim_source ) </eps> \n The Purpose is: \n <code>TRIM</code> enables you to trim leading or trailing characters (or both) from a character string. If <code>trim_character</code> or <code>trim_source</code> is a character literal, then you must enclose it in single quotation marks. If you specify <code>LEADING</code>, then Oracle Database removes any leading characters equal to <code>trim_character</code>. If you specify <code>TRAILING</code>, then Oracle removes any trailing characters equal to <code>trim_character</code>. If you specify <code>BOTH</code> or none of the three, then Oracle removes leading and trailing characters equal to <code>trim_character</code>. If you do not specify <code>trim_character</code>, then the default value is a blank space. If you specify only <code>trim_source</code>, then Oracle removes leading and trailing blank spaces. The function returns a value with data type <code>VARCHAR2</code>. The maximum length of the value is the length of <code>trim_source</code>. If either <code>trim_source</code> or <code>trim_character</code> is null, then the <code>TRIM</code> function returns null. Both <code>trim_character</code> and <code>trim_source</code> can be <code>VARCHAR2</code> or any data type that can be implicitly converted to <code>VARCHAR2</code>. The string returned is a <code>VARCHAR2</code> (<code>NVARCHAR2</code>) data type if <code>trim_source</code> is a <code>CHAR</code> or <code>VARCHAR2</code> (<code>NCHAR</code> or <code>NVARCHAR2</code>) data type, and a <code>CLOB</code> if <code>trim_source</code> is a <code>CLOB</code> data type. The return string is in the same character set as <code>trim_source</code>. \n The Examples is: \n This example trims leading zeros from the hire date of the employees in the <code>hr</code> schema: <code>SELECT employee_id, TO_CHAR(TRIM(LEADING 0 FROM hire_date)) FROM employees WHERE department_id = 60 ORDER BY employee_id; EMPLOYEE_ID TO_CHAR(T ----------- --------- 103 20-MAY-08 104 21-MAY-07 105 25-JUN-05 106 5-FEB-06 107 7-FEB-07 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions219.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_NCHAR(datetime)",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_NCHAR))) (function_argument ( )))",
        "description": "The Syntax is: \n to_nchar_date::= <eps> TO_NCHAR({ datetime | interval } [, fmt [, 'nlsparam' ] ] ) </eps> \n The Purpose is: \n <code>TO_NCHAR</code> (datetime) converts a datetime or interval value of <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, <code>INTERVAL</code> <code>MONTH</code> <code>TO</code> <code>YEAR</code>, or <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> data type from the database character set to the national character set. See Also: <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> \n The Examples is: \n The following example converts the <code>order_date</code> of all orders whose status is <code>9</code> to the national character set: <code>SELECT TO_NCHAR(ORDER_DATE) AS order_date FROM ORDERS WHERE ORDER_STATUS > 9 ORDER BY order_date; ORDER_DATE -------------------------------------------------------------------------- 06-DEC-99 02.22.34.225609 PM 13-SEP-99 10.19.00.654279 AM 14-SEP-99 09.53.40.223345 AM 26-JUN-00 10.19.43.190089 PM 27-JUN-00 09.53.32.335522 PM </code> ",
        "detail": "The Syntax is: \n to_nchar_date::= <eps> TO_NCHAR({ datetime | interval } [, fmt [, 'nlsparam' ] ] ) </eps> \n The Purpose is: \n <code>TO_NCHAR</code> (datetime) converts a datetime or interval value of <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, <code>INTERVAL</code> <code>MONTH</code> <code>TO</code> <code>YEAR</code>, or <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> data type from the database character set to the national character set. See Also: <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> \n The Examples is: \n The following example converts the <code>order_date</code> of all orders whose status is <code>9</code> to the national character set: <code>SELECT TO_NCHAR(ORDER_DATE) AS order_date FROM ORDERS WHERE ORDER_STATUS > 9 ORDER BY order_date; ORDER_DATE -------------------------------------------------------------------------- 06-DEC-99 02.22.34.225609 PM 13-SEP-99 10.19.00.654279 AM 14-SEP-99 09.53.40.223345 AM 26-JUN-00 10.19.43.190089 PM 27-JUN-00 09.53.32.335522 PM </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions208.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "VALUE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c VALUE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> VALUE(correlation_variable) </eps> \n The Purpose is: \n <code>VALUE</code> takes as its argument a correlation variable (table alias) associated with a row of an object table and returns object instances stored in the object table. The type of the object instances is the same type as the object table. \n The Examples is: \n The following example uses the sample table <code>oe.persons</code>, which is created in <link>\"Substitutable Table and Column \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm#i2090577</link>: <code>SELECT VALUE(p) FROM persons p; VALUE(P)(NAME, SSN) ------------------------------------------------------------- PERSON_T('Bob', 1234) EMPLOYEE_T('Joe', 32456, 12, 100000) PART_TIME_EMP_T('Tim', 5678, 13, 1000, 20) </code> See Also: <link>\"IS OF type Condition\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions014.htm#i1051274</link> for information on using <code>IS</code> <code>OF</code> type conditions with the <code>VALUE</code> function ",
        "detail": "The Syntax is: \n <eps> VALUE(correlation_variable) </eps> \n The Purpose is: \n <code>VALUE</code> takes as its argument a correlation variable (table alias) associated with a row of an object table and returns object instances stored in the object table. The type of the object instances is the same type as the object table. \n The Examples is: \n The following example uses the sample table <code>oe.persons</code>, which is created in <link>\"Substitutable Table and Column \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm#i2090577</link>: <code>SELECT VALUE(p) FROM persons p; VALUE(P)(NAME, SSN) ------------------------------------------------------------- PERSON_T('Bob', 1234) EMPLOYEE_T('Joe', 32456, 12, 100000) PART_TIME_EMP_T('Tim', 5678, 13, 1000, 20) </code> See Also: <link>\"IS OF type Condition\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions014.htm#i1051274</link> for information on using <code>IS</code> <code>OF</code> type conditions with the <code>VALUE</code> function ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions229.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "APPENDCHILDXML",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c APPENDCHILDXML))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> APPENDCHILDXML ( XMLType_instance, XPath_string, value_expr [, namespace_string ]) </eps> \n The Purpose is: \n <code>APPENDCHILDXML</code> appends a user-supplied value onto the target XML as the child of the node indicated by an XPath expression. <code>XMLType_instance</code> is an instance of <code>XMLType</code>. <code>XPath_string</code> is an Xpath expression indicating one or more nodes onto which one or more child nodes are to be appended. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. <code>value_expr</code> specifies one or more nodes of <code>XMLType</code>. It must resolve to a string. The optional <code>namespace_string</code> provides namespace information for the <code>XPath_string</code>. This parameter must be of type <code>VARCHAR2</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example adds an <code>/Owner</code> node to the <code>/Warehouse/Building</code> node of <code>warehouse_spec</code> in the <code>oe.warehouses</code> table if the value of the <code>/Building</code> node is \"Rented\": <code>UPDATE warehouses SET warehouse_spec = APPENDCHILDXML(warehouse_spec, 'Warehouse/Building', XMLType('<Owner>Grandco</Owner>')) WHERE EXTRACTVALUE(warehouse_spec, '/Warehouse/Building') = 'Rented'; SELECT warehouse_id, warehouse_name, EXTRACTVALUE(warehouse_spec, '/Warehouse/Building/Owner') \"Prop.Owner\" FROM warehouses WHERE EXISTSNODE(warehouse_spec, '/Warehouse/Building/Owner') = 1; WAREHOUSE_ID WAREHOUSE_NAME Prop.Owner ------------ --------------- ---------- 2 San Francisco Grandco 3 New Jersey Grandco </code> ",
        "detail": "The Syntax is: \n <eps> APPENDCHILDXML ( XMLType_instance, XPath_string, value_expr [, namespace_string ]) </eps> \n The Purpose is: \n <code>APPENDCHILDXML</code> appends a user-supplied value onto the target XML as the child of the node indicated by an XPath expression. <code>XMLType_instance</code> is an instance of <code>XMLType</code>. <code>XPath_string</code> is an Xpath expression indicating one or more nodes onto which one or more child nodes are to be appended. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. <code>value_expr</code> specifies one or more nodes of <code>XMLType</code>. It must resolve to a string. The optional <code>namespace_string</code> provides namespace information for the <code>XPath_string</code>. This parameter must be of type <code>VARCHAR2</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example adds an <code>/Owner</code> node to the <code>/Warehouse/Building</code> node of <code>warehouse_spec</code> in the <code>oe.warehouses</code> table if the value of the <code>/Building</code> node is \"Rented\": <code>UPDATE warehouses SET warehouse_spec = APPENDCHILDXML(warehouse_spec, 'Warehouse/Building', XMLType('<Owner>Grandco</Owner>')) WHERE EXTRACTVALUE(warehouse_spec, '/Warehouse/Building') = 'Rented'; SELECT warehouse_id, warehouse_name, EXTRACTVALUE(warehouse_spec, '/Warehouse/Building/Owner') \"Prop.Owner\" FROM warehouses WHERE EXISTSNODE(warehouse_spec, '/Warehouse/Building/Owner') = 1; WAREHOUSE_ID WAREHOUSE_NAME Prop.Owner ------------ --------------- ---------- 2 San Francisco Grandco 3 New Jersey Grandco </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions012.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SINH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SINH))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SINH(n) </eps> \n The Purpose is: \n <code>SINH</code> returns the hyperbolic sine of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the hyperbolic sine of 1: <code>SELECT SINH(1) \"Hyperbolic sine of 1\" FROM DUAL; Hyperbolic sine of 1 -------------------- 1.17520119 </code> ",
        "detail": "The Syntax is: \n <eps> SINH(n) </eps> \n The Purpose is: \n <code>SINH</code> returns the hyperbolic sine of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the hyperbolic sine of 1: <code>SELECT SINH(1) \"Hyperbolic sine of 1\" FROM DUAL; Hyperbolic sine of 1 -------------------- 1.17520119 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions166.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "GROUPING_ID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c GROUPING_ID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> GROUPING_ID(expr [, expr ]...) </eps> \n The Purpose is: \n <code>GROUPING_ID</code> returns a number corresponding to the <code>GROUPING</code> bit vector associated with a row. <code>GROUPING_ID</code> is applicable only in a <code>SELECT</code> statement that contains a <code>GROUP</code> <code>BY</code> extension, such as <code>ROLLUP</code> or <code>CUBE</code>, and a <code>GROUPING</code> function. In queries with many <code>GROUP</code> <code>BY</code> expressions, determining the <code>GROUP</code> <code>BY</code> level of a particular row requires many <code>GROUPING</code> functions, which leads to cumbersome SQL. <code>GROUPING_ID</code> is useful in these cases. <code>GROUPING_ID</code> is functionally equivalent to taking the results of multiple <code>GROUPING</code> functions and concatenating them into a bit vector (a string of ones and zeros). By using <code>GROUPING_ID</code> you can avoid the need for multiple <code>GROUPING</code> functions and make row filtering conditions easier to express. Row filtering is easier with <code>GROUPING_ID</code> because the desired rows can be identified with a single condition of <code>GROUPING_ID</code> = <code>n</code>. The function is especially useful when storing multiple levels of aggregation in a single table. \n The Examples is: \n The following example shows how to extract grouping IDs from a query of the sample table <code>sh.sales</code>: <code>SELECT channel_id, promo_id, sum(amount_sold) s_sales, GROUPING(channel_id) gc, GROUPING(promo_id) gp, GROUPING_ID(channel_id, promo_id) gcp, GROUPING_ID(promo_id, channel_id) gpc FROM sales WHERE promo_id > 496 GROUP BY CUBE(channel_id, promo_id) ORDER BY channel_id, promo_id, s_sales, gc; CHANNEL_ID PROMO_ID S_SALES GC GP GCP GPC ---------- ---------- ---------- ---------- ---------- ---------- ---------- 2 999 25797563.2 0 0 0 0 2 25797563.2 0 1 1 2 3 999 55336945.1 0 0 0 0 3 55336945.1 0 1 1 2 4 999 13370012.5 0 0 0 0 4 13370012.5 0 1 1 2 999 94504520.8 1 0 2 1 94504520.8 1 1 3 3 </code> ",
        "detail": "The Syntax is: \n <eps> GROUPING_ID(expr [, expr ]...) </eps> \n The Purpose is: \n <code>GROUPING_ID</code> returns a number corresponding to the <code>GROUPING</code> bit vector associated with a row. <code>GROUPING_ID</code> is applicable only in a <code>SELECT</code> statement that contains a <code>GROUP</code> <code>BY</code> extension, such as <code>ROLLUP</code> or <code>CUBE</code>, and a <code>GROUPING</code> function. In queries with many <code>GROUP</code> <code>BY</code> expressions, determining the <code>GROUP</code> <code>BY</code> level of a particular row requires many <code>GROUPING</code> functions, which leads to cumbersome SQL. <code>GROUPING_ID</code> is useful in these cases. <code>GROUPING_ID</code> is functionally equivalent to taking the results of multiple <code>GROUPING</code> functions and concatenating them into a bit vector (a string of ones and zeros). By using <code>GROUPING_ID</code> you can avoid the need for multiple <code>GROUPING</code> functions and make row filtering conditions easier to express. Row filtering is easier with <code>GROUPING_ID</code> because the desired rows can be identified with a single condition of <code>GROUPING_ID</code> = <code>n</code>. The function is especially useful when storing multiple levels of aggregation in a single table. \n The Examples is: \n The following example shows how to extract grouping IDs from a query of the sample table <code>sh.sales</code>: <code>SELECT channel_id, promo_id, sum(amount_sold) s_sales, GROUPING(channel_id) gc, GROUPING(promo_id) gp, GROUPING_ID(channel_id, promo_id) gcp, GROUPING_ID(promo_id, channel_id) gpc FROM sales WHERE promo_id > 496 GROUP BY CUBE(channel_id, promo_id) ORDER BY channel_id, promo_id, s_sales, gc; CHANNEL_ID PROMO_ID S_SALES GC GP GCP GPC ---------- ---------- ---------- ---------- ---------- ---------- ---------- 2 999 25797563.2 0 0 0 0 2 25797563.2 0 1 1 2 3 999 55336945.1 0 0 0 0 3 55336945.1 0 1 1 2 4 999 13370012.5 0 0 0 0 4 13370012.5 0 1 1 2 999 94504520.8 1 0 2 1 94504520.8 1 1 3 3 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions072.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NLSSORT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NLSSORT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NLSSORT(char [, 'nlsparam' ]) </eps> \n The Purpose is: \n <code>NLSSORT</code> returns the string of bytes used to sort <code>char</code>. Both <code>char</code> and <code>'nlsparam'</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The value of <code>'nlsparam'</code> can have the form <code>'NLS_SORT = sort' </code> where <code>sort</code> is a linguistic sort sequence (collation) or <code>BINARY</code>. If you omit <code>'nlsparam'</code>, then this function uses the default sort sequence for your session. If you specify <code>BINARY</code>, then this function returns <code>char</code>. If you specify <code>'nlsparam'</code>, then you can append to the linguistic sort name the suffix <code>_ai</code> to request an accent-insensitive sort or <code>_ci</code> to request a case-insensitive sort. Refer to <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch5lingsort.htm#NLSPG005</link> for more information on accent- and case-insensitive sorting. The string returned, also known as the collation key, is of <code>RAW</code> data type. The length of the collation key resulting from a given <code>char</code> value for a given collation may exceed 2000 bytes, which is the maximum length of the <code>RAW</code> value returned by <code>NLSSORT</code>. In this case, <code>NLSSORT</code> calculates the collation key for a maximum prefix, or initial substring, of <code>char</code> so that the calculated result does not exceed 2000 bytes. For monolingual collations, for example <code>FRENCH</code>, the prefix length is typically 1000 characters. For multilingual collations, for example <code>GENERIC_M</code>, the prefix is typically 500 characters. The exact length may be lower or higher depending on the collation and the characters contained in <code>char</code>. This behavior implies that two character values whose collation keys (<code>NLSSORT</code> results) are compared to find the linguistic ordering are considered equal if they do not differ in the prefix even though they may differ at some further character position. Because the <code>NLSSORT</code> function is used implicitly to find linguistic ordering for comparison conditions, the <code>BETWEEN</code> condition, the <code>IN</code> condition, <code>ORDER</code> <code>BY</code>, <code>GROUP</code> <code>BY</code>, and <code>COUNT</code>(<code>DISTINCT</code>), those operations may return results that are only approximate for long character values. This is a restriction of the current comparison architecture. Currently, the only way to guarantee precise linguistic comparison results is to not compare character values that are longer than 499 characters for monolingual collations and 249 characters for multilingual collations. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n This function can be used to specify sorting and comparison operations based on a linguistic sort sequence rather than on the binary value of a string. The following example creates a test table containing two values and shows how the values returned can be ordered by the <code>NLSSORT</code> function: <code>CREATE TABLE test (name VARCHAR2(15)); INSERT INTO test VALUES ('Gaardiner'); INSERT INTO test VALUES ('Gaberd'); INSERT INTO test VALUES ('Gaasten'); SELECT * FROM test ORDER BY name; NAME --------------- Gaardiner Gaasten Gaberd SELECT * FROM test ORDER BY NLSSORT(name, 'NLS_SORT = XDanish'); NAME --------------- Gaberd Gaardiner Gaasten </code> The following example shows how to use the <code>NLSSORT</code> function in comparison operations: <code>SELECT * FROM test WHERE name > 'Gaberd' ORDER BY name; no rows selected SELECT * FROM test WHERE NLSSORT(name, 'NLS_SORT = XDanish') > NLSSORT('Gaberd', 'NLS_SORT = XDanish') ORDER BY name; NAME --------------- Gaardiner Gaasten </code> If you frequently use <code>NLSSORT</code> in comparison operations with the same linguistic sort sequence, then consider this more efficient alternative: Set the <code>NLS_COMP</code> parameter (either for the database or for the current session) to <code>LINGUISTIC</code>, and set the <code>NLS_SORT</code> parameter for the session to the desired sort sequence. Oracle Database will use that sort sequence by default for all sorting and comparison operations during the current session: <code>ALTER SESSION SET NLS_COMP = 'LINGUISTIC'; ALTER SESSION SET NLS_SORT = 'XDanish'; SELECT * FROM test WHERE name > 'Gaberd' ORDER BY name; NAME --------------- Gaardiner Gaasten </code> See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch5lingsort.htm#NLSPG005</link> for information on sort sequences ",
        "detail": "The Syntax is: \n <eps> NLSSORT(char [, 'nlsparam' ]) </eps> \n The Purpose is: \n <code>NLSSORT</code> returns the string of bytes used to sort <code>char</code>. Both <code>char</code> and <code>'nlsparam'</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The value of <code>'nlsparam'</code> can have the form <code>'NLS_SORT = sort' </code> where <code>sort</code> is a linguistic sort sequence (collation) or <code>BINARY</code>. If you omit <code>'nlsparam'</code>, then this function uses the default sort sequence for your session. If you specify <code>BINARY</code>, then this function returns <code>char</code>. If you specify <code>'nlsparam'</code>, then you can append to the linguistic sort name the suffix <code>_ai</code> to request an accent-insensitive sort or <code>_ci</code> to request a case-insensitive sort. Refer to <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch5lingsort.htm#NLSPG005</link> for more information on accent- and case-insensitive sorting. The string returned, also known as the collation key, is of <code>RAW</code> data type. The length of the collation key resulting from a given <code>char</code> value for a given collation may exceed 2000 bytes, which is the maximum length of the <code>RAW</code> value returned by <code>NLSSORT</code>. In this case, <code>NLSSORT</code> calculates the collation key for a maximum prefix, or initial substring, of <code>char</code> so that the calculated result does not exceed 2000 bytes. For monolingual collations, for example <code>FRENCH</code>, the prefix length is typically 1000 characters. For multilingual collations, for example <code>GENERIC_M</code>, the prefix is typically 500 characters. The exact length may be lower or higher depending on the collation and the characters contained in <code>char</code>. This behavior implies that two character values whose collation keys (<code>NLSSORT</code> results) are compared to find the linguistic ordering are considered equal if they do not differ in the prefix even though they may differ at some further character position. Because the <code>NLSSORT</code> function is used implicitly to find linguistic ordering for comparison conditions, the <code>BETWEEN</code> condition, the <code>IN</code> condition, <code>ORDER</code> <code>BY</code>, <code>GROUP</code> <code>BY</code>, and <code>COUNT</code>(<code>DISTINCT</code>), those operations may return results that are only approximate for long character values. This is a restriction of the current comparison architecture. Currently, the only way to guarantee precise linguistic comparison results is to not compare character values that are longer than 499 characters for monolingual collations and 249 characters for multilingual collations. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n This function can be used to specify sorting and comparison operations based on a linguistic sort sequence rather than on the binary value of a string. The following example creates a test table containing two values and shows how the values returned can be ordered by the <code>NLSSORT</code> function: <code>CREATE TABLE test (name VARCHAR2(15)); INSERT INTO test VALUES ('Gaardiner'); INSERT INTO test VALUES ('Gaberd'); INSERT INTO test VALUES ('Gaasten'); SELECT * FROM test ORDER BY name; NAME --------------- Gaardiner Gaasten Gaberd SELECT * FROM test ORDER BY NLSSORT(name, 'NLS_SORT = XDanish'); NAME --------------- Gaberd Gaardiner Gaasten </code> The following example shows how to use the <code>NLSSORT</code> function in comparison operations: <code>SELECT * FROM test WHERE name > 'Gaberd' ORDER BY name; no rows selected SELECT * FROM test WHERE NLSSORT(name, 'NLS_SORT = XDanish') > NLSSORT('Gaberd', 'NLS_SORT = XDanish') ORDER BY name; NAME --------------- Gaardiner Gaasten </code> If you frequently use <code>NLSSORT</code> in comparison operations with the same linguistic sort sequence, then consider this more efficient alternative: Set the <code>NLS_COMP</code> parameter (either for the database or for the current session) to <code>LINGUISTIC</code>, and set the <code>NLS_SORT</code> parameter for the session to the desired sort sequence. Oracle Database will use that sort sequence by default for all sorting and comparison operations during the current session: <code>ALTER SESSION SET NLS_COMP = 'LINGUISTIC'; ALTER SESSION SET NLS_SORT = 'XDanish'; SELECT * FROM test WHERE name > 'Gaberd' ORDER BY name; NAME --------------- Gaardiner Gaasten </code> See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch5lingsort.htm#NLSPG005</link> for information on sort sequences ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions113.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLCAST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLCAST))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLCAST ( value_expression AS datatype ) </eps> \n The Purpose is: \n <code>XMLCast</code> casts <code>value_expression</code> to the scalar SQL data type specified by <code>datatype</code>. The <code>value_expression</code> argument is a SQL expression that is evaluated. The <code>datatype</code> argument can be of data type <code>NUMBER</code>, <code>VARCHAR2</code>, <code>CHAR</code>, <code>CLOB</code>, <code>BLOB</code>, <code>REF</code> <code>XMLTYPE</code>, and any of the datetime data types. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0400</link> for more information on uses for this function and examples ",
        "detail": "The Syntax is: \n <eps> XMLCAST ( value_expression AS datatype ) </eps> \n The Purpose is: \n <code>XMLCast</code> casts <code>value_expression</code> to the scalar SQL data type specified by <code>datatype</code>. The <code>value_expression</code> argument is a SQL expression that is evaluated. The <code>datatype</code> argument can be of data type <code>NUMBER</code>, <code>VARCHAR2</code>, <code>CHAR</code>, <code>CLOB</code>, <code>BLOB</code>, <code>REF</code> <code>XMLTYPE</code>, and any of the datetime data types. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0400</link> for more information on uses for this function and examples ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions236.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LENGTH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LENGTH))) (function_argument ( )))",
        "description": "The Syntax is: \n length::= <eps> { LENGTH | LENGTHB | LENGTHC | LENGTH2 | LENGTH4 } (char) </eps> \n The Purpose is: \n The <code>LENGTH</code> functions return the length of <code>char</code>. <code>LENGTH</code> calculates length using characters as defined by the input character set. <code>LENGTHB</code> uses bytes instead of characters. <code>LENGTHC</code> uses Unicode complete characters. <code>LENGTH2</code> uses UCS2 code points. <code>LENGTH4</code> uses UCS4 code points. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The exceptions are <code>LENGTHC</code>, <code>LENGTH2</code>, and <code>LENGTH4</code>, which do not allow <code>char</code> to be a <code>CLOB</code> or <code>NCLOB</code>. The return value is of data type <code>NUMBER</code>. If <code>char</code> has data type <code>CHAR</code>, then the length includes all trailing blanks. If <code>char</code> is null, then this function returns null. Restriction on LENGTHB The <code>LENGTHB</code> function is supported for single-byte LOBs only. It cannot be used with <code>CLOB</code> and <code>NCLOB</code> data in a multibyte character set. \n The Examples is: \n The following example uses the <code>LENGTH</code> function using a single-byte database character set: <code>SELECT LENGTH('CANDIDE') \"Length in characters\" FROM DUAL; Length in characters -------------------- 7 </code> The next example assumes a double-byte database character set. <code>SELECT LENGTHB ('CANDIDE') \"Length in bytes\" FROM DUAL; Length in bytes --------------- 14 </code> ",
        "detail": "The Syntax is: \n length::= <eps> { LENGTH | LENGTHB | LENGTHC | LENGTH2 | LENGTH4 } (char) </eps> \n The Purpose is: \n The <code>LENGTH</code> functions return the length of <code>char</code>. <code>LENGTH</code> calculates length using characters as defined by the input character set. <code>LENGTHB</code> uses bytes instead of characters. <code>LENGTHC</code> uses Unicode complete characters. <code>LENGTH2</code> uses UCS2 code points. <code>LENGTH4</code> uses UCS4 code points. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The exceptions are <code>LENGTHC</code>, <code>LENGTH2</code>, and <code>LENGTH4</code>, which do not allow <code>char</code> to be a <code>CLOB</code> or <code>NCLOB</code>. The return value is of data type <code>NUMBER</code>. If <code>char</code> has data type <code>CHAR</code>, then the length includes all trailing blanks. If <code>char</code> is null, then this function returns null. Restriction on LENGTHB The <code>LENGTHB</code> function is supported for single-byte LOBs only. It cannot be used with <code>CLOB</code> and <code>NCLOB</code> data in a multibyte character set. \n The Examples is: \n The following example uses the <code>LENGTH</code> function using a single-byte database character set: <code>SELECT LENGTH('CANDIDE') \"Length in characters\" FROM DUAL; Length in characters -------------------- 7 </code> The next example assumes a double-byte database character set. <code>SELECT LENGTHB ('CANDIDE') \"Length in bytes\" FROM DUAL; Length in bytes --------------- 14 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions088.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NUMTOYMINTERVAL",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NUMTOYMINTERVAL))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NUMTOYMINTERVAL(n, 'interval_unit') </eps> \n The Purpose is: \n <code>NUMTOYMINTERVAL</code> converts number <code>n</code> to an <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> literal. The argument <code>n</code> can be any <code>NUMBER</code> value or an expression that can be implicitly converted to a <code>NUMBER</code> value. The argument <code>interval_unit</code> can be of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type. The value for <code>interval_unit</code> specifies the unit of <code>n</code> and must resolve to one of the following string values: '<code>YEAR</code>' '<code>MONTH</code>' <code>interval_unit</code> is case insensitive. Leading and trailing values within the parentheses are ignored. By default, the precision of the return is 9. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example uses <code>NUMTOYMINTERVAL</code> in a <code>SUM</code> analytic function to calculate, for each employee, the total salary of employees hired in the past one year from his or her hire date. Refer to <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for more information on the syntax of the analytic functions. <code>SELECT last_name, hire_date, salary, SUM(salary) OVER (ORDER BY hire_date RANGE NUMTOYMINTERVAL(1,'year') PRECEDING) AS t_sal FROM employees ORDER BY last_name, hire_date; LAST_NAME HIRE_DATE SALARY T_SAL ------------------------- --------- ---------- ---------- Abel 11-MAY-04 11000 90300 Ande 24-MAR-08 6400 112500 Atkinson 30-OCT-05 2800 177000 Austin 25-JUN-05 4800 134700 . . . Walsh 24-APR-06 3100 186200 Weiss 18-JUL-04 8000 70900 Whalen 17-SEP-03 4400 54000 Zlotkey 29-JAN-08 10500 119000 </code> ",
        "detail": "The Syntax is: \n <eps> NUMTOYMINTERVAL(n, 'interval_unit') </eps> \n The Purpose is: \n <code>NUMTOYMINTERVAL</code> converts number <code>n</code> to an <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> literal. The argument <code>n</code> can be any <code>NUMBER</code> value or an expression that can be implicitly converted to a <code>NUMBER</code> value. The argument <code>interval_unit</code> can be of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type. The value for <code>interval_unit</code> specifies the unit of <code>n</code> and must resolve to one of the following string values: '<code>YEAR</code>' '<code>MONTH</code>' <code>interval_unit</code> is case insensitive. Leading and trailing values within the parentheses are ignored. By default, the precision of the return is 9. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example uses <code>NUMTOYMINTERVAL</code> in a <code>SUM</code> analytic function to calculate, for each employee, the total salary of employees hired in the past one year from his or her hire date. Refer to <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for more information on the syntax of the analytic functions. <code>SELECT last_name, hire_date, salary, SUM(salary) OVER (ORDER BY hire_date RANGE NUMTOYMINTERVAL(1,'year') PRECEDING) AS t_sal FROM employees ORDER BY last_name, hire_date; LAST_NAME HIRE_DATE SALARY T_SAL ------------------------- --------- ---------- ---------- Abel 11-MAY-04 11000 90300 Ande 24-MAR-08 6400 112500 Atkinson 30-OCT-05 2800 177000 Austin 25-JUN-05 4800 134700 . . . Walsh 24-APR-06 3100 186200 Weiss 18-JUL-04 8000 70900 Whalen 17-SEP-03 4400 54000 Zlotkey 29-JAN-08 10500 119000 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions118.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TREAT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TREAT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TREAT(expr AS [ REF ] [ schema. ]type) </eps> \n The Purpose is: \n <code>TREAT</code> changes the declared type of an expression. You must have the <code>EXECUTE</code> object privilege on <code>type</code> to use this function. <code>type</code> must be some supertype or subtype of the declared type of <code>expr</code>. If the most specific type of <code>expr</code> is <code>type</code> (or some subtype of <code>type</code>), then <code>TREAT</code> returns <code>expr</code>. If the most specific type of <code>expr</code> is not <code>type</code> (or some subtype of <code>type</code>), then <code>TREAT</code> returns <code>NULL</code>. You can specify <code>REF</code> only if the declared type of <code>expr</code> is a <code>REF</code> type. If the declared type of <code>expr</code> is a <code>REF</code> to a source type of <code>expr</code>, then <code>type</code> must be some subtype or supertype of the source type of <code>expr</code>. If the most specific type of <code>DEREF</code>(<code>expr</code>) is <code>type</code> (or a subtype of <code>type</code>), then <code>TREAT</code> returns <code>expr</code>. If the most specific type of <code>DEREF</code>(<code>expr</code>) is not <code>type</code> (or a subtype of <code>type</code>), then <code>TREAT</code> returns <code>NULL</code>. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following statement uses the table <code>oe.persons</code>, which is created in <link>\"Substitutable Table and Column \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm#i2090577</link>. The example retrieves the salary attribute of all people in the <code>persons</code> table, the value being null for instances of people that are not employees. <code>SELECT name, TREAT(VALUE(p) AS employee_t).salary salary FROM persons p; NAME SALARY ------------------------- ---------- Bob Joe 100000 Tim 1000 </code> You can use the <code>TREAT</code> function to create an index on the subtype attributes of a substitutable column. For an example, see <link>\"Indexing on Substitutable Columns: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_5012.htm#i2089060</link>. ",
        "detail": "The Syntax is: \n <eps> TREAT(expr AS [ REF ] [ schema. ]type) </eps> \n The Purpose is: \n <code>TREAT</code> changes the declared type of an expression. You must have the <code>EXECUTE</code> object privilege on <code>type</code> to use this function. <code>type</code> must be some supertype or subtype of the declared type of <code>expr</code>. If the most specific type of <code>expr</code> is <code>type</code> (or some subtype of <code>type</code>), then <code>TREAT</code> returns <code>expr</code>. If the most specific type of <code>expr</code> is not <code>type</code> (or some subtype of <code>type</code>), then <code>TREAT</code> returns <code>NULL</code>. You can specify <code>REF</code> only if the declared type of <code>expr</code> is a <code>REF</code> type. If the declared type of <code>expr</code> is a <code>REF</code> to a source type of <code>expr</code>, then <code>type</code> must be some subtype or supertype of the source type of <code>expr</code>. If the most specific type of <code>DEREF</code>(<code>expr</code>) is <code>type</code> (or a subtype of <code>type</code>), then <code>TREAT</code> returns <code>expr</code>. If the most specific type of <code>DEREF</code>(<code>expr</code>) is not <code>type</code> (or a subtype of <code>type</code>), then <code>TREAT</code> returns <code>NULL</code>. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following statement uses the table <code>oe.persons</code>, which is created in <link>\"Substitutable Table and Column \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm#i2090577</link>. The example retrieves the salary attribute of all people in the <code>persons</code> table, the value being null for instances of people that are not employees. <code>SELECT name, TREAT(VALUE(p) AS employee_t).salary salary FROM persons p; NAME SALARY ------------------------- ---------- Bob Joe 100000 Tim 1000 </code> You can use the <code>TREAT</code> function to create an index on the subtype attributes of a substitutable column. For an example, see <link>\"Indexing on Substitutable Columns: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_5012.htm#i2089060</link>. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions218.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ACOS",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ACOS))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ACOS(n) </eps> \n The Purpose is: \n <code>ACOS</code> returns the arc cosine of <code>n</code>. The argument <code>n</code> must be in the range of -1 to 1, and the function returns a value in the range of 0 to pi, expressed in radians. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the arc cosine of .3: <code>SELECT ACOS(.3)\"Arc_Cosine\" FROM DUAL; Arc_Cosine ---------- 1.26610367 </code> ",
        "detail": "The Syntax is: \n <eps> ACOS(n) </eps> \n The Purpose is: \n <code>ACOS</code> returns the arc cosine of <code>n</code>. The argument <code>n</code> must be in the range of -1 to 1, and the function returns a value in the range of 0 to pi, expressed in radians. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the arc cosine of .3: <code>SELECT ACOS(.3)\"Arc_Cosine\" FROM DUAL; Arc_Cosine ---------- 1.26610367 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions010.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SQRT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SQRT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SQRT(n) </eps> \n The Purpose is: \n <code>SQRT</code> returns the square root of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If <code>n</code> resolves to a <code>NUMBER</code>, then the value <code>n</code> cannot be negative. <code>SQRT</code> returns a real number. If <code>n</code> resolves to a binary floating-point number (<code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>): If <code>n</code> >= 0, then the result is positive. If <code>n</code> = -0, then the result is -0. If <code>n</code> < 0, then the result is <code>NaN</code>. \n The Examples is: \n The following example returns the square root of 26: <code>SELECT SQRT(26) \"Square root\" FROM DUAL; Square root ----------- 5.09901951 </code> ",
        "detail": "The Syntax is: \n <eps> SQRT(n) </eps> \n The Purpose is: \n <code>SQRT</code> returns the square root of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If <code>n</code> resolves to a <code>NUMBER</code>, then the value <code>n</code> cannot be negative. <code>SQRT</code> returns a real number. If <code>n</code> resolves to a binary floating-point number (<code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>): If <code>n</code> >= 0, then the result is positive. If <code>n</code> = -0, then the result is -0. If <code>n</code> < 0, then the result is <code>NaN</code>. \n The Examples is: \n The following example returns the square root of 26: <code>SELECT SQRT(26) \"Square root\" FROM DUAL; Square root ----------- 5.09901951 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions168.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "USER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c USER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> USER </eps> \n The Purpose is: \n <code>USER</code> returns the name of the session user (the user who logged on) with the data type <code>VARCHAR2</code>. Oracle Database compares values of this function with blank-padded comparison semantics. In a distributed SQL statement, the <code>UID</code> and <code>USER</code> functions together identify the user on your local database. You cannot use these functions in the condition of a <code>CHECK</code> constraint. \n The Examples is: \n The following example returns the current user and the user's UID: <code>SELECT USER, UID FROM DUAL; </code> ",
        "detail": "The Syntax is: \n <eps> USER </eps> \n The Purpose is: \n <code>USER</code> returns the name of the session user (the user who logged on) with the data type <code>VARCHAR2</code>. Oracle Database compares values of this function with blank-padded comparison semantics. In a distributed SQL statement, the <code>UID</code> and <code>USER</code> functions together identify the user on your local database. You cannot use these functions in the condition of a <code>CHECK</code> constraint. \n The Examples is: \n The following example returns the current user and the user's UID: <code>SELECT USER, UID FROM DUAL; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions227.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "EXP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c EXP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> EXP(n) </eps> \n The Purpose is: \n <code>EXP</code> returns <code>e</code> raised to the <code>n</code>th power, where <code>e</code> = 2.71828183... . The function returns a value of the same type as the argument. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns <code>e</code> to the 4th power: <code>SELECT EXP(4) \"e to the 4th power\" FROM DUAL; e to the 4th power ------------------ 54.59815 </code> ",
        "detail": "The Syntax is: \n <eps> EXP(n) </eps> \n The Purpose is: \n <code>EXP</code> returns <code>e</code> raised to the <code>n</code>th power, where <code>e</code> = 2.71828183... . The function returns a value of the same type as the argument. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns <code>e</code> to the 4th power: <code>SELECT EXP(4) \"e to the 4th power\" FROM DUAL; e to the 4th power ------------------ 54.59815 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions058.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ORA_HASH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ORA_HASH))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ORA_HASH(expr [, max_bucket [, seed_value ] ]) </eps> \n The Purpose is: \n <code>ORA_HASH</code> is a function that computes a hash value for a given expression. This function is useful for operations such as analyzing a subset of data and generating a random sample. The <code>expr</code> argument determines the data for which you want Oracle Database to compute a hash value. There are no restrictions on the length of data represented by <code>expr</code>, which commonly resolves to a column name. The <code>expr</code> cannot be a <code>LONG</code> or LOB type. It cannot be a user-defined object type unless it is a nested table type. The hash value for nested table types does not depend on the order of elements in the collection. All other data types are supported for <code>expr</code>. The optional <code>max_bucket</code> argument determines the maximum bucket value returned by the hash function. You can specify any value between 0 and 4294967295. The default is 4294967295. The optional <code>seed_value</code> argument enables Oracle to produce many different results for the same set of data. Oracle applies the hash function to the combination of <code>expr</code> and <code>seed_value</code>. You can specify any value between 0 and 4294967295. The default is 0. The function returns a <code>NUMBER</code> value. \n The Examples is: \n The following example creates a hash value for each combination of customer ID and product ID in the <code>sh.sales</code> table, divides the hash values into a maximum of 100 buckets, and returns the sum of the <code>amount_sold</code> values in the first bucket (bucket 0). The third argument (5) provides a seed value for the hash function. You can obtain different hash results for the same query by changing the seed value. <code>SELECT SUM(amount_sold) FROM sales WHERE ORA_HASH(CONCAT(cust_id, prod_id), 99, 5) = 0; SUM(AMOUNT_SOLD) ---------------- 989431.14 </code> ",
        "detail": "The Syntax is: \n <eps> ORA_HASH(expr [, max_bucket [, seed_value ] ]) </eps> \n The Purpose is: \n <code>ORA_HASH</code> is a function that computes a hash value for a given expression. This function is useful for operations such as analyzing a subset of data and generating a random sample. The <code>expr</code> argument determines the data for which you want Oracle Database to compute a hash value. There are no restrictions on the length of data represented by <code>expr</code>, which commonly resolves to a column name. The <code>expr</code> cannot be a <code>LONG</code> or LOB type. It cannot be a user-defined object type unless it is a nested table type. The hash value for nested table types does not depend on the order of elements in the collection. All other data types are supported for <code>expr</code>. The optional <code>max_bucket</code> argument determines the maximum bucket value returned by the hash function. You can specify any value between 0 and 4294967295. The default is 4294967295. The optional <code>seed_value</code> argument enables Oracle to produce many different results for the same set of data. Oracle applies the hash function to the combination of <code>expr</code> and <code>seed_value</code>. You can specify any value between 0 and 4294967295. The default is 0. The function returns a <code>NUMBER</code> value. \n The Examples is: \n The following example creates a hash value for each combination of customer ID and product ID in the <code>sh.sales</code> table, divides the hash values into a maximum of 100 buckets, and returns the sum of the <code>amount_sold</code> values in the first bucket (bucket 0). The third argument (5) provides a seed value for the hash function. You can obtain different hash results for the same query by changing the seed value. <code>SELECT SUM(amount_sold) FROM sales WHERE ORA_HASH(CONCAT(cust_id, prod_id), 99, 5) = 0; SUM(AMOUNT_SOLD) ---------------- 989431.14 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions124.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STDDEV_POP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STDDEV_POP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STDDEV_POP(expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>STDDEV_POP</code> computes the population standard deviation and returns the square root of the population variance. You can use it as both an aggregate and analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion This function is the same as the square root of the <code>VAR_POP</code> function. When <code>VAR_POP</code> returns null, this function returns null. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>VAR_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions230.htm#i87119</link> <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> Aggregate Example The following example returns the population and sample standard deviations of the amount of sales in the sample table <code>sh.sales</code>: <code>SELECT STDDEV_POP(amount_sold) \"Pop\", STDDEV_SAMP(amount_sold) \"Samp\" FROM sales; Pop Samp ---------- ---------- 896.355151 896.355592 </code> Analytic Example The following example returns the population standard deviations of salaries in the sample <code>hr.employees</code> table by department: <code>SELECT department_id, last_name, salary, STDDEV_POP(salary) OVER (PARTITION BY department_id) AS pop_std FROM employees ORDER BY department_id, last_name, salary, pop_std; DEPARTMENT_ID LAST_NAME SALARY POP_STD ------------- ------------------------- ---------- ---------- 10 Whalen 4400 0 20 Fay 6000 3500 20 Hartstein 13000 3500 30 Baida 2900 3069.6091 . . . 100 Urman 7800 1644.18166 110 Gietz 8300 1850 110 Higgins 12000 1850 Grant 7000 0 </code> ",
        "detail": "The Syntax is: \n <eps> STDDEV_POP(expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>STDDEV_POP</code> computes the population standard deviation and returns the square root of the population variance. You can use it as both an aggregate and analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion This function is the same as the square root of the <code>VAR_POP</code> function. When <code>VAR_POP</code> returns null, this function returns null. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>VAR_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions230.htm#i87119</link> <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> Aggregate Example The following example returns the population and sample standard deviations of the amount of sales in the sample table <code>sh.sales</code>: <code>SELECT STDDEV_POP(amount_sold) \"Pop\", STDDEV_SAMP(amount_sold) \"Samp\" FROM sales; Pop Samp ---------- ---------- 896.355151 896.355592 </code> Analytic Example The following example returns the population standard deviations of salaries in the sample <code>hr.employees</code> table by department: <code>SELECT department_id, last_name, salary, STDDEV_POP(salary) OVER (PARTITION BY department_id) AS pop_std FROM employees ORDER BY department_id, last_name, salary, pop_std; DEPARTMENT_ID LAST_NAME SALARY POP_STD ------------- ------------------------- ---------- ---------- 10 Whalen 4400 0 20 Fay 6000 3500 20 Hartstein 13000 3500 30 Baida 2900 3069.6091 . . . 100 Urman 7800 1644.18166 110 Gietz 8300 1850 110 Higgins 12000 1850 Grant 7000 0 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions179.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LISTAGG",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LISTAGG))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LISTAGG(measure_expr [, 'delimiter']) WITHIN GROUP (order_by_clause) [OVER query_partition_clause] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>ORDER</code> <code>BY</code> clause and <code>OVER</code> clause \n The Purpose is: \n For a specified measure, <code>LISTAGG</code> orders data within each group specified in the <code>ORDER</code> <code>BY</code> clause and then concatenates the values of the measure column. As a single-set aggregate function, <code>LISTAGG</code> operates on all rows and returns a single output row. As a group-set aggregate, the function operates on and returns an output row for each group defined by the <code>GROUP</code> <code>BY</code> clause. As an analytic function, <code>LISTAGG</code> partitions the query result set into groups based on one or more expression in the <code>query_partition_clause</code>. The arguments to the function are subject to the following rules: The <code>measure_expr</code> can be any expression. Null values in the measure column are ignored. The <code>delimiter_expr</code> designates the string that is to separate the measure values. This clause is optional and defaults to <code>NULL</code>. The <code>order_by_clause</code> determines the order in which the concatenated values are returned. The function is deterministic only if the <code>ORDER</code> <code>BY</code> column list achieved unique ordering. The return data type is <code>RAW</code> if the measure column is <code>RAW</code>; otherwise the return value is <code>VARCHAR2</code>. Aggregate \n The Examples is: \n The following single-set aggregate example lists all of the employees in Department 30 in the <code>hr.employees</code> table, ordered by hire date and last name: <code>SELECT LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date, last_name) \"Emp_list\", MIN(hire_date) \"Earliest\" FROM employees WHERE department_id = 30; Emp_list Earliest ------------------------------------------------------------ --------- Raphaely; Khoo; Tobias; Baida; Himuro; Colmenares 07-DEC-02 </code> The following group-set aggregate example lists, for each department ID in the <code>hr.employees</code> table, the employees in that department in order of their hire date: <code>SELECT department_id \"Dept.\", LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date) \"Employees\" FROM employees GROUP BY department_id ORDER BY department_id; Dept. Employees ------ ------------------------------------------------------------ 10 Whalen 20 Hartstein; Fay 30 Raphaely; Khoo; Tobias; Baida; Himuro; Colmenares 40 Mavris 50 Kaufling; Ladwig; Rajs; Sarchand; Bell; Mallin; Weiss; Davie s; Marlow; Bull; Everett; Fripp; Chung; Nayer; Dilly; Bissot ; Vollman; Stiles; Atkinson; Taylor; Seo; Fleaur; Matos; Pat el; Walsh; Feeney; Dellinger; McCain; Vargas; Gates; Rogers; Mikkilineni; Landry; Cabrio; Jones; Olson; OConnell; Sulliv an; Mourgos; Gee; Perkins; Grant; Geoni; Philtanker; Markle 60 Austin; Hunold; Pataballa; Lorentz; Ernst 70 Baer . . . </code> Analytic Example The following analytic example shows, for each employee hired earlier than September 1, 2003, the employee's department, hire date, and all other employees in that department also hired before September 1, 2003: <code>SELECT department_id \"Dept\", hire_date \"Date\", last_name \"Name\", LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date, last_name) OVER (PARTITION BY department_id) as \"Emp_list\" FROM employees WHERE hire_date < '01-SEP-2003' ORDER BY \"Dept\", \"Date\", \"Name\"; Dept Date Name Emp_list ----- --------- --------------- --------------------------------------------- 30 07-DEC-02 Raphaely Raphaely; Khoo 30 18-MAY-03 Khoo Raphaely; Khoo 40 07-JUN-02 Mavris Mavris 50 01-MAY-03 Kaufling Kaufling; Ladwig 50 14-JUL-03 Ladwig Kaufling; Ladwig 70 07-JUN-02 Baer Baer 90 13-JAN-01 De Haan De Haan; King 90 17-JUN-03 King De Haan; King 100 16-AUG-02 Faviet Faviet; Greenberg 100 17-AUG-02 Greenberg Faviet; Greenberg 110 07-JUN-02 Gietz Gietz; Higgins 110 07-JUN-02 Higgins Gietz; Higgins </code> ",
        "detail": "The Syntax is: \n <eps> LISTAGG(measure_expr [, 'delimiter']) WITHIN GROUP (order_by_clause) [OVER query_partition_clause] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>ORDER</code> <code>BY</code> clause and <code>OVER</code> clause \n The Purpose is: \n For a specified measure, <code>LISTAGG</code> orders data within each group specified in the <code>ORDER</code> <code>BY</code> clause and then concatenates the values of the measure column. As a single-set aggregate function, <code>LISTAGG</code> operates on all rows and returns a single output row. As a group-set aggregate, the function operates on and returns an output row for each group defined by the <code>GROUP</code> <code>BY</code> clause. As an analytic function, <code>LISTAGG</code> partitions the query result set into groups based on one or more expression in the <code>query_partition_clause</code>. The arguments to the function are subject to the following rules: The <code>measure_expr</code> can be any expression. Null values in the measure column are ignored. The <code>delimiter_expr</code> designates the string that is to separate the measure values. This clause is optional and defaults to <code>NULL</code>. The <code>order_by_clause</code> determines the order in which the concatenated values are returned. The function is deterministic only if the <code>ORDER</code> <code>BY</code> column list achieved unique ordering. The return data type is <code>RAW</code> if the measure column is <code>RAW</code>; otherwise the return value is <code>VARCHAR2</code>. Aggregate \n The Examples is: \n The following single-set aggregate example lists all of the employees in Department 30 in the <code>hr.employees</code> table, ordered by hire date and last name: <code>SELECT LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date, last_name) \"Emp_list\", MIN(hire_date) \"Earliest\" FROM employees WHERE department_id = 30; Emp_list Earliest ------------------------------------------------------------ --------- Raphaely; Khoo; Tobias; Baida; Himuro; Colmenares 07-DEC-02 </code> The following group-set aggregate example lists, for each department ID in the <code>hr.employees</code> table, the employees in that department in order of their hire date: <code>SELECT department_id \"Dept.\", LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date) \"Employees\" FROM employees GROUP BY department_id ORDER BY department_id; Dept. Employees ------ ------------------------------------------------------------ 10 Whalen 20 Hartstein; Fay 30 Raphaely; Khoo; Tobias; Baida; Himuro; Colmenares 40 Mavris 50 Kaufling; Ladwig; Rajs; Sarchand; Bell; Mallin; Weiss; Davie s; Marlow; Bull; Everett; Fripp; Chung; Nayer; Dilly; Bissot ; Vollman; Stiles; Atkinson; Taylor; Seo; Fleaur; Matos; Pat el; Walsh; Feeney; Dellinger; McCain; Vargas; Gates; Rogers; Mikkilineni; Landry; Cabrio; Jones; Olson; OConnell; Sulliv an; Mourgos; Gee; Perkins; Grant; Geoni; Philtanker; Markle 60 Austin; Hunold; Pataballa; Lorentz; Ernst 70 Baer . . . </code> Analytic Example The following analytic example shows, for each employee hired earlier than September 1, 2003, the employee's department, hire date, and all other employees in that department also hired before September 1, 2003: <code>SELECT department_id \"Dept\", hire_date \"Date\", last_name \"Name\", LISTAGG(last_name, '; ') WITHIN GROUP (ORDER BY hire_date, last_name) OVER (PARTITION BY department_id) as \"Emp_list\" FROM employees WHERE hire_date < '01-SEP-2003' ORDER BY \"Dept\", \"Date\", \"Name\"; Dept Date Name Emp_list ----- --------- --------------- --------------------------------------------- 30 07-DEC-02 Raphaely Raphaely; Khoo 30 18-MAY-03 Khoo Raphaely; Khoo 40 07-JUN-02 Mavris Mavris 50 01-MAY-03 Kaufling Kaufling; Ladwig 50 14-JUL-03 Ladwig Kaufling; Ladwig 70 07-JUN-02 Baer Baer 90 13-JAN-01 De Haan De Haan; King 90 17-JUN-03 King De Haan; King 100 16-AUG-02 Faviet Faviet; Greenberg 100 17-AUG-02 Greenberg Faviet; Greenberg 110 07-JUN-02 Gietz Gietz; Higgins 110 07-JUN-02 Higgins Gietz; Higgins </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions089.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CLUSTER_PROBABILITY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CLUSTER_PROBABILITY))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CLUSTER_PROBABILITY ( [ schema . ] model [ , cluster_id ] mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with clustering models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns a measure of the degree of confidence of membership of an input row in a cluster associated with the specified model. For <code>cluster_id</code>, specify the identifier of the cluster in the model. The function returns the probability for the specified cluster. If you omit this clause, then the function returns the probability associated with the best predicted cluster. You can use the form without <code>cluster_id</code> in conjunction with the <code>CLUSTER_ID</code> function to obtain the best predicted pair of cluster ID and probability. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link> See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example determines the ten most representative customers, based on likelihood, in cluster 2. This example, and the prerequisite data mining operations, including the creation of the <code>km_sh_clus_sample</code> model and the <code>mining_data_apply_v</code> view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmkmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT * FROM (SELECT cust_id, CLUSTER_PROBABILITY(km_sh_clus_sample, 2 USING *) prob FROM mining_data_apply_v ORDER BY prob DESC) WHERE ROWNUM < 11; CUST_ID PROB ---------- ---------- 100256 .999387471 100988 .99936194 100889 .999335107 101086 .99928882 101215 .999266521 100390 .999264718 100985 .999251722 101026 .999247906 100601 .999242089 100672 .999235711 10 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> CLUSTER_PROBABILITY ( [ schema . ] model [ , cluster_id ] mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with clustering models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns a measure of the degree of confidence of membership of an input row in a cluster associated with the specified model. For <code>cluster_id</code>, specify the identifier of the cluster in the model. The function returns the probability for the specified cluster. If you omit this clause, then the function returns the probability associated with the best predicted cluster. You can use the form without <code>cluster_id</code> in conjunction with the <code>CLUSTER_ID</code> function to obtain the best predicted pair of cluster ID and probability. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link> See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example determines the ten most representative customers, based on likelihood, in cluster 2. This example, and the prerequisite data mining operations, including the creation of the <code>km_sh_clus_sample</code> model and the <code>mining_data_apply_v</code> view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmkmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT * FROM (SELECT cust_id, CLUSTER_PROBABILITY(km_sh_clus_sample, 2 USING *) prob FROM mining_data_apply_v ORDER BY prob DESC) WHERE ROWNUM < 11; CUST_ID PROB ---------- ---------- 100256 .999387471 100988 .99936194 100889 .999335107 101086 .99928882 101215 .999266521 100390 .999264718 100985 .999251722 101026 .999247906 100601 .999242089 100672 .999235711 10 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions028.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "GROUP_ID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c GROUP_ID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> GROUP_ID( ) </eps> \n The Purpose is: \n <code>GROUP_ID</code> distinguishes duplicate groups resulting from a <code>GROUP</code> <code>BY</code> specification. It is useful in filtering out duplicate groupings from the query result. It returns an Oracle <code>NUMBER</code> to uniquely identify duplicate groups. This function is applicable only in a <code>SELECT</code> statement that contains a <code>GROUP</code> <code>BY</code> clause. If <code>n</code> duplicates exist for a particular grouping, then <code>GROUP_ID</code> returns numbers in the range 0 to <code>n</code>-1. \n The Examples is: \n The following example assigns the value <code>1</code> to the duplicate <code>co.country_region</code> grouping from a query on the sample tables <code>sh.countries</code> and <code>sh.sales</code>: <code>SELECT co.country_region, co.country_subregion, SUM(s.amount_sold) \"Revenue\", GROUP_ID() g FROM sales s, customers c, countries co WHERE s.cust_id = c.cust_id AND c.country_id = co.country_id AND s.time_id = '1-JAN-00' AND co.country_region IN ('Americas', 'Europe') GROUP BY GROUPING SETS ( (co.country_region, co.country_subregion), (co.country_region, co.country_subregion) ) ORDER BY co.country_region, co.country_subregion, \"Revenue\", g; COUNTRY_REGION COUNTRY_SUBREGION Revenue G -------------------- ------------------------------ ---------- ---------- Americas Northern America 944.6 0 Americas Northern America 944.6 1 Europe Western Europe 566.39 0 Europe Western Europe 566.39 1 </code> To ensure that only rows with <code>GROUP_ID</code> < 1 are returned, add the following <code>HAVING</code> clause to the end of the statement : <code>HAVING GROUP_ID() < 1 </code> ",
        "detail": "The Syntax is: \n <eps> GROUP_ID( ) </eps> \n The Purpose is: \n <code>GROUP_ID</code> distinguishes duplicate groups resulting from a <code>GROUP</code> <code>BY</code> specification. It is useful in filtering out duplicate groupings from the query result. It returns an Oracle <code>NUMBER</code> to uniquely identify duplicate groups. This function is applicable only in a <code>SELECT</code> statement that contains a <code>GROUP</code> <code>BY</code> clause. If <code>n</code> duplicates exist for a particular grouping, then <code>GROUP_ID</code> returns numbers in the range 0 to <code>n</code>-1. \n The Examples is: \n The following example assigns the value <code>1</code> to the duplicate <code>co.country_region</code> grouping from a query on the sample tables <code>sh.countries</code> and <code>sh.sales</code>: <code>SELECT co.country_region, co.country_subregion, SUM(s.amount_sold) \"Revenue\", GROUP_ID() g FROM sales s, customers c, countries co WHERE s.cust_id = c.cust_id AND c.country_id = co.country_id AND s.time_id = '1-JAN-00' AND co.country_region IN ('Americas', 'Europe') GROUP BY GROUPING SETS ( (co.country_region, co.country_subregion), (co.country_region, co.country_subregion) ) ORDER BY co.country_region, co.country_subregion, \"Revenue\", g; COUNTRY_REGION COUNTRY_SUBREGION Revenue G -------------------- ------------------------------ ---------- ---------- Americas Northern America 944.6 0 Americas Northern America 944.6 1 Europe Western Europe 566.39 0 Europe Western Europe 566.39 1 </code> To ensure that only rows with <code>GROUP_ID</code> < 1 are returned, add the following <code>HAVING</code> clause to the end of the statement : <code>HAVING GROUP_ID() < 1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions070.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_NUMBER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_NUMBER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_NUMBER(expr [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_NUMBER</code> converts <code>expr</code> to a value of <code>NUMBER</code> data type. The <code>expr</code> can be a number value of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code> data type. If you specify an <code>expr</code> of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type, then you can optionally specify the format model <code>fmt</code>. If you specify an <code>expr</code> of <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code> data type, then you cannot specify a format model because a <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code> can be interpreted only by its internal representation. Refer to <link>\"Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34510</link> for information on format models. The <code>'</code><code>nlsparam</code><code>'</code> argument in this function has the same purpose as it does in the <code>TO_CHAR</code> function for number conversions. Refer to <link>TO_CHAR (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm#i79330</link> for more information. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following examples convert character string data into a number: <code>UPDATE employees SET salary = salary + TO_NUMBER('100.00', '9G999D99') WHERE last_name = 'Perkins'; </code> <code>SELECT TO_NUMBER('-AusDollars100','L9G999D99', ' NLS_NUMERIC_CHARACTERS = '',.'' NLS_CURRENCY = ''AusDollars'' ') \"Amount\" FROM DUAL; Amount ---------- -100 </code> ",
        "detail": "The Syntax is: \n <eps> TO_NUMBER(expr [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_NUMBER</code> converts <code>expr</code> to a value of <code>NUMBER</code> data type. The <code>expr</code> can be a number value of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code> data type. If you specify an <code>expr</code> of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type, then you can optionally specify the format model <code>fmt</code>. If you specify an <code>expr</code> of <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code> data type, then you cannot specify a format model because a <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code> can be interpreted only by its internal representation. Refer to <link>\"Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34510</link> for information on format models. The <code>'</code><code>nlsparam</code><code>'</code> argument in this function has the same purpose as it does in the <code>TO_CHAR</code> function for number conversions. Refer to <link>TO_CHAR (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm#i79330</link> for more information. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following examples convert character string data into a number: <code>UPDATE employees SET salary = salary + TO_NUMBER('100.00', '9G999D99') WHERE last_name = 'Perkins'; </code> <code>SELECT TO_NUMBER('-AusDollars100','L9G999D99', ' NLS_NUMERIC_CHARACTERS = '',.'' NLS_CURRENCY = ''AusDollars'' ') \"Amount\" FROM DUAL; Amount ---------- -100 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions211.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "REGEXP_SUBSTR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGEXP_SUBSTR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> REGEXP_SUBSTR(source_char, pattern [, position [, occurrence [, match_param [, subexpr ] ] ] ] ) </eps> \n The Purpose is: \n <code>REGEXP_SUBSTR</code> extends the functionality of the <code>SUBSTR</code> function by letting you search a string for a regular expression pattern. It is also similar to <code>REGEXP_INSTR</code>, but instead of returning the position of the substring, it returns the substring itself. This function is useful if you need the contents of a match string but not its position in the source string. The function returns the string as <code>VARCHAR2</code> or <code>CLOB</code> data in the same character set as <code>source_char</code>. This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>source_char</code> is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. <code>pattern</code> is the regular expression. It is usually a text literal and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. It can contain up to 512 bytes. If the data type of <code>pattern</code> is different from the data type of <code>source_char</code>, then Oracle Database converts <code>pattern</code> to the data type of <code>source_char</code>. For a listing of the operators you can specify in <code>pattern</code>, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>position</code> is a positive integer indicating the character of <code>source_char</code> where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of <code>source_char</code>. <code>occurrence</code> is a positive integer indicating which occurrence of <code>pattern</code> in <code>source_char</code> Oracle should search for. The default is 1, meaning that Oracle searches for the first occurrence of <code>pattern</code>. If <code>occurrence</code> is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of <code>pattern</code>, and so forth. This behavior is different from the <code>SUBSTR</code> function, which begins its search for the second occurrence at the second character of the first occurrence. <code>match_parameter</code> is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for <code>REGEXP_COUNT</code>. Refer to <link>REGEXP_COUNT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions147.htm#CIHDAIHJ</link> for detailed information. For a <code>pattern</code> with subexpressions, <code>subexpr</code> is a nonnegative integer from 0 to 9 indicating which subexpression in <code>pattern</code> is to be returned by the function. This parameter has the same semantics that it has for the <code>REGEXP_INSTR</code> function. Refer to <link>REGEXP_INSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions148.htm#i1239887</link> for more information. See Also: <link>SUBSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions181.htm#i87066</link> and <link>REGEXP_INSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions148.htm#i1239887</link> <link>REGEXP_REPLACE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions149.htm#i1305521</link>, and <link>REGEXP_LIKE Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions007.htm#i1048942</link> \n The Examples is: \n The following example examines the string, looking for the first substring bounded by commas. Oracle Database searches for a comma followed by one or more occurrences of non-comma characters followed by a comma. Oracle returns the substring, including the leading and trailing commas. <code>SELECT REGEXP_SUBSTR('500 Oracle Parkway, Redwood Shores, CA', ',[^,]+,') \"REGEXPR_SUBSTR\" FROM DUAL; REGEXPR_SUBSTR ----------------- , Redwood Shores, </code> The following example examines the string, looking for <code>http://</code> followed by a substring of one or more alphanumeric characters and optionally, a period (<code>.</code>). Oracle searches for a minimum of three and a maximum of four occurrences of this substring between <code>http://</code> and either a slash (<code>/</code>) or the end of the string. <code>SELECT REGEXP_SUBSTR('http://www.example.com/products', 'http://([[:alnum:]]+\\.?){3,4}/?') \"REGEXP_SUBSTR\" FROM DUAL; REGEXP_SUBSTR ---------------------- http://www.example.com/ </code> The next two examples use the <code>subexpr</code> argument to return a specific subexpression of <code>pattern</code>. The first statement returns the first subexpression in <code>pattern</code>: <code>SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 1) \"REGEXP_SUBSTR\" FROM DUAL; REGEXP_SUBSTR ------------------- 123 </code> The next statement returns the fourth subexpression in <code>pattern</code>: <code>SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 4) \"REGEXP_SUBSTR\" FROM DUAL; REGEXP_SUBSTR ------------------- 78 </code> ",
        "detail": "The Syntax is: \n <eps> REGEXP_SUBSTR(source_char, pattern [, position [, occurrence [, match_param [, subexpr ] ] ] ] ) </eps> \n The Purpose is: \n <code>REGEXP_SUBSTR</code> extends the functionality of the <code>SUBSTR</code> function by letting you search a string for a regular expression pattern. It is also similar to <code>REGEXP_INSTR</code>, but instead of returning the position of the substring, it returns the substring itself. This function is useful if you need the contents of a match string but not its position in the source string. The function returns the string as <code>VARCHAR2</code> or <code>CLOB</code> data in the same character set as <code>source_char</code>. This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>source_char</code> is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. <code>pattern</code> is the regular expression. It is usually a text literal and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. It can contain up to 512 bytes. If the data type of <code>pattern</code> is different from the data type of <code>source_char</code>, then Oracle Database converts <code>pattern</code> to the data type of <code>source_char</code>. For a listing of the operators you can specify in <code>pattern</code>, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>position</code> is a positive integer indicating the character of <code>source_char</code> where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of <code>source_char</code>. <code>occurrence</code> is a positive integer indicating which occurrence of <code>pattern</code> in <code>source_char</code> Oracle should search for. The default is 1, meaning that Oracle searches for the first occurrence of <code>pattern</code>. If <code>occurrence</code> is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of <code>pattern</code>, and so forth. This behavior is different from the <code>SUBSTR</code> function, which begins its search for the second occurrence at the second character of the first occurrence. <code>match_parameter</code> is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for <code>REGEXP_COUNT</code>. Refer to <link>REGEXP_COUNT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions147.htm#CIHDAIHJ</link> for detailed information. For a <code>pattern</code> with subexpressions, <code>subexpr</code> is a nonnegative integer from 0 to 9 indicating which subexpression in <code>pattern</code> is to be returned by the function. This parameter has the same semantics that it has for the <code>REGEXP_INSTR</code> function. Refer to <link>REGEXP_INSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions148.htm#i1239887</link> for more information. See Also: <link>SUBSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions181.htm#i87066</link> and <link>REGEXP_INSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions148.htm#i1239887</link> <link>REGEXP_REPLACE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions149.htm#i1305521</link>, and <link>REGEXP_LIKE Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions007.htm#i1048942</link> \n The Examples is: \n The following example examines the string, looking for the first substring bounded by commas. Oracle Database searches for a comma followed by one or more occurrences of non-comma characters followed by a comma. Oracle returns the substring, including the leading and trailing commas. <code>SELECT REGEXP_SUBSTR('500 Oracle Parkway, Redwood Shores, CA', ',[^,]+,') \"REGEXPR_SUBSTR\" FROM DUAL; REGEXPR_SUBSTR ----------------- , Redwood Shores, </code> The following example examines the string, looking for <code>http://</code> followed by a substring of one or more alphanumeric characters and optionally, a period (<code>.</code>). Oracle searches for a minimum of three and a maximum of four occurrences of this substring between <code>http://</code> and either a slash (<code>/</code>) or the end of the string. <code>SELECT REGEXP_SUBSTR('http://www.example.com/products', 'http://([[:alnum:]]+\\.?){3,4}/?') \"REGEXP_SUBSTR\" FROM DUAL; REGEXP_SUBSTR ---------------------- http://www.example.com/ </code> The next two examples use the <code>subexpr</code> argument to return a specific subexpression of <code>pattern</code>. The first statement returns the first subexpression in <code>pattern</code>: <code>SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 1) \"REGEXP_SUBSTR\" FROM DUAL; REGEXP_SUBSTR ------------------- 123 </code> The next statement returns the fourth subexpression in <code>pattern</code>: <code>SELECT REGEXP_SUBSTR('1234567890', '(123)(4(56)(78))', 1, 1, 'i', 4) \"REGEXP_SUBSTR\" FROM DUAL; REGEXP_SUBSTR ------------------- 78 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions150.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLEXISTS",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLEXISTS))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLEXISTS ( XQuery_string [ XML_passing_clause ] ) </eps> XML_passing_clause::= <eps> PASSING [ BY VALUE ] expr [ AS identifier ] [, expr [ AS identifier ] ]... </eps> \n The Purpose is: \n <code>XMLExists</code> checks whether a given XQuery expression returns a nonempty XQuery sequence. If so, the function returns <code>TRUE</code>; otherwise, it returns <code>FALSE</code>. The argument <code>XQuery_string</code> is a literal string, but it can contain XQuery variables that you bind using the <code>XML_passing_clause</code>. The <code>expr</code> in the <code>XML_passing_clause</code> is an expression returning an <code>XMLType</code> or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one <code>expr</code> in the <code>PASSING</code> clause without an identifier. The result of evaluating each <code>expr</code> is bound to the corresponding identifier in the <code>XQuery_string</code>. If any <code>expr</code> that is not followed by an <code>AS</code> clause, then the result of evaluating that expression is used as the context item for evaluating the <code>XQuery_string</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0400</link> for more information on uses for this function and examples ",
        "detail": "The Syntax is: \n <eps> XMLEXISTS ( XQuery_string [ XML_passing_clause ] ) </eps> XML_passing_clause::= <eps> PASSING [ BY VALUE ] expr [ AS identifier ] [, expr [ AS identifier ] ]... </eps> \n The Purpose is: \n <code>XMLExists</code> checks whether a given XQuery expression returns a nonempty XQuery sequence. If so, the function returns <code>TRUE</code>; otherwise, it returns <code>FALSE</code>. The argument <code>XQuery_string</code> is a literal string, but it can contain XQuery variables that you bind using the <code>XML_passing_clause</code>. The <code>expr</code> in the <code>XML_passing_clause</code> is an expression returning an <code>XMLType</code> or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one <code>expr</code> in the <code>PASSING</code> clause without an identifier. The result of evaluating each <code>expr</code> is bound to the corresponding identifier in the <code>XQuery_string</code>. If any <code>expr</code> that is not followed by an <code>AS</code> clause, then the result of evaluating that expression is used as the context item for evaluating the <code>XQuery_string</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0400</link> for more information on uses for this function and examples ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions243.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_KS_TEST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_KS_TEST))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STATS_KS_TEST(expr1, expr2 [, { STATISTIC | SIG } ] ) </eps> \n The Purpose is: \n <code>STATS_KS_TEST</code> is a Kolmogorov-Smirnov function that compares two samples to test whether they are from the same population or from populations that have the same distribution. It does not assume that the population from which the samples were taken is normally distributed. This function takes three arguments: two expressions and a return value of type <code>VARCHAR2</code>. <code>expr1</code> classifies the data into the two samples. <code>expr2</code> contains the values for each of the samples. If <code>expr1</code> classifies the rows into only one sample or into more than two samples, then an error is raised.The function returns one value determined by the third argument. If you omit the third argument, then the default is <code>SIG</code>. The meaning of the return values is shown in <link>Table 5-6&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions172.htm#g1514257</link>. Table 5-6 STATS_KS_TEST Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> STATISTIC </td> <td> Observed value of D </td> </tr> <tr> <td> SIG </td> <td> Significance of D </td> </tr> </tbody> </table> STATS_KS_TEST Example Using the Kolmogorov Smirnov test, the following example determines whether the distribution of sales between men and women is due to chance: <code>SELECT stats_ks_test(cust_gender, amount_sold, 'STATISTIC') ks_statistic, stats_ks_test(cust_gender, amount_sold) p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id; KS_STATISTIC P_VALUE ------------ ---------- .003841396 .004080006 </code> ",
        "detail": "The Syntax is: \n <eps> STATS_KS_TEST(expr1, expr2 [, { STATISTIC | SIG } ] ) </eps> \n The Purpose is: \n <code>STATS_KS_TEST</code> is a Kolmogorov-Smirnov function that compares two samples to test whether they are from the same population or from populations that have the same distribution. It does not assume that the population from which the samples were taken is normally distributed. This function takes three arguments: two expressions and a return value of type <code>VARCHAR2</code>. <code>expr1</code> classifies the data into the two samples. <code>expr2</code> contains the values for each of the samples. If <code>expr1</code> classifies the rows into only one sample or into more than two samples, then an error is raised.The function returns one value determined by the third argument. If you omit the third argument, then the default is <code>SIG</code>. The meaning of the return values is shown in <link>Table 5-6&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions172.htm#g1514257</link>. Table 5-6 STATS_KS_TEST Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> STATISTIC </td> <td> Observed value of D </td> </tr> <tr> <td> SIG </td> <td> Significance of D </td> </tr> </tbody> </table> STATS_KS_TEST Example Using the Kolmogorov Smirnov test, the following example determines whether the distribution of sales between men and women is due to chance: <code>SELECT stats_ks_test(cust_gender, amount_sold, 'STATISTIC') ks_statistic, stats_ks_test(cust_gender, amount_sold) p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id; KS_STATISTIC P_VALUE ------------ ---------- .003841396 .004080006 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions172.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CURRENT_TIMESTAMP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CURRENT_TIMESTAMP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CURRENT_TIMESTAMP [ (precision) ] </eps> \n The Purpose is: \n <code>CURRENT_TIMESTAMP</code> returns the current date and time in the session time zone, in a value of data type <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>. The time zone offset reflects the current local time of the SQL session. If you omit precision, then the default is 6. The difference between this function and <code>LOCALTIMESTAMP</code> is that <code>CURRENT_TIMESTAMP</code> returns a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value while <code>LOCALTIMESTAMP</code> returns a <code>TIMESTAMP</code> value. In the optional argument, <code>precision</code> specifies the fractional second precision of the time value returned. See Also: <link>LOCALTIMESTAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions092.htm#i999873</link> \n The Examples is: \n The following example illustrates that <code>CURRENT_TIMESTAMP</code> is sensitive to the session time zone: <code>ALTER SESSION SET TIME_ZONE = '-5:0'; ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS'; SELECT SESSIONTIMEZONE, CURRENT_TIMESTAMP FROM DUAL; SESSIONTIMEZONE CURRENT_TIMESTAMP --------------- --------------------------------------------------- -05:00 04-APR-00 01.17.56.917550 PM -05:00 ALTER SESSION SET TIME_ZONE = '-8:0'; SELECT SESSIONTIMEZONE, CURRENT_TIMESTAMP FROM DUAL; SESSIONTIMEZONE CURRENT_TIMESTAMP --------------- ---------------------------------------------------- -08:00 04-APR-00 10.18.21.366065 AM -08:00 </code> When you use the <code>CURRENT_TIMESTAMP</code> with a format mask, take care that the format mask matches the value returned by the function. For example, consider the following table: <code>CREATE TABLE current_test (col1 TIMESTAMP WITH TIME ZONE); </code> The following statement fails because the mask does not include the <code>TIME</code> <code>ZONE</code> portion of the type returned by the function: <code>INSERT INTO current_test VALUES (TO_TIMESTAMP_TZ(CURRENT_TIMESTAMP, 'DD-MON-RR HH.MI.SSXFF PM')); </code> The following statement uses the correct format mask to match the return type of <code>CURRENT_TIMESTAMP</code>: <code>INSERT INTO current_test VALUES (TO_TIMESTAMP_TZ(CURRENT_TIMESTAMP, 'DD-MON-RR HH.MI.SSXFF PM TZH:TZM')); </code> ",
        "detail": "The Syntax is: \n <eps> CURRENT_TIMESTAMP [ (precision) ] </eps> \n The Purpose is: \n <code>CURRENT_TIMESTAMP</code> returns the current date and time in the session time zone, in a value of data type <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>. The time zone offset reflects the current local time of the SQL session. If you omit precision, then the default is 6. The difference between this function and <code>LOCALTIMESTAMP</code> is that <code>CURRENT_TIMESTAMP</code> returns a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value while <code>LOCALTIMESTAMP</code> returns a <code>TIMESTAMP</code> value. In the optional argument, <code>precision</code> specifies the fractional second precision of the time value returned. See Also: <link>LOCALTIMESTAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions092.htm#i999873</link> \n The Examples is: \n The following example illustrates that <code>CURRENT_TIMESTAMP</code> is sensitive to the session time zone: <code>ALTER SESSION SET TIME_ZONE = '-5:0'; ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS'; SELECT SESSIONTIMEZONE, CURRENT_TIMESTAMP FROM DUAL; SESSIONTIMEZONE CURRENT_TIMESTAMP --------------- --------------------------------------------------- -05:00 04-APR-00 01.17.56.917550 PM -05:00 ALTER SESSION SET TIME_ZONE = '-8:0'; SELECT SESSIONTIMEZONE, CURRENT_TIMESTAMP FROM DUAL; SESSIONTIMEZONE CURRENT_TIMESTAMP --------------- ---------------------------------------------------- -08:00 04-APR-00 10.18.21.366065 AM -08:00 </code> When you use the <code>CURRENT_TIMESTAMP</code> with a format mask, take care that the format mask matches the value returned by the function. For example, consider the following table: <code>CREATE TABLE current_test (col1 TIMESTAMP WITH TIME ZONE); </code> The following statement fails because the mask does not include the <code>TIME</code> <code>ZONE</code> portion of the type returned by the function: <code>INSERT INTO current_test VALUES (TO_TIMESTAMP_TZ(CURRENT_TIMESTAMP, 'DD-MON-RR HH.MI.SSXFF PM')); </code> The following statement uses the correct format mask to match the return type of <code>CURRENT_TIMESTAMP</code>: <code>INSERT INTO current_test VALUES (TO_TIMESTAMP_TZ(CURRENT_TIMESTAMP, 'DD-MON-RR HH.MI.SSXFF PM TZH:TZM')); </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions045.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_MW_TEST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_MW_TEST))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STATS_MW_TEST(expr1, expr2 [, { STATISTIC | U_STATISTIC | ONE_SIDED_SIG , expr3 | TWO_SIDED_SIG } ] ) </eps> \n The Purpose is: \n A Mann Whitney test compares two independent samples to test the null hypothesis that two populations have the same distribution function against the alternative hypothesis that the two distribution functions are different. The <code>STATS_MW_TEST</code> does not assume that the differences between the samples are normally distributed, as do the <code>STATS_T_TEST_</code>* functions. This function takes three arguments and a return value of type <code>VARCHAR2</code>. <code>expr1</code> classifies the data into groups. <code>expr2</code> contains the values for each of the groups. The function returns one value, determined by the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in the table that follows. The significance of the observed value of Z or U is the probability that the variances are different just by chance\u2014a number between 0 and 1. A small value for the significance indicates that the variances are significantly different. The degree of freedom for each of the variances is the number of observations in the sample minus 1. Table 5-7 STATS_MW_TEST Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> STATISTIC </td> <td> The observed value of Z </td> </tr> <tr> <td> U_STATISTIC </td> <td> The observed value of U </td> </tr> <tr> <td> ONE_SIDED_SIG </td> <td> One-tailed significance of Z </td> </tr> <tr> <td> TWO_SIDED_SIG </td> <td> Two-tailed significance of Z </td> </tr> </tbody> </table> The one-tailed significance is always in relation to the upper tail. The final argument, <code>expr3</code>, indicates which of the two groups specified by expr1 is the high value (the value whose rejection region is the upper tail). <code>STATS_MW_TEST</code> computes the probability that the samples are from the same distribution by checking the differences in the sums of the ranks of the values. If the samples come from the same distribution, then the sums should be close in value. STATS_MW_TEST Example Using the Mann Whitney test, the following example determines whether the distribution of sales between men and women is due to chance: <code>SELECT STATS_MW_TEST (cust_gender, amount_sold, 'STATISTIC') z_statistic, STATS_MW_TEST (cust_gender, amount_sold, 'ONE_SIDED_SIG', 'F') one_sided_p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id; Z_STATISTIC ONE_SIDED_P_VALUE ----------- ----------------- -1.4011509 .080584471 </code> ",
        "detail": "The Syntax is: \n <eps> STATS_MW_TEST(expr1, expr2 [, { STATISTIC | U_STATISTIC | ONE_SIDED_SIG , expr3 | TWO_SIDED_SIG } ] ) </eps> \n The Purpose is: \n A Mann Whitney test compares two independent samples to test the null hypothesis that two populations have the same distribution function against the alternative hypothesis that the two distribution functions are different. The <code>STATS_MW_TEST</code> does not assume that the differences between the samples are normally distributed, as do the <code>STATS_T_TEST_</code>* functions. This function takes three arguments and a return value of type <code>VARCHAR2</code>. <code>expr1</code> classifies the data into groups. <code>expr2</code> contains the values for each of the groups. The function returns one value, determined by the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in the table that follows. The significance of the observed value of Z or U is the probability that the variances are different just by chance\u2014a number between 0 and 1. A small value for the significance indicates that the variances are significantly different. The degree of freedom for each of the variances is the number of observations in the sample minus 1. Table 5-7 STATS_MW_TEST Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> STATISTIC </td> <td> The observed value of Z </td> </tr> <tr> <td> U_STATISTIC </td> <td> The observed value of U </td> </tr> <tr> <td> ONE_SIDED_SIG </td> <td> One-tailed significance of Z </td> </tr> <tr> <td> TWO_SIDED_SIG </td> <td> Two-tailed significance of Z </td> </tr> </tbody> </table> The one-tailed significance is always in relation to the upper tail. The final argument, <code>expr3</code>, indicates which of the two groups specified by expr1 is the high value (the value whose rejection region is the upper tail). <code>STATS_MW_TEST</code> computes the probability that the samples are from the same distribution by checking the differences in the sums of the ranks of the values. If the samples come from the same distribution, then the sums should be close in value. STATS_MW_TEST Example Using the Mann Whitney test, the following example determines whether the distribution of sales between men and women is due to chance: <code>SELECT STATS_MW_TEST (cust_gender, amount_sold, 'STATISTIC') z_statistic, STATS_MW_TEST (cust_gender, amount_sold, 'ONE_SIDED_SIG', 'F') one_sided_p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id; Z_STATISTIC ONE_SIDED_P_VALUE ----------- ----------------- -1.4011509 .080584471 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions174.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LOWER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LOWER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LOWER(char) </eps> \n The Purpose is: \n <code>LOWER</code> returns <code>char</code>, with all letters lowercase. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The return value is the same data type as <code>char</code>. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive lowercase, refer to <link>NLS_LOWER&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions111.htm#i78373</link>. \n The Examples is: \n The following example returns a string in lowercase: <code>SELECT LOWER('MR. SCOTT MCMILLAN') \"Lowercase\" FROM DUAL; Lowercase -------------------- mr. scott mcmillan </code> ",
        "detail": "The Syntax is: \n <eps> LOWER(char) </eps> \n The Purpose is: \n <code>LOWER</code> returns <code>char</code>, with all letters lowercase. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The return value is the same data type as <code>char</code>. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive lowercase, refer to <link>NLS_LOWER&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions111.htm#i78373</link>. \n The Examples is: \n The following example returns a string in lowercase: <code>SELECT LOWER('MR. SCOTT MCMILLAN') \"Lowercase\" FROM DUAL; Lowercase -------------------- mr. scott mcmillan </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions094.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CARDINALITY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CARDINALITY))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CARDINALITY(nested_table) </eps> \n The Purpose is: \n <code>CARDINALITY</code> returns the number of elements in a nested table. The return type is <code>NUMBER</code>. If the nested table is empty, or is a null collection, then <code>CARDINALITY</code> returns <code>NULL</code>. \n The Examples is: \n The following example shows the number of elements in the nested table column <code>ad_textdocs_ntab</code> of the sample table <code>pm.print_media</code>: <code>SELECT product_id, CARDINALITY(ad_textdocs_ntab) cardinality FROM print_media ORDER BY product_id; PRODUCT_ID CARDINALITY ---------- ----------- 2056 3 2268 3 3060 3 3106 3 </code> ",
        "detail": "The Syntax is: \n <eps> CARDINALITY(nested_table) </eps> \n The Purpose is: \n <code>CARDINALITY</code> returns the number of elements in a nested table. The return type is <code>NUMBER</code>. If the nested table is empty, or is a null collection, then <code>CARDINALITY</code> returns <code>NULL</code>. \n The Examples is: \n The following example shows the number of elements in the nested table column <code>ad_textdocs_ntab</code> of the sample table <code>pm.print_media</code>: <code>SELECT product_id, CARDINALITY(ad_textdocs_ntab) cardinality FROM print_media ORDER BY product_id; PRODUCT_ID CARDINALITY ---------- ----------- 2056 3 2268 3 3060 3 3106 3 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions022.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_NCLOB",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_NCLOB))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_NCLOB(lob_column | char) </eps> \n The Purpose is: \n <code>TO_NCLOB</code> converts <code>CLOB</code> values in a LOB column or other character strings to <code>NCLOB</code> values. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. Oracle Database implements this function by converting the character set of <code>char</code> from the database character set to the national character set. \n The Examples is: \n The following example inserts some character data into an <code>NCLOB</code> column of the <code>pm.print_media</code> table by first converting the data with the <code>TO_NCLOB</code> function: <code>INSERT INTO print_media (product_id, ad_id, ad_fltextn) VALUES (3502, 31001, TO_NCLOB('Placeholder for new product description')); </code> ",
        "detail": "The Syntax is: \n <eps> TO_NCLOB(lob_column | char) </eps> \n The Purpose is: \n <code>TO_NCLOB</code> converts <code>CLOB</code> values in a LOB column or other character strings to <code>NCLOB</code> values. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. Oracle Database implements this function by converting the character set of <code>char</code> from the database character set to the national character set. \n The Examples is: \n The following example inserts some character data into an <code>NCLOB</code> column of the <code>pm.print_media</code> table by first converting the data with the <code>TO_NCLOB</code> function: <code>INSERT INTO print_media (product_id, ad_id, ad_fltextn) VALUES (3502, 31001, TO_NCLOB('Placeholder for new product description')); </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions210.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SUBSTR",
        "tree": "(string_function SUBSTR ( ))",
        "description": "The Syntax is: \n substr::= <eps> { SUBSTR | SUBSTRB | SUBSTRC | SUBSTR2 | SUBSTR4 } (char, position [, substring_length ]) </eps> \n The Purpose is: \n The <code>SUBSTR</code> functions return a portion of <code>char</code>, beginning at character <code>position</code>, <code>substring_length</code> characters long. <code>SUBSTR</code> calculates lengths using characters as defined by the input character set. <code>SUBSTRB</code> uses bytes instead of characters. <code>SUBSTRC</code> uses Unicode complete characters. <code>SUBSTR2</code> uses UCS2 code points. <code>SUBSTR4</code> uses UCS4 code points. If <code>position</code> is 0, then it is treated as 1. If <code>position</code> is positive, then Oracle Database counts from the beginning of <code>char</code> to find the first character. If <code>position</code> is negative, then Oracle counts backward from the end of <code>char</code>. If <code>substring_length</code> is omitted, then Oracle returns all characters to the end of <code>char</code>. If <code>substring_length</code> is less than 1, then Oracle returns null. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The exceptions are <code>SUBSTRC</code>, <code>SUBSTR2</code>, and <code>SUBSTR4</code>, which do not allow <code>char</code> to be a <code>CLOB</code> or <code>NCLOB</code>. Both <code>position</code> and <code>substring_length</code> must be of data type <code>NUMBER</code>, or any data type that can be implicitly converted to <code>NUMBER</code>, and must resolve to an integer. The return value is the same data type as <code>char</code>. Floating-point numbers passed as arguments to <code>SUBSTR</code> are automatically converted to integers. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch7progrunicode.htm#NLSPG007</link> for more information about <code>SUBSTR</code> functions and length semantics in different locales \n The Examples is: \n The following example returns several specified substrings of \"ABCDEFG\": <code>SELECT SUBSTR('ABCDEFG',3,4) \"Substring\" FROM DUAL; Substring --------- CDEF SELECT SUBSTR('ABCDEFG',-5,4) \"Substring\" FROM DUAL; Substring --------- CDEF </code> Assume a double-byte database character set: <code>SELECT SUBSTRB('ABCDEFG',5,4.2) \"Substring with bytes\" FROM DUAL; Substring with bytes -------------------- CD </code> ",
        "detail": "The Syntax is: \n substr::= <eps> { SUBSTR | SUBSTRB | SUBSTRC | SUBSTR2 | SUBSTR4 } (char, position [, substring_length ]) </eps> \n The Purpose is: \n The <code>SUBSTR</code> functions return a portion of <code>char</code>, beginning at character <code>position</code>, <code>substring_length</code> characters long. <code>SUBSTR</code> calculates lengths using characters as defined by the input character set. <code>SUBSTRB</code> uses bytes instead of characters. <code>SUBSTRC</code> uses Unicode complete characters. <code>SUBSTR2</code> uses UCS2 code points. <code>SUBSTR4</code> uses UCS4 code points. If <code>position</code> is 0, then it is treated as 1. If <code>position</code> is positive, then Oracle Database counts from the beginning of <code>char</code> to find the first character. If <code>position</code> is negative, then Oracle counts backward from the end of <code>char</code>. If <code>substring_length</code> is omitted, then Oracle returns all characters to the end of <code>char</code>. If <code>substring_length</code> is less than 1, then Oracle returns null. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The exceptions are <code>SUBSTRC</code>, <code>SUBSTR2</code>, and <code>SUBSTR4</code>, which do not allow <code>char</code> to be a <code>CLOB</code> or <code>NCLOB</code>. Both <code>position</code> and <code>substring_length</code> must be of data type <code>NUMBER</code>, or any data type that can be implicitly converted to <code>NUMBER</code>, and must resolve to an integer. The return value is the same data type as <code>char</code>. Floating-point numbers passed as arguments to <code>SUBSTR</code> are automatically converted to integers. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch7progrunicode.htm#NLSPG007</link> for more information about <code>SUBSTR</code> functions and length semantics in different locales \n The Examples is: \n The following example returns several specified substrings of \"ABCDEFG\": <code>SELECT SUBSTR('ABCDEFG',3,4) \"Substring\" FROM DUAL; Substring --------- CDEF SELECT SUBSTR('ABCDEFG',-5,4) \"Substring\" FROM DUAL; Substring --------- CDEF </code> Assume a double-byte database character set: <code>SELECT SUBSTRB('ABCDEFG',5,4.2) \"Substring with bytes\" FROM DUAL; Substring with bytes -------------------- CD </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions181.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TZ_OFFSET",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TZ_OFFSET))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TZ_OFFSET({ 'time_zone_name' | '{ + | - } hh : mi' | SESSIONTIMEZONE | DBTIMEZONE } ) </eps> \n The Purpose is: \n <code>TZ_OFFSET</code> returns the time zone offset corresponding to the argument based on the date the statement is executed. You can enter a valid time zone region name, a time zone offset from UTC (which simply returns itself), or the keyword <code>SESSIONTIMEZONE</code> or <code>DBTIMEZONE</code>. For a listing of valid values for <code>time_zone_name</code>, query the <code>TZNAME</code> column of the <code>V$TIMEZONE_NAMES</code> dynamic performance view. Note: Time zone region names are needed by the daylight saving feature. These names are stored in two types of time zone files: one large and one small. One of these files is the default file, depending on your environment and the release of Oracle Database you are using. For more information regarding time zone files and names, see <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG014</link>. \n The Examples is: \n The following example returns the time zone offset of the US/Eastern time zone from UTC: <code>SELECT TZ_OFFSET('US/Eastern') FROM DUAL; TZ_OFFS ------- -04:00 </code> ",
        "detail": "The Syntax is: \n <eps> TZ_OFFSET({ 'time_zone_name' | '{ + | - } hh : mi' | SESSIONTIMEZONE | DBTIMEZONE } ) </eps> \n The Purpose is: \n <code>TZ_OFFSET</code> returns the time zone offset corresponding to the argument based on the date the statement is executed. You can enter a valid time zone region name, a time zone offset from UTC (which simply returns itself), or the keyword <code>SESSIONTIMEZONE</code> or <code>DBTIMEZONE</code>. For a listing of valid values for <code>time_zone_name</code>, query the <code>TZNAME</code> column of the <code>V$TIMEZONE_NAMES</code> dynamic performance view. Note: Time zone region names are needed by the daylight saving feature. These names are stored in two types of time zone files: one large and one small. One of these files is the default file, depending on your environment and the release of Oracle Database you are using. For more information regarding time zone files and names, see <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG014</link>. \n The Examples is: \n The following example returns the time zone offset of the US/Eastern time zone from UTC: <code>SELECT TZ_OFFSET('US/Eastern') FROM DUAL; TZ_OFFS ------- -04:00 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions222.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CLUSTER_SET",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CLUSTER_SET))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CLUSTER_SET ( [ schema . ] model [ , topN [ , cutoff ] ] mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with clustering models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns a varray of objects containing all possible clusters that a given row belongs to. Each object in the varray is a pair of scalar values containing the cluster ID and the cluster probability. The object fields are named <code>CLUSTER_ID</code> and <code>PROBABILITY</code>, and both are Oracle <code>NUMBER</code>. For the optional <code>topN</code> argument, specify a positive integer. Doing so restricts the set of predicted clusters to those that have one of the top <code>N</code> probability values. If you omit <code>topN</code> or set it to <code>NULL</code>, then all clusters are returned in the collection. If multiple clusters are tied for the <code>Nth</code> value, the database still returns only <code>N</code> values. For the optional <code>cutoff</code> argument, specify a positive integer to restrict the returned clusters to those with a probability greater than or equal to the specified cutoff. You can filter only by <code>cutoff</code> by specifying <code>NULL</code> for <code>topN</code> and the desired cutoff value for <code>cutoff</code>. You can specify <code>topN</code> and <code>cutoff</code> together to restrict the returned clusters to those that are in the top <code>N</code> and have a probability that passes the threshold. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the most relevant attributes (with confidence > 55%) of each cluster to which customer 101362 belongs with > 20% likelihood. This example, and the prerequisite data mining operations, including the creation of the <code>km_sh_clus_sample</code> model and the views and type, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmkmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>WITH clus_tab AS ( SELECT id, A.attribute_name aname, A.conditional_operator op, NVL(A.attribute_str_value, ROUND(A.attribute_num_value),4)) val, A.attribute_support support, A.attribute_confidence confidence FROM TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_KM('km_sh_clus_sample')) T, TABLE(T.rule.antecedent) A WHERE A.attribute_confidence > 0.55 ), clust AS ( SELECT id, CAST(COLLECT(Cattr(aname, op, TO_CHAR(val), support, confidence)) AS Cattrs) cl_attrs FROM clus_tab GROUP BY id ), custclus AS ( SELECT T.cust_id, S.cluster_id, S.probability FROM (SELECT cust_id, CLUSTER_SET(km_sh_clus_sample, NULL, 0.2 USING *) pset FROM mining_data_apply_v WHERE cust_id = 101362) T, TABLE(T.pset) S ) SELECT A.probability prob, A.cluster_id cl_id, B.attr, B.op, B.val, B.supp, B.conf FROM custclus A, (SELECT T.id, C.* FROM clust T, TABLE(T.cl_attrs) C) B WHERE A.cluster_id = B.id ORDER BY prob DESC, cl_id ASC, conf DESC, attr ASC, val ASC; PROB CL_ID ATTR OP VAL SUPP CONF ------- ---------- -------------------------- -- ----------- -------- ------- .7745 8 HOUSEHOLD_SIZE IN 9+ 124 .7500 .7745 8 CUST_MARITAL_STATUS IN Divorc. 116 .6000 .7745 8 CUST_MARITAL_STATUS IN NeverM 116 .6000 .7745 8 CUST_MARITAL_STATUS IN Separ. 116 .6000 .7745 8 CUST_MARITAL_STATUS IN Widowed 116 .6000 .2028 6 AGE >= 17 154 .6667 .2028 6 AGE <= 31.6 154 .6667 .2028 6 CUST_MARITAL_STATUS IN NeverM 172 .6667 8 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> CLUSTER_SET ( [ schema . ] model [ , topN [ , cutoff ] ] mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with clustering models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns a varray of objects containing all possible clusters that a given row belongs to. Each object in the varray is a pair of scalar values containing the cluster ID and the cluster probability. The object fields are named <code>CLUSTER_ID</code> and <code>PROBABILITY</code>, and both are Oracle <code>NUMBER</code>. For the optional <code>topN</code> argument, specify a positive integer. Doing so restricts the set of predicted clusters to those that have one of the top <code>N</code> probability values. If you omit <code>topN</code> or set it to <code>NULL</code>, then all clusters are returned in the collection. If multiple clusters are tied for the <code>Nth</code> value, the database still returns only <code>N</code> values. For the optional <code>cutoff</code> argument, specify a positive integer to restrict the returned clusters to those with a probability greater than or equal to the specified cutoff. You can filter only by <code>cutoff</code> by specifying <code>NULL</code> for <code>topN</code> and the desired cutoff value for <code>cutoff</code>. You can specify <code>topN</code> and <code>cutoff</code> together to restrict the returned clusters to those that are in the top <code>N</code> and have a probability that passes the threshold. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the most relevant attributes (with confidence > 55%) of each cluster to which customer 101362 belongs with > 20% likelihood. This example, and the prerequisite data mining operations, including the creation of the <code>km_sh_clus_sample</code> model and the views and type, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmkmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>WITH clus_tab AS ( SELECT id, A.attribute_name aname, A.conditional_operator op, NVL(A.attribute_str_value, ROUND(A.attribute_num_value),4)) val, A.attribute_support support, A.attribute_confidence confidence FROM TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_KM('km_sh_clus_sample')) T, TABLE(T.rule.antecedent) A WHERE A.attribute_confidence > 0.55 ), clust AS ( SELECT id, CAST(COLLECT(Cattr(aname, op, TO_CHAR(val), support, confidence)) AS Cattrs) cl_attrs FROM clus_tab GROUP BY id ), custclus AS ( SELECT T.cust_id, S.cluster_id, S.probability FROM (SELECT cust_id, CLUSTER_SET(km_sh_clus_sample, NULL, 0.2 USING *) pset FROM mining_data_apply_v WHERE cust_id = 101362) T, TABLE(T.pset) S ) SELECT A.probability prob, A.cluster_id cl_id, B.attr, B.op, B.val, B.supp, B.conf FROM custclus A, (SELECT T.id, C.* FROM clust T, TABLE(T.cl_attrs) C) B WHERE A.cluster_id = B.id ORDER BY prob DESC, cl_id ASC, conf DESC, attr ASC, val ASC; PROB CL_ID ATTR OP VAL SUPP CONF ------- ---------- -------------------------- -- ----------- -------- ------- .7745 8 HOUSEHOLD_SIZE IN 9+ 124 .7500 .7745 8 CUST_MARITAL_STATUS IN Divorc. 116 .6000 .7745 8 CUST_MARITAL_STATUS IN NeverM 116 .6000 .7745 8 CUST_MARITAL_STATUS IN Separ. 116 .6000 .7745 8 CUST_MARITAL_STATUS IN Widowed 116 .6000 .2028 6 AGE >= 17 154 .6667 .2028 6 AGE <= 31.6 154 .6667 .2028 6 CUST_MARITAL_STATUS IN NeverM 172 .6667 8 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions029.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DUMP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c DUMP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> DUMP(expr[, return_fmt [, start_position [, length ] ] ]) </eps> \n The Purpose is: \n <code>DUMP</code> returns a <code>VARCHAR2</code> value containing the data type code, length in bytes, and internal representation of <code>expr</code>. The returned result is always in the database character set. For the data type corresponding to each code, see <link>Table 3-1, \"Built-in Data Type Summary\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#BABCGCHG</link>. The argument <code>return_fmt</code> specifies the format of the return value and can have any of the following values: 8 returns result in octal notation. 10 returns result in decimal notation. 16 returns result in hexadecimal notation. 17 returns each byte printed as a character if and only if it can be interpreted as a printable character in the character set of the compiler\u2014typically ASCII or EBCDIC. Some ASCII control characters may be printed in the form ^X as well. Otherwise the character is printed in hexadecimal notation. All NLS parameters are ignored. Do not depend on any particular output format for <code>DUMP</code> with <code>return_fmt</code> 17. By default, the return value contains no character set information. To retrieve the character set name of <code>expr</code>, add 1000 to any of the preceding format values. For example, a <code>return_fmt</code> of 1008 returns the result in octal and provides the character set name of <code>expr</code>. The arguments <code>start_position</code> and <code>length</code> combine to determine which portion of the internal representation to return. The default is to return the entire internal representation in decimal notation. If <code>expr</code> is null, then this function returns <code>NULL</code>. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following examples show how to extract dump information from a string expression and a column: <code>SELECT DUMP('abc', 1016) FROM DUAL; DUMP('ABC',1016) ------------------------------------------ Typ=96 Len=3 CharacterSet=WE8DEC: 61,62,63 SELECT DUMP(last_name, 8, 3, 2) \"OCTAL\" FROM employees WHERE last_name = 'Hunold' ORDER BY employee_id; OCTAL ------------------------------------------------------------------- Typ=1 Len=6: 156,157 SELECT DUMP(last_name, 10, 3, 2) \"ASCII\" FROM employees WHERE last_name = 'Hunold' ORDER BY employee_id; ASCII -------------------------------------------------------------------- Typ=1 Len=6: 110,111 </code> ",
        "detail": "The Syntax is: \n <eps> DUMP(expr[, return_fmt [, start_position [, length ] ] ]) </eps> \n The Purpose is: \n <code>DUMP</code> returns a <code>VARCHAR2</code> value containing the data type code, length in bytes, and internal representation of <code>expr</code>. The returned result is always in the database character set. For the data type corresponding to each code, see <link>Table 3-1, \"Built-in Data Type Summary\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#BABCGCHG</link>. The argument <code>return_fmt</code> specifies the format of the return value and can have any of the following values: 8 returns result in octal notation. 10 returns result in decimal notation. 16 returns result in hexadecimal notation. 17 returns each byte printed as a character if and only if it can be interpreted as a printable character in the character set of the compiler\u2014typically ASCII or EBCDIC. Some ASCII control characters may be printed in the form ^X as well. Otherwise the character is printed in hexadecimal notation. All NLS parameters are ignored. Do not depend on any particular output format for <code>DUMP</code> with <code>return_fmt</code> 17. By default, the return value contains no character set information. To retrieve the character set name of <code>expr</code>, add 1000 to any of the preceding format values. For example, a <code>return_fmt</code> of 1008 returns the result in octal and provides the character set name of <code>expr</code>. The arguments <code>start_position</code> and <code>length</code> combine to determine which portion of the internal representation to return. The default is to return the entire internal representation in decimal notation. If <code>expr</code> is null, then this function returns <code>NULL</code>. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following examples show how to extract dump information from a string expression and a column: <code>SELECT DUMP('abc', 1016) FROM DUAL; DUMP('ABC',1016) ------------------------------------------ Typ=96 Len=3 CharacterSet=WE8DEC: 61,62,63 SELECT DUMP(last_name, 8, 3, 2) \"OCTAL\" FROM employees WHERE last_name = 'Hunold' ORDER BY employee_id; OCTAL ------------------------------------------------------------------- Typ=1 Len=6: 156,157 SELECT DUMP(last_name, 10, 3, 2) \"ASCII\" FROM employees WHERE last_name = 'Hunold' ORDER BY employee_id; ASCII -------------------------------------------------------------------- Typ=1 Len=6: 110,111 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions055.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLCDATA",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLCDATA))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLCDATA ( value_expr ) </eps> \n The Purpose is: \n <code>XMLCData</code> generates a CDATA section by evaluating <code>value_expr</code>. The <code>value_expr</code> must resolve to a string. The value returned by the function takes the following form: <code><![CDATA[string]]> </code> If the resulting value is not a valid XML CDATA section, then the function returns an error.The following conditions apply to <code>XMLCData</code>: The <code>value_expr</code> cannot contain the substring <code>]]></code>. If <code>value_expr</code> evaluates to null, then the function returns null. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following statement uses the <code>DUAL</code> table to illustrate the syntax of <code>XMLCData</code>: <code>SELECT XMLELEMENT(\"PurchaseOrder\", XMLAttributes(dummy as \"pono\"), XMLCdata('<!DOCTYPE po_dom_group [ <!ELEMENT po_dom_group(student_name)*> <!ELEMENT po_purch_name (#PCDATA)> <!ATTLIST po_name po_no ID #REQUIRED> <!ATTLIST po_name trust_1 IDREF #IMPLIED> <!ATTLIST po_name trust_2 IDREF #IMPLIED> ]>')) \"XMLCData\" FROM DUAL; XMLCData ---------------------------------------------------------- <PurchaseOrder pono=\"X\"><![CDATA[ <!DOCTYPE po_dom_group [ <!ELEMENT po_dom_group(student_name)*> <!ELEMENT po_purch_name (#PCDATA)> <!ATTLIST po_name po_no ID #REQUIRED> <!ATTLIST po_name trust_1 IDREF #IMPLIED> <!ATTLIST po_name trust_2 IDREF #IMPLIED> ]> ]]> </PurchaseOrder> </code> ",
        "detail": "The Syntax is: \n <eps> XMLCDATA ( value_expr ) </eps> \n The Purpose is: \n <code>XMLCData</code> generates a CDATA section by evaluating <code>value_expr</code>. The <code>value_expr</code> must resolve to a string. The value returned by the function takes the following form: <code><![CDATA[string]]> </code> If the resulting value is not a valid XML CDATA section, then the function returns an error.The following conditions apply to <code>XMLCData</code>: The <code>value_expr</code> cannot contain the substring <code>]]></code>. If <code>value_expr</code> evaluates to null, then the function returns null. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following statement uses the <code>DUAL</code> table to illustrate the syntax of <code>XMLCData</code>: <code>SELECT XMLELEMENT(\"PurchaseOrder\", XMLAttributes(dummy as \"pono\"), XMLCdata('<!DOCTYPE po_dom_group [ <!ELEMENT po_dom_group(student_name)*> <!ELEMENT po_purch_name (#PCDATA)> <!ATTLIST po_name po_no ID #REQUIRED> <!ATTLIST po_name trust_1 IDREF #IMPLIED> <!ATTLIST po_name trust_2 IDREF #IMPLIED> ]>')) \"XMLCData\" FROM DUAL; XMLCData ---------------------------------------------------------- <PurchaseOrder pono=\"X\"><![CDATA[ <!DOCTYPE po_dom_group [ <!ELEMENT po_dom_group(student_name)*> <!ELEMENT po_purch_name (#PCDATA)> <!ATTLIST po_name po_no ID #REQUIRED> <!ATTLIST po_name trust_1 IDREF #IMPLIED> <!ATTLIST po_name trust_2 IDREF #IMPLIED> ]> ]]> </PurchaseOrder> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions237.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_DATE",
        "tree": "(string_function TO_DATE ( ))",
        "description": "The Syntax is: \n <eps> TO_DATE(char [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_DATE</code> converts <code>char</code> of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to a value of <code>DATE</code> data type. Note: This function does not convert data to any of the other datetime data types. For information on other datetime conversions, refer to <link>TO_TIMESTAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions213.htm#i999843</link>, <link>TO_TIMESTAMP_TZ&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions214.htm#i999847</link>, <link>TO_DSINTERVAL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions204.htm#i1014645</link>, and <link>TO_YMINTERVAL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions215.htm#i999851</link>. The <code>fmt</code> is a datetime model format specifying the format of <code>char</code>. If you omit <code>fmt</code>, then <code>char</code> must be in the default date format. The default date format is determined implicitly by the <code>NLS_TERRITORY</code> initialization parameter or can be set explicitly by the <code>NLS_DATE_FORMAT</code> parameter. If <code>fmt</code> is <code>J</code>, for Julian, then <code>char</code> must be an integer. Caution: It is good practice always to specify a format mask (<code>fmt</code>) with <code>TO_DATE</code>, as shown in the examples in the section that follows. When it is used without a format mask, the function is valid only if <code>char</code> uses the same format as is determined by the <code>NLS_TERRITORY</code> or <code>NLS_DATE_FORMAT</code> parameters. Furthermore, the function may not be stable across databases unless the explicit format mask is specified to avoid dependencies. The <code>'nlsparam'</code> argument specifies the language of the text string that is being converted to a date. This argument can have this form: <code>'NLS_DATE_LANGUAGE = language' </code> Do not use the <code>TO_DATE</code> function with a <code>DATE</code> value for the <code>char</code> argument. The first two digits of the returned <code>DATE</code> value can differ from the original <code>char</code>, depending on <code>fmt</code> or the default date format. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Datetime Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34924</link> and <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following example converts a character string into a date: <code>SELECT TO_DATE( 'January 15, 1989, 11:00 A.M.', 'Month dd, YYYY, HH:MI A.M.', 'NLS_DATE_LANGUAGE = American') FROM DUAL; TO_DATE(' --------- 15-JAN-89 </code> The value returned reflects the default date format if the <code>NLS_TERRITORY</code> parameter is set to '<code>AMERICA</code>'. Different <code>NLS_TERRITORY</code> values result in different default date formats: <code>ALTER SESSION SET NLS_TERRITORY = 'KOREAN'; SELECT TO_DATE( 'January 15, 1989, 11:00 A.M.', 'Month dd, YYYY, HH:MI A.M.', 'NLS_DATE_LANGUAGE = American') FROM DUAL; TO_DATE( -------- 89/01/15 </code> ",
        "detail": "The Syntax is: \n <eps> TO_DATE(char [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_DATE</code> converts <code>char</code> of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to a value of <code>DATE</code> data type. Note: This function does not convert data to any of the other datetime data types. For information on other datetime conversions, refer to <link>TO_TIMESTAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions213.htm#i999843</link>, <link>TO_TIMESTAMP_TZ&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions214.htm#i999847</link>, <link>TO_DSINTERVAL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions204.htm#i1014645</link>, and <link>TO_YMINTERVAL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions215.htm#i999851</link>. The <code>fmt</code> is a datetime model format specifying the format of <code>char</code>. If you omit <code>fmt</code>, then <code>char</code> must be in the default date format. The default date format is determined implicitly by the <code>NLS_TERRITORY</code> initialization parameter or can be set explicitly by the <code>NLS_DATE_FORMAT</code> parameter. If <code>fmt</code> is <code>J</code>, for Julian, then <code>char</code> must be an integer. Caution: It is good practice always to specify a format mask (<code>fmt</code>) with <code>TO_DATE</code>, as shown in the examples in the section that follows. When it is used without a format mask, the function is valid only if <code>char</code> uses the same format as is determined by the <code>NLS_TERRITORY</code> or <code>NLS_DATE_FORMAT</code> parameters. Furthermore, the function may not be stable across databases unless the explicit format mask is specified to avoid dependencies. The <code>'nlsparam'</code> argument specifies the language of the text string that is being converted to a date. This argument can have this form: <code>'NLS_DATE_LANGUAGE = language' </code> Do not use the <code>TO_DATE</code> function with a <code>DATE</code> value for the <code>char</code> argument. The first two digits of the returned <code>DATE</code> value can differ from the original <code>char</code>, depending on <code>fmt</code> or the default date format. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Datetime Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34924</link> and <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following example converts a character string into a date: <code>SELECT TO_DATE( 'January 15, 1989, 11:00 A.M.', 'Month dd, YYYY, HH:MI A.M.', 'NLS_DATE_LANGUAGE = American') FROM DUAL; TO_DATE(' --------- 15-JAN-89 </code> The value returned reflects the default date format if the <code>NLS_TERRITORY</code> parameter is set to '<code>AMERICA</code>'. Different <code>NLS_TERRITORY</code> values result in different default date formats: <code>ALTER SESSION SET NLS_TERRITORY = 'KOREAN'; SELECT TO_DATE( 'January 15, 1989, 11:00 A.M.', 'Month dd, YYYY, HH:MI A.M.', 'NLS_DATE_LANGUAGE = American') FROM DUAL; TO_DATE( -------- 89/01/15 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions203.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SET",
        "tree": "(general_element_part (id_expression (regular_id SET)) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SET (nested_table) </eps> \n The Purpose is: \n <code>SET</code> converts a nested table into a set by eliminating duplicates. The function returns a nested table whose elements are distinct from one another. The returned nested table is of the same type as the input nested table. The element types of the nested table must be comparable. Refer to <link>\"Comparison Conditions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions002.htm#i1033286</link> for information on the comparability of nonscalar types. \n The Examples is: \n The following example selects from the <code>customers_demo</code> table the unique elements of the <code>cust_address_ntab</code> nested table column: <code>SELECT customer_id, SET(cust_address_ntab) address FROM customers_demo ORDER BY customer_id; </code> <code></code> <code>CUSTOMER_ID ADDRESS(STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID) ----------- ------------------------------------------------------------------------ 101 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('514 W Superior St', '46901', 'Kokomo', 'IN', 'US')) 102 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('2515 Bloyd Ave', '46218', 'Indianapolis', 'IN', 'US')) 103 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('8768 N State Rd 37', '47404', 'Bloomington', 'IN', 'US')) 104 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('6445 Bay Harbor Ln', '46254', 'Indianapolis', 'IN', 'US')) 105 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('4019 W 3Rd St', '47404', 'Bloomington', 'IN', 'US')) . . . </code> The preceding example requires the table <code>customers_demo</code> and a nested table column containing data. Refer to <link>\"Multiset Operators\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/operators006.htm#i1035617</link> to create this table and nested table column. ",
        "detail": "The Syntax is: \n <eps> SET (nested_table) </eps> \n The Purpose is: \n <code>SET</code> converts a nested table into a set by eliminating duplicates. The function returns a nested table whose elements are distinct from one another. The returned nested table is of the same type as the input nested table. The element types of the nested table must be comparable. Refer to <link>\"Comparison Conditions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions002.htm#i1033286</link> for information on the comparability of nonscalar types. \n The Examples is: \n The following example selects from the <code>customers_demo</code> table the unique elements of the <code>cust_address_ntab</code> nested table column: <code>SELECT customer_id, SET(cust_address_ntab) address FROM customers_demo ORDER BY customer_id; </code> <code></code> <code>CUSTOMER_ID ADDRESS(STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID) ----------- ------------------------------------------------------------------------ 101 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('514 W Superior St', '46901', 'Kokomo', 'IN', 'US')) 102 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('2515 Bloyd Ave', '46218', 'Indianapolis', 'IN', 'US')) 103 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('8768 N State Rd 37', '47404', 'Bloomington', 'IN', 'US')) 104 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('6445 Bay Harbor Ln', '46254', 'Indianapolis', 'IN', 'US')) 105 CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP('4019 W 3Rd St', '47404', 'Bloomington', 'IN', 'US')) . . . </code> The preceding example requires the table <code>customers_demo</code> and a nested table column containing data. Refer to <link>\"Multiset Operators\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/operators006.htm#i1035617</link> to create this table and nested table column. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions163.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NEXT_DAY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NEXT_DAY))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NEXT_DAY(date, char) </eps> \n The Purpose is: \n <code>NEXT_DAY</code> returns the date of the first weekday named by <code>char</code> that is later than the date <code>date</code>. The return type is always <code>DATE</code>, regardless of the data type of <code>date</code>. The argument <code>char</code> must be a day of the week in the date language of your session, either the full name or the abbreviation. The minimum number of letters required is the number of letters in the abbreviated version. Any characters immediately following the valid abbreviation are ignored. The return value has the same hours, minutes, and seconds component as the argument <code>date</code>. \n The Examples is: \n This example returns the date of the next Tuesday after October 15, 2009: <code>SELECT NEXT_DAY('15-OCT-2009','TUESDAY') \"NEXT DAY\" FROM DUAL; NEXT DAY -------------------- 20-OCT-2009 00:00:00 </code> ",
        "detail": "The Syntax is: \n <eps> NEXT_DAY(date, char) </eps> \n The Purpose is: \n <code>NEXT_DAY</code> returns the date of the first weekday named by <code>char</code> that is later than the date <code>date</code>. The return type is always <code>DATE</code>, regardless of the data type of <code>date</code>. The argument <code>char</code> must be a day of the week in the date language of your session, either the full name or the abbreviation. The minimum number of letters required is the number of letters in the abbreviated version. Any characters immediately following the valid abbreviation are ignored. The return value has the same hours, minutes, and seconds component as the argument <code>date</code>. \n The Examples is: \n This example returns the date of the next Tuesday after October 15, 2009: <code>SELECT NEXT_DAY('15-OCT-2009','TUESDAY') \"NEXT DAY\" FROM DUAL; NEXT DAY -------------------- 20-OCT-2009 00:00:00 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions106.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NLS_CHARSET_DECL_LEN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NLS_CHARSET_DECL_LEN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NLS_CHARSET_DECL_LEN(byte_count, char_set_id) </eps> \n The Purpose is: \n <code>NLS_CHARSET_DECL_LEN</code> returns the declaration length (in number of characters) of an <code>NCHAR</code> column. The <code>byte_count</code> argument is the width of the column. The <code>char_set_id</code> argument is the character set ID of the column. \n The Examples is: \n The following example returns the number of characters that are in a 200-byte column when you are using a multibyte character set: <code>SELECT NLS_CHARSET_DECL_LEN(200, nls_charset_id('ja16eucfixed')) FROM DUAL; NLS_CHARSET_DECL_LEN(200,NLS_CHARSET_ID('JA16EUCFIXED')) -------------------------------------------------------- 100 </code> ",
        "detail": "The Syntax is: \n <eps> NLS_CHARSET_DECL_LEN(byte_count, char_set_id) </eps> \n The Purpose is: \n <code>NLS_CHARSET_DECL_LEN</code> returns the declaration length (in number of characters) of an <code>NCHAR</code> column. The <code>byte_count</code> argument is the width of the column. The <code>char_set_id</code> argument is the character set ID of the column. \n The Examples is: \n The following example returns the number of characters that are in a 200-byte column when you are using a multibyte character set: <code>SELECT NLS_CHARSET_DECL_LEN(200, nls_charset_id('ja16eucfixed')) FROM DUAL; NLS_CHARSET_DECL_LEN(200,NLS_CHARSET_ID('JA16EUCFIXED')) -------------------------------------------------------- 100 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions107.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "IS_OF_type_Condition",
        "tree": "(general_element_part (id_expression (regular_id IS_OF_type_Condition)) (function_argument ( )))",
        "description": "Use the <code>IS</code> <code>OF</code> <code>type</code> condition to test object instances based on their specific type information. is_of_type_condition::= <eps> expr IS [ NOT ] OF [ TYPE ] ([ ONLY ] [ schema. ] type [, [ ONLY ] [ schema. ] type ]... ) </eps> You must have <code>EXECUTE</code> privilege on all types referenced by <code>type</code>, and all <code>type</code>s must belong to the same type family. This condition evaluates to null if <code>expr</code> is null. If <code>expr</code> is not null, then the condition evaluates to true (or false if you specify the <code>NOT</code> keyword) under either of these circumstances: The most specific type of <code>expr</code> is the subtype of one of the types specified in the <code>type</code> list and you have not specified <code>ONLY</code> for the type, or The most specific type of <code>expr</code> is explicitly specified in the <code>type</code> list. The <code>expr</code> frequently takes the form of the <code>VALUE</code> function with a correlation variable. The following example uses the sample table <code>oe.persons</code>, which is built on a type hierarchy in <link>\"Substitutable Table and Column \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm#i2090577</link>. The example uses the <code>IS</code> <code>OF</code> <code>type</code> condition to restrict the query to specific subtypes: <code>SELECT * FROM persons p WHERE VALUE(p) IS OF TYPE (employee_t); NAME SSN ---------------------------- Joe 32456 Tim 5678 SELECT * FROM persons p WHERE VALUE(p) IS OF (ONLY part_time_emp_t); NAME SSN ---------------------------- Tim 5678 </code> ",
        "detail": "Use the <code>IS</code> <code>OF</code> <code>type</code> condition to test object instances based on their specific type information. is_of_type_condition::= <eps> expr IS [ NOT ] OF [ TYPE ] ([ ONLY ] [ schema. ] type [, [ ONLY ] [ schema. ] type ]... ) </eps> You must have <code>EXECUTE</code> privilege on all types referenced by <code>type</code>, and all <code>type</code>s must belong to the same type family. This condition evaluates to null if <code>expr</code> is null. If <code>expr</code> is not null, then the condition evaluates to true (or false if you specify the <code>NOT</code> keyword) under either of these circumstances: The most specific type of <code>expr</code> is the subtype of one of the types specified in the <code>type</code> list and you have not specified <code>ONLY</code> for the type, or The most specific type of <code>expr</code> is explicitly specified in the <code>type</code> list. The <code>expr</code> frequently takes the form of the <code>VALUE</code> function with a correlation variable. The following example uses the sample table <code>oe.persons</code>, which is built on a type hierarchy in <link>\"Substitutable Table and Column \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm#i2090577</link>. The example uses the <code>IS</code> <code>OF</code> <code>type</code> condition to restrict the query to specific subtypes: <code>SELECT * FROM persons p WHERE VALUE(p) IS OF TYPE (employee_t); NAME SSN ---------------------------- Joe 32456 Tim 5678 SELECT * FROM persons p WHERE VALUE(p) IS OF (ONLY part_time_emp_t); NAME SSN ---------------------------- Tim 5678 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions014.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "COS",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c COS))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> COS(n) </eps> \n The Purpose is: \n <code>COS</code> returns the cosine of <code>n</code> (an angle expressed in radians). This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the cosine of 180 degrees: <code>SELECT COS(180 * 3.14159265359/180) \"Cosine of 180 degrees\" FROM DUAL; Cosine of 180 degrees --------------------- -1 </code> ",
        "detail": "The Syntax is: \n <eps> COS(n) </eps> \n The Purpose is: \n <code>COS</code> returns the cosine of <code>n</code> (an angle expressed in radians). This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the cosine of 180 degrees: <code>SELECT COS(180 * 3.14159265359/180) \"Cosine of 180 degrees\" FROM DUAL; Cosine of 180 degrees --------------------- -1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions037.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "VSIZE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c VSIZE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> VSIZE(expr) </eps> \n The Purpose is: \n <code>VSIZE</code> returns the number of bytes in the internal representation of <code>expr</code>. If <code>expr</code> is null, then this function returns null. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following example returns the number of bytes in the <code>last_name</code> column of the employees in department 10: <code>SELECT last_name, VSIZE (last_name) \"BYTES\" FROM employees WHERE department_id = 10 ORDER BY employee_id; LAST_NAME BYTES --------------- ---------- Whalen 6 </code> ",
        "detail": "The Syntax is: \n <eps> VSIZE(expr) </eps> \n The Purpose is: \n <code>VSIZE</code> returns the number of bytes in the internal representation of <code>expr</code>. If <code>expr</code> is null, then this function returns null. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following example returns the number of bytes in the <code>last_name</code> column of the employees in department 10: <code>SELECT last_name, VSIZE (last_name) \"BYTES\" FROM employees WHERE department_id = 10 ORDER BY employee_id; LAST_NAME BYTES --------------- ---------- Whalen 6 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions233.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TANH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TANH))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TANH(n) </eps> \n The Purpose is: \n <code>TANH</code> returns the hyperbolic tangent of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the hyperbolic tangent of .5: <code>SELECT TANH(.5) \"Hyperbolic tangent of .5\" FROM DUAL; Hyperbolic tangent of .5 ------------------------ .462117157 </code> ",
        "detail": "The Syntax is: \n <eps> TANH(n) </eps> \n The Purpose is: \n <code>TANH</code> returns the hyperbolic tangent of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the hyperbolic tangent of .5: <code>SELECT TANH(.5) \"Hyperbolic tangent of .5\" FROM DUAL; Hyperbolic tangent of .5 ------------------------ .462117157 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions194.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "MIN",
        "tree": "(other_function (over_clause_keyword MIN) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> MIN([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>MIN</code> returns minimum value of <code>expr</code>. You can use it as an aggregate or analytic function. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>, <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics, and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following statement returns the earliest hire date in the <code>hr.employees</code> table: <code>SELECT MIN(hire_date) \"Earliest\" FROM employees; Earliest --------- 13-JAN-01 </code> Analytic Example The following example determines, for each employee, the employees who were hired on or before the same date as the employee. It then determines the subset of employees reporting to the same manager as the employee, and returns the lowest salary in that subset. <code>SELECT manager_id, last_name, hire_date, salary, MIN(salary) OVER(PARTITION BY manager_id ORDER BY hire_date RANGE UNBOUNDED PRECEDING) AS p_cmin FROM employees ORDER BY manager_id, last_name, hire_date, salary; MANAGER_ID LAST_NAME HIRE_DATE SALARY P_CMIN ---------- ------------------------- --------- ---------- ---------- 100 Cambrault 15-OCT-07 11000 6500 100 De Haan 13-JAN-01 17000 17000 100 Errazuriz 10-MAR-05 12000 7900 100 Fripp 10-APR-05 8200 7900 100 Hartstein 17-FEB-04 13000 7900 100 Kaufling 01-MAY-03 7900 7900 100 Kochhar 21-SEP-05 17000 7900 100 Mourgos 16-NOV-07 5800 5800 100 Partners 05-JAN-05 13500 7900 100 Raphaely 07-DEC-02 11000 11000 100 Russell 01-OCT-04 14000 7900 . . . </code> ",
        "detail": "The Syntax is: \n <eps> MIN([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>MIN</code> returns minimum value of <code>expr</code>. You can use it as an aggregate or analytic function. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>, <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics, and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following statement returns the earliest hire date in the <code>hr.employees</code> table: <code>SELECT MIN(hire_date) \"Earliest\" FROM employees; Earliest --------- 13-JAN-01 </code> Analytic Example The following example determines, for each employee, the employees who were hired on or before the same date as the employee. It then determines the subset of employees reporting to the same manager as the employee, and returns the lowest salary in that subset. <code>SELECT manager_id, last_name, hire_date, salary, MIN(salary) OVER(PARTITION BY manager_id ORDER BY hire_date RANGE UNBOUNDED PRECEDING) AS p_cmin FROM employees ORDER BY manager_id, last_name, hire_date, salary; MANAGER_ID LAST_NAME HIRE_DATE SALARY P_CMIN ---------- ------------------------- --------- ---------- ---------- 100 Cambrault 15-OCT-07 11000 6500 100 De Haan 13-JAN-01 17000 17000 100 Errazuriz 10-MAR-05 12000 7900 100 Fripp 10-APR-05 8200 7900 100 Hartstein 17-FEB-04 13000 7900 100 Kaufling 01-MAY-03 7900 7900 100 Kochhar 21-SEP-05 17000 7900 100 Mourgos 16-NOV-07 5800 5800 100 Partners 05-JAN-05 13500 7900 100 Raphaely 07-DEC-02 11000 11000 100 Russell 01-OCT-04 14000 7900 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions100.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TAN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TAN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TAN(n) </eps> \n The Purpose is: \n <code>TAN</code> returns the tangent of <code>n</code> (an angle expressed in radians). This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the tangent of 135 degrees: <code>SELECT TAN(135 * 3.14159265359/180) \"Tangent of 135 degrees\" FROM DUAL; Tangent of 135 degrees ---------------------- - 1 </code> ",
        "detail": "The Syntax is: \n <eps> TAN(n) </eps> \n The Purpose is: \n <code>TAN</code> returns the tangent of <code>n</code> (an angle expressed in radians). This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the tangent of 135 degrees: <code>SELECT TAN(135 * 3.14159265359/180) \"Tangent of 135 degrees\" FROM DUAL; Tangent of 135 degrees ---------------------- - 1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions193.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NCHR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NCHR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NCHR(number) </eps> \n The Purpose is: \n <code>NCHR</code> returns the character having the binary equivalent to <code>number</code> in the national character set. The value returned is always <code>NVARCHAR2</code>. This function is equivalent to using the <code>CHR</code> function with the <code>USING</code> <code>NCHAR_CS</code> clause. This function takes as an argument a <code>NUMBER</code> value, or any value that can be implicitly converted to <code>NUMBER</code>, and returns a character. See Also: <link>CHR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions026.htm#i76965</link> \n The Examples is: \n The following examples return the nchar character 187: <code>SELECT NCHR(187) FROM DUAL; N - > SELECT CHR(187 USING NCHAR_CS) FROM DUAL; C - > </code> ",
        "detail": "The Syntax is: \n <eps> NCHR(number) </eps> \n The Purpose is: \n <code>NCHR</code> returns the character having the binary equivalent to <code>number</code> in the national character set. The value returned is always <code>NVARCHAR2</code>. This function is equivalent to using the <code>CHR</code> function with the <code>USING</code> <code>NCHAR_CS</code> clause. This function takes as an argument a <code>NUMBER</code> value, or any value that can be implicitly converted to <code>NUMBER</code>, and returns a character. See Also: <link>CHR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions026.htm#i76965</link> \n The Examples is: \n The following examples return the nchar character 187: <code>SELECT NCHR(187) FROM DUAL; N - > SELECT CHR(187 USING NCHAR_CS) FROM DUAL; C - > </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions104.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLAGG",
        "tree": "(general_element_part (id_expression (regular_id XMLAGG)) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLAGG(XMLType_instance [ order_by_clause ]) </eps> \n The Purpose is: \n <code>XMLAgg</code> is an aggregate function. It takes a collection of XML fragments and returns an aggregated XML document. Any arguments that return null are dropped from the result. <code>XMLAgg</code> is similar to <code>SYS_XMLAgg</code> except that <code>XMLAgg</code> returns a collection of nodes but it does not accept formatting using the <code>XMLFormat</code> object. Also, <code>XMLAgg</code> does not enclose the output in an element tag as does <code>SYS_XMLAgg</code>. Within the <code>order_by_clause</code>, Oracle Database does not interpret number literals as column positions, as it does in other uses of this clause, but simply as number literals. See Also: <link>XMLELEMENT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions242.htm#i1129193</link> and <link>SYS_XMLAGG&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions189.htm#i1006716</link> \n The Examples is: \n The following example produces a <code>Department</code> element containing <code>Employee</code> elements with employee job ID and last name as the contents of the elements: <code>SELECT XMLELEMENT(\"Department\", XMLAGG(XMLELEMENT(\"Employee\", e.job_id||' '||e.last_name) ORDER BY last_name)) as \"Dept_list\" FROM employees e WHERE e.department_id = 30; Dept_list ------------------------------------------------------------- <Department> <Employee>PU_CLERK Baida</Employee> <Employee>PU_CLERK Colmenares</Employee> <Employee>PU_CLERK Himuro</Employee> <Employee>PU_CLERK Khoo</Employee> <Employee>PU_MAN Raphaely</Employee> <Employee>PU_CLERK Tobias</Employee> </Department> </code> The result is a single row, because <code>XMLAgg</code> aggregates the rows. You can use the <code>GROUP</code> <code>BY</code> clause to group the returned set of rows into multiple groups: <code>SELECT XMLELEMENT(\"Department\", XMLAGG(XMLELEMENT(\"Employee\", e.job_id||' '||e.last_name))) AS \"Dept_list\" FROM employees e GROUP BY e.department_id; Dept_list --------------------------------------------------------- <Department> <Employee>AD_ASST Whalen</Employee> </Department> <Department> <Employee>MK_MAN Hartstein</Employee> <Employee>MK_REP Fay</Employee> </Department> <Department> <Employee>PU_MAN Raphaely</Employee> <Employee>PU_CLERK Khoo</Employee> <Employee>PU_CLERK Tobias</Employee> <Employee>PU_CLERK Baida</Employee> <Employee>PU_CLERK Colmenares</Employee> <Employee>PU_CLERK Himuro</Employee> </Department> . . . </code> ",
        "detail": "The Syntax is: \n <eps> XMLAGG(XMLType_instance [ order_by_clause ]) </eps> \n The Purpose is: \n <code>XMLAgg</code> is an aggregate function. It takes a collection of XML fragments and returns an aggregated XML document. Any arguments that return null are dropped from the result. <code>XMLAgg</code> is similar to <code>SYS_XMLAgg</code> except that <code>XMLAgg</code> returns a collection of nodes but it does not accept formatting using the <code>XMLFormat</code> object. Also, <code>XMLAgg</code> does not enclose the output in an element tag as does <code>SYS_XMLAgg</code>. Within the <code>order_by_clause</code>, Oracle Database does not interpret number literals as column positions, as it does in other uses of this clause, but simply as number literals. See Also: <link>XMLELEMENT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions242.htm#i1129193</link> and <link>SYS_XMLAGG&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions189.htm#i1006716</link> \n The Examples is: \n The following example produces a <code>Department</code> element containing <code>Employee</code> elements with employee job ID and last name as the contents of the elements: <code>SELECT XMLELEMENT(\"Department\", XMLAGG(XMLELEMENT(\"Employee\", e.job_id||' '||e.last_name) ORDER BY last_name)) as \"Dept_list\" FROM employees e WHERE e.department_id = 30; Dept_list ------------------------------------------------------------- <Department> <Employee>PU_CLERK Baida</Employee> <Employee>PU_CLERK Colmenares</Employee> <Employee>PU_CLERK Himuro</Employee> <Employee>PU_CLERK Khoo</Employee> <Employee>PU_MAN Raphaely</Employee> <Employee>PU_CLERK Tobias</Employee> </Department> </code> The result is a single row, because <code>XMLAgg</code> aggregates the rows. You can use the <code>GROUP</code> <code>BY</code> clause to group the returned set of rows into multiple groups: <code>SELECT XMLELEMENT(\"Department\", XMLAGG(XMLELEMENT(\"Employee\", e.job_id||' '||e.last_name))) AS \"Dept_list\" FROM employees e GROUP BY e.department_id; Dept_list --------------------------------------------------------- <Department> <Employee>AD_ASST Whalen</Employee> </Department> <Department> <Employee>MK_MAN Hartstein</Employee> <Employee>MK_REP Fay</Employee> </Department> <Department> <Employee>PU_MAN Raphaely</Employee> <Employee>PU_CLERK Khoo</Employee> <Employee>PU_CLERK Tobias</Employee> <Employee>PU_CLERK Baida</Employee> <Employee>PU_CLERK Colmenares</Employee> <Employee>PU_CLERK Himuro</Employee> </Department> . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions235.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLFOREST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLFOREST))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLFOREST ( value_expr [ AS { c_alias | EVALNAME value_expr } ] [, value_expr [ AS { c_alias | EVALNAME value_expr } ] ]... ) </eps> \n The Purpose is: \n <code>XMLForest</code> converts each of its argument parameters to XML, and then returns an XML fragment that is the concatenation of these converted arguments. If <code>value_expr</code> is a scalar expression, then you can omit the <code>AS</code> clause, and Oracle Database uses the column name as the element name. If <code>value_expr</code> is an object type or collection, then the <code>AS</code> clause is mandatory, and Oracle uses the specified expression as the enclosing tag. You can do this by specifying <code>c_alias</code>, which is a string literal, or by specifying <code>EVALNAME</code> <code>value_expr</code>. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier can be up to 4000 characters and does not have to be a column name or column reference. It cannot be an expression or null. If <code>value_expr</code> is null, then no element is created for that <code>value_expr</code>. \n The Examples is: \n The following example creates an <code>Emp</code> element for a subset of employees, with nested <code>employee_id</code>, <code>last_name</code>, and <code>salary</code> elements as the contents of <code>Emp</code>: <code>SELECT XMLELEMENT(\"Emp\", XMLFOREST(e.employee_id, e.last_name, e.salary)) \"Emp Element\" FROM employees e WHERE employee_id = 204; Emp Element ---------------------------------------------------------------- <Emp> <EMPLOYEE_ID>204</EMPLOYEE_ID> <LAST_NAME>Baer</LAST_NAME> <SALARY>10000</SALARY> </Emp> </code> Refer to the example for <link>XMLCOLATTVAL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions238.htm#i1129374</link> to compare the output of these two functions. ",
        "detail": "The Syntax is: \n <eps> XMLFOREST ( value_expr [ AS { c_alias | EVALNAME value_expr } ] [, value_expr [ AS { c_alias | EVALNAME value_expr } ] ]... ) </eps> \n The Purpose is: \n <code>XMLForest</code> converts each of its argument parameters to XML, and then returns an XML fragment that is the concatenation of these converted arguments. If <code>value_expr</code> is a scalar expression, then you can omit the <code>AS</code> clause, and Oracle Database uses the column name as the element name. If <code>value_expr</code> is an object type or collection, then the <code>AS</code> clause is mandatory, and Oracle uses the specified expression as the enclosing tag. You can do this by specifying <code>c_alias</code>, which is a string literal, or by specifying <code>EVALNAME</code> <code>value_expr</code>. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier can be up to 4000 characters and does not have to be a column name or column reference. It cannot be an expression or null. If <code>value_expr</code> is null, then no element is created for that <code>value_expr</code>. \n The Examples is: \n The following example creates an <code>Emp</code> element for a subset of employees, with nested <code>employee_id</code>, <code>last_name</code>, and <code>salary</code> elements as the contents of <code>Emp</code>: <code>SELECT XMLELEMENT(\"Emp\", XMLFOREST(e.employee_id, e.last_name, e.salary)) \"Emp Element\" FROM employees e WHERE employee_id = 204; Emp Element ---------------------------------------------------------------- <Emp> <EMPLOYEE_ID>204</EMPLOYEE_ID> <LAST_NAME>Baer</LAST_NAME> <SALARY>10000</SALARY> </Emp> </code> Refer to the example for <link>XMLCOLATTVAL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions238.htm#i1129374</link> to compare the output of these two functions. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions244.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "FROM_TZ",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c FROM_TZ))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> FROM_TZ(timestamp_value, time_zone_value) </eps> \n The Purpose is: \n <code>FROM_TZ</code> converts a timestamp value and a time zone to a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value. <code>time_zone_value</code> is a character string in the format <code>'TZH:TZM'</code> or a character expression that returns a string in <code>TZR</code> with optional <code>TZD</code> format. \n The Examples is: \n The following example returns a timestamp value to <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>: <code>SELECT FROM_TZ(TIMESTAMP '2000-03-28 08:00:00', '3:00') FROM DUAL; FROM_TZ(TIMESTAMP'2000-03-2808:00:00','3:00') --------------------------------------------------------------- 28-MAR-00 08.00.000000000 AM +03:00 </code> ",
        "detail": "The Syntax is: \n <eps> FROM_TZ(timestamp_value, time_zone_value) </eps> \n The Purpose is: \n <code>FROM_TZ</code> converts a timestamp value and a time zone to a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value. <code>time_zone_value</code> is a character string in the format <code>'TZH:TZM'</code> or a character expression that returns a string in <code>TZR</code> with optional <code>TZD</code> format. \n The Examples is: \n The following example returns a timestamp value to <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>: <code>SELECT FROM_TZ(TIMESTAMP '2000-03-28 08:00:00', '3:00') FROM DUAL; FROM_TZ(TIMESTAMP'2000-03-2808:00:00','3:00') --------------------------------------------------------------- 28-MAR-00 08.00.000000000 AM +03:00 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions068.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_WSR_TEST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_WSR_TEST))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STATS_WSR_TEST(expr1, expr2 [, { STATISTIC | ONE_SIDED_SIG | TWO_SIDED_SIG } ] ) </eps> \n The Purpose is: \n <code>STATS_WSR_TEST</code> is a Wilcoxon Signed Ranks test of paired samples to determine whether the median of the differences between the samples is significantly different from zero. The absolute values of the differences are ordered and assigned ranks. Then the null hypothesis states that the sum of the ranks of the positive differences is equal to the sum of the ranks of the negative differences. This function takes three arguments: <code>expr1</code> and <code>expr2</code> are the two samples being analyzed, and the third argument is a return value of type <code>VARCHAR2</code>. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-10&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions177.htm#g1514203</link>. Table 5-10 STATS_WSR_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> STATISTIC </td> <td> The observed value of Z </td> </tr> <tr> <td> ONE_SIDED_SIG </td> <td> One-tailed significance of Z </td> </tr> <tr> <td> TWO_SIDED_SIG </td> <td> Two-tailed significance of Z </td> </tr> </tbody> </table> One-sided significance is always with respect to the upper tail. The high value (the value whose rejection region is the upper tail) is <code>expr1</code>. ",
        "detail": "The Syntax is: \n <eps> STATS_WSR_TEST(expr1, expr2 [, { STATISTIC | ONE_SIDED_SIG | TWO_SIDED_SIG } ] ) </eps> \n The Purpose is: \n <code>STATS_WSR_TEST</code> is a Wilcoxon Signed Ranks test of paired samples to determine whether the median of the differences between the samples is significantly different from zero. The absolute values of the differences are ordered and assigned ranks. Then the null hypothesis states that the sum of the ranks of the positive differences is equal to the sum of the ranks of the negative differences. This function takes three arguments: <code>expr1</code> and <code>expr2</code> are the two samples being analyzed, and the third argument is a return value of type <code>VARCHAR2</code>. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-10&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions177.htm#g1514203</link>. Table 5-10 STATS_WSR_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> STATISTIC </td> <td> The observed value of Z </td> </tr> <tr> <td> ONE_SIDED_SIG </td> <td> One-tailed significance of Z </td> </tr> <tr> <td> TWO_SIDED_SIG </td> <td> Two-tailed significance of Z </td> </tr> </tbody> </table> One-sided significance is always with respect to the upper tail. The high value (the value whose rejection region is the upper tail) is <code>expr1</code>. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions177.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "INSERTXMLAFTER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c INSERTXMLAFTER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> INSERTXMLAFTER ( XMLType_instance, XPath_string, value_expr [, namespace_string ] ) </eps> \n The Purpose is: \n <code>INSERTXMLAFTER</code> inserts one or more nodes of any kind immediately after a target node that is not an attribute node. The XML document that is the target of the insertion can be schema-based or non-schema-based. This function is similar to insertXMLbefore, but it inserts after, not before, the target node. <code>XMLType_instance</code> specifies the target node of the of the insertion. <code>XPath_string</code> is an XPath 1.0 expression that locates in the target node zero or more nodes of any kind except attribute nodes. XML-data is inserted immediately after each of these nodes; that is, each node specified becomes the preceding sibling node of a node specified in <code>value_expr</code>. <code>value_expr</code> is the XML data to be inserted. You can specify one or more nodes of any kind. The order of the nodes is preserved after the insertion. The optional <code>namespace_string</code> is the namespace for the target node. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example is similar to that for <code>INSERTCHILDXML</code>, but it adds a third <code>/Owner</code> node after the <code>/Owner</code> node added in the other example. The output of the query has been formatted for readability. <code>UPDATE warehouses SET warehouse_spec = INSERTXMLAFTER(warehouse_spec, '/Warehouse/Building/Owner[1]', XMLType('<Owner>SecondOwner</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Building/Owner') \"Owners\" FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_NAME Owners ----------------------------------- ------------------------------ New Jersey <Owner>GrandCo</Owner> <Owner>SecondOwner</Owner> <Owner>LesserCo</Owner> </code> ",
        "detail": "The Syntax is: \n <eps> INSERTXMLAFTER ( XMLType_instance, XPath_string, value_expr [, namespace_string ] ) </eps> \n The Purpose is: \n <code>INSERTXMLAFTER</code> inserts one or more nodes of any kind immediately after a target node that is not an attribute node. The XML document that is the target of the insertion can be schema-based or non-schema-based. This function is similar to insertXMLbefore, but it inserts after, not before, the target node. <code>XMLType_instance</code> specifies the target node of the of the insertion. <code>XPath_string</code> is an XPath 1.0 expression that locates in the target node zero or more nodes of any kind except attribute nodes. XML-data is inserted immediately after each of these nodes; that is, each node specified becomes the preceding sibling node of a node specified in <code>value_expr</code>. <code>value_expr</code> is the XML data to be inserted. You can specify one or more nodes of any kind. The order of the nodes is preserved after the insertion. The optional <code>namespace_string</code> is the namespace for the target node. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example is similar to that for <code>INSERTCHILDXML</code>, but it adds a third <code>/Owner</code> node after the <code>/Owner</code> node added in the other example. The output of the query has been formatted for readability. <code>UPDATE warehouses SET warehouse_spec = INSERTXMLAFTER(warehouse_spec, '/Warehouse/Building/Owner[1]', XMLType('<Owner>SecondOwner</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Building/Owner') \"Owners\" FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_NAME Owners ----------------------------------- ------------------------------ New Jersey <Owner>GrandCo</Owner> <Owner>SecondOwner</Owner> <Owner>LesserCo</Owner> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions078.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NTILE",
        "tree": "(other_function (over_clause_keyword NTILE) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> NTILE(expr) OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>expr</code> \n The Purpose is: \n <code>NTILE</code> is an analytic function. It divides an ordered data set into a number of buckets indicated by <code>expr</code> and assigns the appropriate bucket number to each row. The buckets are numbered 1 through <code>expr</code>. The <code>expr</code> value must resolve to a positive constant for each partition. Oracle Database expects an integer, and if <code>expr</code> is a noninteger constant, then Oracle truncates the value to an integer. The return value is <code>NUMBER</code>. The number of rows in the buckets can differ by at most 1. The remainder values (the remainder of number of rows divided by buckets) are distributed one for each bucket, starting with bucket 1. If <code>expr</code> is greater than the number of rows, then a number of buckets equal to the number of rows will be filled, and the remaining buckets will be empty. You cannot nest analytic functions by using <code>NTILE</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example divides into 4 buckets the values in the <code>salary</code> column of the <code>oe.employees</code> table from Department 100. The <code>salary</code> column has 6 values in this department, so the two extra values (the remainder of 6 / 4) are allocated to buckets 1 and 2, which therefore have one more value than buckets 3 or 4. <code>SELECT last_name, salary, NTILE(4) OVER (ORDER BY salary DESC) AS quartile FROM employees WHERE department_id = 100 ORDER BY last_name, salary, quartile; LAST_NAME SALARY QUARTILE ------------------------- ---------- ---------- Chen 8200 2 Faviet 9000 1 Greenberg 12008 1 Popp 6900 4 Sciarra 7700 3 Urman 7800 2 </code> ",
        "detail": "The Syntax is: \n <eps> NTILE(expr) OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>expr</code> \n The Purpose is: \n <code>NTILE</code> is an analytic function. It divides an ordered data set into a number of buckets indicated by <code>expr</code> and assigns the appropriate bucket number to each row. The buckets are numbered 1 through <code>expr</code>. The <code>expr</code> value must resolve to a positive constant for each partition. Oracle Database expects an integer, and if <code>expr</code> is a noninteger constant, then Oracle truncates the value to an integer. The return value is <code>NUMBER</code>. The number of rows in the buckets can differ by at most 1. The remainder values (the remainder of number of rows divided by buckets) are distributed one for each bucket, starting with bucket 1. If <code>expr</code> is greater than the number of rows, then a number of buckets equal to the number of rows will be filled, and the remaining buckets will be empty. You cannot nest analytic functions by using <code>NTILE</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example divides into 4 buckets the values in the <code>salary</code> column of the <code>oe.employees</code> table from Department 100. The <code>salary</code> column has 6 values in this department, so the two extra values (the remainder of 6 / 4) are allocated to buckets 1 and 2, which therefore have one more value than buckets 3 or 4. <code>SELECT last_name, salary, NTILE(4) OVER (ORDER BY salary DESC) AS quartile FROM employees WHERE department_id = 100 ORDER BY last_name, salary, quartile; LAST_NAME SALARY QUARTILE ------------------------- ---------- ---------- Chen 8200 2 Faviet 9000 1 Greenberg 12008 1 Popp 6900 4 Sciarra 7700 3 Urman 7800 2 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions115.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_LOB",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_LOB))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_LOB(long_column) </eps> \n The Purpose is: \n <code>TO_LOB</code> converts <code>LONG</code> or <code>LONG</code> RAW values in the column <code>long_column</code> to LOB values. You can apply this function only to a <code>LONG</code> or <code>LONG</code> <code>RAW</code> column, and only in the select list of a subquery in an <code>INSERT</code> statement. Before using this function, you must create a LOB column to receive the converted <code>LONG</code> values. To convert <code>LONG</code> values, create a <code>CLOB</code> column. To convert <code>LONG</code> RAW values, create a <code>BLOB</code> column. You cannot use the <code>TO_LOB</code> function to convert a <code>LONG</code> column to a LOB column in the subquery of a <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statement if you are creating an index-organized table. Instead, create the index-organized table without the <code>LONG</code> column, and then use the <code>TO_LOB</code> function in an <code>INSERT</code> ... <code>AS</code> <code>SELECT</code> statement. You cannot use this function within a PL/SQL package. Instead use the <code>TO_CLOB</code> or <code>TO_BLOB</code> functions. See Also: the <code>modify_col_properties</code> clause of <link>ALTER TABLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_3001.htm#CJAHHIBI</link> for an alternative method of converting <code>LONG</code> columns to LOB <link>INSERT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_9014.htm#i2163698</link> for information on the subquery of an <code>INSERT</code> statement \n The Examples is: \n The following syntax shows how to use the <code>TO_LOB</code> function on your <code>LONG</code> data in a hypothetical table <code>old_table</code>: <code>CREATE TABLE new_table (col1, col2, ... lob_col CLOB); INSERT INTO new_table (select o.col1, o.col2, ... TO_LOB(o.old_long_col) FROM old_table o; </code> ",
        "detail": "The Syntax is: \n <eps> TO_LOB(long_column) </eps> \n The Purpose is: \n <code>TO_LOB</code> converts <code>LONG</code> or <code>LONG</code> RAW values in the column <code>long_column</code> to LOB values. You can apply this function only to a <code>LONG</code> or <code>LONG</code> <code>RAW</code> column, and only in the select list of a subquery in an <code>INSERT</code> statement. Before using this function, you must create a LOB column to receive the converted <code>LONG</code> values. To convert <code>LONG</code> values, create a <code>CLOB</code> column. To convert <code>LONG</code> RAW values, create a <code>BLOB</code> column. You cannot use the <code>TO_LOB</code> function to convert a <code>LONG</code> column to a LOB column in the subquery of a <code>CREATE</code> <code>TABLE</code> ... <code>AS</code> <code>SELECT</code> statement if you are creating an index-organized table. Instead, create the index-organized table without the <code>LONG</code> column, and then use the <code>TO_LOB</code> function in an <code>INSERT</code> ... <code>AS</code> <code>SELECT</code> statement. You cannot use this function within a PL/SQL package. Instead use the <code>TO_CLOB</code> or <code>TO_BLOB</code> functions. See Also: the <code>modify_col_properties</code> clause of <link>ALTER TABLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_3001.htm#CJAHHIBI</link> for an alternative method of converting <code>LONG</code> columns to LOB <link>INSERT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_9014.htm#i2163698</link> for information on the subquery of an <code>INSERT</code> statement \n The Examples is: \n The following syntax shows how to use the <code>TO_LOB</code> function on your <code>LONG</code> data in a hypothetical table <code>old_table</code>: <code>CREATE TABLE new_table (col1, col2, ... lob_col CLOB); INSERT INTO new_table (select o.col1, o.col2, ... TO_LOB(o.old_long_col) FROM old_table o; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions205.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DELETEXML",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c DELETEXML))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> DELETEXML( XMLType_instance, XPath_string [, namespace_string ]) </eps> \n The Purpose is: \n <code>DELETEXML</code> deletes the node or nodes matched by the XPath expression in the target XML. <code>XMLType_instance</code> is an instance of <code>XMLType</code>. <code>XPath_string</code> is an Xpath expression indicating one or more nodes that are to be deleted. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. Any child nodes of the nodes specified by <code>XPath_string</code> are also deleted. The optional <code>namespace_string</code> provides namespace information for the <code>XPath_string</code>. This parameter must be of type <code>VARCHAR2</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example removes the <code>/Owner</code> node from the <code>warehouse_spec</code> of one of the warehouses modified in the example for <link>APPENDCHILDXML&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions012.htm#CIHEGIFE</link>: <code>UPDATE warehouses SET warehouse_spec = DELETEXML(warehouse_spec, '/Warehouse/Building/Owner') WHERE warehouse_id = 2; SELECT warehouse_id, warehouse_spec FROM warehouses WHERE warehouse_id in (2,3); ID WAREHOUSE_SPEC ---------- ----------------------------------- 2 <?xml version=\"1.0\"?> <Warehouse> <Building>Rented</Building> <Area>50000</Area> <Docks>1</Docks> <DockType>Side load</DockType> <WaterAccess>Y</WaterAccess> <RailAccess>N</RailAccess> <Parking>Lot</Parking> <VClearance>12 ft</VClearance> </Warehouse> 3 <?xml version=\"1.0\"?> <Warehouse> <Building>Rented<Owner>Grandco</Owner> </Building> <Area>85700</Area> <DockType/> <WaterAccess>N</WaterAccess> <RailAccess>N</RailAccess> <Parking>Street</Parking> <VClearance>11.5 ft</VClearance> </Warehouse> </code> ",
        "detail": "The Syntax is: \n <eps> DELETEXML( XMLType_instance, XPath_string [, namespace_string ]) </eps> \n The Purpose is: \n <code>DELETEXML</code> deletes the node or nodes matched by the XPath expression in the target XML. <code>XMLType_instance</code> is an instance of <code>XMLType</code>. <code>XPath_string</code> is an Xpath expression indicating one or more nodes that are to be deleted. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. Any child nodes of the nodes specified by <code>XPath_string</code> are also deleted. The optional <code>namespace_string</code> provides namespace information for the <code>XPath_string</code>. This parameter must be of type <code>VARCHAR2</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example removes the <code>/Owner</code> node from the <code>warehouse_spec</code> of one of the warehouses modified in the example for <link>APPENDCHILDXML&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions012.htm#CIHEGIFE</link>: <code>UPDATE warehouses SET warehouse_spec = DELETEXML(warehouse_spec, '/Warehouse/Building/Owner') WHERE warehouse_id = 2; SELECT warehouse_id, warehouse_spec FROM warehouses WHERE warehouse_id in (2,3); ID WAREHOUSE_SPEC ---------- ----------------------------------- 2 <?xml version=\"1.0\"?> <Warehouse> <Building>Rented</Building> <Area>50000</Area> <Docks>1</Docks> <DockType>Side load</DockType> <WaterAccess>Y</WaterAccess> <RailAccess>N</RailAccess> <Parking>Lot</Parking> <VClearance>12 ft</VClearance> </Warehouse> 3 <?xml version=\"1.0\"?> <Warehouse> <Building>Rented<Owner>Grandco</Owner> </Building> <Area>85700</Area> <DockType/> <WaterAccess>N</WaterAccess> <RailAccess>N</RailAccess> <Parking>Street</Parking> <VClearance>11.5 ft</VClearance> </Warehouse> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions051.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "HEXTORAW",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c HEXTORAW))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> HEXTORAW(char) </eps> \n The Purpose is: \n <code>HEXTORAW</code> converts <code>char</code> containing hexadecimal digits in the <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to a raw value. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example creates a simple table with a raw column, and inserts a hexadecimal value that has been converted to <code>RAW</code>: <code>CREATE TABLE test (raw_col RAW(10)); INSERT INTO test VALUES (HEXTORAW('7D')); </code> The following example converts hexadecimal digits to a raw value and casts the raw value to <code>VARCHAR2</code>: <code>SELECT UTL_RAW.CAST_TO_VARCHAR2(HEXTORAW('4041424344')) FROM DUAL; UTL_RAW.CAST_TO_VARCHAR2(HEXTORAW('4041424344')) ------------------------------------------------ @ABCD </code> See Also: <link>\"RAW and LONG RAW Data Types\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i46018</link> and <link>RAWTOHEX&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions143.htm#i78517</link> ",
        "detail": "The Syntax is: \n <eps> HEXTORAW(char) </eps> \n The Purpose is: \n <code>HEXTORAW</code> converts <code>char</code> containing hexadecimal digits in the <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to a raw value. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example creates a simple table with a raw column, and inserts a hexadecimal value that has been converted to <code>RAW</code>: <code>CREATE TABLE test (raw_col RAW(10)); INSERT INTO test VALUES (HEXTORAW('7D')); </code> The following example converts hexadecimal digits to a raw value and casts the raw value to <code>VARCHAR2</code>: <code>SELECT UTL_RAW.CAST_TO_VARCHAR2(HEXTORAW('4041424344')) FROM DUAL; UTL_RAW.CAST_TO_VARCHAR2(HEXTORAW('4041424344')) ------------------------------------------------ @ABCD </code> See Also: <link>\"RAW and LONG RAW Data Types\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i46018</link> and <link>RAWTOHEX&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions143.htm#i78517</link> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions073.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_BINARY_FLOAT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_BINARY_FLOAT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_BINARY_FLOAT(expr [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_BINARY_FLOAT</code> returns a single-precision floating-point number. <code>expr</code> can be a character string or a numeric value of type <code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>. If <code>expr</code> is <code>BINARY_FLOAT</code>, then the function returns <code>expr</code>. The optional '<code>fmt</code>' and '<code>nlsparam</code>' arguments are valid only if <code>expr</code> is a character string. They serve the same purpose as for the <code>TO_CHAR</code> (number) function. The incase-sensitive string '<code>INF</code>' is converted to positive infinity. The incase-sensitive string '-<code>INF</code>' is converted to negative identity. The incase-sensitive string '<code>NaN</code>' is converted to <code>NaN</code> (not a number). You cannot use a floating-point number format element (<code>F</code>, <code>f</code>, <code>D</code>, or <code>d</code>) in a character string <code>expr</code>. Conversions from character strings or <code>NUMBER</code> to <code>BINARY_FLOAT</code> can be inexact, because the <code>NUMBER</code> and character types use decimal precision to represent the numeric value and <code>BINARY_FLOAT</code> uses binary precision. Conversions from <code>BINARY_DOUBLE</code> to <code>BINARY_FLOAT</code> are inexact if the <code>BINARY_DOUBLE</code> value uses more bits of precision than supported by the <code>BINARY_FLOAT</code>. See Also: <link>TO_CHAR (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm#i79330</link> and <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> \n The Examples is: \n Using table <code>float_point_demo</code> created for <link>TO_BINARY_DOUBLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions196.htm#i1279235</link>, the following example converts a value of data type <code>NUMBER</code> to a value of data type <code>BINARY_FLOAT</code>: <code>SELECT dec_num, TO_BINARY_FLOAT(dec_num) FROM float_point_demo; DEC_NUM TO_BINARY_FLOAT(DEC_NUM) ---------- ------------------------ 1234.56 1.235E+003 </code> ",
        "detail": "The Syntax is: \n <eps> TO_BINARY_FLOAT(expr [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_BINARY_FLOAT</code> returns a single-precision floating-point number. <code>expr</code> can be a character string or a numeric value of type <code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>. If <code>expr</code> is <code>BINARY_FLOAT</code>, then the function returns <code>expr</code>. The optional '<code>fmt</code>' and '<code>nlsparam</code>' arguments are valid only if <code>expr</code> is a character string. They serve the same purpose as for the <code>TO_CHAR</code> (number) function. The incase-sensitive string '<code>INF</code>' is converted to positive infinity. The incase-sensitive string '-<code>INF</code>' is converted to negative identity. The incase-sensitive string '<code>NaN</code>' is converted to <code>NaN</code> (not a number). You cannot use a floating-point number format element (<code>F</code>, <code>f</code>, <code>D</code>, or <code>d</code>) in a character string <code>expr</code>. Conversions from character strings or <code>NUMBER</code> to <code>BINARY_FLOAT</code> can be inexact, because the <code>NUMBER</code> and character types use decimal precision to represent the numeric value and <code>BINARY_FLOAT</code> uses binary precision. Conversions from <code>BINARY_DOUBLE</code> to <code>BINARY_FLOAT</code> are inexact if the <code>BINARY_DOUBLE</code> value uses more bits of precision than supported by the <code>BINARY_FLOAT</code>. See Also: <link>TO_CHAR (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm#i79330</link> and <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> \n The Examples is: \n Using table <code>float_point_demo</code> created for <link>TO_BINARY_DOUBLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions196.htm#i1279235</link>, the following example converts a value of data type <code>NUMBER</code> to a value of data type <code>BINARY_FLOAT</code>: <code>SELECT dec_num, TO_BINARY_FLOAT(dec_num) FROM float_point_demo; DEC_NUM TO_BINARY_FLOAT(DEC_NUM) ---------- ------------------------ 1234.56 1.235E+003 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions197.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NLS_CHARSET_NAME",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NLS_CHARSET_NAME))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NLS_CHARSET_NAME(number) </eps> \n The Purpose is: \n <code>NLS_CHARSET_NAME</code> returns the name of the character set corresponding to ID number <code>number</code>. The character set name is returned as a <code>VARCHAR2</code> value in the database character set. If <code>number</code> is not recognized as a valid character set ID, then this function returns null. \n The Examples is: \n The following example returns the character set corresponding to character set ID number 2: <code>SELECT NLS_CHARSET_NAME(2) FROM DUAL; NLS_CH ------ WE8DEC </code> ",
        "detail": "The Syntax is: \n <eps> NLS_CHARSET_NAME(number) </eps> \n The Purpose is: \n <code>NLS_CHARSET_NAME</code> returns the name of the character set corresponding to ID number <code>number</code>. The character set name is returned as a <code>VARCHAR2</code> value in the database character set. If <code>number</code> is not recognized as a valid character set ID, then this function returns null. \n The Examples is: \n The following example returns the character set corresponding to character set ID number 2: <code>SELECT NLS_CHARSET_NAME(2) FROM DUAL; NLS_CH ------ WE8DEC </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions109.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DENSE_RANK",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c DENSE_RANK))) (function_argument ( )))",
        "description": "Aggregate The Syntax is: \n dense_rank_aggregate::= <eps> DENSE_RANK(expr [, expr ]...) WITHIN GROUP (ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [,expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) </eps> Analytic The Syntax is: \n dense_rank_analytic::= <eps> DENSE_RANK( ) OVER([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>DENSE_RANK</code> computes the rank of a row in an ordered group of rows and returns the rank as a <code>NUMBER</code>. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting. This function accepts as arguments any numeric data type and returns <code>NUMBER</code>. As an aggregate function, <code>DENSE_RANK</code> calculates the dense rank of a hypothetical row identified by the arguments of the function with respect to a given sort specification. The arguments of the function must all evaluate to constant expressions within each aggregate group, because they identify a single row within each group. The constant argument expressions and the expressions in the <code>order_by_clause</code> of the aggregate match by position. Therefore, the number of arguments must be the same and types must be compatible. As an analytic function, <code>DENSE_RANK</code> computes the rank of each row returned from a query with respect to the other rows, based on the values of the <code>value_exprs</code> in the <code>order_by_clause</code>. Aggregate Example The following example computes the ranking of a hypothetical employee with the salary $15,500 and a commission of 5% in the sample table <code>oe.employees</code>: <code>SELECT DENSE_RANK(15500, .05) WITHIN GROUP (ORDER BY salary DESC, commission_pct) \"Dense Rank\" FROM employees; Dense Rank ---------- 3 </code> Analytic Example The following statement ranks the employees in the sample <code>hr</code> schema in department 60 based on their salaries. Identical salary values receive the same rank. However, no rank values are skipped. Compare this example with the analytic example for <link>RANK&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions141.htm#i1269223</link>. <code>SELECT department_id, last_name, salary, DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary) DENSE_RANK FROM employees WHERE department_id = 60 ORDER BY DENSE_RANK, last_name; DEPARTMENT_ID LAST_NAME SALARY DENSE_RANK ------------- ------------------------- ---------- ---------- 60 Lorentz 4200 1 60 Austin 4800 2 60 Pataballa 4800 2 60 Ernst 6000 3 60 Hunold 9000 4 </code> ",
        "detail": "Aggregate The Syntax is: \n dense_rank_aggregate::= <eps> DENSE_RANK(expr [, expr ]...) WITHIN GROUP (ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [,expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) </eps> Analytic The Syntax is: \n dense_rank_analytic::= <eps> DENSE_RANK( ) OVER([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>DENSE_RANK</code> computes the rank of a row in an ordered group of rows and returns the rank as a <code>NUMBER</code>. The ranks are consecutive integers beginning with 1. The largest rank value is the number of unique values returned by the query. Rank values are not skipped in the event of ties. Rows with equal values for the ranking criteria receive the same rank. This function is useful for top-N and bottom-N reporting. This function accepts as arguments any numeric data type and returns <code>NUMBER</code>. As an aggregate function, <code>DENSE_RANK</code> calculates the dense rank of a hypothetical row identified by the arguments of the function with respect to a given sort specification. The arguments of the function must all evaluate to constant expressions within each aggregate group, because they identify a single row within each group. The constant argument expressions and the expressions in the <code>order_by_clause</code> of the aggregate match by position. Therefore, the number of arguments must be the same and types must be compatible. As an analytic function, <code>DENSE_RANK</code> computes the rank of each row returned from a query with respect to the other rows, based on the values of the <code>value_exprs</code> in the <code>order_by_clause</code>. Aggregate Example The following example computes the ranking of a hypothetical employee with the salary $15,500 and a commission of 5% in the sample table <code>oe.employees</code>: <code>SELECT DENSE_RANK(15500, .05) WITHIN GROUP (ORDER BY salary DESC, commission_pct) \"Dense Rank\" FROM employees; Dense Rank ---------- 3 </code> Analytic Example The following statement ranks the employees in the sample <code>hr</code> schema in department 60 based on their salaries. Identical salary values receive the same rank. However, no rank values are skipped. Compare this example with the analytic example for <link>RANK&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions141.htm#i1269223</link>. <code>SELECT department_id, last_name, salary, DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary) DENSE_RANK FROM employees WHERE department_id = 60 ORDER BY DENSE_RANK, last_name; DEPARTMENT_ID LAST_NAME SALARY DENSE_RANK ------------- ------------------------- ---------- ---------- 60 Lorentz 4200 1 60 Austin 4800 2 60 Pataballa 4800 2 60 Ernst 6000 3 60 Hunold 9000 4 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions052.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ORA_DST_ERROR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ORA_DST_ERROR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ORA_DST_ERROR(datetime_expr) </eps> \n The Purpose is: \n <code>ORA_DST_ERROR</code> is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value or a <code>VARRAY</code> object that contains <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values, and indicates whether the datetime value will result in an error with the new time zone data. The return values are: <code>0</code>: the datetime value does not result in an error with the new time zone data. <code>1878</code>: the datetime value results in a \"nonexisting time\" error. <code>1883</code>: the datetime value results in a \"duplicate time\" error. This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the <code>DBMS_DST</code>.<code>BEGIN_PREPARE</code> and the <code>DBMS_DST</code>.<code>END_PREPARE</code> procedures or between the execution of the <code>DBMS_DST</code>.<code>BEGIN_UPGRADE</code> and the <code>DBMS_DST</code>.<code>END_UPGRADE</code> procedures. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm#NLSPG259</link> for more information on time zone datafiles and on how Oracle Database handles daylight saving time, and <link>Oracle Database PL/SQL Packages and Types Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_dst.htm#ARPLS234</link> for information on the <code>DBMS_DST</code> package ",
        "detail": "The Syntax is: \n <eps> ORA_DST_ERROR(datetime_expr) </eps> \n The Purpose is: \n <code>ORA_DST_ERROR</code> is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value or a <code>VARRAY</code> object that contains <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values, and indicates whether the datetime value will result in an error with the new time zone data. The return values are: <code>0</code>: the datetime value does not result in an error with the new time zone data. <code>1878</code>: the datetime value results in a \"nonexisting time\" error. <code>1883</code>: the datetime value results in a \"duplicate time\" error. This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the <code>DBMS_DST</code>.<code>BEGIN_PREPARE</code> and the <code>DBMS_DST</code>.<code>END_PREPARE</code> procedures or between the execution of the <code>DBMS_DST</code>.<code>BEGIN_UPGRADE</code> and the <code>DBMS_DST</code>.<code>END_UPGRADE</code> procedures. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm#NLSPG259</link> for more information on time zone datafiles and on how Oracle Database handles daylight saving time, and <link>Oracle Database PL/SQL Packages and Types Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_dst.htm#ARPLS234</link> for information on the <code>DBMS_DST</code> package ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions123.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "INSTR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c INSTR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> { INSTR | INSTRB | INSTRC | INSTR2 | INSTR4 } (string , substring [, position [, occurrence ] ]) </eps> \n The Purpose is: \n The <code>INSTR</code> functions search <code>string</code> for <code>substring</code>. The search operation is defined as comparing the <code>substring</code> argument with substrings of <code>string</code> of the same length for equality until a match is found or there are no more substrings left. Each consecutive compared substring of <code>string</code> begins one character to the right (for forward searches) or one character to the left (for backward searches) from the first character of the previous compared substring. If a substring that is equal to <code>substring</code> is found, then the function returns an integer indicating the position of the first character of this substring. If no such substring is found, then the function returns zero. <code>position</code> is an nonzero integer indicating the character of <code>string</code> where Oracle Database begins the search\u2014that is, the position of the first character of the first substring to compare with <code>substring</code>. If <code>position</code> is negative, then Oracle counts backward from the end of <code>string</code> and then searches backward from the resulting position. <code>occurrence</code> is an integer indicating which occurrence of <code>substring</code> in <code>string</code> Oracle should search for. The value of <code>occurrence</code> must be positive. If <code>occurrence</code> is greater than 1, then the database does not return on the first match but continues comparing consecutive substrings of <code>string</code>, as described above, until match number <code>occurrence</code> has been found. <code>INSTR</code> accepts and returns positions in characters as defined by the input character set, with the first character of string having position 1. <code>INSTRB</code> uses bytes instead of characters. <code>INSTRC</code> uses Unicode complete characters. <code>INSTR2</code> uses UCS2 code points. <code>INSTR4</code> uses UCS4 code points. <code>string</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The exceptions are <code>INSTRC</code>, <code>INSTR2</code>, and <code>INSTR4</code>, which do not allow <code>string</code> to be a <code>CLOB</code> or <code>NCLOB</code>. <code>substring</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The value returned is of <code>NUMBER</code> data type. Both <code>position</code> and <code>occurrence</code> must be of data type <code>NUMBER</code>, or any data type that can be implicitly converted to <code>NUMBER</code>, and must resolve to an integer. The default values of both <code>position</code> and <code>occurrence</code> are 1, meaning Oracle begins searching at the first character of <code>string</code> for the first occurrence of <code>substring</code>. The return value is relative to the beginning of <code>string</code>, regardless of the value of <code>position</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example searches the string <code>CORPORATE</code> <code>FLOOR</code>, beginning with the third character, for the string \"<code>OR</code>\". It returns the position in <code>CORPORATE</code> <code>FLOOR</code> at which the second occurrence of \"<code>OR</code>\" begins: <code>SELECT INSTR('CORPORATE FLOOR','OR', 3, 2) \"Instring\" FROM DUAL; Instring ---------- 14 </code> In the next example, Oracle counts backward from the last character to the third character from the end, which is the first <code>O</code> in <code>FLOOR</code>. Oracle then searches backward for the second occurrence of <code>OR</code>, and finds that this second occurrence begins with the second character in the search string : <code>SELECT INSTR('CORPORATE FLOOR','OR', -3, 2) \"Reversed Instring\" FROM DUAL; Reversed Instring ----------------- 2 </code> The next example assumes a double-byte database character set. <code>SELECT INSTRB('CORPORATE FLOOR','OR',5,2) \"Instring in bytes\" FROM DUAL; Instring in bytes ----------------- 27 </code> ",
        "detail": "The Syntax is: \n <eps> { INSTR | INSTRB | INSTRC | INSTR2 | INSTR4 } (string , substring [, position [, occurrence ] ]) </eps> \n The Purpose is: \n The <code>INSTR</code> functions search <code>string</code> for <code>substring</code>. The search operation is defined as comparing the <code>substring</code> argument with substrings of <code>string</code> of the same length for equality until a match is found or there are no more substrings left. Each consecutive compared substring of <code>string</code> begins one character to the right (for forward searches) or one character to the left (for backward searches) from the first character of the previous compared substring. If a substring that is equal to <code>substring</code> is found, then the function returns an integer indicating the position of the first character of this substring. If no such substring is found, then the function returns zero. <code>position</code> is an nonzero integer indicating the character of <code>string</code> where Oracle Database begins the search\u2014that is, the position of the first character of the first substring to compare with <code>substring</code>. If <code>position</code> is negative, then Oracle counts backward from the end of <code>string</code> and then searches backward from the resulting position. <code>occurrence</code> is an integer indicating which occurrence of <code>substring</code> in <code>string</code> Oracle should search for. The value of <code>occurrence</code> must be positive. If <code>occurrence</code> is greater than 1, then the database does not return on the first match but continues comparing consecutive substrings of <code>string</code>, as described above, until match number <code>occurrence</code> has been found. <code>INSTR</code> accepts and returns positions in characters as defined by the input character set, with the first character of string having position 1. <code>INSTRB</code> uses bytes instead of characters. <code>INSTRC</code> uses Unicode complete characters. <code>INSTR2</code> uses UCS2 code points. <code>INSTR4</code> uses UCS4 code points. <code>string</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The exceptions are <code>INSTRC</code>, <code>INSTR2</code>, and <code>INSTR4</code>, which do not allow <code>string</code> to be a <code>CLOB</code> or <code>NCLOB</code>. <code>substring</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The value returned is of <code>NUMBER</code> data type. Both <code>position</code> and <code>occurrence</code> must be of data type <code>NUMBER</code>, or any data type that can be implicitly converted to <code>NUMBER</code>, and must resolve to an integer. The default values of both <code>position</code> and <code>occurrence</code> are 1, meaning Oracle begins searching at the first character of <code>string</code> for the first occurrence of <code>substring</code>. The return value is relative to the beginning of <code>string</code>, regardless of the value of <code>position</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example searches the string <code>CORPORATE</code> <code>FLOOR</code>, beginning with the third character, for the string \"<code>OR</code>\". It returns the position in <code>CORPORATE</code> <code>FLOOR</code> at which the second occurrence of \"<code>OR</code>\" begins: <code>SELECT INSTR('CORPORATE FLOOR','OR', 3, 2) \"Instring\" FROM DUAL; Instring ---------- 14 </code> In the next example, Oracle counts backward from the last character to the third character from the end, which is the first <code>O</code> in <code>FLOOR</code>. Oracle then searches backward for the second occurrence of <code>OR</code>, and finds that this second occurrence begins with the second character in the search string : <code>SELECT INSTR('CORPORATE FLOOR','OR', -3, 2) \"Reversed Instring\" FROM DUAL; Reversed Instring ----------------- 2 </code> The next example assumes a double-byte database character set. <code>SELECT INSTRB('CORPORATE FLOOR','OR',5,2) \"Instring in bytes\" FROM DUAL; Instring in bytes ----------------- 27 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions080.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LAST_DAY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LAST_DAY))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LAST_DAY(date) </eps> \n The Purpose is: \n <code>LAST_DAY</code> returns the date of the last day of the month that contains <code>date</code>. The last day of the month is defined by the session parameter <code>NLS_CALENDAR</code>. The return type is always <code>DATE</code>, regardless of the data type of <code>date</code>. \n The Examples is: \n The following statement determines how many days are left in the current month. <code>SELECT SYSDATE, LAST_DAY(SYSDATE) \"Last\", LAST_DAY(SYSDATE) - SYSDATE \"Days Left\" FROM DUAL; SYSDATE Last Days Left --------- --------- ---------- 30-MAY-09 31-MAY-09 1 </code> The following example adds <code>5</code> months to the hire date of each employee to give an evaluation date: <code>SELECT last_name, hire_date, TO_CHAR(ADD_MONTHS(LAST_DAY(hire_date), 5)) \"Eval Date\" FROM employees ORDER BY last_name, hire_date; LAST_NAME HIRE_DATE Eval Date ------------------------- --------- --------- Abel 11-MAY-04 31-OCT-04 Ande 24-MAR-08 31-AUG-08 Atkinson 30-OCT-05 31-MAR-06 Austin 25-JUN-05 30-NOV-05 Baer 07-JUN-02 30-NOV-02 Baida 24-DEC-05 31-MAY-06 Banda 21-APR-08 30-SEP-08 Bates 24-MAR-07 31-AUG-07 . . . </code> ",
        "detail": "The Syntax is: \n <eps> LAST_DAY(date) </eps> \n The Purpose is: \n <code>LAST_DAY</code> returns the date of the last day of the month that contains <code>date</code>. The last day of the month is defined by the session parameter <code>NLS_CALENDAR</code>. The return type is always <code>DATE</code>, regardless of the data type of <code>date</code>. \n The Examples is: \n The following statement determines how many days are left in the current month. <code>SELECT SYSDATE, LAST_DAY(SYSDATE) \"Last\", LAST_DAY(SYSDATE) - SYSDATE \"Days Left\" FROM DUAL; SYSDATE Last Days Left --------- --------- ---------- 30-MAY-09 31-MAY-09 1 </code> The following example adds <code>5</code> months to the hire date of each employee to give an evaluation date: <code>SELECT last_name, hire_date, TO_CHAR(ADD_MONTHS(LAST_DAY(hire_date), 5)) \"Eval Date\" FROM employees ORDER BY last_name, hire_date; LAST_NAME HIRE_DATE Eval Date ------------------------- --------- --------- Abel 11-MAY-04 31-OCT-04 Ande 24-MAR-08 31-AUG-08 Atkinson 30-OCT-05 31-MAR-06 Austin 25-JUN-05 30-NOV-05 Baer 07-JUN-02 30-NOV-02 Baida 24-DEC-05 31-MAY-06 Banda 21-APR-08 30-SEP-08 Bates 24-MAR-07 31-AUG-07 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions084.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "COLLECT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c COLLECT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> COLLECT( [ DISTINCT | UNIQUE ] column [ ORDER BY expr ] ) </eps> \n The Purpose is: \n <code>COLLECT</code> is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a <code>CAST</code> function. If <code>column</code> is itself a collection, then the output of <code>COLLECT</code> is a nested table of collections. If <code>column</code> is of a user-defined type, then <code>column</code> must have a <code>MAP</code> or <code>ORDER</code> method defined on it in order for you to use the optional <code>DISTINCT</code>, <code>UNIQUE</code>, and <code>ORDER</code> <code>BY</code> clauses. See Also: <link>CAST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions023.htm#i1269136</link> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> \n The Examples is: \n The following example creates a nested table from the varray column of phone numbers in the sample table <code>oe.customers</code>. The nested table includes only the phone numbers of customers with an income level of <code>L</code>: <code>300,000</code> <code>and</code> <code>above</code>. <code>CREATE TYPE phone_book_t AS TABLE OF phone_list_typ; / SELECT CAST(COLLECT(phone_numbers) AS phone_book_t) \"Income Level L Phone Book\" FROM customers WHERE income_level = 'L: 300,000 and above'; Income Level L Phone Book -------------------------------------------------------------------------------- PHONE_BOOK_T(PHONE_LIST_TYP('+1 414 123 4307'), PHONE_LIST_TYP('+1 608 123 4344' ), PHONE_LIST_TYP('+1 814 123 4696'), PHONE_LIST_TYP('+1 215 123 4721'), PHONE_L IST_TYP('+1 814 123 4755'), PHONE_LIST_TYP('+91 11 012 4817', '+91 11 083 4817') , PHONE_LIST_TYP('+91 172 012 4837'), PHONE_LIST_TYP('+41 31 012 3569', '+41 31 083 3569')) </code> The following example creates a nested table from the column of warehouse names in the sample table <code>oe</code>.<code>warehouses</code>. It uses <code>ORDER</code> <code>BY</code> to order the warehouse names. <code>CREATE TYPE warehouse_name_t AS TABLE OF VARCHAR2(35); / SELECT CAST(COLLECT(warehouse_name ORDER BY warehouse_name) AS warehouse_name_t) \"Warehouses\" FROM warehouses; Warehouses -------------------------------------------------------------------------------- WAREHOUSE_NAME_TYP('Beijing', 'Bombay', 'Mexico City', 'New Jersey', 'San Franci sco', 'Seattle, Washington', 'Southlake, Texas', 'Sydney', 'Toronto') </code> ",
        "detail": "The Syntax is: \n <eps> COLLECT( [ DISTINCT | UNIQUE ] column [ ORDER BY expr ] ) </eps> \n The Purpose is: \n <code>COLLECT</code> is an aggregate function that takes as its argument a column of any type and creates a nested table of the input type out of the rows selected. To get accurate results from this function you must use it within a <code>CAST</code> function. If <code>column</code> is itself a collection, then the output of <code>COLLECT</code> is a nested table of collections. If <code>column</code> is of a user-defined type, then <code>column</code> must have a <code>MAP</code> or <code>ORDER</code> method defined on it in order for you to use the optional <code>DISTINCT</code>, <code>UNIQUE</code>, and <code>ORDER</code> <code>BY</code> clauses. See Also: <link>CAST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions023.htm#i1269136</link> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> \n The Examples is: \n The following example creates a nested table from the varray column of phone numbers in the sample table <code>oe.customers</code>. The nested table includes only the phone numbers of customers with an income level of <code>L</code>: <code>300,000</code> <code>and</code> <code>above</code>. <code>CREATE TYPE phone_book_t AS TABLE OF phone_list_typ; / SELECT CAST(COLLECT(phone_numbers) AS phone_book_t) \"Income Level L Phone Book\" FROM customers WHERE income_level = 'L: 300,000 and above'; Income Level L Phone Book -------------------------------------------------------------------------------- PHONE_BOOK_T(PHONE_LIST_TYP('+1 414 123 4307'), PHONE_LIST_TYP('+1 608 123 4344' ), PHONE_LIST_TYP('+1 814 123 4696'), PHONE_LIST_TYP('+1 215 123 4721'), PHONE_L IST_TYP('+1 814 123 4755'), PHONE_LIST_TYP('+91 11 012 4817', '+91 11 083 4817') , PHONE_LIST_TYP('+91 172 012 4837'), PHONE_LIST_TYP('+41 31 012 3569', '+41 31 083 3569')) </code> The following example creates a nested table from the column of warehouse names in the sample table <code>oe</code>.<code>warehouses</code>. It uses <code>ORDER</code> <code>BY</code> to order the warehouse names. <code>CREATE TYPE warehouse_name_t AS TABLE OF VARCHAR2(35); / SELECT CAST(COLLECT(warehouse_name ORDER BY warehouse_name) AS warehouse_name_t) \"Warehouses\" FROM warehouses; Warehouses -------------------------------------------------------------------------------- WAREHOUSE_NAME_TYP('Beijing', 'Bombay', 'Mexico City', 'New Jersey', 'San Franci sco', 'Seattle, Washington', 'Southlake, Texas', 'Sydney', 'Toronto') </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions031.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYS_GUID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYS_GUID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYS_GUID( ) </eps> \n The Purpose is: \n <code>SYS_GUID</code> generates and returns a globally unique identifier (<code>RAW</code> value) made up of 16 bytes. On most platforms, the generated identifier consists of a host identifier, a process or thread identifier of the process or thread invoking the function, and a nonrepeating value (sequence of bytes) for that process or thread. \n The Examples is: \n The following example adds a column to the sample table <code>hr.locations</code>, inserts unique identifiers into each row, and returns the 32-character hexadecimal representation of the 16-byte <code>RAW</code> value of the global unique identifier: <code>ALTER TABLE locations ADD (uid_col RAW(16)); UPDATE locations SET uid_col = SYS_GUID(); SELECT location_id, uid_col FROM locations ORDER BY location_id, uid_col; LOCATION_ID UID_COL ----------- ---------------------------------------------------------------- 1000 09F686761827CF8AE040578CB20B7491 1100 09F686761828CF8AE040578CB20B7491 1200 09F686761829CF8AE040578CB20B7491 1300 09F68676182ACF8AE040578CB20B7491 1400 09F68676182BCF8AE040578CB20B7491 1500 09F68676182CCF8AE040578CB20B7491 . . . </code> ",
        "detail": "The Syntax is: \n <eps> SYS_GUID( ) </eps> \n The Purpose is: \n <code>SYS_GUID</code> generates and returns a globally unique identifier (<code>RAW</code> value) made up of 16 bytes. On most platforms, the generated identifier consists of a host identifier, a process or thread identifier of the process or thread invoking the function, and a nonrepeating value (sequence of bytes) for that process or thread. \n The Examples is: \n The following example adds a column to the sample table <code>hr.locations</code>, inserts unique identifiers into each row, and returns the 32-character hexadecimal representation of the 16-byte <code>RAW</code> value of the global unique identifier: <code>ALTER TABLE locations ADD (uid_col RAW(16)); UPDATE locations SET uid_col = SYS_GUID(); SELECT location_id, uid_col FROM locations ORDER BY location_id, uid_col; LOCATION_ID UID_COL ----------- ---------------------------------------------------------------- 1000 09F686761827CF8AE040578CB20B7491 1100 09F686761828CF8AE040578CB20B7491 1200 09F686761829CF8AE040578CB20B7491 1300 09F68676182ACF8AE040578CB20B7491 1400 09F68676182BCF8AE040578CB20B7491 1500 09F68676182CCF8AE040578CB20B7491 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions187.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_CLOB",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_CLOB))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_CLOB(lob_column | char) </eps> \n The Purpose is: \n <code>TO_CLOB</code> converts <code>NCLOB</code> values in a LOB column or other character strings to <code>CLOB</code> values. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. Oracle Database executes this function by converting the underlying LOB data from the national character set to the database character set. From within a PL/SQL package, you can use the <code>TO_CLOB</code> function to convert <code>RAW</code>, <code>CHAR</code>, <code>VARCHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code> values to <code>CLOB</code> or <code>NCLOB</code> values. \n The Examples is: \n The following statement converts <code>NCLOB</code> data from the sample <code>pm.print_media</code> table to <code>CLOB</code> and inserts it into a <code>CLOB</code> column, replacing existing data in that column. <code>UPDATE PRINT_MEDIA SET AD_FINALTEXT = TO_CLOB (AD_FLTEXTN); </code> ",
        "detail": "The Syntax is: \n <eps> TO_CLOB(lob_column | char) </eps> \n The Purpose is: \n <code>TO_CLOB</code> converts <code>NCLOB</code> values in a LOB column or other character strings to <code>CLOB</code> values. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. Oracle Database executes this function by converting the underlying LOB data from the national character set to the database character set. From within a PL/SQL package, you can use the <code>TO_CLOB</code> function to convert <code>RAW</code>, <code>CHAR</code>, <code>VARCHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code> values to <code>CLOB</code> or <code>NCLOB</code> values. \n The Examples is: \n The following statement converts <code>NCLOB</code> data from the sample <code>pm.print_media</code> table to <code>CLOB</code> and inserts it into a <code>CLOB</code> column, replacing existing data in that column. <code>UPDATE PRINT_MEDIA SET AD_FINALTEXT = TO_CLOB (AD_FLTEXTN); </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions202.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "COALESCE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c COALESCE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> COALESCE(expr [, expr ]...) </eps> \n The Purpose is: \n <code>COALESCE</code> returns the first non-null <code>expr</code> in the expression list. You must specify at least two expressions. If all occurrences of <code>expr</code> evaluate to null, then the function returns null. Oracle Database uses short-circuit evaluation. The database evaluates each <code>expr</code> value and determines whether it is <code>NULL</code>, rather than evaluating all of the <code>expr</code> values before determining whether any of them is <code>NULL</code>. If all occurrences of <code>expr</code> are numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence This function is a generalization of the <code>NVL</code> function. You can also use <code>COALESCE</code> as a variety of the <code>CASE</code> expression. For example, <code>COALESCE(expr1, expr2) </code> is equivalent to: <code>CASE WHEN expr1 IS NOT NULL THEN expr1 ELSE expr2 END </code> Similarly, <code>COALESCE(expr1, expr2, ..., exprn) </code> where <code>n</code> >= 3, is equivalent to: <code>CASE WHEN expr1 IS NOT NULL THEN expr1 ELSE COALESCE (expr2, ..., exprn) END </code> See Also: <link>NVL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions119.htm#i91798</link> and <link>\"CASE Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm#i1033392</link> \n The Examples is: \n The following example uses the sample <code>oe.product_information</code> table to organize a clearance sale of products. It gives a 10% discount to all products with a list price. If there is no list price, then the sale price is the minimum price. If there is no minimum price, then the sale price is \"5\": <code>SELECT product_id, list_price, min_price, COALESCE(0.9*list_price, min_price, 5) \"Sale\" FROM product_information WHERE supplier_id = 102050 ORDER BY product_id; PRODUCT_ID LIST_PRICE MIN_PRICE Sale ---------- ---------- ---------- ---------- 1769 48 43.2 1770 73 73 2378 305 247 274.5 2382 850 731 765 3355 5 </code> ",
        "detail": "The Syntax is: \n <eps> COALESCE(expr [, expr ]...) </eps> \n The Purpose is: \n <code>COALESCE</code> returns the first non-null <code>expr</code> in the expression list. You must specify at least two expressions. If all occurrences of <code>expr</code> evaluate to null, then the function returns null. Oracle Database uses short-circuit evaluation. The database evaluates each <code>expr</code> value and determines whether it is <code>NULL</code>, rather than evaluating all of the <code>expr</code> values before determining whether any of them is <code>NULL</code>. If all occurrences of <code>expr</code> are numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence This function is a generalization of the <code>NVL</code> function. You can also use <code>COALESCE</code> as a variety of the <code>CASE</code> expression. For example, <code>COALESCE(expr1, expr2) </code> is equivalent to: <code>CASE WHEN expr1 IS NOT NULL THEN expr1 ELSE expr2 END </code> Similarly, <code>COALESCE(expr1, expr2, ..., exprn) </code> where <code>n</code> >= 3, is equivalent to: <code>CASE WHEN expr1 IS NOT NULL THEN expr1 ELSE COALESCE (expr2, ..., exprn) END </code> See Also: <link>NVL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions119.htm#i91798</link> and <link>\"CASE Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm#i1033392</link> \n The Examples is: \n The following example uses the sample <code>oe.product_information</code> table to organize a clearance sale of products. It gives a 10% discount to all products with a list price. If there is no list price, then the sale price is the minimum price. If there is no minimum price, then the sale price is \"5\": <code>SELECT product_id, list_price, min_price, COALESCE(0.9*list_price, min_price, 5) \"Sale\" FROM product_information WHERE supplier_id = 102050 ORDER BY product_id; PRODUCT_ID LIST_PRICE MIN_PRICE Sale ---------- ---------- ---------- ---------- 1769 48 43.2 1770 73 73 2378 305 247 274.5 2382 850 731 765 3355 5 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions030.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_TIMESTAMP_TZ",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_TIMESTAMP_TZ))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_TIMESTAMP_TZ(char [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_TIMESTAMP_TZ</code> converts <code>char</code> of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to a value of <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> data type. Note: This function does not convert character strings to <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>. To do this, use a <code>CAST</code> function, as shown in <link>CAST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions023.htm#i1269136</link>. The optional <code>fmt</code> specifies the format of <code>char</code>. If you omit <code>fmt</code>, then <code>char</code> must be in the default format of the <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> data type. The optional <code>'nlsparam'</code> has the same purpose in this function as in the <code>TO_CHAR</code> function for date conversion. \n The Examples is: \n The following example converts a character string to a value of <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>: <code>SELECT TO_TIMESTAMP_TZ('1999-12-01 11:00:00 -8:00', 'YYYY-MM-DD HH:MI:SS TZH:TZM') FROM DUAL; TO_TIMESTAMP_TZ('1999-12-0111:00:00-08:00','YYYY-MM-DDHH:MI:SSTZH:TZM') -------------------------------------------------------------------- 01-DEC-99 11.00.00.000000000 AM -08:00 </code> The following example casts a null column in a <code>UNION</code> operation as <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code> using the sample tables <code>oe.order_items</code> and <code>oe.orders</code>: <code>SELECT order_id, line_item_id, CAST(NULL AS TIMESTAMP WITH LOCAL TIME ZONE) order_date FROM order_items UNION SELECT order_id, to_number(null), order_date FROM orders; ORDER_ID LINE_ITEM_ID ORDER_DATE ---------- ------------ ----------------------------------- 2354 1 2354 2 2354 3 2354 4 2354 5 2354 6 2354 7 2354 8 2354 9 2354 10 2354 11 2354 12 2354 13 2354 14-JUL-00 05.18.23.234567 PM 2355 1 2355 2 . . . </code> ",
        "detail": "The Syntax is: \n <eps> TO_TIMESTAMP_TZ(char [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_TIMESTAMP_TZ</code> converts <code>char</code> of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to a value of <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> data type. Note: This function does not convert character strings to <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>. To do this, use a <code>CAST</code> function, as shown in <link>CAST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions023.htm#i1269136</link>. The optional <code>fmt</code> specifies the format of <code>char</code>. If you omit <code>fmt</code>, then <code>char</code> must be in the default format of the <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> data type. The optional <code>'nlsparam'</code> has the same purpose in this function as in the <code>TO_CHAR</code> function for date conversion. \n The Examples is: \n The following example converts a character string to a value of <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>: <code>SELECT TO_TIMESTAMP_TZ('1999-12-01 11:00:00 -8:00', 'YYYY-MM-DD HH:MI:SS TZH:TZM') FROM DUAL; TO_TIMESTAMP_TZ('1999-12-0111:00:00-08:00','YYYY-MM-DDHH:MI:SSTZH:TZM') -------------------------------------------------------------------- 01-DEC-99 11.00.00.000000000 AM -08:00 </code> The following example casts a null column in a <code>UNION</code> operation as <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code> using the sample tables <code>oe.order_items</code> and <code>oe.orders</code>: <code>SELECT order_id, line_item_id, CAST(NULL AS TIMESTAMP WITH LOCAL TIME ZONE) order_date FROM order_items UNION SELECT order_id, to_number(null), order_date FROM orders; ORDER_ID LINE_ITEM_ID ORDER_DATE ---------- ------------ ----------------------------------- 2354 1 2354 2 2354 3 2354 4 2354 5 2354 6 2354 7 2354 8 2354 9 2354 10 2354 11 2354 12 2354 13 2354 14-JUL-00 05.18.23.234567 PM 2355 1 2355 2 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions214.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "BFILENAME",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c BFILENAME))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> BFILENAME('directory', 'filename') </eps> \n The Purpose is: \n <code>BFILENAME</code> returns a <code>BFILE</code> locator that is associated with a physical LOB binary file on the server file system. '<code>directory</code>' is a database object that serves as an alias for a full path name on the server file system where the files are actually located. '<code>filename</code>' is the name of the file in the server file system. You must create the directory object and associate a <code>BFILE</code> value with a physical file before you can use them as arguments to <code>BFILENAME</code> in a SQL or PL/SQL statement, <code>DBMS_LOB</code> package, or OCI operation. You can use this function in two ways: In a DML statement to initialize a <code>BFILE</code> column In a programmatic interface to access <code>BFILE</code> data by assigning a value to the <code>BFILE</code> locator The directory argument is case sensitive. You must ensure that you specify the directory object name exactly as it exists in the data dictionary. For example, if an <code>\"Admin\"</code> directory object was created using mixed case and a quoted identifier in the <code>CREATE</code> <code>DIRECTORY</code> statement, then when using the <code>BFILENAME</code> function you must refer to the directory object as <code>'Admin'</code>. You must specify the filename argument according to the case and punctuation conventions for your operating system. See Also: <link>Oracle Database SecureFiles and Large Objects Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e18294/adlob_bfile_ops.htm#ADLOB012</link> and <link>Oracle Call Interface Programmer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e10646/oci03typ.htm#LNOCI030</link> for more information on LOBs and for examples of retrieving <code>BFILE</code> data <link>CREATE DIRECTORY&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_5007.htm#i2061958</link> \n The Examples is: \n The following example inserts a row into the sample table <code>pm.print_media</code>. The example uses the <code>BFILENAME</code> function to identify a binary file on the server file system in the directory <code>/demo/schema/product_media</code>. The example shows how the directory database object <code>media_dir</code> was created in the <code>pm</code> schema. <code>CREATE DIRECTORY media_dir AS '/demo/schema/product_media'; INSERT INTO print_media (product_id, ad_id, ad_graphic) VALUES (3000, 31001, BFILENAME('MEDIA_DIR', 'modem_comp_ad.gif')); </code> ",
        "detail": "The Syntax is: \n <eps> BFILENAME('directory', 'filename') </eps> \n The Purpose is: \n <code>BFILENAME</code> returns a <code>BFILE</code> locator that is associated with a physical LOB binary file on the server file system. '<code>directory</code>' is a database object that serves as an alias for a full path name on the server file system where the files are actually located. '<code>filename</code>' is the name of the file in the server file system. You must create the directory object and associate a <code>BFILE</code> value with a physical file before you can use them as arguments to <code>BFILENAME</code> in a SQL or PL/SQL statement, <code>DBMS_LOB</code> package, or OCI operation. You can use this function in two ways: In a DML statement to initialize a <code>BFILE</code> column In a programmatic interface to access <code>BFILE</code> data by assigning a value to the <code>BFILE</code> locator The directory argument is case sensitive. You must ensure that you specify the directory object name exactly as it exists in the data dictionary. For example, if an <code>\"Admin\"</code> directory object was created using mixed case and a quoted identifier in the <code>CREATE</code> <code>DIRECTORY</code> statement, then when using the <code>BFILENAME</code> function you must refer to the directory object as <code>'Admin'</code>. You must specify the filename argument according to the case and punctuation conventions for your operating system. See Also: <link>Oracle Database SecureFiles and Large Objects Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e18294/adlob_bfile_ops.htm#ADLOB012</link> and <link>Oracle Call Interface Programmer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e10646/oci03typ.htm#LNOCI030</link> for more information on LOBs and for examples of retrieving <code>BFILE</code> data <link>CREATE DIRECTORY&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_5007.htm#i2061958</link> \n The Examples is: \n The following example inserts a row into the sample table <code>pm.print_media</code>. The example uses the <code>BFILENAME</code> function to identify a binary file on the server file system in the directory <code>/demo/schema/product_media</code>. The example shows how the directory database object <code>media_dir</code> was created in the <code>pm</code> schema. <code>CREATE DIRECTORY media_dir AS '/demo/schema/product_media'; INSERT INTO print_media (product_id, ad_id, ad_graphic) VALUES (3000, 31001, BFILENAME('MEDIA_DIR', 'modem_comp_ad.gif')); </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions019.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "RPAD",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c RPAD))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> RPAD(expr1 , n [, expr2 ]) </eps> \n The Purpose is: \n <code>RPAD</code> returns <code>expr1</code>, right-padded to length <code>n</code> characters with <code>expr2</code>, replicated as many times as necessary. This function is useful for formatting the output of a query. Both <code>expr1</code> and <code>expr2</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>expr1</code> is a character data type, <code>NVARCHAR2</code> if <code>expr1</code> is a national character data type, and a LOB if <code>expr1</code> is a LOB data type. The string returned is in the same character set as <code>expr1</code>. The argument <code>n</code> must be a <code>NUMBER</code> integer or a value that can be implicitly converted to a <code>NUMBER</code> integer. <code>expr1</code> cannot be null. If you do not specify <code>expr2</code>, then it defaults to a single blank. If <code>expr1</code> is longer than <code>n</code>, then this function returns the portion of <code>expr1</code> that fits in <code>n</code>. The argument <code>n</code> is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string. \n The Examples is: \n The following example creates a simple chart of salary amounts by padding a single space with asterisks: <code>SELECT last_name, RPAD(' ', salary/1000/1, '*') \"Salary\" FROM employees WHERE department_id = 80 ORDER BY last_name, \"Salary\"; LAST_NAME Salary ------------------------- --------------- Abel ********** Ande ***** Banda ***** Bates ****** Bernstein ******** Bloom ********* Cambrault ********** Cambrault ****** Doran ****** Errazuriz *********** Fox ******** Greene ******** Hall ******** Hutton ******* Johnson ***** King ********* . . . </code> ",
        "detail": "The Syntax is: \n <eps> RPAD(expr1 , n [, expr2 ]) </eps> \n The Purpose is: \n <code>RPAD</code> returns <code>expr1</code>, right-padded to length <code>n</code> characters with <code>expr2</code>, replicated as many times as necessary. This function is useful for formatting the output of a query. Both <code>expr1</code> and <code>expr2</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>expr1</code> is a character data type, <code>NVARCHAR2</code> if <code>expr1</code> is a national character data type, and a LOB if <code>expr1</code> is a LOB data type. The string returned is in the same character set as <code>expr1</code>. The argument <code>n</code> must be a <code>NUMBER</code> integer or a value that can be implicitly converted to a <code>NUMBER</code> integer. <code>expr1</code> cannot be null. If you do not specify <code>expr2</code>, then it defaults to a single blank. If <code>expr1</code> is longer than <code>n</code>, then this function returns the portion of <code>expr1</code> that fits in <code>n</code>. The argument <code>n</code> is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string. \n The Examples is: \n The following example creates a simple chart of salary amounts by padding a single space with asterisks: <code>SELECT last_name, RPAD(' ', salary/1000/1, '*') \"Salary\" FROM employees WHERE department_id = 80 ORDER BY last_name, \"Salary\"; LAST_NAME Salary ------------------------- --------------- Abel ********** Ande ***** Banda ***** Bates ****** Bernstein ******** Bloom ********* Cambrault ********** Cambrault ****** Doran ****** Errazuriz *********** Fox ******** Greene ******** Hall ******** Hutton ******* Johnson ***** King ********* . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions159.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ROW_NUMBER",
        "tree": "(other_function (over_clause_keyword ROW_NUMBER) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> ROW_NUMBER( ) OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>ROW_NUMBER</code> is an analytic function. It assigns a unique number to each row to which it is applied (either each row in the partition or each row returned by the query), in the ordered sequence of rows specified in the <code>order_by_clause</code>, beginning with 1. By nesting a subquery using <code>ROW_NUMBER</code> inside a query that retrieves the <code>ROW_NUMBER</code> values for a specified range, you can find a precise subset of rows from the results of the inner query. This use of the function lets you implement top-N, bottom-N, and inner-N reporting. For consistent results, the query must ensure a deterministic sort order. You cannot nest analytic functions by using <code>ROW_NUMBER</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. Refer to <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>. \n The Examples is: \n The following example finds the three highest paid employees in each department in the <code>hr.employees</code> table. Fewer than three rows are returned for departments with fewer than three employees. <code>SELECT department_id, first_name, last_name, salary FROM ( SELECT department_id, first_name, last_name, salary, ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary desc) rn FROM employees ) WHERE rn <= 3 ORDER BY department_id, salary DESC, last_name; </code> The following example is a join query on the <code>sh.sales</code> table. It finds the sales amounts in 2000 of the five top-selling products in 1999 and compares the difference between 2000 and 1999. The ten top-selling products are calculated within each distribution channel. <code>SELECT sales_2000.channel_desc, sales_2000.prod_name, sales_2000.amt amt_2000, top_5_prods_1999_year.amt amt_1999, sales_2000.amt - top_5_prods_1999_year.amt amt_diff FROM /* The first subquery finds the 5 top-selling products per channel in year 1999. */ (SELECT channel_desc, prod_name, amt FROM ( SELECT channel_desc, prod_name, sum(amount_sold) amt, ROW_NUMBER () OVER (PARTITION BY channel_desc ORDER BY SUM(amount_sold) DESC) rn FROM sales, times, channels, products WHERE sales.time_id = times.time_id AND times.calendar_year = 1999 AND channels.channel_id = sales.channel_id AND products.prod_id = sales.prod_id GROUP BY channel_desc, prod_name ) WHERE rn <= 5 ) top_5_prods_1999_year, /* The next subquery finds sales per product and per channel in 2000. */ (SELECT channel_desc, prod_name, sum(amount_sold) amt FROM sales, times, channels, products WHERE sales.time_id = times.time_id AND times.calendar_year = 2000 AND channels.channel_id = sales.channel_id AND products.prod_id = sales.prod_id GROUP BY channel_desc, prod_name ) sales_2000 WHERE sales_2000.channel_desc = top_5_prods_1999_year.channel_desc AND sales_2000.prod_name = top_5_prods_1999_year.prod_name ORDER BY sales_2000.channel_desc, sales_2000.prod_name ; CHANNEL_DESC PROD_NAME AMT_2000 AMT_1999 AMT_DIFF --------------- --------------==-------------------------------- ---------- ---------- ---------- Direct Sales 17\" LCD w/built-in HDTV Tuner 628855.7 1163645.78 -534790.08 Direct Sales Envoy 256MB - 40GB 502938.54 843377.88 -340439.34 Direct Sales Envoy Ambassador 2259566.96 1770349.25 489217.71 Direct Sales Home Theatre Package with DVD-Audio/Video Play 1235674.15 1260791.44 -25117.29 Direct Sales Mini DV Camcorder with 3.5\" Swivel LCD 775851.87 1326302.51 -550450.64 Internet 17\" LCD w/built-in HDTV Tuner 31707.48 160974.7 -129267.22 Internet 8.3 Minitower Speaker 404090.32 155235.25 248855.07 Internet Envoy 256MB - 40GB 28293.87 154072.02 -125778.15 Internet Home Theatre Package with DVD-Audio/Video Play 155405.54 153175.04 2230.5 Internet Mini DV Camcorder with 3.5\" Swivel LCD 39726.23 189921.97 -150195.74 Partners 17\" LCD w/built-in HDTV Tuner 269973.97 325504.75 -55530.78 Partners Envoy Ambassador 1213063.59 614857.93 598205.66 Partners Home Theatre Package with DVD-Audio/Video Play 700266.58 520166.26 180100.32 Partners Mini DV Camcorder with 3.5\" Swivel LCD 404265.85 520544.11 -116278.26 Partners Unix/Windows 1-user pack 374002.51 340123.02 33879.49 15 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> ROW_NUMBER( ) OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>ROW_NUMBER</code> is an analytic function. It assigns a unique number to each row to which it is applied (either each row in the partition or each row returned by the query), in the ordered sequence of rows specified in the <code>order_by_clause</code>, beginning with 1. By nesting a subquery using <code>ROW_NUMBER</code> inside a query that retrieves the <code>ROW_NUMBER</code> values for a specified range, you can find a precise subset of rows from the results of the inner query. This use of the function lets you implement top-N, bottom-N, and inner-N reporting. For consistent results, the query must ensure a deterministic sort order. You cannot nest analytic functions by using <code>ROW_NUMBER</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. Refer to <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>. \n The Examples is: \n The following example finds the three highest paid employees in each department in the <code>hr.employees</code> table. Fewer than three rows are returned for departments with fewer than three employees. <code>SELECT department_id, first_name, last_name, salary FROM ( SELECT department_id, first_name, last_name, salary, ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary desc) rn FROM employees ) WHERE rn <= 3 ORDER BY department_id, salary DESC, last_name; </code> The following example is a join query on the <code>sh.sales</code> table. It finds the sales amounts in 2000 of the five top-selling products in 1999 and compares the difference between 2000 and 1999. The ten top-selling products are calculated within each distribution channel. <code>SELECT sales_2000.channel_desc, sales_2000.prod_name, sales_2000.amt amt_2000, top_5_prods_1999_year.amt amt_1999, sales_2000.amt - top_5_prods_1999_year.amt amt_diff FROM /* The first subquery finds the 5 top-selling products per channel in year 1999. */ (SELECT channel_desc, prod_name, amt FROM ( SELECT channel_desc, prod_name, sum(amount_sold) amt, ROW_NUMBER () OVER (PARTITION BY channel_desc ORDER BY SUM(amount_sold) DESC) rn FROM sales, times, channels, products WHERE sales.time_id = times.time_id AND times.calendar_year = 1999 AND channels.channel_id = sales.channel_id AND products.prod_id = sales.prod_id GROUP BY channel_desc, prod_name ) WHERE rn <= 5 ) top_5_prods_1999_year, /* The next subquery finds sales per product and per channel in 2000. */ (SELECT channel_desc, prod_name, sum(amount_sold) amt FROM sales, times, channels, products WHERE sales.time_id = times.time_id AND times.calendar_year = 2000 AND channels.channel_id = sales.channel_id AND products.prod_id = sales.prod_id GROUP BY channel_desc, prod_name ) sales_2000 WHERE sales_2000.channel_desc = top_5_prods_1999_year.channel_desc AND sales_2000.prod_name = top_5_prods_1999_year.prod_name ORDER BY sales_2000.channel_desc, sales_2000.prod_name ; CHANNEL_DESC PROD_NAME AMT_2000 AMT_1999 AMT_DIFF --------------- --------------==-------------------------------- ---------- ---------- ---------- Direct Sales 17\" LCD w/built-in HDTV Tuner 628855.7 1163645.78 -534790.08 Direct Sales Envoy 256MB - 40GB 502938.54 843377.88 -340439.34 Direct Sales Envoy Ambassador 2259566.96 1770349.25 489217.71 Direct Sales Home Theatre Package with DVD-Audio/Video Play 1235674.15 1260791.44 -25117.29 Direct Sales Mini DV Camcorder with 3.5\" Swivel LCD 775851.87 1326302.51 -550450.64 Internet 17\" LCD w/built-in HDTV Tuner 31707.48 160974.7 -129267.22 Internet 8.3 Minitower Speaker 404090.32 155235.25 248855.07 Internet Envoy 256MB - 40GB 28293.87 154072.02 -125778.15 Internet Home Theatre Package with DVD-Audio/Video Play 155405.54 153175.04 2230.5 Internet Mini DV Camcorder with 3.5\" Swivel LCD 39726.23 189921.97 -150195.74 Partners 17\" LCD w/built-in HDTV Tuner 269973.97 325504.75 -55530.78 Partners Envoy Ambassador 1213063.59 614857.93 598205.66 Partners Home Theatre Package with DVD-Audio/Video Play 700266.58 520166.26 180100.32 Partners Mini DV Camcorder with 3.5\" Swivel LCD 404265.85 520544.11 -116278.26 Partners Unix/Windows 1-user pack 374002.51 340123.02 33879.49 15 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions156.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CORR",
        "tree": "(other_function (over_clause_keyword CORR) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> CORR(expr1, expr2) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>CORR</code> returns the coefficient of correlation of a set of number pairs. You can use it as an aggregate or analytic function. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle Database applies the function to the set of (<code>expr1</code>, <code>expr2</code>) after eliminating the pairs for which either <code>expr1</code> or <code>expr2</code> is null. Then Oracle makes the following computation: <code>COVAR_POP(expr1, expr2) / (STDDEV_POP(expr1) * STDDEV_POP(expr2)) </code> The function returns a value of type <code>NUMBER</code>. If the function is applied to an empty set, then it returns null. Note: The <code>CORR</code> function calculates the Pearson's correlation coefficient, which requires numeric expressions as arguments. Oracle also provides the <code>CORR_S</code> (Spearman's rho coefficient) and <code>CORR_K</code> (Kendall's tau-b coefficient) functions to support nonparametric or rank correlation. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link>, <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>, and <link>CORR_*&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions036.htm#i1293691</link> for information on the <code>CORR_S</code> and <code>CORR_K</code> functions Aggregate Example The following example calculates the coefficient of correlation between the list prices and minimum prices of products by weight class in the sample table <code>oe.product_information</code>: <code>SELECT weight_class, CORR(list_price, min_price) \"Correlation\" FROM product_information GROUP BY weight_class ORDER BY weight_class, \"Correlation\"; WEIGHT_CLASS Correlation ------------ ----------- 1 .999149795 2 .999022941 3 .998484472 4 .999359909 5 .999536087 </code> Analytic Example The following example shows the correlation between duration at the company and salary by the employee's position. The result set shows the same correlation for each employee in a given job: <code>SELECT employee_id, job_id, TO_CHAR((SYSDATE - hire_date) YEAR TO MONTH ) \"Yrs-Mns\", salary, CORR(SYSDATE-hire_date, salary) OVER(PARTITION BY job_id) AS \"Correlation\" FROM employees WHERE department_id in (50, 80) ORDER BY job_id, employee_id; EMPLOYEE_ID JOB_ID Yrs-Mns SALARY Correlation ----------- ---------- ------- ---------- ----------- 145 SA_MAN +04-09 14000 .912385598 146 SA_MAN +04-06 13500 .912385598 147 SA_MAN +04-04 12000 .912385598 148 SA_MAN +01-08 11000 .912385598 149 SA_MAN +01-05 10500 .912385598 150 SA_REP +04-05 10000 .80436755 151 SA_REP +04-03 9500 .80436755 152 SA_REP +03-10 9000 .80436755 153 SA_REP +03-03 8000 .80436755 154 SA_REP +02-07 7500 .80436755 155 SA_REP +01-07 7000 .80436755 . . . </code> ",
        "detail": "The Syntax is: \n <eps> CORR(expr1, expr2) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>CORR</code> returns the coefficient of correlation of a set of number pairs. You can use it as an aggregate or analytic function. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle Database applies the function to the set of (<code>expr1</code>, <code>expr2</code>) after eliminating the pairs for which either <code>expr1</code> or <code>expr2</code> is null. Then Oracle makes the following computation: <code>COVAR_POP(expr1, expr2) / (STDDEV_POP(expr1) * STDDEV_POP(expr2)) </code> The function returns a value of type <code>NUMBER</code>. If the function is applied to an empty set, then it returns null. Note: The <code>CORR</code> function calculates the Pearson's correlation coefficient, which requires numeric expressions as arguments. Oracle also provides the <code>CORR_S</code> (Spearman's rho coefficient) and <code>CORR_K</code> (Kendall's tau-b coefficient) functions to support nonparametric or rank correlation. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link>, <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>, and <link>CORR_*&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions036.htm#i1293691</link> for information on the <code>CORR_S</code> and <code>CORR_K</code> functions Aggregate Example The following example calculates the coefficient of correlation between the list prices and minimum prices of products by weight class in the sample table <code>oe.product_information</code>: <code>SELECT weight_class, CORR(list_price, min_price) \"Correlation\" FROM product_information GROUP BY weight_class ORDER BY weight_class, \"Correlation\"; WEIGHT_CLASS Correlation ------------ ----------- 1 .999149795 2 .999022941 3 .998484472 4 .999359909 5 .999536087 </code> Analytic Example The following example shows the correlation between duration at the company and salary by the employee's position. The result set shows the same correlation for each employee in a given job: <code>SELECT employee_id, job_id, TO_CHAR((SYSDATE - hire_date) YEAR TO MONTH ) \"Yrs-Mns\", salary, CORR(SYSDATE-hire_date, salary) OVER(PARTITION BY job_id) AS \"Correlation\" FROM employees WHERE department_id in (50, 80) ORDER BY job_id, employee_id; EMPLOYEE_ID JOB_ID Yrs-Mns SALARY Correlation ----------- ---------- ------- ---------- ----------- 145 SA_MAN +04-09 14000 .912385598 146 SA_MAN +04-06 13500 .912385598 147 SA_MAN +04-04 12000 .912385598 148 SA_MAN +01-08 11000 .912385598 149 SA_MAN +01-05 10500 .912385598 150 SA_REP +04-05 10000 .80436755 151 SA_REP +04-03 9500 .80436755 152 SA_REP +03-10 9000 .80436755 153 SA_REP +03-03 8000 .80436755 154 SA_REP +02-07 7500 .80436755 155 SA_REP +01-07 7000 .80436755 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions035.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYS_CONTEXT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYS_CONTEXT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYS_CONTEXT('namespace', 'parameter' [, length ]) </eps> \n The Purpose is: \n <code>SYS_CONTEXT</code> returns the value of <code>parameter</code> associated with the context <code>namespace</code> at the current instant. You can use this function in both SQL and PL/SQL statements. <code>SYS_CONTEXT</code> must be executed locally. For <code>namespace</code> and <code>parameter</code>, you can specify either a string or an expression that resolves to a string designating a namespace or an attribute. If you specify literal arguments for <code>namespace</code> and <code>parameter</code>, and you are using <code>SYS_CONTEXT</code> explicitly in a SQL statement\u2014rather than in a PL/SQL function that in turn is in mentioned in a SQL statement\u2014then Oracle Database evaluates <code>SYS_CONTEXT</code> only once per SQL statement execution for each call site that invokes the <code>SYS_CONTEXT</code> function. The context <code>namespace</code> must already have been created, and the associated <code>parameter</code> and its value must also have been set using the <code>DBMS_SESSION</code>.<code>set_context</code> procedure. The <code>namespace</code> must be a valid SQL identifier. The <code>parameter</code> name can be any string. It is not case sensitive, but it cannot exceed 30 bytes in length. The data type of the return value is <code>VARCHAR2</code>. The default maximum size of the return value is 256 bytes. You can override this default by specifying the optional <code>length</code> parameter, which must be a <code>NUMBER</code> or a value that can be implicitly converted to <code>NUMBER</code>. The valid range of values is 1 to 4000 bytes. If you specify an invalid value, then Oracle Database ignores it and uses the default. Oracle provides the following built-in namespaces: <code>USERENV</code> - Describes the current session. The predefined parameters of namespace <code>USERENV</code> are listed in <link>Table 5-11&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions184.htm#g1513460</link>. <code>SYS_SESSION_ROLES</code> - Indicates whether a specified role is currently enabled for the session. This namespace is available starting with Oracle Database 11g Release 2 (11.2.0.4). See Also: <link>Oracle Database Security Guide&LINK&https://docs.oracle.com/cd/E11882_01/network.112/e36292/app_context.htm#DBSEG14002</link> for information on using the application context feature in your application development <link>CREATE CONTEXT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_5002.htm#i2060927</link> for information on creating user-defined context namespaces <link>Oracle Database PL/SQL Packages and Types Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_sessio.htm#ARPLS054</link> for information on the <code>DBMS_SESSION</code>.<code>set_context</code> procedure \n The Examples is: \n The following statement returns the name of the user who logged onto the database: <code>CONNECT OE Enter password: password SELECT SYS_CONTEXT ('USERENV', 'SESSION_USER') FROM DUAL; SYS_CONTEXT ('USERENV', 'SESSION_USER') ------------------------------------------------------ OE </code> The following example queries the <code>SESSION_ROLES</code> data dictionary view to show that <code>RESOURCE</code> is the only role currently enabled for the session. It then uses the <code>SYS_CONTEXT</code> function to show that the <code>RESOURCE</code> role is currently enabled for the session and the <code>DBA</code> role is not. <code>CONNECT OE Enter password: password SELECT role FROM session_roles; ROLE -------- RESOURCE SELECT SYS_CONTEXT('SYS_SESSION_ROLES', 'RESOURCE') FROM DUAL SYS_CONTEXT('SYS_SESSION_ROLES','RESOURCE') -------------------------------------- TRUE SELECT SYS_CONTEXT('SYS_SESSION_ROLES', 'DBA') FROM DUAL; SYS_CONTEXT('SYS_SESSION_ROLES','DBA') -------------------------------------- FALSE </code> Note: For simplicity in demonstrating this feature, these examples do not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <link>Oracle Database Security Guide&LINK&https://docs.oracle.com/cd/E11882_01/network.112/e36292/app_devs.htm#DBSEG50053</link> for password management guidelines and other security recommendations. The following hypothetical example returns the group number that was set as the value for the attribute <code>group_no</code> in the PL/SQL package that was associated with the context <code>hr_apps</code> when <code>hr_apps</code> was created: <code>SELECT SYS_CONTEXT ('hr_apps', 'group_no') \"User Group\" FROM DUAL; </code> Table 5-11 Predefined Parameters of Namespace USERENV <table> <thead> <tr> <th>Parameter</th> <th>Return Value</th> </tr> </thead> <tbody> <tr> <td> ACTION </td> <td> Identifies the position in the module (application name) and is set through the DBMS_APPLICATION_INFO package or OCI. </td> </tr> <tr> <td> AUDITED_CURSORID </td> <td> Returns the cursor ID of the SQL that triggered the audit. This parameter is not valid in a fine-grained auditing environment. If you specify it in such an environment, then Oracle Database always returns NULL. </td> </tr> <tr> <td> AUTHENTICATED_IDENTITY </td> <td> Returns the identity used in authentication. In the list that follows, the type of user is followed by the value returned: Kerberos-authenticated enterprise user: kerberos principal name Kerberos-authenticated external user : kerberos principal name; same as the schema name SSL-authenticated enterprise user: the DN in the user's PKI certificate SSL-authenticated external user: the DN in the user's PKI certificate Password-authenticated enterprise user: nickname; same as the login name Password-authenticated database user: the database username; same as the schema name OS-authenticated external user: the external operating system user name Radius-authenticated external user: the schema name Proxy with DN : Oracle Internet Directory DN of the client Proxy with certificate: certificate DN of the client Proxy with username: database user name if client is a local database user; nickname if client is an enterprise user. SYSDBA/SYSOPER using Password File: login name SYSDBA/SYSOPER using OS authentication: operating system user name </td> </tr> <tr> <td> AUTHENTICATION_DATA </td> <td> Data being used to authenticate the login user. For X.503 certificate authenticated sessions, this field returns the context of the certificate in HEX2 format. Note: You can change the return value of the AUTHENTICATION_DATA attribute using the length parameter of the syntax. Values of up to 4000 are accepted. This is the only attribute of USERENV for which Oracle Database implements such a change. </td> </tr> <tr> <td> AUTHENTICATION_METHOD </td> <td> Returns the method of authentication. In the list that follows, the type of user is followed by the method returned: Password-authenticated enterprise user, local database user, or SYSDBA/SYSOPER using Password File; proxy with username using password: PASSWORD Kerberos-authenticated enterprise or external user: KERBEROS SSL-authenticated enterprise or external user: SSL Radius-authenticated external user: RADIUS OS-authenticated external user or SYSDBA/SYSOPER: OS Proxy with certificate, DN, or username without using password: NONE Background process (job queue slave process): JOB Parallel Query Slave process: PQ_SLAVE You can use IDENTIFICATION_TYPE to distinguish between external and enterprise users when the authentication method is Password, Kerberos, or SSL. </td> </tr> <tr> <td> BG_JOB_ID </td> <td> Job ID of the current session if it was established by an Oracle Database background process. Null if the session was not established by a background process. </td> </tr> <tr> <td> CLIENT_IDENTIFIER </td> <td> Returns an identifier that is set by the application through the DBMS_SESSION.SET_IDENTIFIER procedure, the OCI attribute OCI_ATTR_CLIENT_IDENTIFIER, or Oracle Dynamic Monitoring Service (DMS). This attribute is used by various database components to identify lightweight application users who authenticate as the same database user. </td> </tr> <tr> <td> CLIENT_INFO </td> <td> Returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. </td> </tr> <tr> <td> CURRENT_BIND </td> <td> The bind variables for fine-grained auditing. You can specify this attribute only inside the event handler for the fine-grained auditing feature. </td> </tr> <tr> <td> CURRENT_EDITION_ID </td> <td> The identifier of the current edition. </td> </tr> <tr> <td> CURRENT_EDITION_NAME </td> <td> The name of the current edition. </td> </tr> <tr> <td> CURRENT_SCHEMA </td> <td> The name of the currently active default schema. This value may change during the duration of a session through use of an ALTER SESSION SET CURRENT_SCHEMA statement. This may also change during the duration of a session to reflect the owner of any active definer's rights object. When used directly in the body of a view definition, this returns the default schema used when executing the cursor that is using the view; it does not respect views used in the cursor as being definer's rights. Note: Oracle recommends against issuing the SQL statement ALTER SESSION SET CURRENT_SCHEMA from within all types of stored PL/SQL units except logon triggers. </td> </tr> <tr> <td> CURRENT_SCHEMAID </td> <td> Identifier of the currently active default schema. </td> </tr> <tr> <td> CURRENT_SQL CURRENT_SQLn </td> <td> CURRENT_SQL returns the first 4K bytes of the current SQL that triggered the fine-grained auditing event. The CURRENT_SQLn attributes return subsequent 4K-byte increments, where n can be an integer from 1 to 7, inclusive. CURRENT_SQL1 returns bytes 4K to 8K; CURRENT_SQL2 returns bytes 8K to 12K, and so forth. You can specify these attributes only inside the event handler for the fine-grained auditing feature. </td> </tr> <tr> <td> CURRENT_SQL_LENGTH </td> <td> The length of the current SQL statement that triggers fine-grained audit or row-level security (RLS) policy functions or event handlers. You can specify this attribute only inside the event handler for the fine-grained auditing feature. </td> </tr> <tr> <td> CURRENT_USER </td> <td> The name of the database user whose privileges are currently active. This may change during the duration of a session to reflect the owner of any active definer's rights object. When no definer's rights object is active, CURRENT_USER returns the same value as SESSION_USER. When used directly in the body of a view definition, this returns the user that is executing the cursor that is using the view; it does not respect views used in the cursor as being definer's rights. </td> </tr> <tr> <td> CURRENT_USERID </td> <td> The identifier of the database user whose privileges are currently active. </td> </tr> <tr> <td> DATABASE_ROLE </td> <td> The database role using the SYS_CONTEXT function with the USERENV namespace. The role is one of the following: PRIMARY, PHYSICAL STANDBY, LOGICAL STANDBY, SNAPSHOT STANDBY. </td> </tr> <tr> <td> DB_DOMAIN </td> <td> Domain of the database as specified in the DB_DOMAIN initialization parameter. </td> </tr> <tr> <td> DB_NAME </td> <td> Name of the database as specified in the DB_NAME initialization parameter. </td> </tr> <tr> <td> DB_UNIQUE_NAME </td> <td> Name of the database as specified in the DB_UNIQUE_NAME initialization parameter. </td> </tr> <tr> <td> DBLINK_INFO </td> <td> Returns the source of a database link session. Specifically, it returns a string of the form: SOURCE_GLOBAL_NAME=dblink_src_global_name, DBLINK_NAME=dblink_name, SOURCE_AUDIT_SESSIONID=dblink_src_audit_sessionid where: dblink_src_global_name is the unique global name of the source database dblink_name is the name of the database link on the source database dblink_src_audit_sessionid is the audit session ID of the session on the source database that initiated the connection to the remote database using dblink_name </td> </tr> <tr> <td> ENTRYID </td> <td> The current audit entry number. The audit entryid sequence is shared between fine-grained audit records and regular audit records. You cannot use this attribute in distributed SQL statements. The correct auditing entry identifier can be seen only through an audit handler for standard or fine-grained audit. </td> </tr> <tr> <td> ENTERPRISE_IDENTITY </td> <td> Returns the user's enterprise-wide identity: For enterprise users: the Oracle Internet Directory DN. For external users: the external identity (Kerberos principal name, Radius schema names, OS user name, Certificate DN). For local users and SYSDBA/SYSOPER logins: NULL. The value of the attribute differs by proxy method: For a proxy with DN: the Oracle Internet Directory DN of the client For a proxy with certificate: the certificate DN of the client for external users; the Oracle Internet Directory DN for global users For a proxy with username: the Oracle Internet Directory DN if the client is an enterprise users; NULL if the client is a local database user. </td> </tr> <tr> <td> FG_JOB_ID </td> <td> Job ID of the current session if it was established by a client foreground process. Null if the session was not established by a foreground process. </td> </tr> <tr> <td> GLOBAL_CONTEXT_MEMORY </td> <td> Returns the number being used in the System Global Area by the globally accessed context. </td> </tr> <tr> <td> GLOBAL_UID </td> <td> Returns the global user ID from Oracle Internet Directory for Enterprise User Security (EUS) logins; returns null for all other logins. </td> </tr> <tr> <td> HOST </td> <td> Name of the host machine from which the client has connected. </td> </tr> <tr> <td> IDENTIFICATION_TYPE </td> <td> Returns the way the user's schema was created in the database. Specifically, it reflects the IDENTIFIED clause in the CREATE/ALTER USER syntax. In the list that follows, the syntax used during schema creation is followed by the identification type returned: IDENTIFIED BY password: LOCAL IDENTIFIED EXTERNALLY: EXTERNAL IDENTIFIED GLOBALLY: GLOBAL SHARED IDENTIFIED GLOBALLY AS DN: GLOBAL PRIVATE </td> </tr> <tr> <td> INSTANCE </td> <td> The instance identification number of the current instance. </td> </tr> <tr> <td> INSTANCE_NAME </td> <td> The name of the instance. </td> </tr> <tr> <td> IP_ADDRESS </td> <td> IP address of the machine from which the client is connected. If the client and server are on the same machine and the connection uses IPv6 addressing, then ::1 is returned. </td> </tr> <tr> <td> ISDBA </td> <td> Returns TRUE if the user has been authenticated as having DBA privileges either through the operating system or through a password file. </td> </tr> <tr> <td> LANG </td> <td> The abbreviated name for the language, a shorter form than the existing 'LANGUAGE' parameter. </td> </tr> <tr> <td> LANGUAGE </td> <td> The language and territory currently used by your session, along with the database character set, in this form: language_territory.characterset </td> </tr> <tr> <td> MODULE </td> <td> The application name (module) set through the DBMS_APPLICATION_INFO package or OCI. </td> </tr> <tr> <td> NETWORK_PROTOCOL </td> <td> Network protocol being used for communication, as specified in the 'PROTOCOL=protocol' portion of the connect string. </td> </tr> <tr> <td> NLS_CALENDAR </td> <td> The current calendar of the current session. </td> </tr> <tr> <td> NLS_CURRENCY </td> <td> The currency of the current session. </td> </tr> <tr> <td> NLS_DATE_FORMAT </td> <td> The date format for the session. </td> </tr> <tr> <td> NLS_DATE_LANGUAGE </td> <td> The language used for expressing dates. </td> </tr> <tr> <td> NLS_SORT </td> <td> BINARY or the linguistic sort basis. </td> </tr> <tr> <td> NLS_TERRITORY </td> <td> The territory of the current session. </td> </tr> <tr> <td> OS_USER </td> <td> Operating system user name of the client process that initiated the database session. </td> </tr> <tr> <td> POLICY_INVOKER </td> <td> The invoker of row-level security (RLS) policy functions. </td> </tr> <tr> <td> PROXY_ENTERPRISE_IDENTITY </td> <td> Returns the Oracle Internet Directory DN when the proxy user is an enterprise user. </td> </tr> <tr> <td> PROXY_USER </td> <td> Name of the database user who opened the current session on behalf of SESSION_USER. </td> </tr> <tr> <td> PROXY_USERID </td> <td> Identifier of the database user who opened the current session on behalf of SESSION_USER. </td> </tr> <tr> <td> SERVER_HOST </td> <td> The host name of the machine on which the instance is running. </td> </tr> <tr> <td> SERVICE_NAME </td> <td> The name of the service to which a given session is connected. </td> </tr> <tr> <td> SESSION_EDITION_ID </td> <td> The identifier of the session edition. </td> </tr> <tr> <td> SESSION_EDITION_NAME </td> <td> The name of the session edition. </td> </tr> <tr> <td> SESSION_USER </td> <td> The name of the database user at logon. For enterprise users, returns the schema. For other users, returns the database user name. This value remains the same throughout the duration of the session. </td> </tr> <tr> <td> SESSION_USERID </td> <td> The identifier of the database user at logon. </td> </tr> <tr> <td> SESSIONID </td> <td> The auditing session identifier. You cannot use this attribute in distributed SQL statements. </td> </tr> <tr> <td> SID </td> <td> The session ID. </td> </tr> <tr> <td> STATEMENTID </td> <td> The auditing statement identifier. STATEMENTID represents the number of SQL statements audited in a given session. You cannot use this attribute in distributed SQL statements. The correct auditing statement identifier can be seen only through an audit handler for standard or fine-grained audit. </td> </tr> <tr> <td> TERMINAL </td> <td> The operating system identifier for the client of the current session. In distributed SQL statements, this attribute returns the identifier for your local session. In a distributed environment, this is supported only for remote SELECT statements, not for remote INSERT, UPDATE, or DELETE operations. (The return length of this parameter may vary by operating system.) </td> </tr> </tbody> </table> <link>Table 5-12&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions184.htm#CIHEFDFI</link> lists the parameters of namespace <code>USERENV</code> that have been deprecated. Do not specify any of these parameters. Instead use the alternatives suggested in the Comments column. Table 5-12 Deprecated Parameters of Namespace USERENV <table> <thead> <tr> <th>Parameter</th> <th>Comments</th> </tr> </thead> <tbody> <tr> <td> AUTHENTICATION_TYPE </td> <td> This parameter returned a value indicating how the user was authenticated. The same information is now available from the new AUTHENTICATION_METHOD parameter combined with IDENTIFICATION_TYPE. </td> </tr> <tr> <td> EXTERNAL_NAME </td> <td> This parameter returned the external name of the user. More complete information can now be obtained from the AUTHENTICATED_IDENTITY and ENTERPRISE_IDENTITY parameter. </td> </tr> </tbody> </table> ",
        "detail": "The Syntax is: \n <eps> SYS_CONTEXT('namespace', 'parameter' [, length ]) </eps> \n The Purpose is: \n <code>SYS_CONTEXT</code> returns the value of <code>parameter</code> associated with the context <code>namespace</code> at the current instant. You can use this function in both SQL and PL/SQL statements. <code>SYS_CONTEXT</code> must be executed locally. For <code>namespace</code> and <code>parameter</code>, you can specify either a string or an expression that resolves to a string designating a namespace or an attribute. If you specify literal arguments for <code>namespace</code> and <code>parameter</code>, and you are using <code>SYS_CONTEXT</code> explicitly in a SQL statement\u2014rather than in a PL/SQL function that in turn is in mentioned in a SQL statement\u2014then Oracle Database evaluates <code>SYS_CONTEXT</code> only once per SQL statement execution for each call site that invokes the <code>SYS_CONTEXT</code> function. The context <code>namespace</code> must already have been created, and the associated <code>parameter</code> and its value must also have been set using the <code>DBMS_SESSION</code>.<code>set_context</code> procedure. The <code>namespace</code> must be a valid SQL identifier. The <code>parameter</code> name can be any string. It is not case sensitive, but it cannot exceed 30 bytes in length. The data type of the return value is <code>VARCHAR2</code>. The default maximum size of the return value is 256 bytes. You can override this default by specifying the optional <code>length</code> parameter, which must be a <code>NUMBER</code> or a value that can be implicitly converted to <code>NUMBER</code>. The valid range of values is 1 to 4000 bytes. If you specify an invalid value, then Oracle Database ignores it and uses the default. Oracle provides the following built-in namespaces: <code>USERENV</code> - Describes the current session. The predefined parameters of namespace <code>USERENV</code> are listed in <link>Table 5-11&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions184.htm#g1513460</link>. <code>SYS_SESSION_ROLES</code> - Indicates whether a specified role is currently enabled for the session. This namespace is available starting with Oracle Database 11g Release 2 (11.2.0.4). See Also: <link>Oracle Database Security Guide&LINK&https://docs.oracle.com/cd/E11882_01/network.112/e36292/app_context.htm#DBSEG14002</link> for information on using the application context feature in your application development <link>CREATE CONTEXT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_5002.htm#i2060927</link> for information on creating user-defined context namespaces <link>Oracle Database PL/SQL Packages and Types Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_sessio.htm#ARPLS054</link> for information on the <code>DBMS_SESSION</code>.<code>set_context</code> procedure \n The Examples is: \n The following statement returns the name of the user who logged onto the database: <code>CONNECT OE Enter password: password SELECT SYS_CONTEXT ('USERENV', 'SESSION_USER') FROM DUAL; SYS_CONTEXT ('USERENV', 'SESSION_USER') ------------------------------------------------------ OE </code> The following example queries the <code>SESSION_ROLES</code> data dictionary view to show that <code>RESOURCE</code> is the only role currently enabled for the session. It then uses the <code>SYS_CONTEXT</code> function to show that the <code>RESOURCE</code> role is currently enabled for the session and the <code>DBA</code> role is not. <code>CONNECT OE Enter password: password SELECT role FROM session_roles; ROLE -------- RESOURCE SELECT SYS_CONTEXT('SYS_SESSION_ROLES', 'RESOURCE') FROM DUAL SYS_CONTEXT('SYS_SESSION_ROLES','RESOURCE') -------------------------------------- TRUE SELECT SYS_CONTEXT('SYS_SESSION_ROLES', 'DBA') FROM DUAL; SYS_CONTEXT('SYS_SESSION_ROLES','DBA') -------------------------------------- FALSE </code> Note: For simplicity in demonstrating this feature, these examples do not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <link>Oracle Database Security Guide&LINK&https://docs.oracle.com/cd/E11882_01/network.112/e36292/app_devs.htm#DBSEG50053</link> for password management guidelines and other security recommendations. The following hypothetical example returns the group number that was set as the value for the attribute <code>group_no</code> in the PL/SQL package that was associated with the context <code>hr_apps</code> when <code>hr_apps</code> was created: <code>SELECT SYS_CONTEXT ('hr_apps', 'group_no') \"User Group\" FROM DUAL; </code> Table 5-11 Predefined Parameters of Namespace USERENV <table> <thead> <tr> <th>Parameter</th> <th>Return Value</th> </tr> </thead> <tbody> <tr> <td> ACTION </td> <td> Identifies the position in the module (application name) and is set through the DBMS_APPLICATION_INFO package or OCI. </td> </tr> <tr> <td> AUDITED_CURSORID </td> <td> Returns the cursor ID of the SQL that triggered the audit. This parameter is not valid in a fine-grained auditing environment. If you specify it in such an environment, then Oracle Database always returns NULL. </td> </tr> <tr> <td> AUTHENTICATED_IDENTITY </td> <td> Returns the identity used in authentication. In the list that follows, the type of user is followed by the value returned: Kerberos-authenticated enterprise user: kerberos principal name Kerberos-authenticated external user : kerberos principal name; same as the schema name SSL-authenticated enterprise user: the DN in the user's PKI certificate SSL-authenticated external user: the DN in the user's PKI certificate Password-authenticated enterprise user: nickname; same as the login name Password-authenticated database user: the database username; same as the schema name OS-authenticated external user: the external operating system user name Radius-authenticated external user: the schema name Proxy with DN : Oracle Internet Directory DN of the client Proxy with certificate: certificate DN of the client Proxy with username: database user name if client is a local database user; nickname if client is an enterprise user. SYSDBA/SYSOPER using Password File: login name SYSDBA/SYSOPER using OS authentication: operating system user name </td> </tr> <tr> <td> AUTHENTICATION_DATA </td> <td> Data being used to authenticate the login user. For X.503 certificate authenticated sessions, this field returns the context of the certificate in HEX2 format. Note: You can change the return value of the AUTHENTICATION_DATA attribute using the length parameter of the syntax. Values of up to 4000 are accepted. This is the only attribute of USERENV for which Oracle Database implements such a change. </td> </tr> <tr> <td> AUTHENTICATION_METHOD </td> <td> Returns the method of authentication. In the list that follows, the type of user is followed by the method returned: Password-authenticated enterprise user, local database user, or SYSDBA/SYSOPER using Password File; proxy with username using password: PASSWORD Kerberos-authenticated enterprise or external user: KERBEROS SSL-authenticated enterprise or external user: SSL Radius-authenticated external user: RADIUS OS-authenticated external user or SYSDBA/SYSOPER: OS Proxy with certificate, DN, or username without using password: NONE Background process (job queue slave process): JOB Parallel Query Slave process: PQ_SLAVE You can use IDENTIFICATION_TYPE to distinguish between external and enterprise users when the authentication method is Password, Kerberos, or SSL. </td> </tr> <tr> <td> BG_JOB_ID </td> <td> Job ID of the current session if it was established by an Oracle Database background process. Null if the session was not established by a background process. </td> </tr> <tr> <td> CLIENT_IDENTIFIER </td> <td> Returns an identifier that is set by the application through the DBMS_SESSION.SET_IDENTIFIER procedure, the OCI attribute OCI_ATTR_CLIENT_IDENTIFIER, or Oracle Dynamic Monitoring Service (DMS). This attribute is used by various database components to identify lightweight application users who authenticate as the same database user. </td> </tr> <tr> <td> CLIENT_INFO </td> <td> Returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. </td> </tr> <tr> <td> CURRENT_BIND </td> <td> The bind variables for fine-grained auditing. You can specify this attribute only inside the event handler for the fine-grained auditing feature. </td> </tr> <tr> <td> CURRENT_EDITION_ID </td> <td> The identifier of the current edition. </td> </tr> <tr> <td> CURRENT_EDITION_NAME </td> <td> The name of the current edition. </td> </tr> <tr> <td> CURRENT_SCHEMA </td> <td> The name of the currently active default schema. This value may change during the duration of a session through use of an ALTER SESSION SET CURRENT_SCHEMA statement. This may also change during the duration of a session to reflect the owner of any active definer's rights object. When used directly in the body of a view definition, this returns the default schema used when executing the cursor that is using the view; it does not respect views used in the cursor as being definer's rights. Note: Oracle recommends against issuing the SQL statement ALTER SESSION SET CURRENT_SCHEMA from within all types of stored PL/SQL units except logon triggers. </td> </tr> <tr> <td> CURRENT_SCHEMAID </td> <td> Identifier of the currently active default schema. </td> </tr> <tr> <td> CURRENT_SQL CURRENT_SQLn </td> <td> CURRENT_SQL returns the first 4K bytes of the current SQL that triggered the fine-grained auditing event. The CURRENT_SQLn attributes return subsequent 4K-byte increments, where n can be an integer from 1 to 7, inclusive. CURRENT_SQL1 returns bytes 4K to 8K; CURRENT_SQL2 returns bytes 8K to 12K, and so forth. You can specify these attributes only inside the event handler for the fine-grained auditing feature. </td> </tr> <tr> <td> CURRENT_SQL_LENGTH </td> <td> The length of the current SQL statement that triggers fine-grained audit or row-level security (RLS) policy functions or event handlers. You can specify this attribute only inside the event handler for the fine-grained auditing feature. </td> </tr> <tr> <td> CURRENT_USER </td> <td> The name of the database user whose privileges are currently active. This may change during the duration of a session to reflect the owner of any active definer's rights object. When no definer's rights object is active, CURRENT_USER returns the same value as SESSION_USER. When used directly in the body of a view definition, this returns the user that is executing the cursor that is using the view; it does not respect views used in the cursor as being definer's rights. </td> </tr> <tr> <td> CURRENT_USERID </td> <td> The identifier of the database user whose privileges are currently active. </td> </tr> <tr> <td> DATABASE_ROLE </td> <td> The database role using the SYS_CONTEXT function with the USERENV namespace. The role is one of the following: PRIMARY, PHYSICAL STANDBY, LOGICAL STANDBY, SNAPSHOT STANDBY. </td> </tr> <tr> <td> DB_DOMAIN </td> <td> Domain of the database as specified in the DB_DOMAIN initialization parameter. </td> </tr> <tr> <td> DB_NAME </td> <td> Name of the database as specified in the DB_NAME initialization parameter. </td> </tr> <tr> <td> DB_UNIQUE_NAME </td> <td> Name of the database as specified in the DB_UNIQUE_NAME initialization parameter. </td> </tr> <tr> <td> DBLINK_INFO </td> <td> Returns the source of a database link session. Specifically, it returns a string of the form: SOURCE_GLOBAL_NAME=dblink_src_global_name, DBLINK_NAME=dblink_name, SOURCE_AUDIT_SESSIONID=dblink_src_audit_sessionid where: dblink_src_global_name is the unique global name of the source database dblink_name is the name of the database link on the source database dblink_src_audit_sessionid is the audit session ID of the session on the source database that initiated the connection to the remote database using dblink_name </td> </tr> <tr> <td> ENTRYID </td> <td> The current audit entry number. The audit entryid sequence is shared between fine-grained audit records and regular audit records. You cannot use this attribute in distributed SQL statements. The correct auditing entry identifier can be seen only through an audit handler for standard or fine-grained audit. </td> </tr> <tr> <td> ENTERPRISE_IDENTITY </td> <td> Returns the user's enterprise-wide identity: For enterprise users: the Oracle Internet Directory DN. For external users: the external identity (Kerberos principal name, Radius schema names, OS user name, Certificate DN). For local users and SYSDBA/SYSOPER logins: NULL. The value of the attribute differs by proxy method: For a proxy with DN: the Oracle Internet Directory DN of the client For a proxy with certificate: the certificate DN of the client for external users; the Oracle Internet Directory DN for global users For a proxy with username: the Oracle Internet Directory DN if the client is an enterprise users; NULL if the client is a local database user. </td> </tr> <tr> <td> FG_JOB_ID </td> <td> Job ID of the current session if it was established by a client foreground process. Null if the session was not established by a foreground process. </td> </tr> <tr> <td> GLOBAL_CONTEXT_MEMORY </td> <td> Returns the number being used in the System Global Area by the globally accessed context. </td> </tr> <tr> <td> GLOBAL_UID </td> <td> Returns the global user ID from Oracle Internet Directory for Enterprise User Security (EUS) logins; returns null for all other logins. </td> </tr> <tr> <td> HOST </td> <td> Name of the host machine from which the client has connected. </td> </tr> <tr> <td> IDENTIFICATION_TYPE </td> <td> Returns the way the user's schema was created in the database. Specifically, it reflects the IDENTIFIED clause in the CREATE/ALTER USER syntax. In the list that follows, the syntax used during schema creation is followed by the identification type returned: IDENTIFIED BY password: LOCAL IDENTIFIED EXTERNALLY: EXTERNAL IDENTIFIED GLOBALLY: GLOBAL SHARED IDENTIFIED GLOBALLY AS DN: GLOBAL PRIVATE </td> </tr> <tr> <td> INSTANCE </td> <td> The instance identification number of the current instance. </td> </tr> <tr> <td> INSTANCE_NAME </td> <td> The name of the instance. </td> </tr> <tr> <td> IP_ADDRESS </td> <td> IP address of the machine from which the client is connected. If the client and server are on the same machine and the connection uses IPv6 addressing, then ::1 is returned. </td> </tr> <tr> <td> ISDBA </td> <td> Returns TRUE if the user has been authenticated as having DBA privileges either through the operating system or through a password file. </td> </tr> <tr> <td> LANG </td> <td> The abbreviated name for the language, a shorter form than the existing 'LANGUAGE' parameter. </td> </tr> <tr> <td> LANGUAGE </td> <td> The language and territory currently used by your session, along with the database character set, in this form: language_territory.characterset </td> </tr> <tr> <td> MODULE </td> <td> The application name (module) set through the DBMS_APPLICATION_INFO package or OCI. </td> </tr> <tr> <td> NETWORK_PROTOCOL </td> <td> Network protocol being used for communication, as specified in the 'PROTOCOL=protocol' portion of the connect string. </td> </tr> <tr> <td> NLS_CALENDAR </td> <td> The current calendar of the current session. </td> </tr> <tr> <td> NLS_CURRENCY </td> <td> The currency of the current session. </td> </tr> <tr> <td> NLS_DATE_FORMAT </td> <td> The date format for the session. </td> </tr> <tr> <td> NLS_DATE_LANGUAGE </td> <td> The language used for expressing dates. </td> </tr> <tr> <td> NLS_SORT </td> <td> BINARY or the linguistic sort basis. </td> </tr> <tr> <td> NLS_TERRITORY </td> <td> The territory of the current session. </td> </tr> <tr> <td> OS_USER </td> <td> Operating system user name of the client process that initiated the database session. </td> </tr> <tr> <td> POLICY_INVOKER </td> <td> The invoker of row-level security (RLS) policy functions. </td> </tr> <tr> <td> PROXY_ENTERPRISE_IDENTITY </td> <td> Returns the Oracle Internet Directory DN when the proxy user is an enterprise user. </td> </tr> <tr> <td> PROXY_USER </td> <td> Name of the database user who opened the current session on behalf of SESSION_USER. </td> </tr> <tr> <td> PROXY_USERID </td> <td> Identifier of the database user who opened the current session on behalf of SESSION_USER. </td> </tr> <tr> <td> SERVER_HOST </td> <td> The host name of the machine on which the instance is running. </td> </tr> <tr> <td> SERVICE_NAME </td> <td> The name of the service to which a given session is connected. </td> </tr> <tr> <td> SESSION_EDITION_ID </td> <td> The identifier of the session edition. </td> </tr> <tr> <td> SESSION_EDITION_NAME </td> <td> The name of the session edition. </td> </tr> <tr> <td> SESSION_USER </td> <td> The name of the database user at logon. For enterprise users, returns the schema. For other users, returns the database user name. This value remains the same throughout the duration of the session. </td> </tr> <tr> <td> SESSION_USERID </td> <td> The identifier of the database user at logon. </td> </tr> <tr> <td> SESSIONID </td> <td> The auditing session identifier. You cannot use this attribute in distributed SQL statements. </td> </tr> <tr> <td> SID </td> <td> The session ID. </td> </tr> <tr> <td> STATEMENTID </td> <td> The auditing statement identifier. STATEMENTID represents the number of SQL statements audited in a given session. You cannot use this attribute in distributed SQL statements. The correct auditing statement identifier can be seen only through an audit handler for standard or fine-grained audit. </td> </tr> <tr> <td> TERMINAL </td> <td> The operating system identifier for the client of the current session. In distributed SQL statements, this attribute returns the identifier for your local session. In a distributed environment, this is supported only for remote SELECT statements, not for remote INSERT, UPDATE, or DELETE operations. (The return length of this parameter may vary by operating system.) </td> </tr> </tbody> </table> <link>Table 5-12&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions184.htm#CIHEFDFI</link> lists the parameters of namespace <code>USERENV</code> that have been deprecated. Do not specify any of these parameters. Instead use the alternatives suggested in the Comments column. Table 5-12 Deprecated Parameters of Namespace USERENV <table> <thead> <tr> <th>Parameter</th> <th>Comments</th> </tr> </thead> <tbody> <tr> <td> AUTHENTICATION_TYPE </td> <td> This parameter returned a value indicating how the user was authenticated. The same information is now available from the new AUTHENTICATION_METHOD parameter combined with IDENTIFICATION_TYPE. </td> </tr> <tr> <td> EXTERNAL_NAME </td> <td> This parameter returned the external name of the user. More complete information can now be obtained from the AUTHENTICATED_IDENTITY and ENTERPRISE_IDENTITY parameter. </td> </tr> </tbody> </table> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions184.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "RANK",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c RANK))) (function_argument ( )))",
        "description": "Aggregate The Syntax is: \n rank_aggregate::= <eps> RANK(expr [, expr ]...) WITHIN GROUP (ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) </eps> Analytic The Syntax is: \n rank_analytic::= <eps> RANK( ) OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>RANK</code> calculates the rank of a value in a group of values. The return type is <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Rows with equal values for the ranking criteria receive the same rank. Oracle Database then adds the number of tied rows to the tied rank to calculate the next rank. Therefore, the ranks may not be consecutive numbers. This function is useful for top-N and bottom-N reporting. As an aggregate function, <code>RANK</code> calculates the rank of a hypothetical row identified by the arguments of the function with respect to a given sort specification. The arguments of the function must all evaluate to constant expressions within each aggregate group, because they identify a single row within each group. The constant argument expressions and the expressions in the <code>ORDER</code> <code>BY</code> clause of the aggregate match by position. Therefore, the number of arguments must be the same and their types must be compatible. As an analytic function, <code>RANK</code> computes the rank of each row returned from a query with respect to the other rows returned by the query, based on the values of the <code>value_exprs</code> in the <code>order_by_clause</code>. Aggregate Example The following example calculates the rank of a hypothetical employee in the sample table <code>hr.employees</code> with a salary of $15,500 and a commission of 5%: <code>SELECT RANK(15500, .05) WITHIN GROUP (ORDER BY salary, commission_pct) \"Rank\" FROM employees; Rank ---------- 105 </code> Similarly, the following query returns the rank for a $15,500 salary among the employee salaries: <code>SELECT RANK(15500) WITHIN GROUP (ORDER BY salary DESC) \"Rank of 15500\" FROM employees; Rank of 15500 -------------- 4 </code> Analytic Example The following statement ranks the employees in the sample <code>hr</code> schema in department 60 based on their salaries. Identical salary values receive the same rank and cause nonconsecutive ranks. Compare this example with the analytic example for <link>DENSE_RANK&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions052.htm#i1064409</link>. <code>SELECT department_id, last_name, salary, RANK() OVER (PARTITION BY department_id ORDER BY salary) RANK FROM employees WHERE department_id = 60 ORDER BY RANK, last_name; DEPARTMENT_ID LAST_NAME SALARY RANK ------------- ------------------------- ---------- ---------- 60 Lorentz 4200 1 60 Austin 4800 2 60 Pataballa 4800 2 60 Ernst 6000 4 60 Hunold 9000 5 </code> ",
        "detail": "Aggregate The Syntax is: \n rank_aggregate::= <eps> RANK(expr [, expr ]...) WITHIN GROUP (ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) </eps> Analytic The Syntax is: \n rank_analytic::= <eps> RANK( ) OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>RANK</code> calculates the rank of a value in a group of values. The return type is <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Rows with equal values for the ranking criteria receive the same rank. Oracle Database then adds the number of tied rows to the tied rank to calculate the next rank. Therefore, the ranks may not be consecutive numbers. This function is useful for top-N and bottom-N reporting. As an aggregate function, <code>RANK</code> calculates the rank of a hypothetical row identified by the arguments of the function with respect to a given sort specification. The arguments of the function must all evaluate to constant expressions within each aggregate group, because they identify a single row within each group. The constant argument expressions and the expressions in the <code>ORDER</code> <code>BY</code> clause of the aggregate match by position. Therefore, the number of arguments must be the same and their types must be compatible. As an analytic function, <code>RANK</code> computes the rank of each row returned from a query with respect to the other rows returned by the query, based on the values of the <code>value_exprs</code> in the <code>order_by_clause</code>. Aggregate Example The following example calculates the rank of a hypothetical employee in the sample table <code>hr.employees</code> with a salary of $15,500 and a commission of 5%: <code>SELECT RANK(15500, .05) WITHIN GROUP (ORDER BY salary, commission_pct) \"Rank\" FROM employees; Rank ---------- 105 </code> Similarly, the following query returns the rank for a $15,500 salary among the employee salaries: <code>SELECT RANK(15500) WITHIN GROUP (ORDER BY salary DESC) \"Rank of 15500\" FROM employees; Rank of 15500 -------------- 4 </code> Analytic Example The following statement ranks the employees in the sample <code>hr</code> schema in department 60 based on their salaries. Identical salary values receive the same rank and cause nonconsecutive ranks. Compare this example with the analytic example for <link>DENSE_RANK&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions052.htm#i1064409</link>. <code>SELECT department_id, last_name, salary, RANK() OVER (PARTITION BY department_id ORDER BY salary) RANK FROM employees WHERE department_id = 60 ORDER BY RANK, last_name; DEPARTMENT_ID LAST_NAME SALARY RANK ------------- ------------------------- ---------- ---------- 60 Lorentz 4200 1 60 Austin 4800 2 60 Pataballa 4800 2 60 Ernst 6000 4 60 Hunold 9000 5 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions141.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "INSERTXMLBEFORE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c INSERTXMLBEFORE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> INSERTXMLBEFORE ( XMLType_instance, XPath_string, value_expr [, namespace_string ] ) </eps> \n The Purpose is: \n <code>INSERTXMLBEFORE</code> inserts a user-supplied value into the target XML before the node indicated by the XPath expression. This function is similar to INSERTXMLAFTER, but it inserts before, not after, the target node. Compare this function with <link>INSERTCHILDXML&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions075.htm#CIHIJEBB</link>. <code>XMLType_instance</code> is an instance of <code>XMLType</code>. <code>XPath_string</code> is an Xpath expression indicating one or more nodes into which one or more child nodes are to be inserted. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. <code>value_expr</code> is a fragment of <code>XMLType</code> that defines one or more nodes being inserted and their position within the parent node. It must resolve to a string. The optional <code>namespace_string</code> provides namespace information for the <code>XPath_string</code>. This parameter must be of type <code>VARCHAR2</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example is similar to that for <link>INSERTCHILDXML&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions075.htm#CIHIJEBB</link>, but it adds a third <code>/Owner</code> node before the <code>/Owner</code> node added in the other example. The output of the query has been formatted for readability. <code>UPDATE warehouses SET warehouse_spec = INSERTXMLBEFORE(warehouse_spec, '/Warehouse/Building/Owner[2]', XMLType('<Owner>ThirdOwner</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Building/Owner') \"Owners\" FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_NAME Owners ----------------------------------- ------------------------------ New Jersey <Owner>GrandCo</Owner> <Owner>ThirdOwner</Owner> <Owner>LesserCo</Owner> </code> ",
        "detail": "The Syntax is: \n <eps> INSERTXMLBEFORE ( XMLType_instance, XPath_string, value_expr [, namespace_string ] ) </eps> \n The Purpose is: \n <code>INSERTXMLBEFORE</code> inserts a user-supplied value into the target XML before the node indicated by the XPath expression. This function is similar to INSERTXMLAFTER, but it inserts before, not after, the target node. Compare this function with <link>INSERTCHILDXML&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions075.htm#CIHIJEBB</link>. <code>XMLType_instance</code> is an instance of <code>XMLType</code>. <code>XPath_string</code> is an Xpath expression indicating one or more nodes into which one or more child nodes are to be inserted. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. <code>value_expr</code> is a fragment of <code>XMLType</code> that defines one or more nodes being inserted and their position within the parent node. It must resolve to a string. The optional <code>namespace_string</code> provides namespace information for the <code>XPath_string</code>. This parameter must be of type <code>VARCHAR2</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example is similar to that for <link>INSERTCHILDXML&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions075.htm#CIHIJEBB</link>, but it adds a third <code>/Owner</code> node before the <code>/Owner</code> node added in the other example. The output of the query has been formatted for readability. <code>UPDATE warehouses SET warehouse_spec = INSERTXMLBEFORE(warehouse_spec, '/Warehouse/Building/Owner[2]', XMLType('<Owner>ThirdOwner</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Building/Owner') \"Owners\" FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_NAME Owners ----------------------------------- ------------------------------ New Jersey <Owner>GrandCo</Owner> <Owner>ThirdOwner</Owner> <Owner>LesserCo</Owner> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions079.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ROWIDTOCHAR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ROWIDTOCHAR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ROWIDTOCHAR(rowid) </eps> \n The Purpose is: \n <code>ROWIDTOCHAR</code> converts a rowid value to <code>VARCHAR2</code> data type. The result of this conversion is always 18 characters long. \n The Examples is: \n The following example converts a rowid value in the <code>employees</code> table to a character value. (Results vary for each build of the sample database.) <code>SELECT ROWID FROM employees WHERE ROWIDTOCHAR(ROWID) LIKE '%JAAB%' ORDER BY ROWID; ROWID ------------------ AAAFfIAAFAAAABSAAb </code> ",
        "detail": "The Syntax is: \n <eps> ROWIDTOCHAR(rowid) </eps> \n The Purpose is: \n <code>ROWIDTOCHAR</code> converts a rowid value to <code>VARCHAR2</code> data type. The result of this conversion is always 18 characters long. \n The Examples is: \n The following example converts a rowid value in the <code>employees</code> table to a character value. (Results vary for each build of the sample database.) <code>SELECT ROWID FROM employees WHERE ROWIDTOCHAR(ROWID) LIKE '%JAAB%' ORDER BY ROWID; ROWID ------------------ AAAFfIAAFAAAABSAAb </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions157.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CUME_DIST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CUME_DIST))) (function_argument ( )))",
        "description": "Aggregate The Syntax is: \n cume_dist_aggregate::= <eps> CUME_DIST(expr[,expr ]...) WITHIN GROUP (ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) </eps> Analytic The Syntax is: \n cume_dist_analytic::= <eps> CUME_DIST() OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>CUME_DIST</code> calculates the cumulative distribution of a value in a group of values. The range of values returned by <code>CUME_DIST</code> is >0 to <=1. Tie values always evaluate to the same cumulative distribution value. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence As an aggregate function, <code>CUME_DIST</code> calculates, for a hypothetical row <code>r</code> identified by the arguments of the function and a corresponding sort specification, the relative position of row <code>r</code> among the rows in the aggregation group. Oracle makes this calculation as if the hypothetical row <code>r</code> were inserted into the group of rows to be aggregated over. The arguments of the function identify a single hypothetical row within each aggregate group. Therefore, they must all evaluate to constant expressions within each aggregate group. The constant argument expressions and the expressions in the <code>ORDER</code> <code>BY</code> clause of the aggregate match by position. Therefore, the number of arguments must be the same and their types must be compatible. As an analytic function, <code>CUME_DIST</code> computes the relative position of a specified value in a group of values. For a row <code>r</code>, assuming ascending ordering, the <code>CUME_DIST</code> of <code>r</code> is the number of rows with values lower than or equal to the value of <code>r</code>, divided by the number of rows being evaluated (the entire query result set or a partition). Aggregate Example The following example calculates the cumulative distribution of a hypothetical employee with a salary of $15,500 and commission rate of 5% among the employees in the sample table <code>oe.employees</code>: <code>SELECT CUME_DIST(15500, .05) WITHIN GROUP (ORDER BY salary, commission_pct) \"Cume-Dist of 15500\" FROM employees; Cume-Dist of 15500 ------------------ .972222222 </code> Analytic Example The following example calculates the salary percentile for each employee in the purchasing division. For example, 40% of clerks have salaries less than or equal to Himuro. <code>SELECT job_id, last_name, salary, CUME_DIST() OVER (PARTITION BY job_id ORDER BY salary) AS cume_dist FROM employees WHERE job_id LIKE 'PU%' ORDER BY job_id, last_name, salary, cume_dist; JOB_ID LAST_NAME SALARY CUME_DIST ---------- ------------------------- ---------- ---------- PU_CLERK Baida 2900 .8 PU_CLERK Colmenares 2500 .2 PU_CLERK Himuro 2600 .4 PU_CLERK Khoo 3100 1 PU_CLERK Tobias 2800 .6 PU_MAN Raphaely 11000 1 </code> ",
        "detail": "Aggregate The Syntax is: \n cume_dist_aggregate::= <eps> CUME_DIST(expr[,expr ]...) WITHIN GROUP (ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) </eps> Analytic The Syntax is: \n cume_dist_analytic::= <eps> CUME_DIST() OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>CUME_DIST</code> calculates the cumulative distribution of a value in a group of values. The range of values returned by <code>CUME_DIST</code> is >0 to <=1. Tie values always evaluate to the same cumulative distribution value. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence As an aggregate function, <code>CUME_DIST</code> calculates, for a hypothetical row <code>r</code> identified by the arguments of the function and a corresponding sort specification, the relative position of row <code>r</code> among the rows in the aggregation group. Oracle makes this calculation as if the hypothetical row <code>r</code> were inserted into the group of rows to be aggregated over. The arguments of the function identify a single hypothetical row within each aggregate group. Therefore, they must all evaluate to constant expressions within each aggregate group. The constant argument expressions and the expressions in the <code>ORDER</code> <code>BY</code> clause of the aggregate match by position. Therefore, the number of arguments must be the same and their types must be compatible. As an analytic function, <code>CUME_DIST</code> computes the relative position of a specified value in a group of values. For a row <code>r</code>, assuming ascending ordering, the <code>CUME_DIST</code> of <code>r</code> is the number of rows with values lower than or equal to the value of <code>r</code>, divided by the number of rows being evaluated (the entire query result set or a partition). Aggregate Example The following example calculates the cumulative distribution of a hypothetical employee with a salary of $15,500 and commission rate of 5% among the employees in the sample table <code>oe.employees</code>: <code>SELECT CUME_DIST(15500, .05) WITHIN GROUP (ORDER BY salary, commission_pct) \"Cume-Dist of 15500\" FROM employees; Cume-Dist of 15500 ------------------ .972222222 </code> Analytic Example The following example calculates the salary percentile for each employee in the purchasing division. For example, 40% of clerks have salaries less than or equal to Himuro. <code>SELECT job_id, last_name, salary, CUME_DIST() OVER (PARTITION BY job_id ORDER BY salary) AS cume_dist FROM employees WHERE job_id LIKE 'PU%' ORDER BY job_id, last_name, salary, cume_dist; JOB_ID LAST_NAME SALARY CUME_DIST ---------- ------------------------- ---------- ---------- PU_CLERK Baida 2900 .8 PU_CLERK Colmenares 2500 .2 PU_CLERK Himuro 2600 .4 PU_CLERK Khoo 3100 1 PU_CLERK Tobias 2800 .6 PU_MAN Raphaely 11000 1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions043.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "FEATURE_SET",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c FEATURE_SET))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> FEATURE_SET( [ schema . ] model [, topN [, cutoff ] ] mining_attribute_clause ) </eps> mining_attribute_clause:= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with feature extraction models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns a varray of objects containing all possible features. Each object in the varray is a pair of scalar values containing the feature ID and the feature value. The object fields are named <code>FEATURE\u00ad_ID</code> and <code>VALUE</code>, and both are Oracle <code>NUMBER</code>. The optional <code>topN</code> argument is a positive integer that restricts the set of features to those that have one of the top <code>N</code> values. If there is a tie at the <code>Nth</code> value, then the database still returns only <code>N</code> values. If you omit this argument, then the function returns all features. The optional <code>cutoff</code> argument restricts the returned features to only those that have a feature value greater than or equal to the specified cutoff. To filter only by <code>cutoff</code>, specify <code>NULL</code> for <code>topN</code> and the desired cutoff for <code>cutoff</code>. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the top features corresponding to a given customer record (based on match quality), and determines the top attributes for each feature (based on coefficient > 0.25). This example and the prerequisite data mining operations, including the creation of the model, views, and type, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmnmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>WITH feat_tab AS ( SELECT F.feature_id fid, A.attribute_name attr, TO_CHAR(A.attribute_value) val, A.coefficient coeff FROM TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_NMF('nmf_sh_sample')) F, TABLE(F.attribute_set) A WHERE A.coefficient > 0.25 ), feat AS ( SELECT fid, CAST(COLLECT(Featattr(attr, val, coeff)) AS Featattrs) f_attrs FROM feat_tab GROUP BY fid ), cust_10_features AS ( SELECT T.cust_id, S.feature_id, S.value FROM (SELECT cust_id, FEATURE_SET(nmf_sh_sample, 10 USING *) pset FROM nmf_sh_sample_apply_prepared WHERE cust_id = 100002) T, TABLE(T.pset) S ) SELECT A.value, A.feature_id fid, B.attr, B.val, B.coeff FROM cust_10_features A, (SELECT T.fid, F.* FROM feat T, TABLE(T.f_attrs) F) B WHERE A.feature_id = B.fid ORDER BY A.value DESC, A.feature_id ASC, coeff DESC, attr ASC, val ASC; VALUE FID ATTR VAL COEFF -------- ---- ------------------------- ------------------------ ------- 6.8409 7 YRS_RESIDENCE 1.3879 6.8409 7 BOOKKEEPING_APPLICATION .4388 6.8409 7 CUST_GENDER M .2956 6.8409 7 COUNTRY_NAME United States of America .2848 6.4975 3 YRS_RESIDENCE 1.2668 6.4975 3 BOOKKEEPING_APPLICATION .3465 6.4975 3 COUNTRY_NAME United States of America .2927 6.4886 2 YRS_RESIDENCE 1.3285 6.4886 2 CUST_GENDER M .2819 6.4886 2 PRINTER_SUPPLIES .2704 6.3953 4 YRS_RESIDENCE 1.2931 5.9640 6 YRS_RESIDENCE 1.1585 5.9640 6 HOME_THEATER_PACKAGE .2576 5.2424 5 YRS_RESIDENCE 1.0067 2.4714 8 YRS_RESIDENCE .3297 2.3559 1 YRS_RESIDENCE .2768 2.3559 1 FLAT_PANEL_MONITOR .2593 17 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> FEATURE_SET( [ schema . ] model [, topN [, cutoff ] ] mining_attribute_clause ) </eps> mining_attribute_clause:= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with feature extraction models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns a varray of objects containing all possible features. Each object in the varray is a pair of scalar values containing the feature ID and the feature value. The object fields are named <code>FEATURE\u00ad_ID</code> and <code>VALUE</code>, and both are Oracle <code>NUMBER</code>. The optional <code>topN</code> argument is a positive integer that restricts the set of features to those that have one of the top <code>N</code> values. If there is a tie at the <code>Nth</code> value, then the database still returns only <code>N</code> values. If you omit this argument, then the function returns all features. The optional <code>cutoff</code> argument restricts the returned features to only those that have a feature value greater than or equal to the specified cutoff. To filter only by <code>cutoff</code>, specify <code>NULL</code> for <code>topN</code> and the desired cutoff for <code>cutoff</code>. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the top features corresponding to a given customer record (based on match quality), and determines the top attributes for each feature (based on coefficient > 0.25). This example and the prerequisite data mining operations, including the creation of the model, views, and type, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmnmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>WITH feat_tab AS ( SELECT F.feature_id fid, A.attribute_name attr, TO_CHAR(A.attribute_value) val, A.coefficient coeff FROM TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_NMF('nmf_sh_sample')) F, TABLE(F.attribute_set) A WHERE A.coefficient > 0.25 ), feat AS ( SELECT fid, CAST(COLLECT(Featattr(attr, val, coeff)) AS Featattrs) f_attrs FROM feat_tab GROUP BY fid ), cust_10_features AS ( SELECT T.cust_id, S.feature_id, S.value FROM (SELECT cust_id, FEATURE_SET(nmf_sh_sample, 10 USING *) pset FROM nmf_sh_sample_apply_prepared WHERE cust_id = 100002) T, TABLE(T.pset) S ) SELECT A.value, A.feature_id fid, B.attr, B.val, B.coeff FROM cust_10_features A, (SELECT T.fid, F.* FROM feat T, TABLE(T.f_attrs) F) B WHERE A.feature_id = B.fid ORDER BY A.value DESC, A.feature_id ASC, coeff DESC, attr ASC, val ASC; VALUE FID ATTR VAL COEFF -------- ---- ------------------------- ------------------------ ------- 6.8409 7 YRS_RESIDENCE 1.3879 6.8409 7 BOOKKEEPING_APPLICATION .4388 6.8409 7 CUST_GENDER M .2956 6.8409 7 COUNTRY_NAME United States of America .2848 6.4975 3 YRS_RESIDENCE 1.2668 6.4975 3 BOOKKEEPING_APPLICATION .3465 6.4975 3 COUNTRY_NAME United States of America .2927 6.4886 2 YRS_RESIDENCE 1.3285 6.4886 2 CUST_GENDER M .2819 6.4886 2 PRINTER_SUPPLIES .2704 6.3953 4 YRS_RESIDENCE 1.2931 5.9640 6 YRS_RESIDENCE 1.1585 5.9640 6 HOME_THEATER_PACKAGE .2576 5.2424 5 YRS_RESIDENCE 1.0067 2.4714 8 YRS_RESIDENCE .3297 2.3559 1 YRS_RESIDENCE .2768 2.3559 1 FLAT_PANEL_MONITOR .2593 17 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions063.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_CROSSTAB",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_CROSSTAB))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STATS_CROSSTAB(expr1, expr2 [, { CHISQ_OBS | CHISQ_SIG | CHISQ_DF | PHI_COEFFICIENT | CRAMERS_V | CONT_COEFFICIENT | COHENS_K } ] ) </eps> \n The Purpose is: \n Crosstabulation (commonly called crosstab) is a method used to analyze two nominal variables. The <code>STATS_CROSSTAB</code> function takes three arguments: two expressions and a return value of type <code>VARCHAR2</code>. <code>expr1</code> and <code>expr2</code> are the two variables being analyzed. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>CHISQ_SIG</code>. The meaning of the return values is shown in <link>Table 5-4&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions170.htm#g1514175</link>. Table 5-4 STATS_CROSSTAB Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> CHISQ_OBS </td> <td> Observed value of chi-squared </td> </tr> <tr> <td> CHISQ_SIG </td> <td> Significance of observed chi-squared </td> </tr> <tr> <td> CHISQ_DF </td> <td> Degree of freedom for chi-squared </td> </tr> <tr> <td> PHI_COEFFICIENT </td> <td> Phi coefficient </td> </tr> <tr> <td> CRAMERS_V </td> <td> Cramer's V statistic </td> </tr> <tr> <td> CONT_COEFFICIENT </td> <td> Contingency coefficient </td> </tr> <tr> <td> COHENS_K </td> <td> Cohen's kappa </td> </tr> </tbody> </table> STATS_CROSSTAB Example The following example determines the strength of the association between gender and income level: <code>SELECT STATS_CROSSTAB (cust_gender, cust_income_level, 'CHISQ_OBS') chi_squared, STATS_CROSSTAB (cust_gender, cust_income_level, 'CHISQ_SIG') p_value, STATS_CROSSTAB (cust_gender, cust_income_level, 'PHI_COEFFICIENT') phi_coefficient FROM sh.customers; CHI_SQUARED P_VALUE PHI_COEFFICIENT ----------- ---------- --------------- 251.690705 1.2364E-47 .067367056 </code> ",
        "detail": "The Syntax is: \n <eps> STATS_CROSSTAB(expr1, expr2 [, { CHISQ_OBS | CHISQ_SIG | CHISQ_DF | PHI_COEFFICIENT | CRAMERS_V | CONT_COEFFICIENT | COHENS_K } ] ) </eps> \n The Purpose is: \n Crosstabulation (commonly called crosstab) is a method used to analyze two nominal variables. The <code>STATS_CROSSTAB</code> function takes three arguments: two expressions and a return value of type <code>VARCHAR2</code>. <code>expr1</code> and <code>expr2</code> are the two variables being analyzed. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>CHISQ_SIG</code>. The meaning of the return values is shown in <link>Table 5-4&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions170.htm#g1514175</link>. Table 5-4 STATS_CROSSTAB Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> CHISQ_OBS </td> <td> Observed value of chi-squared </td> </tr> <tr> <td> CHISQ_SIG </td> <td> Significance of observed chi-squared </td> </tr> <tr> <td> CHISQ_DF </td> <td> Degree of freedom for chi-squared </td> </tr> <tr> <td> PHI_COEFFICIENT </td> <td> Phi coefficient </td> </tr> <tr> <td> CRAMERS_V </td> <td> Cramer's V statistic </td> </tr> <tr> <td> CONT_COEFFICIENT </td> <td> Contingency coefficient </td> </tr> <tr> <td> COHENS_K </td> <td> Cohen's kappa </td> </tr> </tbody> </table> STATS_CROSSTAB Example The following example determines the strength of the association between gender and income level: <code>SELECT STATS_CROSSTAB (cust_gender, cust_income_level, 'CHISQ_OBS') chi_squared, STATS_CROSSTAB (cust_gender, cust_income_level, 'CHISQ_SIG') p_value, STATS_CROSSTAB (cust_gender, cust_income_level, 'PHI_COEFFICIENT') phi_coefficient FROM sh.customers; CHI_SQUARED P_VALUE PHI_COEFFICIENT ----------- ---------- --------------- 251.690705 1.2364E-47 .067367056 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions170.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLISVALID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLISVALID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLISVALID ( XMLType_instance [, XMLSchema_URL [, element ]] ) </eps> \n The Purpose is: \n <code>XMLISVALID</code> checks whether the input <code>XMLType_instance</code> conforms to the relevant XML schema. It does not change the validation status recorded for <code>XMLType_instance</code>. If the input XML document is determined to be valid, then <code>XMLISVALID</code> returns 1; otherwise, it returns 0. If you provide <code>XMLSchema_URL</code> as an argument, then that is used to check conformance. Otherwise, the XML schema specified by the XML document is used to check conformance. <code>XMLType_instance</code> is the XMLType instance to be validated. <code>XMLSchema_URL</code> is the URL of the XML schema against which to check conformance. <code>element</code> is the element of the specified schema against which to check conformance. Use this if you have an XML schema that defines more than one top level element, and you want to check conformance against a specific one of those elements. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb03usg.htm#ADXDB4105</link> for information on the use of this function, including examples ",
        "detail": "The Syntax is: \n <eps> XMLISVALID ( XMLType_instance [, XMLSchema_URL [, element ]] ) </eps> \n The Purpose is: \n <code>XMLISVALID</code> checks whether the input <code>XMLType_instance</code> conforms to the relevant XML schema. It does not change the validation status recorded for <code>XMLType_instance</code>. If the input XML document is determined to be valid, then <code>XMLISVALID</code> returns 1; otherwise, it returns 0. If you provide <code>XMLSchema_URL</code> as an argument, then that is used to check conformance. Otherwise, the XML schema specified by the XML document is used to check conformance. <code>XMLType_instance</code> is the XMLType instance to be validated. <code>XMLSchema_URL</code> is the URL of the XML schema against which to check conformance. <code>element</code> is the element of the specified schema against which to check conformance. Use this if you have an XML schema that defines more than one top level element, and you want to check conformance against a specific one of those elements. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb03usg.htm#ADXDB4105</link> for information on the use of this function, including examples ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions245.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NTH_VALUE",
        "tree": "(other_function (over_clause_keyword NTH_VALUE) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> NTH_VALUE (measure_expr, n) [ FROM { FIRST | LAST } ][ { RESPECT | IGNORE } NULLS ] OVER (analytic_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>analytic_clause</code> \n The Purpose is: \n <code>NTH_VALUE</code> returns the <code>measure_expr</code> value of the nth row in the window defined by the <code>analytic_clause</code>. The returned value has the data type of the <code>measure_expr</code>. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>measure_expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. <code>n</code> determines the nth row for which the measure value is to be returned. <code>n</code> can be a constant, bind variable, column, or an expression involving them, as long as it resolves to a positive integer. The function returns <code>NULL</code> if the data source window has fewer than <code>n</code> rows. If <code>n</code> is null, then the function returns an error. <code>FROM</code> {<code>FIRST</code> | <code>LAST</code>} determines whether the calculation begins at the first or last row of the window. The default is <code>FROM</code> <code>FIRST</code>. If you omit the <code>windowing_clause</code> of the <code>analytic_clause</code>, it defaults to <code>RANGE</code> <code>BETWEEN</code> <code>UNBOUNDED</code> <code>PRECEDING</code> <code>AND</code> <code>CURRENT</code> <code>ROW</code>. This default sometimes returns an unexpected value for <code>NTH_VALUE</code> ... <code>FROM</code> <code>LAST</code> ... , because the last value in the window is at the bottom of the window, which is not fixed. It keeps changing as the current row changes. For expected results, specify the <code>windowing_clause</code> as <code>RANGE</code> <code>BETWEEN</code> <code>UNBOUNDED</code> <code>PRECEDING</code> <code>AND</code> <code>UNBOUNDED</code> <code>FOLLOWING</code>. Alternatively, you can specify the <code>windowing_clause</code> as <code>RANGE</code> <code>BETWEEN</code> <code>CURRENT</code> <code>ROW</code> <code>AND</code> <code>UNBOUNDED</code> <code>FOLLOWING</code>. See Also: <link>Oracle Database Data Warehousing Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e25554/analysis.htm#DWHSG02017</link> for more information on the use of this function \n The Examples is: \n The following example shows the minimum <code>amount_sold</code> value for the second <code>channel_id</code> in ascending order for each <code>prod_id</code> between 13 and 16: <code>SELECT prod_id, channel_id, MIN(amount_sold), NTH_VALUE(MIN(amount_sold), 2) OVER (PARTITION BY prod_id ORDER BY channel_id ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) nv FROM sales WHERE prod_id BETWEEN 13 and 16 GROUP BY prod_id, channel_id; PROD_ID CHANNEL_ID MIN(AMOUNT_SOLD) NV ---------- ---------- ---------------- ---------- 13 2 907.34 906.2 13 3 906.2 906.2 13 4 842.21 906.2 14 2 1015.94 1036.72 14 3 1036.72 1036.72 14 4 935.79 1036.72 15 2 871.19 871.19 15 3 871.19 871.19 15 4 871.19 871.19 16 2 266.84 266.84 16 3 266.84 266.84 16 4 266.84 266.84 16 9 11.99 266.84 13 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> NTH_VALUE (measure_expr, n) [ FROM { FIRST | LAST } ][ { RESPECT | IGNORE } NULLS ] OVER (analytic_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>analytic_clause</code> \n The Purpose is: \n <code>NTH_VALUE</code> returns the <code>measure_expr</code> value of the nth row in the window defined by the <code>analytic_clause</code>. The returned value has the data type of the <code>measure_expr</code>. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>measure_expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. <code>n</code> determines the nth row for which the measure value is to be returned. <code>n</code> can be a constant, bind variable, column, or an expression involving them, as long as it resolves to a positive integer. The function returns <code>NULL</code> if the data source window has fewer than <code>n</code> rows. If <code>n</code> is null, then the function returns an error. <code>FROM</code> {<code>FIRST</code> | <code>LAST</code>} determines whether the calculation begins at the first or last row of the window. The default is <code>FROM</code> <code>FIRST</code>. If you omit the <code>windowing_clause</code> of the <code>analytic_clause</code>, it defaults to <code>RANGE</code> <code>BETWEEN</code> <code>UNBOUNDED</code> <code>PRECEDING</code> <code>AND</code> <code>CURRENT</code> <code>ROW</code>. This default sometimes returns an unexpected value for <code>NTH_VALUE</code> ... <code>FROM</code> <code>LAST</code> ... , because the last value in the window is at the bottom of the window, which is not fixed. It keeps changing as the current row changes. For expected results, specify the <code>windowing_clause</code> as <code>RANGE</code> <code>BETWEEN</code> <code>UNBOUNDED</code> <code>PRECEDING</code> <code>AND</code> <code>UNBOUNDED</code> <code>FOLLOWING</code>. Alternatively, you can specify the <code>windowing_clause</code> as <code>RANGE</code> <code>BETWEEN</code> <code>CURRENT</code> <code>ROW</code> <code>AND</code> <code>UNBOUNDED</code> <code>FOLLOWING</code>. See Also: <link>Oracle Database Data Warehousing Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e25554/analysis.htm#DWHSG02017</link> for more information on the use of this function \n The Examples is: \n The following example shows the minimum <code>amount_sold</code> value for the second <code>channel_id</code> in ascending order for each <code>prod_id</code> between 13 and 16: <code>SELECT prod_id, channel_id, MIN(amount_sold), NTH_VALUE(MIN(amount_sold), 2) OVER (PARTITION BY prod_id ORDER BY channel_id ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) nv FROM sales WHERE prod_id BETWEEN 13 and 16 GROUP BY prod_id, channel_id; PROD_ID CHANNEL_ID MIN(AMOUNT_SOLD) NV ---------- ---------- ---------------- ---------- 13 2 907.34 906.2 13 3 906.2 906.2 13 4 842.21 906.2 14 2 1015.94 1036.72 14 3 1036.72 1036.72 14 4 935.79 1036.72 15 2 871.19 871.19 15 3 871.19 871.19 15 4 871.19 871.19 16 2 266.84 266.84 16 3 266.84 266.84 16 4 266.84 266.84 16 9 11.99 266.84 13 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions114.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STDDEV",
        "tree": "(other_function (over_clause_keyword STDDEV) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> STDDEV([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>STDDEV</code> returns the sample standard deviation of <code>expr</code>, a set of numbers. You can use it as both an aggregate and analytic function. It differs from <code>STDDEV_SAMP</code> in that <code>STDDEV</code> returns zero when it has only 1 row of input data, whereas <code>STDDEV_SAMP</code> returns null. Oracle Database calculates the standard deviation as the square root of the variance defined for the <code>VARIANCE</code> aggregate function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link>, <link>VARIANCE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions232.htm#i89144</link>, and <link>STDDEV_SAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions180.htm#i86697</link> <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> Aggregate \n The Examples is: \n The following example returns the standard deviation of the salaries in the sample <code>hr.employees</code> table: <code>SELECT STDDEV(salary) \"Deviation\" FROM employees; Deviation ---------- 3909.36575 </code> Analytic \n The Examples is: \n The query in the following example returns the cumulative standard deviation of the salaries in Department 80 in the sample table <code>hr.employees</code>, ordered by <code>hire_date</code>: <code>SELECT last_name, salary, STDDEV(salary) OVER (ORDER BY hire_date) \"StdDev\" FROM employees WHERE department_id = 30 ORDER BY last_name, salary, \"StdDev\"; LAST_NAME SALARY StdDev ------------------------- ---------- ---------- Baida 2900 4035.26125 Colmenares 2500 3362.58829 Himuro 2600 3649.2465 Khoo 3100 5586.14357 Raphaely 11000 0 Tobias 2800 4650.0896 </code> ",
        "detail": "The Syntax is: \n <eps> STDDEV([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>STDDEV</code> returns the sample standard deviation of <code>expr</code>, a set of numbers. You can use it as both an aggregate and analytic function. It differs from <code>STDDEV_SAMP</code> in that <code>STDDEV</code> returns zero when it has only 1 row of input data, whereas <code>STDDEV_SAMP</code> returns null. Oracle Database calculates the standard deviation as the square root of the variance defined for the <code>VARIANCE</code> aggregate function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link>, <link>VARIANCE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions232.htm#i89144</link>, and <link>STDDEV_SAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions180.htm#i86697</link> <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> Aggregate \n The Examples is: \n The following example returns the standard deviation of the salaries in the sample <code>hr.employees</code> table: <code>SELECT STDDEV(salary) \"Deviation\" FROM employees; Deviation ---------- 3909.36575 </code> Analytic \n The Examples is: \n The query in the following example returns the cumulative standard deviation of the salaries in Department 80 in the sample table <code>hr.employees</code>, ordered by <code>hire_date</code>: <code>SELECT last_name, salary, STDDEV(salary) OVER (ORDER BY hire_date) \"StdDev\" FROM employees WHERE department_id = 30 ORDER BY last_name, salary, \"StdDev\"; LAST_NAME SALARY StdDev ------------------------- ---------- ---------- Baida 2900 4035.26125 Colmenares 2500 3362.58829 Himuro 2600 3649.2465 Khoo 3100 5586.14357 Raphaely 11000 0 Tobias 2800 4650.0896 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions178.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ABS",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ABS))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ABS(n) </eps> \n The Purpose is: \n <code>ABS</code> returns the absolute value of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the absolute value of -15: <code>SELECT ABS(-15) \"Absolute\" FROM DUAL; Absolute ---------- 15 </code> ",
        "detail": "The Syntax is: \n <eps> ABS(n) </eps> \n The Purpose is: \n <code>ABS</code> returns the absolute value of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the absolute value of -15: <code>SELECT ABS(-15) \"Absolute\" FROM DUAL; Absolute ---------- 15 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions009.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "FLOOR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c FLOOR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> FLOOR(n) </eps> \n The Purpose is: \n <code>FLOOR</code> returns the largest integer equal to or less than <code>n</code>. The number <code>n</code> can always be written as the sum of an integer <code>k</code> and a positive fraction <code>f</code> such that 0 <= <code>f</code> < 1 and <code>n</code> = <code>k</code> + <code>f</code>. The value of <code>FLOOR</code> is the integer <code>k</code>. Thus, the value of <code>FLOOR</code> is <code>n</code> itself if and only if <code>n</code> is precisely an integer. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>CEIL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions024.htm#i97801</link> \n The Examples is: \n The following example returns the largest integer equal to or less than 15.7: <code>SELECT FLOOR(15.7) \"Floor\" FROM DUAL; Floor ---------- 15 </code> ",
        "detail": "The Syntax is: \n <eps> FLOOR(n) </eps> \n The Purpose is: \n <code>FLOOR</code> returns the largest integer equal to or less than <code>n</code>. The number <code>n</code> can always be written as the sum of an integer <code>k</code> and a positive fraction <code>f</code> such that 0 <= <code>f</code> < 1 and <code>n</code> = <code>k</code> + <code>f</code>. The value of <code>FLOOR</code> is the integer <code>k</code>. Thus, the value of <code>FLOOR</code> is <code>n</code> itself if and only if <code>n</code> is precisely an integer. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>CEIL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions024.htm#i97801</link> \n The Examples is: \n The following example returns the largest integer equal to or less than 15.7: <code>SELECT FLOOR(15.7) \"Floor\" FROM DUAL; Floor ---------- 15 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions067.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CAST",
        "tree": "(other_function CAST ( ))",
        "description": "The Syntax is: \n <eps> CAST({ expr | MULTISET (subquery) } AS type_name) </eps> \n The Purpose is: \n <code>CAST</code> converts one built-in data type or collection-typed value into another built-in data type or collection-typed value. <code>CAST</code> lets you convert built-in data types or collection-typed values of one type into another built-in data type or collection type. You can cast an unnamed operand (such as a date or the result set of a subquery) or a named collection (such as a varray or a nested table) into a type-compatible data type or named collection. The <code>type_name</code> must be the name of a built-in data type or collection type and the operand must be a built-in data type or must evaluate to a collection value. For the operand, <code>expr</code> can be either a built-in data type, a collection type, or an instance of an <code>ANYDATA</code> type. If <code>expr</code> is an instance of an <code>ANYDATA</code> type, then <code>CAST</code> tries to extract the value of the <code>ANYDATA</code> instance and return it if it matches the cast target type, otherwise, null will be returned. <code>MULTISET</code> informs Oracle Database to take the result set of the subquery and return a collection value. <link>Table 5-1&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions023.htm#g1514003</link> shows which built-in data types can be cast into which other built-in data types. (<code>CAST</code> does not support <code>LONG</code>, <code>LONG</code> <code>RAW</code>, or the Oracle-supplied types.) <code>CAST</code> does not directly support any of the LOB data types. When you use <code>CAST</code> to convert a <code>CLOB</code> value into a character data type or a <code>BLOB</code> value into the <code>RAW</code> data type, the database implicitly converts the LOB value to character or raw data and then explicitly casts the resulting value into the target data type. If the resulting value is larger than the target type, then the database returns an error. When you use <code>CAST</code> ... <code>MULTISET</code> to get a collection value, each select list item in the query passed to the <code>CAST</code> function is converted to the corresponding attribute type of the target collection element type. Table 5-1 Casting Built-In Data Types <table> <thead> <tr> <th></th> <th>from BINARY_FLOAT, BINARY_DOUBLE</th> <th>from CHAR, VARCHAR2</th> <th>fromNUMBER</th> <th>from DATETIME / INTERVAL (Note 1)</th> <th>fromRAW</th> <th>from ROWID, UROWID (Note 2)</th> <th>from NCHAR, NVARCHAR2</th> </tr> </thead> <tbody> <tr> <td> to BINARY_FLOAT, BINARY_DOUBLE </td> <td> X </td> <td> X </td> <td> X </td> <td> -- </td> <td> -- </td> <td> -- </td> <td> X </td> </tr> <tr> <td> to CHAR, VARCHAR2 </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> <td> -- </td> </tr> <tr> <td> to NUMBER </td> <td> X </td> <td> X </td> <td> X </td> <td> -- </td> <td> -- </td> <td> -- </td> <td> X </td> </tr> <tr> <td> to DATE, TIMESTAMP, INTERVAL </td> <td> -- </td> <td> X </td> <td> -- </td> <td> X </td> <td> -- </td> <td> -- </td> <td> -- </td> </tr> <tr> <td> to RAW </td> <td> -- </td> <td> X </td> <td> -- </td> <td> -- </td> <td> X </td> <td> -- </td> <td> -- </td> </tr> <tr> <td> to ROWID, UROWID </td> <td> -- </td> <td> X </td> <td> -- </td> <td> -- </td> <td> -- </td> <td> X </td> <td> -- </td> </tr> <tr> <td> to NCHAR, NVARCHAR2 </td> <td> X </td> <td> -- </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> </tr> </tbody> </table> Note 1: Datetime/interval includes <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIMEZONE</code>, <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>, and <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code>. Note 2: You cannot cast a <code>UROWID</code> to a <code>ROWID</code> if the <code>UROWID</code> contains the value of a <code>ROWID</code> of an index-organized table. If you want to cast a named collection type into another named collection type, then the elements of both collections must be of the same type. See Also: <link>\"Implicit Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i163326</link> for information on how Oracle Database implicitly converts collection type data into character data and <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> If the result set of <code>subquery</code> can evaluate to multiple rows, then you must specify the <code>MULTISET</code> keyword. The rows resulting from the subquery form the elements of the collection value into which they are cast. Without the <code>MULTISET</code> keyword, the subquery is treated as a scalar subquery. Built-In Data Type \n The Examples is: \n The following examples use the <code>CAST</code> function with scalar data types. The first example converts text to a timestamp value by applying the format model provided in the session parameter <code>NLS_TIMESTAMP_FORMAT</code>. If you want to avoid dependency on this NLS parameter, then you can use the <code>TO_DATE</code> as shown in the second example. <code>SELECT CAST('22-OCT-1997' AS TIMESTAMP WITH LOCAL TIME ZONE) FROM DUAL; SELECT CAST(TO_DATE('22-Oct-1997', 'DD-Mon-YYYY') AS TIMESTAMP WITH LOCAL TIME ZONE) FROM DUAL; </code> In the preceding example, <code>TO_DATE</code> converts from text to <code>DATE</code>, and <code>CAST</code> converts from <code>DATE</code> to <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, interpreting the date in the session time zone (<code>SESSIONTIMEZONE</code>). <code>SELECT product_id, CAST(ad_sourcetext AS VARCHAR2(30)) text FROM print_media ORDER BY product_id; </code> Collection \n The Examples is: \n The <code>CAST</code> examples that follow build on the <code>cust_address_typ</code> found in the sample order entry schema, <code>oe</code>. <code>CREATE TYPE address_book_t AS TABLE OF cust_address_typ; / CREATE TYPE address_array_t AS VARRAY(3) OF cust_address_typ; / CREATE TABLE cust_address ( custno NUMBER, street_address VARCHAR2(40), postal_code VARCHAR2(10), city VARCHAR2(30), state_province VARCHAR2(10), country_id CHAR(2)); CREATE TABLE cust_short (custno NUMBER, name VARCHAR2(31)); CREATE TABLE states (state_id NUMBER, addresses address_array_t); </code> This example casts a subquery: <code>SELECT s.custno, s.name, CAST(MULTISET(SELECT ca.street_address, ca.postal_code, ca.city, ca.state_province, ca.country_id FROM cust_address ca WHERE s.custno = ca.custno) AS address_book_t) FROM cust_short s ORDER BY s.custno; </code> <code>CAST</code> converts a varray type column into a nested table: <code>SELECT CAST(s.addresses AS address_book_t) FROM states s WHERE s.state_id = 111; </code> The following objects create the basis of the example that follows: <code>CREATE TABLE projects (employee_id NUMBER, project_name VARCHAR2(10)); CREATE TABLE emps_short (employee_id NUMBER, last_name VARCHAR2(10)); CREATE TYPE project_table_typ AS TABLE OF VARCHAR2(10); / </code> The following example of a <code>MULTISET</code> expression uses these objects: <code>SELECT e.last_name, CAST(MULTISET(SELECT p.project_name FROM projects p WHERE p.employee_id = e.employee_id ORDER BY p.project_name) AS project_table_typ) FROM emps_short e ORDER BY e.last_name; </code> ",
        "detail": "The Syntax is: \n <eps> CAST({ expr | MULTISET (subquery) } AS type_name) </eps> \n The Purpose is: \n <code>CAST</code> converts one built-in data type or collection-typed value into another built-in data type or collection-typed value. <code>CAST</code> lets you convert built-in data types or collection-typed values of one type into another built-in data type or collection type. You can cast an unnamed operand (such as a date or the result set of a subquery) or a named collection (such as a varray or a nested table) into a type-compatible data type or named collection. The <code>type_name</code> must be the name of a built-in data type or collection type and the operand must be a built-in data type or must evaluate to a collection value. For the operand, <code>expr</code> can be either a built-in data type, a collection type, or an instance of an <code>ANYDATA</code> type. If <code>expr</code> is an instance of an <code>ANYDATA</code> type, then <code>CAST</code> tries to extract the value of the <code>ANYDATA</code> instance and return it if it matches the cast target type, otherwise, null will be returned. <code>MULTISET</code> informs Oracle Database to take the result set of the subquery and return a collection value. <link>Table 5-1&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions023.htm#g1514003</link> shows which built-in data types can be cast into which other built-in data types. (<code>CAST</code> does not support <code>LONG</code>, <code>LONG</code> <code>RAW</code>, or the Oracle-supplied types.) <code>CAST</code> does not directly support any of the LOB data types. When you use <code>CAST</code> to convert a <code>CLOB</code> value into a character data type or a <code>BLOB</code> value into the <code>RAW</code> data type, the database implicitly converts the LOB value to character or raw data and then explicitly casts the resulting value into the target data type. If the resulting value is larger than the target type, then the database returns an error. When you use <code>CAST</code> ... <code>MULTISET</code> to get a collection value, each select list item in the query passed to the <code>CAST</code> function is converted to the corresponding attribute type of the target collection element type. Table 5-1 Casting Built-In Data Types <table> <thead> <tr> <th></th> <th>from BINARY_FLOAT, BINARY_DOUBLE</th> <th>from CHAR, VARCHAR2</th> <th>fromNUMBER</th> <th>from DATETIME / INTERVAL (Note 1)</th> <th>fromRAW</th> <th>from ROWID, UROWID (Note 2)</th> <th>from NCHAR, NVARCHAR2</th> </tr> </thead> <tbody> <tr> <td> to BINARY_FLOAT, BINARY_DOUBLE </td> <td> X </td> <td> X </td> <td> X </td> <td> -- </td> <td> -- </td> <td> -- </td> <td> X </td> </tr> <tr> <td> to CHAR, VARCHAR2 </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> <td> -- </td> </tr> <tr> <td> to NUMBER </td> <td> X </td> <td> X </td> <td> X </td> <td> -- </td> <td> -- </td> <td> -- </td> <td> X </td> </tr> <tr> <td> to DATE, TIMESTAMP, INTERVAL </td> <td> -- </td> <td> X </td> <td> -- </td> <td> X </td> <td> -- </td> <td> -- </td> <td> -- </td> </tr> <tr> <td> to RAW </td> <td> -- </td> <td> X </td> <td> -- </td> <td> -- </td> <td> X </td> <td> -- </td> <td> -- </td> </tr> <tr> <td> to ROWID, UROWID </td> <td> -- </td> <td> X </td> <td> -- </td> <td> -- </td> <td> -- </td> <td> X </td> <td> -- </td> </tr> <tr> <td> to NCHAR, NVARCHAR2 </td> <td> X </td> <td> -- </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> <td> X </td> </tr> </tbody> </table> Note 1: Datetime/interval includes <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIMEZONE</code>, <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>, and <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code>. Note 2: You cannot cast a <code>UROWID</code> to a <code>ROWID</code> if the <code>UROWID</code> contains the value of a <code>ROWID</code> of an index-organized table. If you want to cast a named collection type into another named collection type, then the elements of both collections must be of the same type. See Also: <link>\"Implicit Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i163326</link> for information on how Oracle Database implicitly converts collection type data into character data and <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> If the result set of <code>subquery</code> can evaluate to multiple rows, then you must specify the <code>MULTISET</code> keyword. The rows resulting from the subquery form the elements of the collection value into which they are cast. Without the <code>MULTISET</code> keyword, the subquery is treated as a scalar subquery. Built-In Data Type \n The Examples is: \n The following examples use the <code>CAST</code> function with scalar data types. The first example converts text to a timestamp value by applying the format model provided in the session parameter <code>NLS_TIMESTAMP_FORMAT</code>. If you want to avoid dependency on this NLS parameter, then you can use the <code>TO_DATE</code> as shown in the second example. <code>SELECT CAST('22-OCT-1997' AS TIMESTAMP WITH LOCAL TIME ZONE) FROM DUAL; SELECT CAST(TO_DATE('22-Oct-1997', 'DD-Mon-YYYY') AS TIMESTAMP WITH LOCAL TIME ZONE) FROM DUAL; </code> In the preceding example, <code>TO_DATE</code> converts from text to <code>DATE</code>, and <code>CAST</code> converts from <code>DATE</code> to <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, interpreting the date in the session time zone (<code>SESSIONTIMEZONE</code>). <code>SELECT product_id, CAST(ad_sourcetext AS VARCHAR2(30)) text FROM print_media ORDER BY product_id; </code> Collection \n The Examples is: \n The <code>CAST</code> examples that follow build on the <code>cust_address_typ</code> found in the sample order entry schema, <code>oe</code>. <code>CREATE TYPE address_book_t AS TABLE OF cust_address_typ; / CREATE TYPE address_array_t AS VARRAY(3) OF cust_address_typ; / CREATE TABLE cust_address ( custno NUMBER, street_address VARCHAR2(40), postal_code VARCHAR2(10), city VARCHAR2(30), state_province VARCHAR2(10), country_id CHAR(2)); CREATE TABLE cust_short (custno NUMBER, name VARCHAR2(31)); CREATE TABLE states (state_id NUMBER, addresses address_array_t); </code> This example casts a subquery: <code>SELECT s.custno, s.name, CAST(MULTISET(SELECT ca.street_address, ca.postal_code, ca.city, ca.state_province, ca.country_id FROM cust_address ca WHERE s.custno = ca.custno) AS address_book_t) FROM cust_short s ORDER BY s.custno; </code> <code>CAST</code> converts a varray type column into a nested table: <code>SELECT CAST(s.addresses AS address_book_t) FROM states s WHERE s.state_id = 111; </code> The following objects create the basis of the example that follows: <code>CREATE TABLE projects (employee_id NUMBER, project_name VARCHAR2(10)); CREATE TABLE emps_short (employee_id NUMBER, last_name VARCHAR2(10)); CREATE TYPE project_table_typ AS TABLE OF VARCHAR2(10); / </code> The following example of a <code>MULTISET</code> expression uses these objects: <code>SELECT e.last_name, CAST(MULTISET(SELECT p.project_name FROM projects p WHERE p.employee_id = e.employee_id ORDER BY p.project_name) AS project_table_typ) FROM emps_short e ORDER BY e.last_name; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions023.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ITERATION_NUMBER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ITERATION_NUMBER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ITERATION_NUMBER </eps> \n The Purpose is: \n The <code>ITERATION_NUMBER</code> function can be used only in the <code>model_clause</code> of the <code>SELECT</code> statement and then only when <code>ITERATE(</code><code>number</code><code>)</code> is specified in the <code>model_rules_clause</code>. It returns an integer representing the completed iteration through the model rules. The <code>ITERATION_NUMBER</code> function returns 0 during the first iteration. For each subsequent iteration, the <code>ITERATION_NUMBER</code> function returns the equivalent of <code>iteration_number</code> plus one. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics \n The Examples is: \n The following example assigns the sales of the Mouse Pad for the years 1998 and 1999 to the sales of the Mouse Pad for the years 2001 and 2002 respectively: <code>SELECT country, prod, year, s FROM sales_view_ref MODEL PARTITION BY (country) DIMENSION BY (prod, year) MEASURES (sale s) IGNORE NAV UNIQUE DIMENSION RULES UPSERT SEQUENTIAL ORDER ITERATE(2) ( s['Mouse Pad', 2001 + ITERATION_NUMBER] = s['Mouse Pad', 1998 + ITERATION_NUMBER] ) ORDER BY country, prod, year; COUNTRY PROD YEAR S ---------- ----------------------------------- -------- --------- France Mouse Pad 1998 2509.42 France Mouse Pad 1999 3678.69 France Mouse Pad 2000 3000.72 France Mouse Pad 2001 2509.42 France Mouse Pad 2002 3678.69 France Standard Mouse 1998 2390.83 France Standard Mouse 1999 2280.45 France Standard Mouse 2000 1274.31 France Standard Mouse 2001 2164.54 Germany Mouse Pad 1998 5827.87 Germany Mouse Pad 1999 8346.44 Germany Mouse Pad 2000 7375.46 Germany Mouse Pad 2001 5827.87 Germany Mouse Pad 2002 8346.44 Germany Standard Mouse 1998 7116.11 Germany Standard Mouse 1999 6263.14 Germany Standard Mouse 2000 2637.31 Germany Standard Mouse 2001 6456.13 18 rows selected. </code> The preceding example requires the view <code>sales_view_ref</code>. Refer to <link>\"The MODEL clause: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2171160</link> to create this view. ",
        "detail": "The Syntax is: \n <eps> ITERATION_NUMBER </eps> \n The Purpose is: \n The <code>ITERATION_NUMBER</code> function can be used only in the <code>model_clause</code> of the <code>SELECT</code> statement and then only when <code>ITERATE(</code><code>number</code><code>)</code> is specified in the <code>model_rules_clause</code>. It returns an integer representing the completed iteration through the model rules. The <code>ITERATION_NUMBER</code> function returns 0 during the first iteration. For each subsequent iteration, the <code>ITERATION_NUMBER</code> function returns the equivalent of <code>iteration_number</code> plus one. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics \n The Examples is: \n The following example assigns the sales of the Mouse Pad for the years 1998 and 1999 to the sales of the Mouse Pad for the years 2001 and 2002 respectively: <code>SELECT country, prod, year, s FROM sales_view_ref MODEL PARTITION BY (country) DIMENSION BY (prod, year) MEASURES (sale s) IGNORE NAV UNIQUE DIMENSION RULES UPSERT SEQUENTIAL ORDER ITERATE(2) ( s['Mouse Pad', 2001 + ITERATION_NUMBER] = s['Mouse Pad', 1998 + ITERATION_NUMBER] ) ORDER BY country, prod, year; COUNTRY PROD YEAR S ---------- ----------------------------------- -------- --------- France Mouse Pad 1998 2509.42 France Mouse Pad 1999 3678.69 France Mouse Pad 2000 3000.72 France Mouse Pad 2001 2509.42 France Mouse Pad 2002 3678.69 France Standard Mouse 1998 2390.83 France Standard Mouse 1999 2280.45 France Standard Mouse 2000 1274.31 France Standard Mouse 2001 2164.54 Germany Mouse Pad 1998 5827.87 Germany Mouse Pad 1999 8346.44 Germany Mouse Pad 2000 7375.46 Germany Mouse Pad 2001 5827.87 Germany Mouse Pad 2002 8346.44 Germany Standard Mouse 1998 7116.11 Germany Standard Mouse 1999 6263.14 Germany Standard Mouse 2000 2637.31 Germany Standard Mouse 2001 6456.13 18 rows selected. </code> The preceding example requires the view <code>sales_view_ref</code>. Refer to <link>\"The MODEL clause: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2171160</link> to create this view. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions081.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PREDICTION",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PREDICTION))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PREDICTION ( [ schema . ] model [ cost_matrix_clause ] mining_attribute_clause ) </eps> cost_matrix_clause::= <eps> COST { MODEL [AUTO] | ( class_value [, class_value]... ) VALUES ( ( cost_value [, cost_value]...) [ , (cost_value [, cost_value]... ) ]... ) } </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with mining models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns the best prediction for the model. The data type returned depends on the target value type used during the build of the model. For regression models, this function returns the expected value. cost_matrix_clause The <code>COST</code> clause is relevant for all classification models. Specify <code>COST</code> <code>MODEL</code> to indicate that the scoring should be performed by taking into account the scoring cost matrix associated with the model. If no such scoring cost matrix exists, then the database returns an error. Specify <code>COST</code> <code>MODEL</code> <code>AUTO</code> if the existence of a cost matrix is unknown. In this case: If the stored cost matrix exists, then the function returns the lowest cost prediction using the stored cost matrix. If no stored cost matrix exists, then the function returns the highest probability prediction. Use the <code>VALUES</code> clause (the bottom branch of the <code>cost_matrix_clause</code>) to specify an inline cost matrix. You can use an inline cost matrix regardless of whether the model has an associated scoring cost matrix. Refer to <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG243</link> for an example of an inline cost matrix If you omit the <code>cost_matrix_clause</code> clause, then the best prediction is the target class with the highest probability. If two or more classes are tied with the highest probability, the database chooses one class. mining_attribute_clause This maps the predictors that were provided when the model was built. Specifying <code>USING *</code> maps to all to the columns and expressions that can be retrieved from the underlying inputs (tables, views, and so on). If you specify more predictors in the <code>mining_attribute_clause</code> than there are predictors used by the model, then the extra expressions are silently ignored. If you specify fewer predictors than are used during the build, then the operation proceeds with the subset of predictors you specify and returns information on a best-effort basis. All types of models will return a result regardless of the number of predictors you specify in this clause. If you specify a predictor with the same name as was used during the build but a different data type, then the database implicitly converts to produce a predictor value of the same type as the original build. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example returns by gender the average age of customers who are likely to use an affinity card. The <code>PREDICTION</code> function takes into account only the <code>cust_marital_status</code>, <code>education</code>, and <code>household_size</code> predictors. This example, and the prerequisite data mining operations, including the creation of the view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT cust_gender, COUNT(*) AS cnt, ROUND(AVG(age)) AS avg_age FROM mining_data_apply_v WHERE PREDICTION(DT_SH_Clas_sample COST MODEL USING cust_marital_status, education, household_size) = 1 GROUP BY cust_gender ORDER BY cust_gender; C CNT AVG_AGE - ---------- ---------- F 170 38 M 685 42 </code> ",
        "detail": "The Syntax is: \n <eps> PREDICTION ( [ schema . ] model [ cost_matrix_clause ] mining_attribute_clause ) </eps> cost_matrix_clause::= <eps> COST { MODEL [AUTO] | ( class_value [, class_value]... ) VALUES ( ( cost_value [, cost_value]...) [ , (cost_value [, cost_value]... ) ]... ) } </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with mining models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns the best prediction for the model. The data type returned depends on the target value type used during the build of the model. For regression models, this function returns the expected value. cost_matrix_clause The <code>COST</code> clause is relevant for all classification models. Specify <code>COST</code> <code>MODEL</code> to indicate that the scoring should be performed by taking into account the scoring cost matrix associated with the model. If no such scoring cost matrix exists, then the database returns an error. Specify <code>COST</code> <code>MODEL</code> <code>AUTO</code> if the existence of a cost matrix is unknown. In this case: If the stored cost matrix exists, then the function returns the lowest cost prediction using the stored cost matrix. If no stored cost matrix exists, then the function returns the highest probability prediction. Use the <code>VALUES</code> clause (the bottom branch of the <code>cost_matrix_clause</code>) to specify an inline cost matrix. You can use an inline cost matrix regardless of whether the model has an associated scoring cost matrix. Refer to <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG243</link> for an example of an inline cost matrix If you omit the <code>cost_matrix_clause</code> clause, then the best prediction is the target class with the highest probability. If two or more classes are tied with the highest probability, the database chooses one class. mining_attribute_clause This maps the predictors that were provided when the model was built. Specifying <code>USING *</code> maps to all to the columns and expressions that can be retrieved from the underlying inputs (tables, views, and so on). If you specify more predictors in the <code>mining_attribute_clause</code> than there are predictors used by the model, then the extra expressions are silently ignored. If you specify fewer predictors than are used during the build, then the operation proceeds with the subset of predictors you specify and returns information on a best-effort basis. All types of models will return a result regardless of the number of predictors you specify in this clause. If you specify a predictor with the same name as was used during the build but a different data type, then the database implicitly converts to produce a predictor value of the same type as the original build. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example returns by gender the average age of customers who are likely to use an affinity card. The <code>PREDICTION</code> function takes into account only the <code>cust_marital_status</code>, <code>education</code>, and <code>household_size</code> predictors. This example, and the prerequisite data mining operations, including the creation of the view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT cust_gender, COUNT(*) AS cnt, ROUND(AVG(age)) AS avg_age FROM mining_data_apply_v WHERE PREDICTION(DT_SH_Clas_sample COST MODEL USING cust_marital_status, education, household_size) = 1 GROUP BY cust_gender ORDER BY cust_gender; C CNT AVG_AGE - ---------- ---------- F 170 38 M 685 42 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "UPPER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c UPPER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> UPPER(char) </eps> \n The Purpose is: \n <code>UPPER</code> returns <code>char</code>, with all letters uppercase. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The return value is the same data type as <code>char</code>. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase, refer to <link>NLS_UPPER&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions112.htm#i89889</link>. \n The Examples is: \n The following example returns each employee's last name in uppercase: <code>SELECT UPPER(last_name) \"Uppercase\" FROM employees; </code> ",
        "detail": "The Syntax is: \n <eps> UPPER(char) </eps> \n The Purpose is: \n <code>UPPER</code> returns <code>char</code>, with all letters uppercase. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The return value is the same data type as <code>char</code>. The database sets the case of the characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase, refer to <link>NLS_UPPER&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions112.htm#i89889</link>. \n The Examples is: \n The following example returns each employee's last name in uppercase: <code>SELECT UPPER(last_name) \"Uppercase\" FROM employees; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions226.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ADD_MONTHS",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ADD_MONTHS))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ADD_MONTHS(date, integer) </eps> \n The Purpose is: \n <code>ADD_MONTHS</code> returns the date <code>date</code> plus <code>integer</code> months. A month is defined by the session parameter <code>NLS_CALENDAR</code>. The date argument can be a datetime value or any value that can be implicitly converted to <code>DATE</code>. The <code>integer</code> argument can be an integer or any value that can be implicitly converted to an integer. The return type is always <code>DATE</code>, regardless of the data type of <code>date</code>. If <code>date</code> is the last day of the month or if the resulting month has fewer days than the day component of <code>date</code>, then the result is the last day of the resulting month. Otherwise, the result has the same day component as <code>date</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the month after the <code>hire_date</code> in the sample table <code>employees</code>: <code>SELECT TO_CHAR(ADD_MONTHS(hire_date, 1), 'DD-MON-YYYY') \"Next month\" FROM employees WHERE last_name = 'Baer'; Next Month ----------- 07-JUL-2002 </code> ",
        "detail": "The Syntax is: \n <eps> ADD_MONTHS(date, integer) </eps> \n The Purpose is: \n <code>ADD_MONTHS</code> returns the date <code>date</code> plus <code>integer</code> months. A month is defined by the session parameter <code>NLS_CALENDAR</code>. The date argument can be a datetime value or any value that can be implicitly converted to <code>DATE</code>. The <code>integer</code> argument can be an integer or any value that can be implicitly converted to an integer. The return type is always <code>DATE</code>, regardless of the data type of <code>date</code>. If <code>date</code> is the last day of the month or if the resulting month has fewer days than the day component of <code>date</code>, then the result is the last day of the resulting month. Otherwise, the result has the same day component as <code>date</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the month after the <code>hire_date</code> in the sample table <code>employees</code>: <code>SELECT TO_CHAR(ADD_MONTHS(hire_date, 1), 'DD-MON-YYYY') \"Next month\" FROM employees WHERE last_name = 'Baer'; Next Month ----------- 07-JUL-2002 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions011.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "INSERTCHILDXMLAFTER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c INSERTCHILDXMLAFTER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> INSERTCHILDXMLAFTER ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ] ) </eps> \n The Purpose is: \n <code>INSERTXMLCHILDAFTER</code> inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately after a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based. <code>XMLType_instance</code> identifies the XML data that is the target of the insertion. <code>XPath_string</code> locates the parent elements within target-data; child-data is inserted under each parent element. <code>child_expr</code> is a relative XPath 1.0 expression that locates the existing child that will precede the inserted child-data. It must name a child element of the element indicated by parent-xpath, and it can include a predicate. <code>value_expr</code> is the <code>XMLType</code> child element data to insert. Each top-level element node in this argument must have the same data type as the element indicated by child_expr. The optional <code>namespace_string</code> specifies the namespace for the parent elements, existing child element, and child element XML data to be inserted. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example is similar to that for <code>INSERTCHILDXML</code>, but it adds a third <code>/Owner</code> node after the <code>/Owner</code> node added in the other example. The output of the query has been formatted for readability. <code>UPDATE warehouses SET warehouse_spec = INSERTCHILDXMLAFTER(warehouse_spec, '/Warehouse/Building', 'Owner[2]', XMLType('<Owner>ThirdOwner</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Building/Owner') \"Owners\" FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_NAME Owners ----------------------------------- ------------------------------ New Jersey <Owner>GrandCo</Owner> <Owner>LesserCo</Owner> <Owner>ThirdOwner</Owner> </code> ",
        "detail": "The Syntax is: \n <eps> INSERTCHILDXMLAFTER ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ] ) </eps> \n The Purpose is: \n <code>INSERTXMLCHILDAFTER</code> inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately after a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based. <code>XMLType_instance</code> identifies the XML data that is the target of the insertion. <code>XPath_string</code> locates the parent elements within target-data; child-data is inserted under each parent element. <code>child_expr</code> is a relative XPath 1.0 expression that locates the existing child that will precede the inserted child-data. It must name a child element of the element indicated by parent-xpath, and it can include a predicate. <code>value_expr</code> is the <code>XMLType</code> child element data to insert. Each top-level element node in this argument must have the same data type as the element indicated by child_expr. The optional <code>namespace_string</code> specifies the namespace for the parent elements, existing child element, and child element XML data to be inserted. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example is similar to that for <code>INSERTCHILDXML</code>, but it adds a third <code>/Owner</code> node after the <code>/Owner</code> node added in the other example. The output of the query has been formatted for readability. <code>UPDATE warehouses SET warehouse_spec = INSERTCHILDXMLAFTER(warehouse_spec, '/Warehouse/Building', 'Owner[2]', XMLType('<Owner>ThirdOwner</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Building/Owner') \"Owners\" FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_NAME Owners ----------------------------------- ------------------------------ New Jersey <Owner>GrandCo</Owner> <Owner>LesserCo</Owner> <Owner>ThirdOwner</Owner> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions076.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLCOMMENT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLCOMMENT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLCOMMENT ( value_expr ) </eps> \n The Purpose is: \n <code>XMLComment</code> generates an XML comment using an evaluated result of <code>value_expr</code>. The <code>value_expr</code> must resolve to a string. It cannot contain two consecutive dashes (hyphens). The value returned by the function takes the following form: <code><!--string--> </code> If <code>value_expr</code> resolves to null, then the function returns null. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following example uses the <code>DUAL</code> table to illustrate the <code>XMLComment</code> syntax: <code>SELECT XMLCOMMENT('OrderAnalysisComp imported, reconfigured, disassembled') AS \"XMLCOMMENT\" FROM DUAL; XMLCOMMENT -------------------------------------------------------------------------------- <!--OrderAnalysisComp imported, reconfigured, disassembled--> </code> ",
        "detail": "The Syntax is: \n <eps> XMLCOMMENT ( value_expr ) </eps> \n The Purpose is: \n <code>XMLComment</code> generates an XML comment using an evaluated result of <code>value_expr</code>. The <code>value_expr</code> must resolve to a string. It cannot contain two consecutive dashes (hyphens). The value returned by the function takes the following form: <code><!--string--> </code> If <code>value_expr</code> resolves to null, then the function returns null. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following example uses the <code>DUAL</code> table to illustrate the <code>XMLComment</code> syntax: <code>SELECT XMLCOMMENT('OrderAnalysisComp imported, reconfigured, disassembled') AS \"XMLCOMMENT\" FROM DUAL; XMLCOMMENT -------------------------------------------------------------------------------- <!--OrderAnalysisComp imported, reconfigured, disassembled--> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions239.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DEREF",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c DEREF))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> DEREF(expr) </eps> \n The Purpose is: \n <code>DEREF</code> returns the object reference of argument <code>expr</code>, where <code>expr</code> must return a <code>REF</code> to an object. If you do not use this function in a query, then Oracle Database returns the object ID of the <code>REF</code> instead, as shown in the example that follows. See Also: <link>MAKE_REF&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions097.htm#i77900</link> \n The Examples is: \n The sample schema <code>oe</code> contains an object type <code>cust_address_typ</code>. The <link>\"REF Constraint \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/clauses002.htm#i1015744</link> create a similar type, <code>cust_address_typ_new</code>, and a table with one column that is a <code>REF</code> to the type. The following example shows how to insert into such a column and how to use <code>DEREF</code> to extract information from the column: <code>INSERT INTO address_table VALUES ('1 First', 'G45 EU8', 'Paris', 'CA', 'US'); INSERT INTO customer_addresses SELECT 999, REF(a) FROM address_table a; SELECT address FROM customer_addresses ORDER BY address; ADDRESS -------------------------------------------------------------------------------- 000022020876B2245DBE325C5FE03400400B40DCB176B2245DBE305C5FE03400400B40DCB1 SELECT DEREF(address) FROM customer_addresses; DEREF(ADDRESS)(STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID) -------------------------------------------------------------------------------- CUST_ADDRESS_TYP_NEW('1 First', 'G45 EU8', 'Paris', 'CA', 'US') </code> ",
        "detail": "The Syntax is: \n <eps> DEREF(expr) </eps> \n The Purpose is: \n <code>DEREF</code> returns the object reference of argument <code>expr</code>, where <code>expr</code> must return a <code>REF</code> to an object. If you do not use this function in a query, then Oracle Database returns the object ID of the <code>REF</code> instead, as shown in the example that follows. See Also: <link>MAKE_REF&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions097.htm#i77900</link> \n The Examples is: \n The sample schema <code>oe</code> contains an object type <code>cust_address_typ</code>. The <link>\"REF Constraint \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/clauses002.htm#i1015744</link> create a similar type, <code>cust_address_typ_new</code>, and a table with one column that is a <code>REF</code> to the type. The following example shows how to insert into such a column and how to use <code>DEREF</code> to extract information from the column: <code>INSERT INTO address_table VALUES ('1 First', 'G45 EU8', 'Paris', 'CA', 'US'); INSERT INTO customer_addresses SELECT 999, REF(a) FROM address_table a; SELECT address FROM customer_addresses ORDER BY address; ADDRESS -------------------------------------------------------------------------------- 000022020876B2245DBE325C5FE03400400B40DCB176B2245DBE305C5FE03400400B40DCB1 SELECT DEREF(address) FROM customer_addresses; DEREF(ADDRESS)(STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID) -------------------------------------------------------------------------------- CUST_ADDRESS_TYP_NEW('1 First', 'G45 EU8', 'Paris', 'CA', 'US') </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions054.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NANVL",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NANVL))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NANVL(n2, n1) </eps> \n The Purpose is: \n The <code>NANVL</code> function is useful only for floating-point numbers of type <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>. It instructs Oracle Database to return an alternative value <code>n1</code> if the input value <code>n2</code> is <code>NaN</code> (not a number). If <code>n2</code> is not <code>NaN</code>, then Oracle returns <code>n2</code>. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion, <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics, and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence \n The Examples is: \n Using table <code>float_point_demo</code> created for <link>TO_BINARY_DOUBLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions196.htm#i1279235</link>, insert a second entry into the table: <code>INSERT INTO float_point_demo VALUES (0,'NaN','NaN'); SELECT * FROM float_point_demo; DEC_NUM BIN_DOUBLE BIN_FLOAT ---------- ---------- ---------- 1234.56 1.235E+003 1.235E+003 0 Nan Nan </code> The following example returns <code>bin_float</code> if it is a number. Otherwise, 0 is returned. <code>SELECT bin_float, NANVL(bin_float,0) FROM float_point_demo; BIN_FLOAT NANVL(BIN_FLOAT,0) ---------- ------------------ 1.235E+003 1.235E+003 Nan 0 </code> ",
        "detail": "The Syntax is: \n <eps> NANVL(n2, n1) </eps> \n The Purpose is: \n The <code>NANVL</code> function is useful only for floating-point numbers of type <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>. It instructs Oracle Database to return an alternative value <code>n1</code> if the input value <code>n2</code> is <code>NaN</code> (not a number). If <code>n2</code> is not <code>NaN</code>, then Oracle returns <code>n2</code>. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion, <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics, and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence \n The Examples is: \n Using table <code>float_point_demo</code> created for <link>TO_BINARY_DOUBLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions196.htm#i1279235</link>, insert a second entry into the table: <code>INSERT INTO float_point_demo VALUES (0,'NaN','NaN'); SELECT * FROM float_point_demo; DEC_NUM BIN_DOUBLE BIN_FLOAT ---------- ---------- ---------- 1234.56 1.235E+003 1.235E+003 0 Nan Nan </code> The following example returns <code>bin_float</code> if it is a number. Otherwise, 0 is returned. <code>SELECT bin_float, NANVL(bin_float,0) FROM float_point_demo; BIN_FLOAT NANVL(BIN_FLOAT,0) ---------- ------------------ 1.235E+003 1.235E+003 Nan 0 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions103.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_TIMESTAMP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_TIMESTAMP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_TIMESTAMP(char [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_TIMESTAMP</code> converts <code>char</code> of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to a value of <code>TIMESTAMP</code> data type. The optional <code>fmt</code> specifies the format of <code>char</code>. If you omit <code>fmt</code>, then <code>char</code> must be in the default format of the <code>TIMESTAMP</code> data type, which is determined by the <code>NLS_TIMESTAMP_FORMAT</code> initialization parameter. The optional <code>'nlsparam'</code> argument has the same purpose in this function as in the <code>TO_CHAR</code> function for date conversion. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example converts a character string to a timestamp. The character string is not in the default <code>TIMESTAMP</code> format, so the format mask must be specified: <code>SELECT TO_TIMESTAMP ('10-Sep-02 14:10:10.123000', 'DD-Mon-RR HH24:MI:SS.FF') FROM DUAL; TO_TIMESTAMP('10-SEP-0214:10:10.123000','DD-MON-RRHH24:MI:SS.FF') --------------------------------------------------------------------------- 10-SEP-02 02.10.10.123000000 PM </code> See Also: <link><code>NLS_TIMESTAMP_FORMAT</code> parameter&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e40402/initparams157.htm#REFRN10131</link> for information on the default <code>TIMESTAMP</code> format and <link>\"Datetime Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34924</link> for information on specifying the format mask ",
        "detail": "The Syntax is: \n <eps> TO_TIMESTAMP(char [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_TIMESTAMP</code> converts <code>char</code> of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to a value of <code>TIMESTAMP</code> data type. The optional <code>fmt</code> specifies the format of <code>char</code>. If you omit <code>fmt</code>, then <code>char</code> must be in the default format of the <code>TIMESTAMP</code> data type, which is determined by the <code>NLS_TIMESTAMP_FORMAT</code> initialization parameter. The optional <code>'nlsparam'</code> argument has the same purpose in this function as in the <code>TO_CHAR</code> function for date conversion. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example converts a character string to a timestamp. The character string is not in the default <code>TIMESTAMP</code> format, so the format mask must be specified: <code>SELECT TO_TIMESTAMP ('10-Sep-02 14:10:10.123000', 'DD-Mon-RR HH24:MI:SS.FF') FROM DUAL; TO_TIMESTAMP('10-SEP-0214:10:10.123000','DD-MON-RRHH24:MI:SS.FF') --------------------------------------------------------------------------- 10-SEP-02 02.10.10.123000000 PM </code> See Also: <link><code>NLS_TIMESTAMP_FORMAT</code> parameter&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e40402/initparams157.htm#REFRN10131</link> for information on the default <code>TIMESTAMP</code> format and <link>\"Datetime Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34924</link> for information on specifying the format mask ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions213.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DEPTH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c DEPTH))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> DEPTH(correlation_integer) </eps> \n The Purpose is: \n <code>DEPTH</code> is an ancillary function used only with the <code>UNDER_PATH</code> and <code>EQUALS_PATH</code> conditions. It returns the number of levels in the path specified by the <code>UNDER_PATH</code> condition with the same correlation variable. The <code>correlation_integer</code> can be any <code>NUMBER</code> integer. Use it to correlate this ancillary function with its primary condition if the statement contains multiple primary conditions. Values less than 1 are treated as 1. See Also: <link>EQUALS_PATH Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions009.htm#i1051094</link>, <link>UNDER_PATH Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions009.htm#i1041646</link>, and the related function <link>PATH&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions125.htm#i1150364</link> \n The Examples is: \n The <code>EQUALS_PATH</code> and <code>UNDER_PATH</code> conditions can take two ancillary functions, <code>DEPTH</code> and <code>PATH</code>. The following example shows the use of both ancillary functions. The example assumes the existence of the XMLSchema <code>warehouses.xsd</code> (created in <link>\"Using XML in SQL Statements\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_examples002.htm#i686084</link>). <code>SELECT PATH(1), DEPTH(2) FROM RESOURCE_VIEW WHERE UNDER_PATH(res, '/sys/schemas/OE', 1)=1 AND UNDER_PATH(res, '/sys/schemas/OE', 2)=1; PATH(1) DEPTH(2) -------------------------------- -------- . . . www.example.com 1 www.example.com/xwarehouses.xsd 2 . . . </code> ",
        "detail": "The Syntax is: \n <eps> DEPTH(correlation_integer) </eps> \n The Purpose is: \n <code>DEPTH</code> is an ancillary function used only with the <code>UNDER_PATH</code> and <code>EQUALS_PATH</code> conditions. It returns the number of levels in the path specified by the <code>UNDER_PATH</code> condition with the same correlation variable. The <code>correlation_integer</code> can be any <code>NUMBER</code> integer. Use it to correlate this ancillary function with its primary condition if the statement contains multiple primary conditions. Values less than 1 are treated as 1. See Also: <link>EQUALS_PATH Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions009.htm#i1051094</link>, <link>UNDER_PATH Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions009.htm#i1041646</link>, and the related function <link>PATH&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions125.htm#i1150364</link> \n The Examples is: \n The <code>EQUALS_PATH</code> and <code>UNDER_PATH</code> conditions can take two ancillary functions, <code>DEPTH</code> and <code>PATH</code>. The following example shows the use of both ancillary functions. The example assumes the existence of the XMLSchema <code>warehouses.xsd</code> (created in <link>\"Using XML in SQL Statements\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_examples002.htm#i686084</link>). <code>SELECT PATH(1), DEPTH(2) FROM RESOURCE_VIEW WHERE UNDER_PATH(res, '/sys/schemas/OE', 1)=1 AND UNDER_PATH(res, '/sys/schemas/OE', 2)=1; PATH(1) DEPTH(2) -------------------------------- -------- . . . www.example.com 1 www.example.com/xwarehouses.xsd 2 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions053.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYSDATE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYSDATE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYSDATE </eps> \n The Purpose is: \n <code>SYSDATE</code> returns the current date and time set for the operating system on which the database server resides. The data type of the returned value is <code>DATE</code>, and the format returned depends on the value of the <code>NLS_DATE_FORMAT</code> initialization parameter. The function requires no arguments. In distributed SQL statements, this function returns the date and time set for the operating system of your local database. You cannot use this function in the condition of a <code>CHECK</code> constraint. Note: The <code>FIXED_DATE</code> initialization parameter enables you to set a constant date and time that <code>SYSDATE</code> will always return instead of the current date and time. This parameter is useful primarily for testing. Refer to <link>Oracle Database Reference&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e40402/initparams095.htm#REFRN10062</link> for more information on the <code>FIXED_DATE</code> initialization parameter. \n The Examples is: \n The following example returns the current operating system date and time: <code>SELECT TO_CHAR (SYSDATE, 'MM-DD-YYYY HH24:MI:SS') \"NOW\" FROM DUAL; NOW ------------------- 04-13-2001 09:45:51 </code> ",
        "detail": "The Syntax is: \n <eps> SYSDATE </eps> \n The Purpose is: \n <code>SYSDATE</code> returns the current date and time set for the operating system on which the database server resides. The data type of the returned value is <code>DATE</code>, and the format returned depends on the value of the <code>NLS_DATE_FORMAT</code> initialization parameter. The function requires no arguments. In distributed SQL statements, this function returns the date and time set for the operating system of your local database. You cannot use this function in the condition of a <code>CHECK</code> constraint. Note: The <code>FIXED_DATE</code> initialization parameter enables you to set a constant date and time that <code>SYSDATE</code> will always return instead of the current date and time. This parameter is useful primarily for testing. Refer to <link>Oracle Database Reference&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e40402/initparams095.htm#REFRN10062</link> for more information on the <code>FIXED_DATE</code> initialization parameter. \n The Examples is: \n The following example returns the current operating system date and time: <code>SELECT TO_CHAR (SYSDATE, 'MM-DD-YYYY HH24:MI:SS') \"NOW\" FROM DUAL; NOW ------------------- 04-13-2001 09:45:51 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions191.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DATAOBJ_TO_PARTITION",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c DATAOBJ_TO_PARTITION))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> DATAOBJ_TO_PARTITION( table, partition_id ) </eps> \n The Purpose is: \n <code>DATAOBJ_TO_PARTITION</code> is useful only to Data Cartridge developers who are performing data maintenance or query operations on system-partitioned tables that are used to store domain index data. The DML or query operations are triggered by corresponding operations on the base table of the domain index. This function takes as arguments the name of the base table and the partition ID of the base table partition, both of which are passed to the function by the appropriate ODCIIndex method. The function returns the partition ID of the corresponding system-partitioned table, which can be used to perform the operation (DML or query) on that partition of the system-partitioned table. See Also: <link>Oracle Database Data Cartridge Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e10765/dom_idx.htm#ADDCI290</link> for information on the use of this function, including examples ",
        "detail": "The Syntax is: \n <eps> DATAOBJ_TO_PARTITION( table, partition_id ) </eps> \n The Purpose is: \n <code>DATAOBJ_TO_PARTITION</code> is useful only to Data Cartridge developers who are performing data maintenance or query operations on system-partitioned tables that are used to store domain index data. The DML or query operations are triggered by corresponding operations on the base table of the domain index. This function takes as arguments the name of the base table and the partition ID of the base table partition, both of which are passed to the function by the appropriate ODCIIndex method. The function returns the partition ID of the corresponding system-partitioned table, which can be used to perform the operation (DML or query) on that partition of the system-partitioned table. See Also: <link>Oracle Database Data Cartridge Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e10765/dom_idx.htm#ADDCI290</link> for information on the use of this function, including examples ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions047.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLSERIALIZE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLSERIALIZE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLSERIALIZE ( { DOCUMENT | CONTENT } value_expr [ AS datatype ] [ ENCODING xml_encoding_spec ] [ VERSION string_literal ] [ NO INDENT | { INDENT [SIZE = number] } ] [ { HIDE | SHOW } DEFAULTS ] ) </eps> \n The Purpose is: \n <code>XMLSerialize</code> creates a string or LOB containing the contents of <code>value_expr</code>. If you specify <code>DOCUMENT</code>, then the <code>value_expr</code> must be a valid XML document. If you specify <code>CONTENT</code>, then the <code>value_expr</code> need not be a singly rooted XML document. However it must be valid XML content. The <code>datatype</code> specified can be a string type (<code>VARCHAR2</code> or <code>VARCHAR</code>, but not <code>NVARCHAR2</code>), <code>BLOB</code>, or <code>CLOB</code>. The default is <code>CLOB</code>. If <code>datatype</code> is <code>BLOB</code>, then you can specify the <code>ENCODING</code> clause to use the specified encoding in the prolog. The <code>xml_encoding_spec</code> is an XML encoding declaration (<code>encoding=\"...\"</code>). Specify the <code>VERSION</code> clause to use the version you provide as <code>string_literal</code> in the XML declaration (<code><?xml version=\"...\" ...?></code>). Specify <code>NO</code> <code>INDENT</code> to strip all insignificant whitespace from the output. Specify <code>INDENT SIZE =</code> <code>N</code>, where <code>N</code> is a whole number, for output that is pretty-printed using a relative indentation of <code>N</code> spaces. If <code>N</code> is <code>0</code>, then pretty-printing inserts a newline character after each element, placing each element on a line by itself, but omitting all other insignificant whitespace in the output. If <code>INDENT</code> is present without a <code>SIZE</code> specification, then 2-space indenting is used. If you omit this clause, then the behavior (pretty-printing or not) is indeterminate. <code>HIDE DEFAULTS</code> and <code>SHOW DEFAULTS</code> apply only to XML schema-based data. If you specify <code>SHOW DEFAULTS</code> and the input data is missing any optional elements or attributes for which the XML schema defines default values, then those elements or attributes are included in the output with their default values. If you specify <code>HIDE DEFAULTS</code>, then no such elements or attributes are included in the output. <code>HIDE DEFAULTS</code> is the default behavior. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following statement uses the <code>DUAL</code> table to illustrate the syntax of <code>XMLSerialize</code>: <code>SELECT XMLSERIALIZE(CONTENT XMLTYPE('<Owner>Grandco</Owner>')) AS xmlserialize_doc FROM DUAL; XMLSERIALIZE_DOC ---------------- <Owner>Grandco</Owner> </code> ",
        "detail": "The Syntax is: \n <eps> XMLSERIALIZE ( { DOCUMENT | CONTENT } value_expr [ AS datatype ] [ ENCODING xml_encoding_spec ] [ VERSION string_literal ] [ NO INDENT | { INDENT [SIZE = number] } ] [ { HIDE | SHOW } DEFAULTS ] ) </eps> \n The Purpose is: \n <code>XMLSerialize</code> creates a string or LOB containing the contents of <code>value_expr</code>. If you specify <code>DOCUMENT</code>, then the <code>value_expr</code> must be a valid XML document. If you specify <code>CONTENT</code>, then the <code>value_expr</code> need not be a singly rooted XML document. However it must be valid XML content. The <code>datatype</code> specified can be a string type (<code>VARCHAR2</code> or <code>VARCHAR</code>, but not <code>NVARCHAR2</code>), <code>BLOB</code>, or <code>CLOB</code>. The default is <code>CLOB</code>. If <code>datatype</code> is <code>BLOB</code>, then you can specify the <code>ENCODING</code> clause to use the specified encoding in the prolog. The <code>xml_encoding_spec</code> is an XML encoding declaration (<code>encoding=\"...\"</code>). Specify the <code>VERSION</code> clause to use the version you provide as <code>string_literal</code> in the XML declaration (<code><?xml version=\"...\" ...?></code>). Specify <code>NO</code> <code>INDENT</code> to strip all insignificant whitespace from the output. Specify <code>INDENT SIZE =</code> <code>N</code>, where <code>N</code> is a whole number, for output that is pretty-printed using a relative indentation of <code>N</code> spaces. If <code>N</code> is <code>0</code>, then pretty-printing inserts a newline character after each element, placing each element on a line by itself, but omitting all other insignificant whitespace in the output. If <code>INDENT</code> is present without a <code>SIZE</code> specification, then 2-space indenting is used. If you omit this clause, then the behavior (pretty-printing or not) is indeterminate. <code>HIDE DEFAULTS</code> and <code>SHOW DEFAULTS</code> apply only to XML schema-based data. If you specify <code>SHOW DEFAULTS</code> and the input data is missing any optional elements or attributes for which the XML schema defines default values, then those elements or attributes are included in the output with their default values. If you specify <code>HIDE DEFAULTS</code>, then no such elements or attributes are included in the output. <code>HIDE DEFAULTS</code> is the default behavior. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following statement uses the <code>DUAL</code> table to illustrate the syntax of <code>XMLSerialize</code>: <code>SELECT XMLSERIALIZE(CONTENT XMLTYPE('<Owner>Grandco</Owner>')) AS xmlserialize_doc FROM DUAL; XMLSERIALIZE_DOC ---------------- <Owner>Grandco</Owner> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions252.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NVL2",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NVL2))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NVL2(expr1, expr2, expr3) </eps> \n The Purpose is: \n <code>NVL2</code> lets you determine the value returned by a query based on whether a specified expression is null or not null. If <code>expr1</code> is not null, then <code>NVL2</code> returns <code>expr2</code>. If <code>expr1</code> is null, then <code>NVL2</code> returns <code>expr3</code>. The argument <code>expr1</code> can have any data type. The arguments <code>expr2</code> and <code>expr3</code> can have any data types except <code>LONG</code>. If the data types of <code>expr2</code> and <code>expr3</code> are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. If <code>expr2</code> is character or numeric data, then the implicit conversion is implemented as follows: If <code>expr2</code> is character data, then Oracle Database converts <code>expr3</code> to the data type of <code>expr2</code> before returning a value unless <code>expr3</code> is a null constant. In that case, a data type conversion is not necessary, and the database returns <code>VARCHAR2</code> in the character set of <code>expr2</code>. If <code>expr2</code> is numeric data, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence \n The Examples is: \n The following example shows whether the income of some employees is made up of salary plus commission, or just salary, depending on whether the <code>commission_pct</code> column of <code>employees</code> is null or not. <code>SELECT last_name, salary, NVL2(commission_pct, salary + (salary * commission_pct), salary) income FROM employees WHERE last_name like 'B%' ORDER BY last_name; LAST_NAME SALARY INCOME ------------------------- ---------- ---------- Baer 10000 10000 Baida 2900 2900 Banda 6200 6820 Bates 7300 8395 Bell 4000 4000 Bernstein 9500 11875 Bissot 3300 3300 Bloom 10000 12000 Bull 4100 4100 </code> ",
        "detail": "The Syntax is: \n <eps> NVL2(expr1, expr2, expr3) </eps> \n The Purpose is: \n <code>NVL2</code> lets you determine the value returned by a query based on whether a specified expression is null or not null. If <code>expr1</code> is not null, then <code>NVL2</code> returns <code>expr2</code>. If <code>expr1</code> is null, then <code>NVL2</code> returns <code>expr3</code>. The argument <code>expr1</code> can have any data type. The arguments <code>expr2</code> and <code>expr3</code> can have any data types except <code>LONG</code>. If the data types of <code>expr2</code> and <code>expr3</code> are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. If <code>expr2</code> is character or numeric data, then the implicit conversion is implemented as follows: If <code>expr2</code> is character data, then Oracle Database converts <code>expr3</code> to the data type of <code>expr2</code> before returning a value unless <code>expr3</code> is a null constant. In that case, a data type conversion is not necessary, and the database returns <code>VARCHAR2</code> in the character set of <code>expr2</code>. If <code>expr2</code> is numeric data, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence \n The Examples is: \n The following example shows whether the income of some employees is made up of salary plus commission, or just salary, depending on whether the <code>commission_pct</code> column of <code>employees</code> is null or not. <code>SELECT last_name, salary, NVL2(commission_pct, salary + (salary * commission_pct), salary) income FROM employees WHERE last_name like 'B%' ORDER BY last_name; LAST_NAME SALARY INCOME ------------------------- ---------- ---------- Baer 10000 10000 Baida 2900 2900 Banda 6200 6820 Bates 7300 8395 Bell 4000 4000 Bernstein 9500 11875 Bissot 3300 3300 Bloom 10000 12000 Bull 4100 4100 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions120.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NUMTODSINTERVAL",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NUMTODSINTERVAL))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NUMTODSINTERVAL(n, 'interval_unit') </eps> \n The Purpose is: \n <code>NUMTODSINTERVAL</code> converts <code>n</code> to an <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> literal. The argument <code>n</code> can be any <code>NUMBER</code> value or an expression that can be implicitly converted to a <code>NUMBER</code> value. The argument <code>interval_unit</code> can be of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type. The value for <code>interval_unit</code> specifies the unit of <code>n</code> and must resolve to one of the following string values: '<code>DAY</code>' '<code>HOUR</code>' '<code>MINUTE</code>' '<code>SECOND</code>' <code>interval_unit</code> is case insensitive. Leading and trailing values within the parentheses are ignored. By default, the precision of the return is 9. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example uses <code>NUMTODSINTERVAL</code> in a <code>COUNT</code> analytic function to calculate, for each employee, the number of employees hired by the same manager within the past 100 days from his or her hire date. Refer to <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for more information on the syntax of the analytic functions. <code>SELECT manager_id, last_name, hire_date, COUNT(*) OVER (PARTITION BY manager_id ORDER BY hire_date RANGE NUMTODSINTERVAL(100, 'day') PRECEDING) AS t_count FROM employees ORDER BY last_name, hire_date; MANAGER_ID LAST_NAME HIRE_DATE T_COUNT ---------- ------------------------- --------- ---------- 149 Abel 11-MAY-04 1 147 Ande 24-MAR-08 3 121 Atkinson 30-OCT-05 2 103 Austin 25-JUN-05 1 . . . 124 Walsh 24-APR-06 2 100 Weiss 18-JUL-04 1 101 Whalen 17-SEP-03 1 100 Zlotkey 29-JAN-08 2 </code> ",
        "detail": "The Syntax is: \n <eps> NUMTODSINTERVAL(n, 'interval_unit') </eps> \n The Purpose is: \n <code>NUMTODSINTERVAL</code> converts <code>n</code> to an <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> literal. The argument <code>n</code> can be any <code>NUMBER</code> value or an expression that can be implicitly converted to a <code>NUMBER</code> value. The argument <code>interval_unit</code> can be of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type. The value for <code>interval_unit</code> specifies the unit of <code>n</code> and must resolve to one of the following string values: '<code>DAY</code>' '<code>HOUR</code>' '<code>MINUTE</code>' '<code>SECOND</code>' <code>interval_unit</code> is case insensitive. Leading and trailing values within the parentheses are ignored. By default, the precision of the return is 9. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example uses <code>NUMTODSINTERVAL</code> in a <code>COUNT</code> analytic function to calculate, for each employee, the number of employees hired by the same manager within the past 100 days from his or her hire date. Refer to <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for more information on the syntax of the analytic functions. <code>SELECT manager_id, last_name, hire_date, COUNT(*) OVER (PARTITION BY manager_id ORDER BY hire_date RANGE NUMTODSINTERVAL(100, 'day') PRECEDING) AS t_count FROM employees ORDER BY last_name, hire_date; MANAGER_ID LAST_NAME HIRE_DATE T_COUNT ---------- ------------------------- --------- ---------- 149 Abel 11-MAY-04 1 147 Ande 24-MAR-08 3 121 Atkinson 30-OCT-05 2 103 Austin 25-JUN-05 1 . . . 124 Walsh 24-APR-06 2 100 Weiss 18-JUL-04 1 101 Whalen 17-SEP-03 1 100 Zlotkey 29-JAN-08 2 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions117.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "FIRST_VALUE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c FIRST_VALUE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> FIRST_VALUE { (expr) [ {RESPECT | IGNORE} NULLS ] | (expr [ {RESPECT | IGNORE} NULLS ]) } OVER (analytic_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>expr</code> \n The Purpose is: \n <code>FIRST_VALUE</code> is an analytic function. It returns the first value in an ordered set of values. If the first value in the set is null, then the function returns <code>NULL</code> unless you specify <code>IGNORE NULLS</code>. This setting is useful for data densification. Note: The two forms of this syntax have the same behavior. The top branch is the ANSI format, which Oracle recommends. The bottom branch is deprecated but is supported for backward compatibility. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. If you specify <code>IGNORE NULLS</code>, then <code>FIRST_VALUE</code> returns the first non-null value in the set, or <code>NULL</code> if all values are null. Refer to <link>\"Using Partitioned Outer Joins: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2177515</link> for an example of data densification. You cannot nest analytic functions by using <code>FIRST_VALUE</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. Refer to <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>. \n The Examples is: \n The following example selects, for each employee in Department 90, the name of the employee with the lowest salary. <code>SELECT department_id, last_name, salary, FIRST_VALUE(last_name) OVER (ORDER BY salary ASC ROWS UNBOUNDED PRECEDING) AS lowest_sal FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY employee_id) ORDER BY last_name; DEPARTMENT_ID LAST_NAME SALARY LOWEST_SAL ------------- ------------------------- ---------- ------------------------- 90 De Haan 17000 Kochhar 90 King 24000 Kochhar 90 Kochhar 17000 Kochhar </code> The example illustrates the nondeterministic nature of the <code>FIRST_VALUE</code> function. Kochhar and DeHaan have the same salary, so are in adjacent rows. Kochhar appears first because the rows returned by the subquery are ordered by <code>employee_id</code>. However, if the rows returned by the subquery are ordered by <code>employee_id</code> in descending order, as in the next example, then the function returns a different value: <code>SELECT department_id, last_name, salary, FIRST_VALUE(last_name) OVER (ORDER BY salary ASC ROWS UNBOUNDED PRECEDING) AS fv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER by employee_id DESC) ORDER BY last_name; DEPARTMENT_ID LAST_NAME SALARY FV ------------- ------------------------- ---------- ------------------------- 90 De Haan 17000 De Haan 90 King 24000 De Haan 90 Kochhar 17000 De Haan </code> The following example shows how to make the <code>FIRST_VALUE</code> function deterministic by ordering on a unique key. <code>SELECT department_id, last_name, salary, hire_date, FIRST_VALUE(last_name) OVER (ORDER BY salary ASC, hire_date ROWS UNBOUNDED PRECEDING) AS fv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY employee_id DESC) ORDER BY last_name; DEPARTMENT_ID LAST_NAME SALARY HIRE_DATE FV ------------- --------------- ---------- --------- ------------------------- 90 De Haan 17000 13-JAN-01 De Haan 90 King 24000 17-JUN-03 De Haan 90 Kochhar 17000 21-SEP-05 De Haan </code> When you use a logical offset (<code>RANGE</code> instead of <code>ROWS</code>), the function is deterministic. When duplicates are found for the <code>ORDER</code> <code>BY</code> expression, the <code>FIRST_VALUE</code> is the lowest value of <code>expr</code>: <code>SELECT department_id, last_name, salary, FIRST_VALUE(last_name) OVER (ORDER BY salary ASC RANGE UNBOUNDED PRECEDING) AS lowest_sal FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY employee_id); DEPARTMENT_ID LAST_NAME SALARY LOWEST_SAL ------------- ------------------------- ---------- ------------------------- 90 De Haan 17000 De Haan 90 Kochhar 17000 De Haan 90 King 24000 De Haan </code> ",
        "detail": "The Syntax is: \n <eps> FIRST_VALUE { (expr) [ {RESPECT | IGNORE} NULLS ] | (expr [ {RESPECT | IGNORE} NULLS ]) } OVER (analytic_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>expr</code> \n The Purpose is: \n <code>FIRST_VALUE</code> is an analytic function. It returns the first value in an ordered set of values. If the first value in the set is null, then the function returns <code>NULL</code> unless you specify <code>IGNORE NULLS</code>. This setting is useful for data densification. Note: The two forms of this syntax have the same behavior. The top branch is the ANSI format, which Oracle recommends. The bottom branch is deprecated but is supported for backward compatibility. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. If you specify <code>IGNORE NULLS</code>, then <code>FIRST_VALUE</code> returns the first non-null value in the set, or <code>NULL</code> if all values are null. Refer to <link>\"Using Partitioned Outer Joins: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2177515</link> for an example of data densification. You cannot nest analytic functions by using <code>FIRST_VALUE</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. Refer to <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>. \n The Examples is: \n The following example selects, for each employee in Department 90, the name of the employee with the lowest salary. <code>SELECT department_id, last_name, salary, FIRST_VALUE(last_name) OVER (ORDER BY salary ASC ROWS UNBOUNDED PRECEDING) AS lowest_sal FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY employee_id) ORDER BY last_name; DEPARTMENT_ID LAST_NAME SALARY LOWEST_SAL ------------- ------------------------- ---------- ------------------------- 90 De Haan 17000 Kochhar 90 King 24000 Kochhar 90 Kochhar 17000 Kochhar </code> The example illustrates the nondeterministic nature of the <code>FIRST_VALUE</code> function. Kochhar and DeHaan have the same salary, so are in adjacent rows. Kochhar appears first because the rows returned by the subquery are ordered by <code>employee_id</code>. However, if the rows returned by the subquery are ordered by <code>employee_id</code> in descending order, as in the next example, then the function returns a different value: <code>SELECT department_id, last_name, salary, FIRST_VALUE(last_name) OVER (ORDER BY salary ASC ROWS UNBOUNDED PRECEDING) AS fv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER by employee_id DESC) ORDER BY last_name; DEPARTMENT_ID LAST_NAME SALARY FV ------------- ------------------------- ---------- ------------------------- 90 De Haan 17000 De Haan 90 King 24000 De Haan 90 Kochhar 17000 De Haan </code> The following example shows how to make the <code>FIRST_VALUE</code> function deterministic by ordering on a unique key. <code>SELECT department_id, last_name, salary, hire_date, FIRST_VALUE(last_name) OVER (ORDER BY salary ASC, hire_date ROWS UNBOUNDED PRECEDING) AS fv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY employee_id DESC) ORDER BY last_name; DEPARTMENT_ID LAST_NAME SALARY HIRE_DATE FV ------------- --------------- ---------- --------- ------------------------- 90 De Haan 17000 13-JAN-01 De Haan 90 King 24000 17-JUN-03 De Haan 90 Kochhar 17000 21-SEP-05 De Haan </code> When you use a logical offset (<code>RANGE</code> instead of <code>ROWS</code>), the function is deterministic. When duplicates are found for the <code>ORDER</code> <code>BY</code> expression, the <code>FIRST_VALUE</code> is the lowest value of <code>expr</code>: <code>SELECT department_id, last_name, salary, FIRST_VALUE(last_name) OVER (ORDER BY salary ASC RANGE UNBOUNDED PRECEDING) AS lowest_sal FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY employee_id); DEPARTMENT_ID LAST_NAME SALARY LOWEST_SAL ------------- ------------------------- ---------- ------------------------- 90 De Haan 17000 De Haan 90 Kochhar 17000 De Haan 90 King 24000 De Haan </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions066.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "REGEXP_REPLACE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGEXP_REPLACE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> REGEXP_REPLACE(source_char, pattern [, replace_string [, position [, occurrence [, match_param ] ] ] ] ) </eps> \n The Purpose is: \n <code>REGEXP_REPLACE</code> extends the functionality of the <code>REPLACE</code> function by letting you search a string for a regular expression pattern. By default, the function returns <code>source_char</code> with every occurrence of the regular expression pattern replaced with <code>replace_string</code>. The string returned is in the same character set as <code>source_char</code>. The function returns <code>VARCHAR2</code> if the first argument is not a LOB and returns <code>CLOB</code> if the first argument is a LOB. This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>source_char</code> is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code> or <code>NCLOB</code>. <code>pattern</code> is the regular expression. It is usually a text literal and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. It can contain up to 512 bytes. If the data type of <code>pattern</code> is different from the data type of <code>source_char</code>, then Oracle Database converts <code>pattern</code> to the data type of <code>source_char</code>. For a listing of the operators you can specify in <code>pattern</code>, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>replace_string</code> can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. If <code>replace_string</code> is a <code>CLOB</code> or <code>NCLOB</code>, then Oracle truncates <code>replace_string</code> to 32K. The <code>replace_string</code> can contain up to 500 backreferences to subexpressions in the form <code>\\n</code>, where <code>n</code> is a number from 1 to 9. If you want to include a backslash (<code>\\</code>) in <code>replace_string</code>, then you must precede it with the escape character, which is also a backslash. For example, to replace <code>\\2</code> you would enter <code>\\\\2</code>. For more information on backreference expressions, refer to the notes to <link>\"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>, <link>Table D-1&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix001.htm#BABJDBHB</link>. <code>position</code> is a positive integer indicating the character of <code>source_char</code> where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of <code>source_char</code>. <code>occurrence</code> is a nonnegative integer indicating the occurrence of the replace operation: If you specify 0, then Oracle replaces all occurrences of the match. If you specify a positive integer <code>n</code>, then Oracle replaces the <code>n</code>th occurrence. If <code>occurrence</code> is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of <code>pattern</code>, and so forth. This behavior is different from the <code>INSTR</code> function, which begins its search for the second occurrence at the second character of the first occurrence. <code>match_parameter</code> is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for <code>REGEXP_COUNT</code>. Refer to <link>REGEXP_COUNT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions147.htm#CIHDAIHJ</link> for detailed information. See Also: <link>REPLACE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions153.htm#i78608</link> <link>REGEXP_INSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions148.htm#i1239887</link>, <link>REGEXP_SUBSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions150.htm#i1239858</link>, and <link>REGEXP_LIKE Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions007.htm#i1048942</link> \n The Examples is: \n The following example examines <code>phone_number</code>, looking for the pattern <code>xxx</code>.<code>xxx</code>.<code>xxxx</code>. Oracle reformats this pattern with (<code>xxx</code>) <code>xxx</code>-<code>xxxx</code>. <code>SELECT REGEXP_REPLACE(phone_number, '([[:digit:]]{3})\\.([[:digit:]]{3})\\.([[:digit:]]{4})', '(\\1) \\2-\\3') \"REGEXP_REPLACE\" FROM employees ORDER BY \"REGEXP_REPLACE\"; REGEXP_REPLACE -------------------------------------------------------------------------------- (515) 123-4444 (515) 123-4567 (515) 123-4568 (515) 123-4569 (515) 123-5555 . . . </code> The following example examines <code>country_name</code>. Oracle puts a space after each non-null character in the string. <code>SELECT REGEXP_REPLACE(country_name, '(.)', '\\1 ') \"REGEXP_REPLACE\" FROM countries; REGEXP_REPLACE -------------------------------------------------------------------------------- A r g e n t i n a A u s t r a l i a B e l g i u m B r a z i l C a n a d a . . . </code> The following example examines the string, looking for two or more spaces. Oracle replaces each occurrence of two or more spaces with a single space. <code>SELECT REGEXP_REPLACE('500 Oracle Parkway, Redwood Shores, CA', '( ){2,}', ' ') \"REGEXP_REPLACE\" FROM DUAL; REGEXP_REPLACE -------------------------------------- 500 Oracle Parkway, Redwood Shores, CA </code> ",
        "detail": "The Syntax is: \n <eps> REGEXP_REPLACE(source_char, pattern [, replace_string [, position [, occurrence [, match_param ] ] ] ] ) </eps> \n The Purpose is: \n <code>REGEXP_REPLACE</code> extends the functionality of the <code>REPLACE</code> function by letting you search a string for a regular expression pattern. By default, the function returns <code>source_char</code> with every occurrence of the regular expression pattern replaced with <code>replace_string</code>. The string returned is in the same character set as <code>source_char</code>. The function returns <code>VARCHAR2</code> if the first argument is not a LOB and returns <code>CLOB</code> if the first argument is a LOB. This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>source_char</code> is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code> or <code>NCLOB</code>. <code>pattern</code> is the regular expression. It is usually a text literal and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. It can contain up to 512 bytes. If the data type of <code>pattern</code> is different from the data type of <code>source_char</code>, then Oracle Database converts <code>pattern</code> to the data type of <code>source_char</code>. For a listing of the operators you can specify in <code>pattern</code>, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>replace_string</code> can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. If <code>replace_string</code> is a <code>CLOB</code> or <code>NCLOB</code>, then Oracle truncates <code>replace_string</code> to 32K. The <code>replace_string</code> can contain up to 500 backreferences to subexpressions in the form <code>\\n</code>, where <code>n</code> is a number from 1 to 9. If you want to include a backslash (<code>\\</code>) in <code>replace_string</code>, then you must precede it with the escape character, which is also a backslash. For example, to replace <code>\\2</code> you would enter <code>\\\\2</code>. For more information on backreference expressions, refer to the notes to <link>\"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>, <link>Table D-1&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix001.htm#BABJDBHB</link>. <code>position</code> is a positive integer indicating the character of <code>source_char</code> where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of <code>source_char</code>. <code>occurrence</code> is a nonnegative integer indicating the occurrence of the replace operation: If you specify 0, then Oracle replaces all occurrences of the match. If you specify a positive integer <code>n</code>, then Oracle replaces the <code>n</code>th occurrence. If <code>occurrence</code> is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of <code>pattern</code>, and so forth. This behavior is different from the <code>INSTR</code> function, which begins its search for the second occurrence at the second character of the first occurrence. <code>match_parameter</code> is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for <code>REGEXP_COUNT</code>. Refer to <link>REGEXP_COUNT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions147.htm#CIHDAIHJ</link> for detailed information. See Also: <link>REPLACE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions153.htm#i78608</link> <link>REGEXP_INSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions148.htm#i1239887</link>, <link>REGEXP_SUBSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions150.htm#i1239858</link>, and <link>REGEXP_LIKE Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions007.htm#i1048942</link> \n The Examples is: \n The following example examines <code>phone_number</code>, looking for the pattern <code>xxx</code>.<code>xxx</code>.<code>xxxx</code>. Oracle reformats this pattern with (<code>xxx</code>) <code>xxx</code>-<code>xxxx</code>. <code>SELECT REGEXP_REPLACE(phone_number, '([[:digit:]]{3})\\.([[:digit:]]{3})\\.([[:digit:]]{4})', '(\\1) \\2-\\3') \"REGEXP_REPLACE\" FROM employees ORDER BY \"REGEXP_REPLACE\"; REGEXP_REPLACE -------------------------------------------------------------------------------- (515) 123-4444 (515) 123-4567 (515) 123-4568 (515) 123-4569 (515) 123-5555 . . . </code> The following example examines <code>country_name</code>. Oracle puts a space after each non-null character in the string. <code>SELECT REGEXP_REPLACE(country_name, '(.)', '\\1 ') \"REGEXP_REPLACE\" FROM countries; REGEXP_REPLACE -------------------------------------------------------------------------------- A r g e n t i n a A u s t r a l i a B e l g i u m B r a z i l C a n a d a . . . </code> The following example examines the string, looking for two or more spaces. Oracle replaces each occurrence of two or more spaces with a single space. <code>SELECT REGEXP_REPLACE('500 Oracle Parkway, Redwood Shores, CA', '( ){2,}', ' ') \"REGEXP_REPLACE\" FROM DUAL; REGEXP_REPLACE -------------------------------------- 500 Oracle Parkway, Redwood Shores, CA </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions149.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_BLOB",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_BLOB))) (function_argument ( )))",
        "description": "The Syntax is: \n to_blob::= <eps> TO_BLOB ( raw_value ) </eps> \n The Purpose is: \n <code>TO_BLOB</code> converts <code>LONG</code> <code>RAW</code> and <code>RAW</code> values to <code>BLOB</code> values. From within a PL/SQL package, you can use <code>TO_BLOB</code> to convert <code>RAW</code> and <code>BLOB</code> values to <code>BLOB</code>. \n The Examples is: \n The following hypothetical example returns the <code>BLOB</code> of a <code>RAW</code> column value: <code>SELECT TO_BLOB(raw_column) blob FROM raw_table; BLOB ----------------------- 00AADD343CDBBD </code> ",
        "detail": "The Syntax is: \n to_blob::= <eps> TO_BLOB ( raw_value ) </eps> \n The Purpose is: \n <code>TO_BLOB</code> converts <code>LONG</code> <code>RAW</code> and <code>RAW</code> values to <code>BLOB</code> values. From within a PL/SQL package, you can use <code>TO_BLOB</code> to convert <code>RAW</code> and <code>BLOB</code> values to <code>BLOB</code>. \n The Examples is: \n The following hypothetical example returns the <code>BLOB</code> of a <code>RAW</code> column value: <code>SELECT TO_BLOB(raw_column) blob FROM raw_table; BLOB ----------------------- 00AADD343CDBBD </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions198.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ROUND(date)",
        "tree": "(numeric_function ROUND ( ))",
        "description": "The Syntax is: \n round_date::= <eps> ROUND(date [, fmt ]) </eps> \n The Purpose is: \n <code>ROUND</code> returns <code>date</code> rounded to the unit specified by the format model <code>fmt</code>. This function is not sensitive to the <code>NLS_CALENDAR</code> session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type <code>DATE</code>, even if you specify a different datetime data type for <code>date</code>. If you omit <code>fmt</code>, then <code>date</code> is rounded to the nearest day. The <code>date</code> expression must resolve to a <code>DATE</code> value. See Also: <link>\"ROUND and TRUNC Date Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions255.htm#i1002084</link> for the permitted format models to use in <code>fmt</code> \n The Examples is: \n The following example rounds a date to the first day of the following year: <code>SELECT ROUND (TO_DATE ('27-OCT-00'),'YEAR') \"New Year\" FROM DUAL; New Year --------- 01-JAN-01 </code> ",
        "detail": "The Syntax is: \n round_date::= <eps> ROUND(date [, fmt ]) </eps> \n The Purpose is: \n <code>ROUND</code> returns <code>date</code> rounded to the unit specified by the format model <code>fmt</code>. This function is not sensitive to the <code>NLS_CALENDAR</code> session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type <code>DATE</code>, even if you specify a different datetime data type for <code>date</code>. If you omit <code>fmt</code>, then <code>date</code> is rounded to the nearest day. The <code>date</code> expression must resolve to a <code>DATE</code> value. See Also: <link>\"ROUND and TRUNC Date Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions255.htm#i1002084</link> for the permitted format models to use in <code>fmt</code> \n The Examples is: \n The following example rounds a date to the first day of the following year: <code>SELECT ROUND (TO_DATE ('27-OCT-00'),'YEAR') \"New Year\" FROM DUAL; New Year --------- 01-JAN-01 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions154.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LEAST",
        "tree": "(numeric_function LEAST ( ))",
        "description": "The Syntax is: \n <eps> LEAST(expr [, expr ]...) </eps> \n The Purpose is: \n <code>LEAST</code> returns the least of a list of one or more expressions. Oracle Database uses the first <code>expr</code> to determine the return type. If the first <code>expr</code> is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first <code>expr</code> is not numeric, then each <code>expr</code> after the first is implicitly converted to the data type of the first <code>expr</code> before the comparison. Oracle Database compares each <code>expr</code> using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the <code>NLS_COMP</code> parameter is set to <code>LINGUISTIC</code> and the <code>NLS_SORT</code> parameter has a setting other than <code>BINARY</code>. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is <code>VARCHAR2</code> if the first <code>expr</code> is a character data type and <code>NVARCHAR2</code> if the first <code>expr</code> is a national character data type. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information on character comparison <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics <link>\"GREATEST\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions069.htm#i77473</link>, which returns the greatest of a list of one or more expressions \n The Examples is: \n The following statement selects the string with the least value: <code>SELECT LEAST('HARRY','HARRIOT','HAROLD') \"Least\" FROM DUAL; Least ------ HAROLD </code> In the following statement, the first argument is numeric. Oracle Database determines that the argument with the highest numeric precedence is the third argument, converts the remaining arguments to the data type of the third argument, and returns the least value as that data type: <code>SELECT LEAST (1, '2.1', '.000832') \"Least\" FROM DUAL; Least ------- .000832 </code> ",
        "detail": "The Syntax is: \n <eps> LEAST(expr [, expr ]...) </eps> \n The Purpose is: \n <code>LEAST</code> returns the least of a list of one or more expressions. Oracle Database uses the first <code>expr</code> to determine the return type. If the first <code>expr</code> is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first <code>expr</code> is not numeric, then each <code>expr</code> after the first is implicitly converted to the data type of the first <code>expr</code> before the comparison. Oracle Database compares each <code>expr</code> using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the <code>NLS_COMP</code> parameter is set to <code>LINGUISTIC</code> and the <code>NLS_SORT</code> parameter has a setting other than <code>BINARY</code>. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is <code>VARCHAR2</code> if the first <code>expr</code> is a character data type and <code>NVARCHAR2</code> if the first <code>expr</code> is a national character data type. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information on character comparison <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics <link>\"GREATEST\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions069.htm#i77473</link>, which returns the greatest of a list of one or more expressions \n The Examples is: \n The following statement selects the string with the least value: <code>SELECT LEAST('HARRY','HARRIOT','HAROLD') \"Least\" FROM DUAL; Least ------ HAROLD </code> In the following statement, the first argument is numeric. Oracle Database determines that the argument with the highest numeric precedence is the third argument, converts the remaining arguments to the data type of the third argument, and returns the least value as that data type: <code>SELECT LEAST (1, '2.1', '.000832') \"Least\" FROM DUAL; Least ------- .000832 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions087.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "FEATURE_ID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c FEATURE_ID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> FEATURE_ID( [ schema . ] model mining_attribute_clause ) </eps> mining_attribute_clause:= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with feature extraction models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns an Oracle <code>NUMBER</code> that is the identifier of the feature with the highest value in the row. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the features and corresponding count of customers in a dataset. This example and the prerequisite data mining operations, including creation of the <code>nmf_sh_sample</code> model and <code>nmf_sh_sample_apply_prepared</code> view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmnmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT FEATURE_ID(nmf_sh_sample USING *) AS feat, COUNT(*) AS cnt FROM nmf_sh_sample_apply_prepared GROUP BY FEATURE_ID(nmf_sh_sample USING *) ORDER BY cnt DESC, feat DESC; FEAT CNT ---------- ---------- 7 1443 2 49 3 6 6 1 1 1 </code> ",
        "detail": "The Syntax is: \n <eps> FEATURE_ID( [ schema . ] model mining_attribute_clause ) </eps> mining_attribute_clause:= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with feature extraction models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns an Oracle <code>NUMBER</code> that is the identifier of the feature with the highest value in the row. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the features and corresponding count of customers in a dataset. This example and the prerequisite data mining operations, including creation of the <code>nmf_sh_sample</code> model and <code>nmf_sh_sample_apply_prepared</code> view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmnmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT FEATURE_ID(nmf_sh_sample USING *) AS feat, COUNT(*) AS cnt FROM nmf_sh_sample_apply_prepared GROUP BY FEATURE_ID(nmf_sh_sample USING *) ORDER BY cnt DESC, feat DESC; FEAT CNT ---------- ---------- 7 1443 2 49 3 6 6 1 1 1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions062.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "POWERMULTISET",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c POWERMULTISET))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> POWERMULTISET(expr) </eps> \n The Purpose is: \n <code>POWERMULTISET</code> takes as input a nested table and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the input nested table. <code>expr</code> can be any expression that evaluates to a nested table. If <code>expr</code> resolves to null, then Oracle Database returns <code>NULL</code>. If <code>expr</code> resolves to a nested table that is empty, then Oracle returns an error. The element types of the nested table must be comparable. Refer to <link>\"Comparison Conditions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions002.htm#i1033286</link> for information on the comparability of nonscalar types. Note: This function is not supported in PL/SQL. \n The Examples is: \n First, create a data type that is a nested table of the <code>cust_address_tab_type</code> data type: <code>CREATE TYPE cust_address_tab_tab_typ AS TABLE OF cust_address_tab_typ; / </code> Now, select the nested table column <code>cust_address_ntab</code> from the <code>customers_demo</code> table using the <code>POWERMULTISET</code> function: <code>SELECT CAST(POWERMULTISET(cust_address_ntab) AS cust_address_tab_tab_typ) FROM customers_demo; CAST(POWERMULTISET(CUST_ADDRESS_NTAB) AS CUST_ADDRESS_TAB_TAB_TYP) (STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID) ------------------------------------------------------------------ CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP ('514 W Superior St', '46901', 'Kokomo', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP ('2515 Bloyd Ave', '46218', 'Indianapolis', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP ('8768 N State Rd 37', '47404', 'Bloomington', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP ('6445 Bay Harbor Ln', '46254', 'Indianapolis', 'IN', 'US'))) . . . </code> The preceding example requires the <code>customers_demo</code> table and a nested table column containing data. Refer to <link>\"Multiset Operators\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/operators006.htm#i1035617</link> to create this table and nested table columns. ",
        "detail": "The Syntax is: \n <eps> POWERMULTISET(expr) </eps> \n The Purpose is: \n <code>POWERMULTISET</code> takes as input a nested table and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the input nested table. <code>expr</code> can be any expression that evaluates to a nested table. If <code>expr</code> resolves to null, then Oracle Database returns <code>NULL</code>. If <code>expr</code> resolves to a nested table that is empty, then Oracle returns an error. The element types of the nested table must be comparable. Refer to <link>\"Comparison Conditions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions002.htm#i1033286</link> for information on the comparability of nonscalar types. Note: This function is not supported in PL/SQL. \n The Examples is: \n First, create a data type that is a nested table of the <code>cust_address_tab_type</code> data type: <code>CREATE TYPE cust_address_tab_tab_typ AS TABLE OF cust_address_tab_typ; / </code> Now, select the nested table column <code>cust_address_ntab</code> from the <code>customers_demo</code> table using the <code>POWERMULTISET</code> function: <code>SELECT CAST(POWERMULTISET(cust_address_ntab) AS cust_address_tab_tab_typ) FROM customers_demo; CAST(POWERMULTISET(CUST_ADDRESS_NTAB) AS CUST_ADDRESS_TAB_TAB_TYP) (STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID) ------------------------------------------------------------------ CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP ('514 W Superior St', '46901', 'Kokomo', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP ('2515 Bloyd Ave', '46218', 'Indianapolis', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP ('8768 N State Rd 37', '47404', 'Bloomington', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP(CUST_ADDRESS_TYP ('6445 Bay Harbor Ln', '46254', 'Indianapolis', 'IN', 'US'))) . . . </code> The preceding example requires the <code>customers_demo</code> table and a nested table column containing data. Refer to <link>\"Multiset Operators\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/operators006.htm#i1035617</link> to create this table and nested table columns. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions130.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NLS_UPPER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NLS_UPPER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NLS_UPPER(char [, 'nlsparam' ]) </eps> \n The Purpose is: \n <code>NLS_UPPER</code> returns <code>char</code>, with all letters uppercase. Both <code>char</code> and <code>'nlsparam'</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>char</code> is a character data type and a LOB if <code>char</code> is a LOB data type. The return string is in the same character set as <code>char</code>. The <code>'nlsparam'</code> can have the same form and serve the same purpose as in the <code>NLS_INITCAP</code> function. \n The Examples is: \n The following example returns a string with all the letters converted to uppercase: <code>SELECT NLS_UPPER('gro\u00dfe') \"Uppercase\" FROM DUAL; Upper ----- GRO\u00dfE SELECT NLS_UPPER('gro\u00dfe', 'NLS_SORT = XGerman') \"Uppercase\" FROM DUAL; Upperc ------ GROSSE </code> See Also: <link>NLS_INITCAP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions110.htm#i89841</link> ",
        "detail": "The Syntax is: \n <eps> NLS_UPPER(char [, 'nlsparam' ]) </eps> \n The Purpose is: \n <code>NLS_UPPER</code> returns <code>char</code>, with all letters uppercase. Both <code>char</code> and <code>'nlsparam'</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>char</code> is a character data type and a LOB if <code>char</code> is a LOB data type. The return string is in the same character set as <code>char</code>. The <code>'nlsparam'</code> can have the same form and serve the same purpose as in the <code>NLS_INITCAP</code> function. \n The Examples is: \n The following example returns a string with all the letters converted to uppercase: <code>SELECT NLS_UPPER('gro\u00dfe') \"Uppercase\" FROM DUAL; Upper ----- GRO\u00dfE SELECT NLS_UPPER('gro\u00dfe', 'NLS_SORT = XGerman') \"Uppercase\" FROM DUAL; Upperc ------ GROSSE </code> See Also: <link>NLS_INITCAP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions110.htm#i89841</link> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions112.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CURRENT_DATE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CURRENT_DATE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CURRENT_DATE </eps> \n The Purpose is: \n <code>CURRENT_DATE</code> returns the current date in the session time zone, in a value in the Gregorian calendar of data type <code>DATE</code>. \n The Examples is: \n The following example illustrates that <code>CURRENT_DATE</code> is sensitive to the session time zone: <code>ALTER SESSION SET TIME_ZONE = '-5:0'; ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS'; SELECT SESSIONTIMEZONE, CURRENT_DATE FROM DUAL; SESSIONTIMEZONE CURRENT_DATE --------------- -------------------- -05:00 29-MAY-2000 13:14:03 ALTER SESSION SET TIME_ZONE = '-8:0'; SELECT SESSIONTIMEZONE, CURRENT_DATE FROM DUAL; SESSIONTIMEZONE CURRENT_DATE --------------- -------------------- -08:00 29-MAY-2000 10:14:33 </code> ",
        "detail": "The Syntax is: \n <eps> CURRENT_DATE </eps> \n The Purpose is: \n <code>CURRENT_DATE</code> returns the current date in the session time zone, in a value in the Gregorian calendar of data type <code>DATE</code>. \n The Examples is: \n The following example illustrates that <code>CURRENT_DATE</code> is sensitive to the session time zone: <code>ALTER SESSION SET TIME_ZONE = '-5:0'; ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS'; SELECT SESSIONTIMEZONE, CURRENT_DATE FROM DUAL; SESSIONTIMEZONE CURRENT_DATE --------------- -------------------- -05:00 29-MAY-2000 13:14:03 ALTER SESSION SET TIME_ZONE = '-8:0'; SELECT SESSIONTIMEZONE, CURRENT_DATE FROM DUAL; SESSIONTIMEZONE CURRENT_DATE --------------- -------------------- -08:00 29-MAY-2000 10:14:33 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions044.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "BITAND",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c BITAND))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> BITAND(expr1, expr2) </eps> \n The Purpose is: \n The <code>BITAND</code> function treats its inputs and its output as vectors of bits; the output is the bitwise <code>AND</code> of the inputs. The types of <code>expr1</code> and <code>expr2</code> are <code>NUMBER</code>, and the result is of type <code>NUMBER</code>. If either argument to <code>BITAND</code> is <code>NULL</code>, the result is <code>NULL</code>. The arguments must be in the range -(2(n-1)) .. ((2(n-1))-1). If an argument is out of this range, the result is undefined. The result is computed in several steps. First, each argument A is replaced with the value <code>SIGN(A)*FLOOR(ABS(A))</code>. This conversion has the effect of truncating each argument towards zero. Next, each argument A (which must now be an integer value) is converted to an n-bit two's complement binary integer value. The two bit values are combined using a bitwise <code>AND</code> operation. Finally, the resulting n-bit two's complement value is converted back to <code>NUMBER</code>. Notes on the BITAND Function The current implementation of <code>BITAND</code> defines <code>n</code> = 128. PL/SQL supports an overload of <code>BITAND</code> for which the types of the inputs and of the result are all <code>BINARY_INTEGER</code> and for which <code>n</code> = 32. \n The Examples is: \n The following example performs an <code>AND</code> operation on the numbers 6 (binary 1,1,0) and 3 (binary 0,1,1): <code>SELECT BITAND(6,3) FROM DUAL; BITAND(6,3) ----------- 2 </code> This is the same as the following example, which shows the binary values of 6 and 3. The <code>BITAND</code> function operates only on the significant digits of the binary values: <code>SELECT BITAND( BIN_TO_NUM(1,1,0), BIN_TO_NUM(0,1,1)) \"Binary\" FROM DUAL; Binary ---------- 2 </code> Refer to the example for <link>BIN_TO_NUM&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions020.htm#i1002025</link> for information on encoding multiple values in a single column value. The following example supposes that the <code>order_status</code> column of the sample table <code>oe.orders</code> encodes several choices as individual bits within a single numeric value. For example, an order still in the warehouse is represented by a binary value 001 (decimal 1). An order being sent by ground transportation is represented by a binary value 010 (decimal 2). An insured package is represented by a binary value 100 (decimal 4). The example uses the <code>DECODE</code> function to provide two values for each of the three bits in the <code>order_status</code> value, one value if the bit is turned on and one if it is turned off. <code>SELECT order_id, customer_id, order_status, DECODE(BITAND(order_status, 1), 1, 'Warehouse', 'PostOffice') \"Location\", DECODE(BITAND(order_status, 2), 2, 'Ground', 'Air') \"Method\", DECODE(BITAND(order_status, 4), 4, 'Insured', 'Certified') \"Receipt\" FROM orders WHERE sales_rep_id = 160 ORDER BY order_id; ORDER_ID CUSTOMER_ID ORDER_STATUS Location Method Receipt ---------- ----------- ------------ ---------- ------ --------- 2416 104 6 PostOffice Ground Insured 2419 107 3 Warehouse Ground Certified 2420 108 2 PostOffice Ground Certified 2423 145 3 Warehouse Ground Certified 2441 106 5 Warehouse Air Insured 2455 145 7 Warehouse Ground Insured </code> For the <code>Location</code> column, <code>BITAND</code> first compares <code>order_status</code> with 1 (binary 001). Only significant bit values are compared, so any binary value with a 1 in its rightmost bit (any odd number) will evaluate positively and return 1. Even numbers will return 0. The <code>DECODE</code> function compares the value returned by <code>BITAND</code> with 1. If they are both 1, then the location is \"Warehouse\". If they are different, then the location is \"PostOffice\". The <code>Method</code> and <code>Receipt</code> columns are calculated similarly. For <code>Method</code>, <code>BITAND</code> performs the <code>AND</code> operation on <code>order_status</code> and 2 (binary 010). For <code>Receipt</code>, <code>BITAND</code> performs the <code>AND</code> operation on <code>order_status</code> and 4 (binary 100). ",
        "detail": "The Syntax is: \n <eps> BITAND(expr1, expr2) </eps> \n The Purpose is: \n The <code>BITAND</code> function treats its inputs and its output as vectors of bits; the output is the bitwise <code>AND</code> of the inputs. The types of <code>expr1</code> and <code>expr2</code> are <code>NUMBER</code>, and the result is of type <code>NUMBER</code>. If either argument to <code>BITAND</code> is <code>NULL</code>, the result is <code>NULL</code>. The arguments must be in the range -(2(n-1)) .. ((2(n-1))-1). If an argument is out of this range, the result is undefined. The result is computed in several steps. First, each argument A is replaced with the value <code>SIGN(A)*FLOOR(ABS(A))</code>. This conversion has the effect of truncating each argument towards zero. Next, each argument A (which must now be an integer value) is converted to an n-bit two's complement binary integer value. The two bit values are combined using a bitwise <code>AND</code> operation. Finally, the resulting n-bit two's complement value is converted back to <code>NUMBER</code>. Notes on the BITAND Function The current implementation of <code>BITAND</code> defines <code>n</code> = 128. PL/SQL supports an overload of <code>BITAND</code> for which the types of the inputs and of the result are all <code>BINARY_INTEGER</code> and for which <code>n</code> = 32. \n The Examples is: \n The following example performs an <code>AND</code> operation on the numbers 6 (binary 1,1,0) and 3 (binary 0,1,1): <code>SELECT BITAND(6,3) FROM DUAL; BITAND(6,3) ----------- 2 </code> This is the same as the following example, which shows the binary values of 6 and 3. The <code>BITAND</code> function operates only on the significant digits of the binary values: <code>SELECT BITAND( BIN_TO_NUM(1,1,0), BIN_TO_NUM(0,1,1)) \"Binary\" FROM DUAL; Binary ---------- 2 </code> Refer to the example for <link>BIN_TO_NUM&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions020.htm#i1002025</link> for information on encoding multiple values in a single column value. The following example supposes that the <code>order_status</code> column of the sample table <code>oe.orders</code> encodes several choices as individual bits within a single numeric value. For example, an order still in the warehouse is represented by a binary value 001 (decimal 1). An order being sent by ground transportation is represented by a binary value 010 (decimal 2). An insured package is represented by a binary value 100 (decimal 4). The example uses the <code>DECODE</code> function to provide two values for each of the three bits in the <code>order_status</code> value, one value if the bit is turned on and one if it is turned off. <code>SELECT order_id, customer_id, order_status, DECODE(BITAND(order_status, 1), 1, 'Warehouse', 'PostOffice') \"Location\", DECODE(BITAND(order_status, 2), 2, 'Ground', 'Air') \"Method\", DECODE(BITAND(order_status, 4), 4, 'Insured', 'Certified') \"Receipt\" FROM orders WHERE sales_rep_id = 160 ORDER BY order_id; ORDER_ID CUSTOMER_ID ORDER_STATUS Location Method Receipt ---------- ----------- ------------ ---------- ------ --------- 2416 104 6 PostOffice Ground Insured 2419 107 3 Warehouse Ground Certified 2420 108 2 PostOffice Ground Certified 2423 145 3 Warehouse Ground Certified 2441 106 5 Warehouse Air Insured 2455 145 7 Warehouse Ground Insured </code> For the <code>Location</code> column, <code>BITAND</code> first compares <code>order_status</code> with 1 (binary 001). Only significant bit values are compared, so any binary value with a 1 in its rightmost bit (any odd number) will evaluate positively and return 1. Even numbers will return 0. The <code>DECODE</code> function compares the value returned by <code>BITAND</code> with 1. If they are both 1, then the location is \"Warehouse\". If they are different, then the location is \"PostOffice\". The <code>Method</code> and <code>Receipt</code> columns are calculated similarly. For <code>Method</code>, <code>BITAND</code> performs the <code>AND</code> operation on <code>order_status</code> and 2 (binary 010). For <code>Receipt</code>, <code>BITAND</code> performs the <code>AND</code> operation on <code>order_status</code> and 4 (binary 100). ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions021.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LAG",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LAG))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LAG { ( value_expr [, offset [, default]]) [ { RESPECT | IGNORE } NULLS ] | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] ) } OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>value_expr</code> \n The Purpose is: \n <code>LAG</code> is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, <code>LAG</code> provides access to a row at a given physical offset prior to that position. For the optional <code>offset</code> argument, specify an integer that is greater than zero. If you do not specify <code>offset</code>, then its default is 1. The optional <code>default</code> value is returned if the offset goes beyond the scope of the window. If you do not specify <code>default</code>, then its default is null. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>value_expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. You cannot nest analytic functions by using <code>LAG</code> or any other analytic function for <code>value_expr</code>. However, you can use other built-in function expressions for <code>value_expr</code>. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>LEAD&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions086.htm#i83834</link> \n The Examples is: \n The following example provides, for each purchasing clerk in the <code>employees</code> table, the salary of the employee hired just before: <code>SELECT hire_date, last_name, salary, LAG(salary, 1, 0 ) OVER (ORDER BY hire_date) AS prev_sal FROM employees WHERE job_id = 'PU_CLERK' ORDER BY hire_date; HIRE_DATE LAST_NAME SALARY PREV_SAL --------- ------------------------- ---------- ---------- 18-MAY-03 Khoo 3100 0 24-JUL-05 Tobias 2800 3100 24-DEC-05 Baida 2900 2800 15-NOV-06 Himuro 2600 2900 10-AUG-07 Colmenares 2500 2600 </code> ",
        "detail": "The Syntax is: \n <eps> LAG { ( value_expr [, offset [, default]]) [ { RESPECT | IGNORE } NULLS ] | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] ) } OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>value_expr</code> \n The Purpose is: \n <code>LAG</code> is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, <code>LAG</code> provides access to a row at a given physical offset prior to that position. For the optional <code>offset</code> argument, specify an integer that is greater than zero. If you do not specify <code>offset</code>, then its default is 1. The optional <code>default</code> value is returned if the offset goes beyond the scope of the window. If you do not specify <code>default</code>, then its default is null. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>value_expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. You cannot nest analytic functions by using <code>LAG</code> or any other analytic function for <code>value_expr</code>. However, you can use other built-in function expressions for <code>value_expr</code>. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>LEAD&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions086.htm#i83834</link> \n The Examples is: \n The following example provides, for each purchasing clerk in the <code>employees</code> table, the salary of the employee hired just before: <code>SELECT hire_date, last_name, salary, LAG(salary, 1, 0 ) OVER (ORDER BY hire_date) AS prev_sal FROM employees WHERE job_id = 'PU_CLERK' ORDER BY hire_date; HIRE_DATE LAST_NAME SALARY PREV_SAL --------- ------------------------- ---------- ---------- 18-MAY-03 Khoo 3100 0 24-JUL-05 Tobias 2800 3100 24-DEC-05 Baida 2900 2800 15-NOV-06 Himuro 2600 2900 10-AUG-07 Colmenares 2500 2600 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions082.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_CHAR_(number)",
        "tree": "(general_element_part (id_expression (regular_id TO_CHAR_)) (function_argument ( )))",
        "description": "The Syntax is: \n to_char_number::= <eps> TO_CHAR(n [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_CHAR</code> (number) converts <code>n</code> to a value of <code>VARCHAR2</code> data type, using the optional number format <code>fmt</code>. The value <code>n</code> can be of type <code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>. If you omit <code>fmt</code>, then <code>n</code> is converted to a <code>VARCHAR2</code> value exactly long enough to hold its significant digits. If <code>n</code> is negative, then the sign is applied after the format is applied. Thus <code>TO_CHAR(-1, '$9')</code> returns -$1, rather than $-1. Refer to <link>\"Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34510</link> for information on number formats. The <code>'nlsparam'</code> argument specifies these characters that are returned by number format elements: Decimal character Group separator Local currency symbol International currency symbol This argument can have this form: <code>'NLS_NUMERIC_CHARACTERS = ''dg'' NLS_CURRENCY = ''text'' NLS_ISO_CURRENCY = territory ' </code> The characters <code>d</code> and <code>g</code> represent the decimal character and group separator, respectively. They must be different single-byte characters. Within the quoted string, you must use two single quotation marks around the parameter values. Ten characters are available for the currency symbol. If you omit <code>'nlsparam'</code> or any one of the parameters, then this function uses the default parameter values for your session. See Also: <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> \n The Examples is: \n The following statement uses implicit conversion to combine a string and a number into a number: <code>SELECT TO_CHAR('01110' + 1) FROM DUAL; TO_C ---- 1111 </code> Compare this example with the first example for <link>TO_CHAR (character)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions199.htm#i1006717</link>. In the next example, the output is blank padded to the left of the currency symbol. <code>SELECT TO_CHAR(-10000,'L99G999D99MI') \"Amount\" FROM DUAL; Amount -------------- $10,000.00- SELECT TO_CHAR(-10000,'L99G999D99MI', 'NLS_NUMERIC_CHARACTERS = '',.'' NLS_CURRENCY = ''AusDollars'' ') \"Amount\" FROM DUAL; Amount ------------------- AusDollars10.000,00- </code> In the optional number format <code>fmt</code>, <code>L</code> designates local currency symbol and <code>MI</code> designates a trailing minus sign. See <link>Table 3-17, \"Matching Character Data and Format Models with the FX Format Model Modifier\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#g195443</link> for a complete listing of number format elements. ",
        "detail": "The Syntax is: \n to_char_number::= <eps> TO_CHAR(n [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_CHAR</code> (number) converts <code>n</code> to a value of <code>VARCHAR2</code> data type, using the optional number format <code>fmt</code>. The value <code>n</code> can be of type <code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>. If you omit <code>fmt</code>, then <code>n</code> is converted to a <code>VARCHAR2</code> value exactly long enough to hold its significant digits. If <code>n</code> is negative, then the sign is applied after the format is applied. Thus <code>TO_CHAR(-1, '$9')</code> returns -$1, rather than $-1. Refer to <link>\"Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34510</link> for information on number formats. The <code>'nlsparam'</code> argument specifies these characters that are returned by number format elements: Decimal character Group separator Local currency symbol International currency symbol This argument can have this form: <code>'NLS_NUMERIC_CHARACTERS = ''dg'' NLS_CURRENCY = ''text'' NLS_ISO_CURRENCY = territory ' </code> The characters <code>d</code> and <code>g</code> represent the decimal character and group separator, respectively. They must be different single-byte characters. Within the quoted string, you must use two single quotation marks around the parameter values. Ten characters are available for the currency symbol. If you omit <code>'nlsparam'</code> or any one of the parameters, then this function uses the default parameter values for your session. See Also: <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> \n The Examples is: \n The following statement uses implicit conversion to combine a string and a number into a number: <code>SELECT TO_CHAR('01110' + 1) FROM DUAL; TO_C ---- 1111 </code> Compare this example with the first example for <link>TO_CHAR (character)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions199.htm#i1006717</link>. In the next example, the output is blank padded to the left of the currency symbol. <code>SELECT TO_CHAR(-10000,'L99G999D99MI') \"Amount\" FROM DUAL; Amount -------------- $10,000.00- SELECT TO_CHAR(-10000,'L99G999D99MI', 'NLS_NUMERIC_CHARACTERS = '',.'' NLS_CURRENCY = ''AusDollars'' ') \"Amount\" FROM DUAL; Amount ------------------- AusDollars10.000,00- </code> In the optional number format <code>fmt</code>, <code>L</code> designates local currency symbol and <code>MI</code> designates a trailing minus sign. See <link>Table 3-17, \"Matching Character Data and Format Models with the FX Format Model Modifier\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#g195443</link> for a complete listing of number format elements. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NULLIF",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NULLIF))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NULLIF(expr1, expr2) </eps> \n The Purpose is: \n <code>NULLIF</code> compares <code>expr1</code> and <code>expr2</code>. If they are equal, then the function returns null. If they are not equal, then the function returns <code>expr1</code>. You cannot specify the literal <code>NULL</code> for <code>expr1</code>. If both arguments are numeric data types, then Oracle Database determines the argument with the higher numeric precedence, implicitly converts the other argument to that data type, and returns that data type. If the arguments are not numeric, then they must be of the same data type, or Oracle returns an error. The <code>NULLIF</code> function is logically equivalent to the following <code>CASE</code> expression: <code>CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END </code> See Also: <link>\"CASE Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm#i1033392</link> \n The Examples is: \n The following example selects those employees from the sample schema <code>hr</code> who have changed jobs since they were hired, as indicated by a <code>job_id</code> in the <code>job_history</code> table different from the current <code>job_id</code> in the <code>employees</code> table: <code>SELECT e.last_name, NULLIF(j.job_id, e.job_id) \"Old Job ID\" FROM employees e, job_history j WHERE e.employee_id = j.employee_id ORDER BY last_name, \"Old Job ID\"; LAST_NAME Old Job ID ------------------------- ---------- De Haan IT_PROG Hartstein MK_REP Kaufling ST_CLERK Kochhar AC_ACCOUNT Kochhar AC_MGR Raphaely ST_CLERK Taylor SA_MAN Taylor Whalen AC_ACCOUNT Whalen </code> ",
        "detail": "The Syntax is: \n <eps> NULLIF(expr1, expr2) </eps> \n The Purpose is: \n <code>NULLIF</code> compares <code>expr1</code> and <code>expr2</code>. If they are equal, then the function returns null. If they are not equal, then the function returns <code>expr1</code>. You cannot specify the literal <code>NULL</code> for <code>expr1</code>. If both arguments are numeric data types, then Oracle Database determines the argument with the higher numeric precedence, implicitly converts the other argument to that data type, and returns that data type. If the arguments are not numeric, then they must be of the same data type, or Oracle returns an error. The <code>NULLIF</code> function is logically equivalent to the following <code>CASE</code> expression: <code>CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END </code> See Also: <link>\"CASE Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm#i1033392</link> \n The Examples is: \n The following example selects those employees from the sample schema <code>hr</code> who have changed jobs since they were hired, as indicated by a <code>job_id</code> in the <code>job_history</code> table different from the current <code>job_id</code> in the <code>employees</code> table: <code>SELECT e.last_name, NULLIF(j.job_id, e.job_id) \"Old Job ID\" FROM employees e, job_history j WHERE e.employee_id = j.employee_id ORDER BY last_name, \"Old Job ID\"; LAST_NAME Old Job ID ------------------------- ---------- De Haan IT_PROG Hartstein MK_REP Kaufling ST_CLERK Kochhar AC_ACCOUNT Kochhar AC_MGR Raphaely ST_CLERK Taylor SA_MAN Taylor Whalen AC_ACCOUNT Whalen </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions116.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LNNVL",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LNNVL))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LNNVL(condition) </eps> \n The Purpose is: \n <code>LNNVL</code> provides a concise way to evaluate a condition when one or both operands of the condition may be null. The function can be used in the <code>WHERE</code> clause of a query, or as the <code>WHEN</code> condition in a searched <code>CASE</code> expression. It takes as an argument a condition and returns <code>TRUE</code> if the condition is <code>FALSE</code> or <code>UNKNOWN</code> and <code>FALSE</code> if the condition is <code>TRUE</code>. <code>LNNVL</code> can be used anywhere a scalar expression can appear, even in contexts where the <code>IS</code> [<code>NOT</code>] <code>NULL</code>, <code>AND</code>, or <code>OR</code> conditions are not valid but would otherwise be required to account for potential nulls. Oracle Database sometimes uses the <code>LNNVL</code> function internally in this way to rewrite <code>NOT</code> <code>IN</code> conditions as <code>NOT</code> <code>EXISTS</code> conditions. In such cases, output from <code>EXPLAIN</code> <code>PLAN</code> shows this operation in the plan table output. The <code>condition</code> can evaluate any scalar values but cannot be a compound condition containing <code>AND</code>, <code>OR</code>, or <code>BETWEEN</code>. The table that follows shows what <code>LNNVL</code> returns given that <code>a</code> = 2 and <code>b</code> is null. <table> <thead> <tr> <th>Condition</th> <th>Truth of Condition</th> <th>LNNVL Return Value</th> </tr> </thead> <tbody> <tr> <td>a = 1</td> <td>FALSE</td> <td>TRUE</td> </tr> <tr> <td>a = 2</td> <td>TRUE</td> <td>FALSE</td> </tr> <tr> <td>a IS NULL</td> <td>FALSE</td> <td>TRUE</td> </tr> <tr> <td>b = 1</td> <td>UNKNOWN</td> <td>TRUE</td> </tr> <tr> <td>b IS NULL</td> <td>TRUE</td> <td>FALSE</td> </tr> <tr> <td>a = b</td> <td>UNKNOWN</td> <td>TRUE</td> </tr> </tbody> </table> \n The Examples is: \n Suppose that you want to know the number of employees with commission rates of less than 20%, including employees who do not receive commissions. The following query returns only employees who actually receive a commission of less than 20%: <code>SELECT COUNT(*) FROM employees WHERE commission_pct < .2; COUNT(*) ---------- 11 </code> To include the 72 employees who receive no commission at all, you could rewrite the query using the <code>LNNVL</code> function as follows: <code>SELECT COUNT(*) FROM employees WHERE LNNVL(commission_pct >= .2); COUNT(*) ---------- 83 </code> ",
        "detail": "The Syntax is: \n <eps> LNNVL(condition) </eps> \n The Purpose is: \n <code>LNNVL</code> provides a concise way to evaluate a condition when one or both operands of the condition may be null. The function can be used in the <code>WHERE</code> clause of a query, or as the <code>WHEN</code> condition in a searched <code>CASE</code> expression. It takes as an argument a condition and returns <code>TRUE</code> if the condition is <code>FALSE</code> or <code>UNKNOWN</code> and <code>FALSE</code> if the condition is <code>TRUE</code>. <code>LNNVL</code> can be used anywhere a scalar expression can appear, even in contexts where the <code>IS</code> [<code>NOT</code>] <code>NULL</code>, <code>AND</code>, or <code>OR</code> conditions are not valid but would otherwise be required to account for potential nulls. Oracle Database sometimes uses the <code>LNNVL</code> function internally in this way to rewrite <code>NOT</code> <code>IN</code> conditions as <code>NOT</code> <code>EXISTS</code> conditions. In such cases, output from <code>EXPLAIN</code> <code>PLAN</code> shows this operation in the plan table output. The <code>condition</code> can evaluate any scalar values but cannot be a compound condition containing <code>AND</code>, <code>OR</code>, or <code>BETWEEN</code>. The table that follows shows what <code>LNNVL</code> returns given that <code>a</code> = 2 and <code>b</code> is null. <table> <thead> <tr> <th>Condition</th> <th>Truth of Condition</th> <th>LNNVL Return Value</th> </tr> </thead> <tbody> <tr> <td>a = 1</td> <td>FALSE</td> <td>TRUE</td> </tr> <tr> <td>a = 2</td> <td>TRUE</td> <td>FALSE</td> </tr> <tr> <td>a IS NULL</td> <td>FALSE</td> <td>TRUE</td> </tr> <tr> <td>b = 1</td> <td>UNKNOWN</td> <td>TRUE</td> </tr> <tr> <td>b IS NULL</td> <td>TRUE</td> <td>FALSE</td> </tr> <tr> <td>a = b</td> <td>UNKNOWN</td> <td>TRUE</td> </tr> </tbody> </table> \n The Examples is: \n Suppose that you want to know the number of employees with commission rates of less than 20%, including employees who do not receive commissions. The following query returns only employees who actually receive a commission of less than 20%: <code>SELECT COUNT(*) FROM employees WHERE commission_pct < .2; COUNT(*) ---------- 11 </code> To include the 72 employees who receive no commission at all, you could rewrite the query using the <code>LNNVL</code> function as follows: <code>SELECT COUNT(*) FROM employees WHERE LNNVL(commission_pct >= .2); COUNT(*) ---------- 83 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions091.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PRESENTV",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PRESENTV))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PRESENTV(cell_reference, expr1, expr2) </eps> \n The Purpose is: \n The <code>PRESENTV</code> function can be used only within the <code>model_clause</code> of the <code>SELECT</code> statement and then only on the right-hand side of a model rule. It returns <code>expr1</code> when, prior to the execution of the <code>model_clause</code>, <code>cell_reference</code> exists. Otherwise it returns <code>expr2</code>. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics \n The Examples is: \n In the following example, if a row containing sales for the Mouse Pad for the year 2000 exists, then the sales value for the Mouse Pad for the year 2001 is set to the sales value for the Mouse Pad for the year 2000. If the row does not exist, then a row is created with the sales value for the Mouse Pad for year 20001 set to 0. <code>SELECT country, prod, year, s FROM sales_view_ref MODEL PARTITION BY (country) DIMENSION BY (prod, year) MEASURES (sale s) IGNORE NAV UNIQUE DIMENSION RULES UPSERT SEQUENTIAL ORDER ( s['Mouse Pad', 2001] = PRESENTV(s['Mouse Pad', 2000], s['Mouse Pad', 2000], 0) ) ORDER BY country, prod, year; COUNTRY PROD YEAR S ---------- ----------------------------------- -------- --------- France Mouse Pad 1998 2509.42 France Mouse Pad 1999 3678.69 France Mouse Pad 2000 3000.72 France Mouse Pad 2001 3000.72 France Standard Mouse 1998 2390.83 France Standard Mouse 1999 2280.45 France Standard Mouse 2000 1274.31 France Standard Mouse 2001 2164.54 Germany Mouse Pad 1998 5827.87 Germany Mouse Pad 1999 8346.44 Germany Mouse Pad 2000 7375.46 Germany Mouse Pad 2001 7375.46 Germany Standard Mouse 1998 7116.11 Germany Standard Mouse 1999 6263.14 Germany Standard Mouse 2000 2637.31 Germany Standard Mouse 2001 6456.13 16 rows selected. </code> The preceding example requires the view <code>sales_view_ref</code>. Refer to <link>\"The MODEL clause: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2171160</link> to create this view. ",
        "detail": "The Syntax is: \n <eps> PRESENTV(cell_reference, expr1, expr2) </eps> \n The Purpose is: \n The <code>PRESENTV</code> function can be used only within the <code>model_clause</code> of the <code>SELECT</code> statement and then only on the right-hand side of a model rule. It returns <code>expr1</code> when, prior to the execution of the <code>model_clause</code>, <code>cell_reference</code> exists. Otherwise it returns <code>expr2</code>. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics \n The Examples is: \n In the following example, if a row containing sales for the Mouse Pad for the year 2000 exists, then the sales value for the Mouse Pad for the year 2001 is set to the sales value for the Mouse Pad for the year 2000. If the row does not exist, then a row is created with the sales value for the Mouse Pad for year 20001 set to 0. <code>SELECT country, prod, year, s FROM sales_view_ref MODEL PARTITION BY (country) DIMENSION BY (prod, year) MEASURES (sale s) IGNORE NAV UNIQUE DIMENSION RULES UPSERT SEQUENTIAL ORDER ( s['Mouse Pad', 2001] = PRESENTV(s['Mouse Pad', 2000], s['Mouse Pad', 2000], 0) ) ORDER BY country, prod, year; COUNTRY PROD YEAR S ---------- ----------------------------------- -------- --------- France Mouse Pad 1998 2509.42 France Mouse Pad 1999 3678.69 France Mouse Pad 2000 3000.72 France Mouse Pad 2001 3000.72 France Standard Mouse 1998 2390.83 France Standard Mouse 1999 2280.45 France Standard Mouse 2000 1274.31 France Standard Mouse 2001 2164.54 Germany Mouse Pad 1998 5827.87 Germany Mouse Pad 1999 8346.44 Germany Mouse Pad 2000 7375.46 Germany Mouse Pad 2001 7375.46 Germany Standard Mouse 1998 7116.11 Germany Standard Mouse 1999 6263.14 Germany Standard Mouse 2000 2637.31 Germany Standard Mouse 2001 6456.13 16 rows selected. </code> The preceding example requires the view <code>sales_view_ref</code>. Refer to <link>\"The MODEL clause: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2171160</link> to create this view. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions139.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "POWERMULTISET_BY_CARDINALITY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c POWERMULTISET_BY_CARDINALITY))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> POWERMULTISET_BY_CARDINALITY(expr, cardinality) </eps> \n The Purpose is: \n <code>POWERMULTISET_BY_CARDINALITY</code> takes as input a nested table and a cardinality and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the nested table of the specified cardinality. <code>expr</code> can be any expression that evaluates to a nested table. <code>cardinality</code> can be any positive integer. If <code>expr</code> resolves to null, then Oracle Database returns <code>NULL</code>. If <code>expr</code> resolves to a nested table that is empty, then Oracle returns an error. The element types of the nested table must be comparable. Refer to <link>\"Comparison Conditions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions002.htm#i1033286</link> for information on the comparability of nonscalar types. Note: This function is not supported in PL/SQL. \n The Examples is: \n First, create a data type that is a nested table of the <code>cust_address_tab_type</code> data type: <code>CREATE TYPE cust_address_tab_tab_typ AS TABLE OF cust_address_tab_typ; / </code> Next, duplicate the elements in all the nested table rows to increase the cardinality of the nested table rows to 2: <code>UPDATE customers_demo SET cust_address_ntab = cust_address_ntab MULTISET UNION cust_address_ntab; </code> Now, select the nested table column <code>cust_address_ntab</code> from the <code>customers_demo</code> table using the <code>POWERMULTISET_BY_CARDINALITY</code> function: <code>SELECT CAST(POWERMULTISET_BY_CARDINALITY(cust_address_ntab, 2) AS cust_address_tab_tab_typ) FROM customers_demo; CAST(POWERMULTISET_BY_CARDINALITY(CUST_ADDRESS_NTAB,2) AS CUST_ADDRESS_TAB_TAB_TYP) (STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID) ---------------------------------------------------------------------------------------- CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP (CUST_ADDRESS_TYP('514 W Superior St', '46901', 'Kokomo', 'IN', 'US'), CUST_ADDRESS_TYP('514 W Superior St', '46901', 'Kokomo', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP (CUST_ADDRESS_TYP('2515 Bloyd Ave', '46218', 'Indianapolis', 'IN', 'US'), CUST_ADDRESS_TYP('2515 Bloyd Ave', '46218', 'Indianapolis', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP (CUST_ADDRESS_TYP('8768 N State Rd 37', '47404', 'Bloomington', 'IN', 'US'), CUST_ADDRESS_TYP('8768 N State Rd 37', '47404', 'Bloomington', 'IN', 'US'))) . . . </code> The preceding example requires the <code>customers_demo</code> table and a nested table column containing data. Refer to <link>\"Multiset Operators\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/operators006.htm#i1035617</link> to create this table and nested table columns. ",
        "detail": "The Syntax is: \n <eps> POWERMULTISET_BY_CARDINALITY(expr, cardinality) </eps> \n The Purpose is: \n <code>POWERMULTISET_BY_CARDINALITY</code> takes as input a nested table and a cardinality and returns a nested table of nested tables containing all nonempty subsets (called submultisets) of the nested table of the specified cardinality. <code>expr</code> can be any expression that evaluates to a nested table. <code>cardinality</code> can be any positive integer. If <code>expr</code> resolves to null, then Oracle Database returns <code>NULL</code>. If <code>expr</code> resolves to a nested table that is empty, then Oracle returns an error. The element types of the nested table must be comparable. Refer to <link>\"Comparison Conditions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions002.htm#i1033286</link> for information on the comparability of nonscalar types. Note: This function is not supported in PL/SQL. \n The Examples is: \n First, create a data type that is a nested table of the <code>cust_address_tab_type</code> data type: <code>CREATE TYPE cust_address_tab_tab_typ AS TABLE OF cust_address_tab_typ; / </code> Next, duplicate the elements in all the nested table rows to increase the cardinality of the nested table rows to 2: <code>UPDATE customers_demo SET cust_address_ntab = cust_address_ntab MULTISET UNION cust_address_ntab; </code> Now, select the nested table column <code>cust_address_ntab</code> from the <code>customers_demo</code> table using the <code>POWERMULTISET_BY_CARDINALITY</code> function: <code>SELECT CAST(POWERMULTISET_BY_CARDINALITY(cust_address_ntab, 2) AS cust_address_tab_tab_typ) FROM customers_demo; CAST(POWERMULTISET_BY_CARDINALITY(CUST_ADDRESS_NTAB,2) AS CUST_ADDRESS_TAB_TAB_TYP) (STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID) ---------------------------------------------------------------------------------------- CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP (CUST_ADDRESS_TYP('514 W Superior St', '46901', 'Kokomo', 'IN', 'US'), CUST_ADDRESS_TYP('514 W Superior St', '46901', 'Kokomo', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP (CUST_ADDRESS_TYP('2515 Bloyd Ave', '46218', 'Indianapolis', 'IN', 'US'), CUST_ADDRESS_TYP('2515 Bloyd Ave', '46218', 'Indianapolis', 'IN', 'US'))) CUST_ADDRESS_TAB_TAB_TYP(CUST_ADDRESS_TAB_TYP (CUST_ADDRESS_TYP('8768 N State Rd 37', '47404', 'Bloomington', 'IN', 'US'), CUST_ADDRESS_TYP('8768 N State Rd 37', '47404', 'Bloomington', 'IN', 'US'))) . . . </code> The preceding example requires the <code>customers_demo</code> table and a nested table column containing data. Refer to <link>\"Multiset Operators\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/operators006.htm#i1035617</link> to create this table and nested table columns. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions131.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ORA_DST_AFFECTED",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ORA_DST_AFFECTED))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ORA_DST_AFFECTED(datetime_expr) </eps> \n The Purpose is: \n <code>ORA_DST_AFFECTED</code> is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value or a <code>VARRAY</code> object that contains <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values. The function returns <code>1</code> if the datetime value is affected by or will result in a \"nonexisting time\" or \"duplicate time\" error with the new time zone data. Otherwise, it returns 0. This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the <code>DBMS_DST</code>.<code>BEGIN_PREPARE</code> and the <code>DBMS_DST</code>.<code>END_PREPARE</code> procedures or between the execution of the <code>DBMS_DST</code>.<code>BEGIN_UPGRADE</code> and the <code>DBMS_DST</code>.<code>END_UPGRADE</code> procedures. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm#NLSPG259</link> for more information on time zone datafiles and on how Oracle Database handles daylight saving time, and <link>Oracle Database PL/SQL Packages and Types Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_dst.htm#ARPLS234</link> for information on the <code>DBMS_DST</code> package ",
        "detail": "The Syntax is: \n <eps> ORA_DST_AFFECTED(datetime_expr) </eps> \n The Purpose is: \n <code>ORA_DST_AFFECTED</code> is useful when you are changing the time zone data file for your database. The function takes as an argument a datetime expression that resolves to a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value or a <code>VARRAY</code> object that contains <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values. The function returns <code>1</code> if the datetime value is affected by or will result in a \"nonexisting time\" or \"duplicate time\" error with the new time zone data. Otherwise, it returns 0. This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the <code>DBMS_DST</code>.<code>BEGIN_PREPARE</code> and the <code>DBMS_DST</code>.<code>END_PREPARE</code> procedures or between the execution of the <code>DBMS_DST</code>.<code>BEGIN_UPGRADE</code> and the <code>DBMS_DST</code>.<code>END_UPGRADE</code> procedures. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm#NLSPG259</link> for more information on time zone datafiles and on how Oracle Database handles daylight saving time, and <link>Oracle Database PL/SQL Packages and Types Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_dst.htm#ARPLS234</link> for information on the <code>DBMS_DST</code> package ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions121.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CUBE_TABLE",
        "tree": "(general_element_part (id_expression (regular_id CUBE_TABLE)) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CUBE_TABLE ( ' { schema.cube [ {HIERARCHY | HRR} dimension hierarchy ]... | schema.dimension [ {HIERARCHY | HRR} [dimension] hierarchy ] } ' ) </eps> \n The Purpose is: \n <code>CUBE_TABLE</code> extracts data from a cube or dimension and returns it in the two-dimensional format of a relational table, which can be used by SQL-based applications. The function takes a single <code>VARCHAR2</code> argument. The optional hierarchy clause enables you to specify a dimension hierarchy. A cube can have multiple hierarchy clauses, one for each dimension. You can generate these different types of tables: A cube table contains a key column for each dimension and a column for each measure and calculated measure in the cube. To create a cube table, you can specify the cube with or without a cube hierarchy clause. For a dimension with multiple hierarchies, this clause limits the return values to the dimension members and levels in the specified hierarchy. Without a hierarchy clause, all dimension members and all levels are included. A dimension table contains a key column, and a column for each level and each attribute. It also contains a <code>MEMBER_TYPE</code> column, which identifies each member with one of the following codes: <code>L</code> - Loaded from a table, view, or synonym <code>A</code> - Loaded member and the single root of all hierarchies in the dimension, that is, the \"all\" aggregate member <code>C</code> - Calculated member All dimension members and all levels are included in the table. To create a dimension table, specify the dimension without a dimension hierarchy clause. A hierarchy table contains all the columns of a dimension table plus a column for the parent member and a column for each source level. It also contains a <code>MEMBER_TYPE</code> column, as described for dimension tables. Any dimension members and levels that are not part of the named hierarchy are excluded from the table. To create a hierarchy table, specify the dimension with a dimension hierarchy clause. <code>CUBE_TABLE</code> is a table function and is always used in the context of a <code>SELECT</code> statement with this syntax: <code>SELECT ... FROM TABLE(CUBE_TABLE('arg')); </code> See Also: <link>Oracle OLAP User's Guide&LINK&https://docs.oracle.com/cd/E11882_01/olap.112/e17123/query.htm#OLAUG400</link> for information about dimensional objects and about the tables generated by <code>CUBE_TABLE</code>. \n The Examples is: \n The following examples require Oracle Database with the OLAP option and the <code>GLOBAL</code> sample schema. Refer to <link>Oracle OLAP User's Guide&LINK&https://docs.oracle.com/cd/E11882_01/olap.112/e17123/start.htm#OLAUG9117</link> for information on downloading and installing the <code>GLOBAL</code> sample schema. The following <code>SELECT</code> statement generates a dimension table of <code>CHANNEL</code> in the <code>GLOBAL</code> schema. <code>SELECT dim_key, level_name, long_description, channel_total_id tot_id, channel_channel_id chan_id, channel_long_description chan_desc, total_long_description tot_desc FROM TABLE(CUBE_TABLE('global.channel')); DIM_KEY LEVEL_NAME LONG_DESCRIPTION TOT_ID CHAN_ID CHAN_DESC TOT_DESC ----------- ---------- ---------------- ------ ------- ------------ ------------- CHANNEL_CAT CHANNEL Catalog TOTAL CAT Catalog Total Channel CHANNEL_DIR CHANNEL Direct Sales TOTAL DIR Direct Sales Total Channel CHANNEL_INT CHANNEL Internet TOTAL INT Internet Total Channel TOTAL_TOTAL TOTAL Total Channel TOTAL Total Channel </code> The next statement generates a cube table of <code>UNITS_CUBE</code>. It restricts the table to the <code>MARKET</code> and <code>CALENDAR</code> hierarchies. <code>SELECT sales, units, cost, time, customer, product, channel FROM TABLE(CUBE_TABLE('global.units_cube HIERARCHY customer market HIERARCHY time calendar')) WHERE rownum < 20; SALES UNITS COST TIME CUSTOMER PRODUCT CHANNEL ---------- ---------- ---------- -------------------------- -------------- ----------- ----------- 24538587.9 61109 22840853.7 CALENDAR_QUARTER_CY1998.Q1 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL 24993273.3 61320 23147171 CALENDAR_QUARTER_CY1998.Q2 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL 25080541.4 65265 23242535.4 CALENDAR_QUARTER_CY1998.Q3 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL 26258474 66122 24391020.6 CALENDAR_QUARTER_CY1998.Q4 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL 32785170 77589 30607218.1 CALENDAR_QUARTER_CY1999.Q1 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL . . . </code> ",
        "detail": "The Syntax is: \n <eps> CUBE_TABLE ( ' { schema.cube [ {HIERARCHY | HRR} dimension hierarchy ]... | schema.dimension [ {HIERARCHY | HRR} [dimension] hierarchy ] } ' ) </eps> \n The Purpose is: \n <code>CUBE_TABLE</code> extracts data from a cube or dimension and returns it in the two-dimensional format of a relational table, which can be used by SQL-based applications. The function takes a single <code>VARCHAR2</code> argument. The optional hierarchy clause enables you to specify a dimension hierarchy. A cube can have multiple hierarchy clauses, one for each dimension. You can generate these different types of tables: A cube table contains a key column for each dimension and a column for each measure and calculated measure in the cube. To create a cube table, you can specify the cube with or without a cube hierarchy clause. For a dimension with multiple hierarchies, this clause limits the return values to the dimension members and levels in the specified hierarchy. Without a hierarchy clause, all dimension members and all levels are included. A dimension table contains a key column, and a column for each level and each attribute. It also contains a <code>MEMBER_TYPE</code> column, which identifies each member with one of the following codes: <code>L</code> - Loaded from a table, view, or synonym <code>A</code> - Loaded member and the single root of all hierarchies in the dimension, that is, the \"all\" aggregate member <code>C</code> - Calculated member All dimension members and all levels are included in the table. To create a dimension table, specify the dimension without a dimension hierarchy clause. A hierarchy table contains all the columns of a dimension table plus a column for the parent member and a column for each source level. It also contains a <code>MEMBER_TYPE</code> column, as described for dimension tables. Any dimension members and levels that are not part of the named hierarchy are excluded from the table. To create a hierarchy table, specify the dimension with a dimension hierarchy clause. <code>CUBE_TABLE</code> is a table function and is always used in the context of a <code>SELECT</code> statement with this syntax: <code>SELECT ... FROM TABLE(CUBE_TABLE('arg')); </code> See Also: <link>Oracle OLAP User's Guide&LINK&https://docs.oracle.com/cd/E11882_01/olap.112/e17123/query.htm#OLAUG400</link> for information about dimensional objects and about the tables generated by <code>CUBE_TABLE</code>. \n The Examples is: \n The following examples require Oracle Database with the OLAP option and the <code>GLOBAL</code> sample schema. Refer to <link>Oracle OLAP User's Guide&LINK&https://docs.oracle.com/cd/E11882_01/olap.112/e17123/start.htm#OLAUG9117</link> for information on downloading and installing the <code>GLOBAL</code> sample schema. The following <code>SELECT</code> statement generates a dimension table of <code>CHANNEL</code> in the <code>GLOBAL</code> schema. <code>SELECT dim_key, level_name, long_description, channel_total_id tot_id, channel_channel_id chan_id, channel_long_description chan_desc, total_long_description tot_desc FROM TABLE(CUBE_TABLE('global.channel')); DIM_KEY LEVEL_NAME LONG_DESCRIPTION TOT_ID CHAN_ID CHAN_DESC TOT_DESC ----------- ---------- ---------------- ------ ------- ------------ ------------- CHANNEL_CAT CHANNEL Catalog TOTAL CAT Catalog Total Channel CHANNEL_DIR CHANNEL Direct Sales TOTAL DIR Direct Sales Total Channel CHANNEL_INT CHANNEL Internet TOTAL INT Internet Total Channel TOTAL_TOTAL TOTAL Total Channel TOTAL Total Channel </code> The next statement generates a cube table of <code>UNITS_CUBE</code>. It restricts the table to the <code>MARKET</code> and <code>CALENDAR</code> hierarchies. <code>SELECT sales, units, cost, time, customer, product, channel FROM TABLE(CUBE_TABLE('global.units_cube HIERARCHY customer market HIERARCHY time calendar')) WHERE rownum < 20; SALES UNITS COST TIME CUSTOMER PRODUCT CHANNEL ---------- ---------- ---------- -------------------------- -------------- ----------- ----------- 24538587.9 61109 22840853.7 CALENDAR_QUARTER_CY1998.Q1 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL 24993273.3 61320 23147171 CALENDAR_QUARTER_CY1998.Q2 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL 25080541.4 65265 23242535.4 CALENDAR_QUARTER_CY1998.Q3 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL 26258474 66122 24391020.6 CALENDAR_QUARTER_CY1998.Q4 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL 32785170 77589 30607218.1 CALENDAR_QUARTER_CY1999.Q1 TOTAL_TOTAL TOTAL_TOTAL TOTAL_TOTAL . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions042.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLPI",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLPI))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLPI ( { [ NAME ] identifier | EVALNAME value_expr } [, value_expr ] ) </eps> \n The Purpose is: \n <code>XMLPI</code> generates an XML processing instruction using <code>identifier</code> and optionally the evaluated result of <code>value_expr</code>. A processing instruction is commonly used to provide to an application information that is associated with all or part of an XML document. The application uses the processing instruction to determine how best to process the XML document. You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying <code>identifier</code>, which is a string literal, or by specifying <code>EVALNAME</code> <code>value_expr</code>. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier can be up to 4000 characters and does not have to be a column name or column reference. It cannot be an expression or null. The optional <code>value_expr</code> must resolve to a string. If you omit the optional <code>value_expr</code>, then a zero-length string is the default. The value returned by the function takes this form: <code><?identifier string?> </code> <code>XMLPI</code> is subject to the following restrictions: The <code>identifier</code> must be a valid target for a processing instruction. You cannot specify <code>xml</code> in any case combination for <code>identifier</code>. The <code>identifier</code> cannot contain the consecutive characters <code>?></code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following statement uses the <code>DUAL</code> table to illustrate the use of the <code>XMLPI</code> syntax: <code>SELECT XMLPI(NAME \"Order analysisComp\", 'imported, reconfigured, disassembled') AS \"XMLPI\" FROM DUAL; XMLPI -------------------------------------------------------------------------------- <?Order analysisComp imported, reconfigured, disassembled?> </code> ",
        "detail": "The Syntax is: \n <eps> XMLPI ( { [ NAME ] identifier | EVALNAME value_expr } [, value_expr ] ) </eps> \n The Purpose is: \n <code>XMLPI</code> generates an XML processing instruction using <code>identifier</code> and optionally the evaluated result of <code>value_expr</code>. A processing instruction is commonly used to provide to an application information that is associated with all or part of an XML document. The application uses the processing instruction to determine how best to process the XML document. You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying <code>identifier</code>, which is a string literal, or by specifying <code>EVALNAME</code> <code>value_expr</code>. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier can be up to 4000 characters and does not have to be a column name or column reference. It cannot be an expression or null. The optional <code>value_expr</code> must resolve to a string. If you omit the optional <code>value_expr</code>, then a zero-length string is the default. The value returned by the function takes this form: <code><?identifier string?> </code> <code>XMLPI</code> is subject to the following restrictions: The <code>identifier</code> must be a valid target for a processing instruction. You cannot specify <code>xml</code> in any case combination for <code>identifier</code>. The <code>identifier</code> cannot contain the consecutive characters <code>?></code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following statement uses the <code>DUAL</code> table to illustrate the use of the <code>XMLPI</code> syntax: <code>SELECT XMLPI(NAME \"Order analysisComp\", 'imported, reconfigured, disassembled') AS \"XMLPI\" FROM DUAL; XMLPI -------------------------------------------------------------------------------- <?Order analysisComp imported, reconfigured, disassembled?> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions248.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ATAN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ATAN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ATAN(n) </eps> \n The Purpose is: \n <code>ATAN</code> returns the arc tangent of <code>n</code>. The argument <code>n</code> can be in an unbounded range and returns a value in the range of -pi/2 to pi/2, expressed in radians. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>ATAN2&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions017.htm#i76816</link> for information about the <code>ATAN2</code> function and <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the arc tangent of .3: <code>SELECT ATAN(.3) \"Arc_Tangent\" FROM DUAL; Arc_Tangent ---------- .291456794 </code> ",
        "detail": "The Syntax is: \n <eps> ATAN(n) </eps> \n The Purpose is: \n <code>ATAN</code> returns the arc tangent of <code>n</code>. The argument <code>n</code> can be in an unbounded range and returns a value in the range of -pi/2 to pi/2, expressed in radians. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>ATAN2&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions017.htm#i76816</link> for information about the <code>ATAN2</code> function and <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the arc tangent of .3: <code>SELECT ATAN(.3) \"Arc_Tangent\" FROM DUAL; Arc_Tangent ---------- .291456794 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions016.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLROOT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLROOT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLROOT ( value_expr, VERSION { value_expr | NO VALUE } [, STANDALONE { YES | NO | NO VALUE } ] ) </eps> \n The Purpose is: \n <code>XMLROOT</code> lets you create a new XML value by providing version and standalone properties in the XML root information (prolog) of an existing XML value. If the <code>value_expr</code> already has a prolog, then the database returns an error. If the input is null, then the function returns null. The value returned takes the following form: <code><?xml version = \"version\" [ STANDALONE = \"{yes | no}\" ]?> </code> The first <code>value_expr</code> specifies the XML value for which you are providing prolog information. In the <code>VERSION</code> clause, <code>value_expr</code> must resolve to a string representing a valid XML version. If you specify <code>NO</code> <code>VALUE</code> for <code>VERSION</code>, then the version defaults to 1.0. If you omit the optional <code>STANDALONE</code> clause, or if you specify it with <code>NO</code> <code>VALUE</code>, then the standalone property is absent from the value returned by the function. \n The Examples is: \n The following statement uses the <code>DUAL</code> table to illustrate the syntax of <code>XMLROOT</code>: <code>SELECT XMLROOT ( XMLType('<poid>143598</poid>'), VERSION '1.0', STANDALONE YES) AS \"XMLROOT\" FROM DUAL; XMLROOT -------------------------------------------------------------------------------- <?xml version=\"1.0\" standalone=\"yes\"?> <poid>143598</poid> </code> ",
        "detail": "The Syntax is: \n <eps> XMLROOT ( value_expr, VERSION { value_expr | NO VALUE } [, STANDALONE { YES | NO | NO VALUE } ] ) </eps> \n The Purpose is: \n <code>XMLROOT</code> lets you create a new XML value by providing version and standalone properties in the XML root information (prolog) of an existing XML value. If the <code>value_expr</code> already has a prolog, then the database returns an error. If the input is null, then the function returns null. The value returned takes the following form: <code><?xml version = \"version\" [ STANDALONE = \"{yes | no}\" ]?> </code> The first <code>value_expr</code> specifies the XML value for which you are providing prolog information. In the <code>VERSION</code> clause, <code>value_expr</code> must resolve to a string representing a valid XML version. If you specify <code>NO</code> <code>VALUE</code> for <code>VERSION</code>, then the version defaults to 1.0. If you omit the optional <code>STANDALONE</code> clause, or if you specify it with <code>NO</code> <code>VALUE</code>, then the standalone property is absent from the value returned by the function. \n The Examples is: \n The following statement uses the <code>DUAL</code> table to illustrate the syntax of <code>XMLROOT</code>: <code>SELECT XMLROOT ( XMLType('<poid>143598</poid>'), VERSION '1.0', STANDALONE YES) AS \"XMLROOT\" FROM DUAL; XMLROOT -------------------------------------------------------------------------------- <?xml version=\"1.0\" standalone=\"yes\"?> <poid>143598</poid> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions250.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_SINGLE_BYTE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_SINGLE_BYTE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_SINGLE_BYTE(char) </eps> \n The Purpose is: \n <code>TO_SINGLE_BYTE</code> returns <code>char</code> with all of its multibyte characters converted to their corresponding single-byte characters. <code>char</code> can be of data type <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The value returned is in the same data type as <code>char</code>. Any multibyte characters in <code>char</code> that have no single-byte equivalents appear in the output as multibyte characters. This function is useful only if your database character set contains both single-byte and multibyte characters. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example illustrates going from a multibyte <code>A</code> in UTF8 to a single byte ASCII <code>A</code>: <code>SELECT TO_SINGLE_BYTE( CHR(15711393)) FROM DUAL; T - A </code> ",
        "detail": "The Syntax is: \n <eps> TO_SINGLE_BYTE(char) </eps> \n The Purpose is: \n <code>TO_SINGLE_BYTE</code> returns <code>char</code> with all of its multibyte characters converted to their corresponding single-byte characters. <code>char</code> can be of data type <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The value returned is in the same data type as <code>char</code>. Any multibyte characters in <code>char</code> that have no single-byte equivalents appear in the output as multibyte characters. This function is useful only if your database character set contains both single-byte and multibyte characters. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example illustrates going from a multibyte <code>A</code> in UTF8 to a single byte ASCII <code>A</code>: <code>SELECT TO_SINGLE_BYTE( CHR(15711393)) FROM DUAL; T - A </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions212.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SIN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SIN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SIN(n) </eps> \n The Purpose is: \n <code>SIN</code> returns the sine of <code>n</code> (an angle expressed in radians). This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the sine of 30 degrees: <code>SELECT SIN(30 * 3.14159265359/180) \"Sine of 30 degrees\" FROM DUAL; Sine of 30 degrees ------------------ .5 </code> ",
        "detail": "The Syntax is: \n <eps> SIN(n) </eps> \n The Purpose is: \n <code>SIN</code> returns the sine of <code>n</code> (an angle expressed in radians). This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the sine of 30 degrees: <code>SELECT SIN(30 * 3.14159265359/180) \"Sine of 30 degrees\" FROM DUAL; Sine of 30 degrees ------------------ .5 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions165.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYS_EXTRACT_UTC",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYS_EXTRACT_UTC))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYS_EXTRACT_UTC(datetime_with_timezone) </eps> \n The Purpose is: \n <code>SYS_EXTRACT_UTC</code> extracts the UTC (Coordinated Universal Time\u2014formerly Greenwich Mean Time) from a datetime value with time zone offset or time zone region name. If a time zone is not specified, then the datetime is associated with the session time zone. \n The Examples is: \n The following example extracts the UTC from a specified datetime: <code>SELECT SYS_EXTRACT_UTC(TIMESTAMP '2000-03-28 11:30:00.00 -08:00') FROM DUAL; SYS_EXTRACT_UTC(TIMESTAMP'2000-03-2811:30:00.00-08:00') ----------------------------------------------------------------- 28-MAR-00 07.30.00 PM </code> ",
        "detail": "The Syntax is: \n <eps> SYS_EXTRACT_UTC(datetime_with_timezone) </eps> \n The Purpose is: \n <code>SYS_EXTRACT_UTC</code> extracts the UTC (Coordinated Universal Time\u2014formerly Greenwich Mean Time) from a datetime value with time zone offset or time zone region name. If a time zone is not specified, then the datetime is associated with the session time zone. \n The Examples is: \n The following example extracts the UTC from a specified datetime: <code>SELECT SYS_EXTRACT_UTC(TIMESTAMP '2000-03-28 11:30:00.00 -08:00') FROM DUAL; SYS_EXTRACT_UTC(TIMESTAMP'2000-03-2811:30:00.00-08:00') ----------------------------------------------------------------- 28-MAR-00 07.30.00 PM </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions186.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLCONCAT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLCONCAT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLCONCAT(XMLType_instance [, XMLType_instance ]...) </eps> \n The Purpose is: \n <code>XMLConcat</code> takes as input a series of <code>XMLType</code> instances, concatenates the series of elements for each row, and returns the concatenated series. <code>XMLConcat</code> is the inverse of <code>XMLSequence</code>. Null expressions are dropped from the result. If all the value expressions are null, then the function returns null. See Also: <link>XMLSEQUENCE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions251.htm#i1129570</link> \n The Examples is: \n The following example creates XML elements for the first and last names of a subset of employees, and then concatenates and returns those elements: <code>SELECT XMLCONCAT(XMLELEMENT(\"First\", e.first_name), XMLELEMENT(\"Last\", e.last_name)) AS \"Result\" FROM employees e WHERE e.employee_id > 202; Result ---------------------------------------------------------------- <First>Susan</First> <Last>Mavris</Last> <First>Hermann</First> <Last>Baer</Last> <First>Shelley</First> <Last>Higgins</Last> <First>William</First> <Last>Gietz</Last> 4 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> XMLCONCAT(XMLType_instance [, XMLType_instance ]...) </eps> \n The Purpose is: \n <code>XMLConcat</code> takes as input a series of <code>XMLType</code> instances, concatenates the series of elements for each row, and returns the concatenated series. <code>XMLConcat</code> is the inverse of <code>XMLSequence</code>. Null expressions are dropped from the result. If all the value expressions are null, then the function returns null. See Also: <link>XMLSEQUENCE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions251.htm#i1129570</link> \n The Examples is: \n The following example creates XML elements for the first and last names of a subset of employees, and then concatenates and returns those elements: <code>SELECT XMLCONCAT(XMLELEMENT(\"First\", e.first_name), XMLELEMENT(\"Last\", e.last_name)) AS \"Result\" FROM employees e WHERE e.employee_id > 202; Result ---------------------------------------------------------------- <First>Susan</First> <Last>Mavris</Last> <First>Hermann</First> <Last>Baer</Last> <First>Shelley</First> <Last>Higgins</Last> <First>William</First> <Last>Gietz</Last> 4 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions240.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DECODE",
        "tree": "(string_function DECODE ( ))",
        "description": "The Syntax is: \n <eps> DECODE(expr, search, result [, search, result ]... [, default ]) </eps> \n The Purpose is: \n <code>DECODE</code> compares <code>expr</code> to each <code>search</code> value one by one. If <code>expr</code> is equal to a <code>search</code>, then Oracle Database returns the corresponding <code>result</code>. If no match is found, then Oracle returns <code>default</code>. If <code>default</code> is omitted, then Oracle returns null. The arguments can be any of the numeric types (<code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>) or character types. If <code>expr</code> and <code>search</code> are character data, then Oracle compares them using nonpadded comparison semantics. <code>expr</code>, <code>search</code>, and <code>result</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The string returned is of <code>VARCHAR2</code> data type and is in the same character set as the first <code>result</code> parameter. If the first <code>search-result</code> pair are numeric, then Oracle compares all <code>search-result</code> expressions and the first <code>expr</code> to determine the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. The <code>search</code>, <code>result</code>, and <code>default</code> values can be derived from expressions. Oracle Database uses short-circuit evaluation. The database evaluates each <code>search</code> value only before comparing it to <code>expr</code>, rather than evaluating all <code>search</code> values before comparing any of them with <code>expr</code>. Consequently, Oracle never evaluates a <code>search</code> if a previous <code>search</code> is equal to <code>expr</code>. Oracle automatically converts <code>expr</code> and each <code>search</code> value to the data type of the first <code>search</code> value before comparing. Oracle automatically converts the return value to the same data type as the first <code>result</code>. If the first <code>result</code> has the data type <code>CHAR</code> or if the first <code>result</code> is null, then Oracle converts the return value to the data type <code>VARCHAR2</code>. In a <code>DECODE</code> function, Oracle considers two nulls to be equivalent. If <code>expr</code> is null, then Oracle returns the <code>result</code> of the first <code>search</code> that is also null. The maximum number of components in the <code>DECODE</code> function, including <code>expr</code>, <code>searches</code>, <code>results</code>, and <code>default</code>, is 255. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for information on comparison semantics <link>\"Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i46862</link> for information on data type conversion in general <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on floating-point comparison semantics <link>\"Implicit and Explicit Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i53062</link> for information on the drawbacks of implicit conversion <link>\"COALESCE\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions030.htm#i1001341</link> and <link>\"CASE Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm#i1033392</link>, which provide functionality similar to that of <code>DECODE</code> \n The Examples is: \n This example decodes the value <code>warehouse_id</code>. If <code>warehouse_id</code> is 1, then the function returns '<code>Southlake</code>'; if <code>warehouse_id</code> is 2, then it returns '<code>San Francisco</code>'; and so forth. If <code>warehouse_id</code> is not 1, 2, 3, or 4, then the function returns '<code>Non domestic</code>'. <code>SELECT product_id, DECODE (warehouse_id, 1, 'Southlake', 2, 'San Francisco', 3, 'New Jersey', 4, 'Seattle', 'Non domestic') \"Location\" FROM inventories WHERE product_id < 1775 ORDER BY product_id, \"Location\"; </code> ",
        "detail": "The Syntax is: \n <eps> DECODE(expr, search, result [, search, result ]... [, default ]) </eps> \n The Purpose is: \n <code>DECODE</code> compares <code>expr</code> to each <code>search</code> value one by one. If <code>expr</code> is equal to a <code>search</code>, then Oracle Database returns the corresponding <code>result</code>. If no match is found, then Oracle returns <code>default</code>. If <code>default</code> is omitted, then Oracle returns null. The arguments can be any of the numeric types (<code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>) or character types. If <code>expr</code> and <code>search</code> are character data, then Oracle compares them using nonpadded comparison semantics. <code>expr</code>, <code>search</code>, and <code>result</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The string returned is of <code>VARCHAR2</code> data type and is in the same character set as the first <code>result</code> parameter. If the first <code>search-result</code> pair are numeric, then Oracle compares all <code>search-result</code> expressions and the first <code>expr</code> to determine the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. The <code>search</code>, <code>result</code>, and <code>default</code> values can be derived from expressions. Oracle Database uses short-circuit evaluation. The database evaluates each <code>search</code> value only before comparing it to <code>expr</code>, rather than evaluating all <code>search</code> values before comparing any of them with <code>expr</code>. Consequently, Oracle never evaluates a <code>search</code> if a previous <code>search</code> is equal to <code>expr</code>. Oracle automatically converts <code>expr</code> and each <code>search</code> value to the data type of the first <code>search</code> value before comparing. Oracle automatically converts the return value to the same data type as the first <code>result</code>. If the first <code>result</code> has the data type <code>CHAR</code> or if the first <code>result</code> is null, then Oracle converts the return value to the data type <code>VARCHAR2</code>. In a <code>DECODE</code> function, Oracle considers two nulls to be equivalent. If <code>expr</code> is null, then Oracle returns the <code>result</code> of the first <code>search</code> that is also null. The maximum number of components in the <code>DECODE</code> function, including <code>expr</code>, <code>searches</code>, <code>results</code>, and <code>default</code>, is 255. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for information on comparison semantics <link>\"Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i46862</link> for information on data type conversion in general <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on floating-point comparison semantics <link>\"Implicit and Explicit Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i53062</link> for information on the drawbacks of implicit conversion <link>\"COALESCE\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions030.htm#i1001341</link> and <link>\"CASE Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm#i1033392</link>, which provide functionality similar to that of <code>DECODE</code> \n The Examples is: \n This example decodes the value <code>warehouse_id</code>. If <code>warehouse_id</code> is 1, then the function returns '<code>Southlake</code>'; if <code>warehouse_id</code> is 2, then it returns '<code>San Francisco</code>'; and so forth. If <code>warehouse_id</code> is not 1, 2, 3, or 4, then the function returns '<code>Non domestic</code>'. <code>SELECT product_id, DECODE (warehouse_id, 1, 'Southlake', 2, 'San Francisco', 3, 'New Jersey', 4, 'Seattle', 'Non domestic') \"Location\" FROM inventories WHERE product_id < 1775 ORDER BY product_id, \"Location\"; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions049.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "IN_Condition",
        "tree": "(general_element_part (id_expression (regular_id IN_Condition)) (function_argument ( )))",
        "description": "An <code>in_condition</code> is a membership condition. It tests a value for membership in a list of values or subquery in_condition::= <eps> { expr [ NOT ] IN ({ expression_list | subquery }) | ( expr [, expr ]... ) [ NOT ] IN ({ expression_list [, expression_list ]... | subquery } ) } </eps> expression_list::= <eps> { expr [, expr ]... | ( [expr [, expr ]] ...) } </eps> If you use the upper form of the <code>in_condition</code> condition (with a single expression to the left of the operator), then you must use the upper form of <code>expression_list</code>. If you use the lower form of this condition (with multiple expressions to the left of the operator), then you must use the lower form of <code>expression_list</code>, and the expressions in each <code>expression_list</code> must match in number and data type the expressions to the left of the operator. You can specify up to 1000 expressions in <code>expression_list</code>. Oracle Database does not always evaluate the expressions in an <code>expression_list</code> in the order in which they appear in the <code>IN</code> list. However, expressions in the select list of a subquery are evaluated in their specified order. See Also: <link>\"Expression Lists\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions015.htm#i1033664</link> <link>Table 7-12&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions013.htm#CJAFFIIG</link> lists the form of <code>IN</code> condition. Table 7-12 IN Condition <table> <thead> <tr> <th>Type of Condition</th> <th>Operation</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td> IN </td> <td> Equal-to-any-member-of test. Equivalent to =ANY. </td> <td> SELECT * FROM employees WHERE job_id IN ('PU_CLERK','SH_CLERK') ORDER BY employee_id; SELECT * FROM employees WHERE salary IN (SELECT salary FROM employees WHERE department_id =30) ORDER BY employee_id; </td> </tr> <tr> <td> NOT IN </td> <td> Equivalent to !=ALL. Evaluates to FALSE if any member of the set is NULL. </td> <td> SELECT * FROM employees WHERE salary NOT IN (SELECT salary FROM employees WHERE department_id = 30) ORDER BY employee_id; SELECT * FROM employees WHERE job_id NOT IN ('PU_CLERK', 'SH_CLERK') ORDER BY employee_id; </td> </tr> </tbody> </table> If any item in the list following a <code>NOT</code> <code>IN</code> operation evaluates to null, then all rows evaluate to <code>FALSE</code> or <code>UNKNOWN</code>, and no rows are returned. For example, the following statement returns the string '<code>True</code>' for each row: <code>SELECT 'True' FROM employees WHERE department_id NOT IN (10, 20); </code> However, the following statement returns no rows: <code>SELECT 'True' FROM employees WHERE department_id NOT IN (10, 20, NULL); </code> The preceding example returns no rows because the <code>WHERE</code> clause condition evaluates to: <code>department_id != 10 AND department_id != 20 AND department_id != null </code> Because the third condition compares <code>department_id</code> with a null, it results in an <code>UNKNOWN</code>, so the entire expression results in <code>FALSE</code> (for rows with <code>department_id</code> equal to 10 or 20). This behavior can easily be overlooked, especially when the <code>NOT</code> <code>IN</code> operator references a subquery. Moreover, if a <code>NOT</code> <code>IN</code> condition references a subquery that returns no rows at all, then all rows will be returned, as shown in the following example: <code>SELECT 'True' FROM employees WHERE department_id NOT IN (SELECT 0 FROM DUAL WHERE 1=2); </code> Restriction on LEVEL in WHERE Clauses In a [<code>NOT</code>] <code>IN</code> condition in a <code>WHERE</code> clause, if the right-hand side of the condition is a subquery, you cannot use <code>LEVEL</code> on the left-hand side of the condition. However, you can specify <code>LEVEL</code> in a subquery of the <code>FROM</code> clause to achieve the same result. For example, the following statement is not valid: <code>SELECT employee_id, last_name FROM employees WHERE (employee_id, LEVEL) IN (SELECT employee_id, 2 FROM employees) START WITH employee_id = 2 CONNECT BY PRIOR employee_id = manager_id; </code> But the following statement is valid because it encapsulates the query containing the <code>LEVEL</code> information in the <code>FROM</code> clause: <code>SELECT v.employee_id, v.last_name, v.lev FROM (SELECT employee_id, last_name, LEVEL lev FROM employees v START WITH employee_id = 100 CONNECT BY PRIOR employee_id = manager_id) v WHERE (v.employee_id, v.lev) IN (SELECT employee_id, 2 FROM employees); </code> ",
        "detail": "An <code>in_condition</code> is a membership condition. It tests a value for membership in a list of values or subquery in_condition::= <eps> { expr [ NOT ] IN ({ expression_list | subquery }) | ( expr [, expr ]... ) [ NOT ] IN ({ expression_list [, expression_list ]... | subquery } ) } </eps> expression_list::= <eps> { expr [, expr ]... | ( [expr [, expr ]] ...) } </eps> If you use the upper form of the <code>in_condition</code> condition (with a single expression to the left of the operator), then you must use the upper form of <code>expression_list</code>. If you use the lower form of this condition (with multiple expressions to the left of the operator), then you must use the lower form of <code>expression_list</code>, and the expressions in each <code>expression_list</code> must match in number and data type the expressions to the left of the operator. You can specify up to 1000 expressions in <code>expression_list</code>. Oracle Database does not always evaluate the expressions in an <code>expression_list</code> in the order in which they appear in the <code>IN</code> list. However, expressions in the select list of a subquery are evaluated in their specified order. See Also: <link>\"Expression Lists\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions015.htm#i1033664</link> <link>Table 7-12&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions013.htm#CJAFFIIG</link> lists the form of <code>IN</code> condition. Table 7-12 IN Condition <table> <thead> <tr> <th>Type of Condition</th> <th>Operation</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td> IN </td> <td> Equal-to-any-member-of test. Equivalent to =ANY. </td> <td> SELECT * FROM employees WHERE job_id IN ('PU_CLERK','SH_CLERK') ORDER BY employee_id; SELECT * FROM employees WHERE salary IN (SELECT salary FROM employees WHERE department_id =30) ORDER BY employee_id; </td> </tr> <tr> <td> NOT IN </td> <td> Equivalent to !=ALL. Evaluates to FALSE if any member of the set is NULL. </td> <td> SELECT * FROM employees WHERE salary NOT IN (SELECT salary FROM employees WHERE department_id = 30) ORDER BY employee_id; SELECT * FROM employees WHERE job_id NOT IN ('PU_CLERK', 'SH_CLERK') ORDER BY employee_id; </td> </tr> </tbody> </table> If any item in the list following a <code>NOT</code> <code>IN</code> operation evaluates to null, then all rows evaluate to <code>FALSE</code> or <code>UNKNOWN</code>, and no rows are returned. For example, the following statement returns the string '<code>True</code>' for each row: <code>SELECT 'True' FROM employees WHERE department_id NOT IN (10, 20); </code> However, the following statement returns no rows: <code>SELECT 'True' FROM employees WHERE department_id NOT IN (10, 20, NULL); </code> The preceding example returns no rows because the <code>WHERE</code> clause condition evaluates to: <code>department_id != 10 AND department_id != 20 AND department_id != null </code> Because the third condition compares <code>department_id</code> with a null, it results in an <code>UNKNOWN</code>, so the entire expression results in <code>FALSE</code> (for rows with <code>department_id</code> equal to 10 or 20). This behavior can easily be overlooked, especially when the <code>NOT</code> <code>IN</code> operator references a subquery. Moreover, if a <code>NOT</code> <code>IN</code> condition references a subquery that returns no rows at all, then all rows will be returned, as shown in the following example: <code>SELECT 'True' FROM employees WHERE department_id NOT IN (SELECT 0 FROM DUAL WHERE 1=2); </code> Restriction on LEVEL in WHERE Clauses In a [<code>NOT</code>] <code>IN</code> condition in a <code>WHERE</code> clause, if the right-hand side of the condition is a subquery, you cannot use <code>LEVEL</code> on the left-hand side of the condition. However, you can specify <code>LEVEL</code> in a subquery of the <code>FROM</code> clause to achieve the same result. For example, the following statement is not valid: <code>SELECT employee_id, last_name FROM employees WHERE (employee_id, LEVEL) IN (SELECT employee_id, 2 FROM employees) START WITH employee_id = 2 CONNECT BY PRIOR employee_id = manager_id; </code> But the following statement is valid because it encapsulates the query containing the <code>LEVEL</code> information in the <code>FROM</code> clause: <code>SELECT v.employee_id, v.last_name, v.lev FROM (SELECT employee_id, last_name, LEVEL lev FROM employees v START WITH employee_id = 100 CONNECT BY PRIOR employee_id = manager_id) v WHERE (v.employee_id, v.lev) IN (SELECT employee_id, 2 FROM employees); </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions013.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_BINOMIAL_TEST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_BINOMIAL_TEST))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STATS_BINOMIAL_TEST(expr1, expr2, p [, { TWO_SIDED_PROB | EXACT_PROB | ONE_SIDED_PROB_OR_MORE | ONE_SIDED_PROB_OR_LESS } ] ) </eps> \n The Purpose is: \n <code>STATS_BINOMIAL_TEST</code> is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small. This function takes four arguments: <code>expr1</code> is the sample being examined. <code>expr2</code> contains the values for which the proportion is expected to be, and <code>p</code> is a proportion to test against. The fourth argument is a return value of type <code>VARCHAR2</code>. If you omit the fourth argument, then the default is <code>TWO_SIDED_PROB</code>. The meaning of the return values is shown in <link>Table 5-3&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions169.htm#g1514238</link>. Table 5-3 STATS_BINOMIAL Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> TWO_SIDED_PROB </td> <td> The probability that the given population proportion, p, could result in the observed proportion or a more extreme one. </td> </tr> <tr> <td> EXACT_PROB </td> <td> The probability that the given population proportion, p, could result in exactly the observed proportion. </td> </tr> <tr> <td> ONE_SIDED_PROB_OR_MORE </td> <td> The probability that the given population proportion, p, could result in the observed proportion or a larger one. </td> </tr> <tr> <td> ONE_SIDED_PROB_OR_LESS </td> <td> The probability that the given population proportion, p, could result in the observed proportion or a smaller one. </td> </tr> </tbody> </table> <code>EXACT_PROB</code> gives the probability of getting exactly proportion p. In cases where you want to test whether the proportion found in the sample is significantly different from a 50-50 split, <code>p</code> would normally be 0.50. If you want to test only whether the proportion is different, then use the return value <code>TWO_SIDED_PROB</code>. If your test is whether the proportion is more than the value of <code>expr2</code>, then use the return value <code>ONE_SIDED_PROB_OR_MORE</code>. If the test is to determine whether the proportion of <code>expr2</code> is less, then use the return value <code>ONE_SIDED_PROB_OR_LESS</code>. STATS_BINOMIAL_TEST Example The following example determines the probability that reality exactly matches the number of men observed under the assumption that 69% of the population is composed of men: <code>SELECT AVG(DECODE(cust_gender, 'M', 1, 0)) real_proportion, STATS_BINOMIAL_TEST (cust_gender, 'M', 0.68, 'EXACT_PROB') exact, STATS_BINOMIAL_TEST (cust_gender, 'M', 0.68, 'ONE_SIDED_PROB_OR_LESS') prob_or_less FROM sh.customers; </code> ",
        "detail": "The Syntax is: \n <eps> STATS_BINOMIAL_TEST(expr1, expr2, p [, { TWO_SIDED_PROB | EXACT_PROB | ONE_SIDED_PROB_OR_MORE | ONE_SIDED_PROB_OR_LESS } ] ) </eps> \n The Purpose is: \n <code>STATS_BINOMIAL_TEST</code> is an exact probability test used for dichotomous variables, where only two possible values exist. It tests the difference between a sample proportion and a given proportion. The sample size in such tests is usually small. This function takes four arguments: <code>expr1</code> is the sample being examined. <code>expr2</code> contains the values for which the proportion is expected to be, and <code>p</code> is a proportion to test against. The fourth argument is a return value of type <code>VARCHAR2</code>. If you omit the fourth argument, then the default is <code>TWO_SIDED_PROB</code>. The meaning of the return values is shown in <link>Table 5-3&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions169.htm#g1514238</link>. Table 5-3 STATS_BINOMIAL Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> TWO_SIDED_PROB </td> <td> The probability that the given population proportion, p, could result in the observed proportion or a more extreme one. </td> </tr> <tr> <td> EXACT_PROB </td> <td> The probability that the given population proportion, p, could result in exactly the observed proportion. </td> </tr> <tr> <td> ONE_SIDED_PROB_OR_MORE </td> <td> The probability that the given population proportion, p, could result in the observed proportion or a larger one. </td> </tr> <tr> <td> ONE_SIDED_PROB_OR_LESS </td> <td> The probability that the given population proportion, p, could result in the observed proportion or a smaller one. </td> </tr> </tbody> </table> <code>EXACT_PROB</code> gives the probability of getting exactly proportion p. In cases where you want to test whether the proportion found in the sample is significantly different from a 50-50 split, <code>p</code> would normally be 0.50. If you want to test only whether the proportion is different, then use the return value <code>TWO_SIDED_PROB</code>. If your test is whether the proportion is more than the value of <code>expr2</code>, then use the return value <code>ONE_SIDED_PROB_OR_MORE</code>. If the test is to determine whether the proportion of <code>expr2</code> is less, then use the return value <code>ONE_SIDED_PROB_OR_LESS</code>. STATS_BINOMIAL_TEST Example The following example determines the probability that reality exactly matches the number of men observed under the assumption that 69% of the population is composed of men: <code>SELECT AVG(DECODE(cust_gender, 'M', 1, 0)) real_proportion, STATS_BINOMIAL_TEST (cust_gender, 'M', 0.68, 'EXACT_PROB') exact, STATS_BINOMIAL_TEST (cust_gender, 'M', 0.68, 'ONE_SIDED_PROB_OR_LESS') prob_or_less FROM sh.customers; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions169.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CONCAT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CONCAT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CONCAT(char1, char2) </eps> \n The Purpose is: \n <code>CONCAT</code> returns <code>char1</code> concatenated with <code>char2</code>. Both <code>char1</code> and <code>char2</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is in the same character set as <code>char1</code>. Its data type depends on the data types of the arguments. In concatenations of two different data types, Oracle Database returns the data type that results in a lossless conversion. Therefore, if one of the arguments is a LOB, then the returned value is a LOB. If one of the arguments is a national data type, then the returned value is a national data type. For example: <code>CONCAT</code>(<code>CLOB</code>, <code>NCLOB</code>) returns <code>NCLOB</code> <code>CONCAT</code>(<code>NCLOB</code>, <code>NCHAR</code>) returns <code>NCLOB</code> <code>CONCAT</code>(<code>NCLOB</code>, <code>CHAR</code>) returns <code>NCLOB</code> <code>CONCAT</code>(<code>NCHAR</code>, <code>CLOB</code>) returns <code>NCLOB</code> This function is equivalent to the concatenation operator (||). See Also: <link>\"Concatenation Operator\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/operators003.htm#i997789</link> for information on the <code>CONCAT</code> operator \n The Examples is: \n This example uses nesting to concatenate three character strings: <code>SELECT CONCAT(CONCAT(last_name, '''s job category is '), job_id) \"Job\" FROM employees WHERE employee_id = 152; Job ------------------------------------------------------ Hall's job category is SA_REP </code> ",
        "detail": "The Syntax is: \n <eps> CONCAT(char1, char2) </eps> \n The Purpose is: \n <code>CONCAT</code> returns <code>char1</code> concatenated with <code>char2</code>. Both <code>char1</code> and <code>char2</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is in the same character set as <code>char1</code>. Its data type depends on the data types of the arguments. In concatenations of two different data types, Oracle Database returns the data type that results in a lossless conversion. Therefore, if one of the arguments is a LOB, then the returned value is a LOB. If one of the arguments is a national data type, then the returned value is a national data type. For example: <code>CONCAT</code>(<code>CLOB</code>, <code>NCLOB</code>) returns <code>NCLOB</code> <code>CONCAT</code>(<code>NCLOB</code>, <code>NCHAR</code>) returns <code>NCLOB</code> <code>CONCAT</code>(<code>NCLOB</code>, <code>CHAR</code>) returns <code>NCLOB</code> <code>CONCAT</code>(<code>NCHAR</code>, <code>CLOB</code>) returns <code>NCLOB</code> This function is equivalent to the concatenation operator (||). See Also: <link>\"Concatenation Operator\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/operators003.htm#i997789</link> for information on the <code>CONCAT</code> operator \n The Examples is: \n This example uses nesting to concatenate three character strings: <code>SELECT CONCAT(CONCAT(last_name, '''s job category is '), job_id) \"Job\" FROM employees WHERE employee_id = 152; Job ------------------------------------------------------ Hall's job category is SA_REP </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions033.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "BIN_TO_NUM",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c BIN_TO_NUM))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> BIN_TO_NUM(expr [, expr ]... ) </eps> \n The Purpose is: \n <code>BIN_TO_NUM</code> converts a bit vector to its equivalent number. Each argument to this function represents a bit in the bit vector. This function takes as arguments any numeric data type, or any nonnumeric data type that can be implicitly converted to <code>NUMBER</code>. Each <code>expr</code> must evaluate to 0 or 1. This function returns Oracle <code>NUMBER</code>. <code>BIN_TO_NUM</code> is useful in data warehousing applications for selecting groups of interest from a materialized view using grouping sets. See Also: <link>group_by_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2182483</link> for information on <code>GROUPING</code> <code>SETS</code> syntax <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion <link>Oracle Database Data Warehousing Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e25554/aggreg.htm#DWHSG020</link> for information on data aggregation in general \n The Examples is: \n The following example converts a binary value to a number: <code>SELECT BIN_TO_NUM(1,0,1,0) FROM DUAL; BIN_TO_NUM(1,0,1,0) ------------------- 10 </code> The next example converts three values into a single binary value and uses <code>BIN_TO_NUM</code> to convert that binary into a number. The example uses a PL/SQL declaration to specify the original values. These would normally be derived from actual data sources. <code>SELECT order_status FROM orders WHERE order_id = 2441; ORDER_STATUS ------------ 5 DECLARE warehouse NUMBER := 1; ground NUMBER := 1; insured NUMBER := 1; result NUMBER; BEGIN SELECT BIN_TO_NUM(warehouse, ground, insured) INTO result FROM DUAL; UPDATE orders SET order_status = result WHERE order_id = 2441; END; / PL/SQL procedure successfully completed. SELECT order_status FROM orders WHERE order_id = 2441; ORDER_STATUS ------------ 7 </code> Refer to the examples for <link>BITAND&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions021.htm#i98000</link> for information on reversing this process by extracting multiple values from a single column value. ",
        "detail": "The Syntax is: \n <eps> BIN_TO_NUM(expr [, expr ]... ) </eps> \n The Purpose is: \n <code>BIN_TO_NUM</code> converts a bit vector to its equivalent number. Each argument to this function represents a bit in the bit vector. This function takes as arguments any numeric data type, or any nonnumeric data type that can be implicitly converted to <code>NUMBER</code>. Each <code>expr</code> must evaluate to 0 or 1. This function returns Oracle <code>NUMBER</code>. <code>BIN_TO_NUM</code> is useful in data warehousing applications for selecting groups of interest from a materialized view using grouping sets. See Also: <link>group_by_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2182483</link> for information on <code>GROUPING</code> <code>SETS</code> syntax <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion <link>Oracle Database Data Warehousing Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e25554/aggreg.htm#DWHSG020</link> for information on data aggregation in general \n The Examples is: \n The following example converts a binary value to a number: <code>SELECT BIN_TO_NUM(1,0,1,0) FROM DUAL; BIN_TO_NUM(1,0,1,0) ------------------- 10 </code> The next example converts three values into a single binary value and uses <code>BIN_TO_NUM</code> to convert that binary into a number. The example uses a PL/SQL declaration to specify the original values. These would normally be derived from actual data sources. <code>SELECT order_status FROM orders WHERE order_id = 2441; ORDER_STATUS ------------ 5 DECLARE warehouse NUMBER := 1; ground NUMBER := 1; insured NUMBER := 1; result NUMBER; BEGIN SELECT BIN_TO_NUM(warehouse, ground, insured) INTO result FROM DUAL; UPDATE orders SET order_status = result WHERE order_id = 2441; END; / PL/SQL procedure successfully completed. SELECT order_status FROM orders WHERE order_id = 2441; ORDER_STATUS ------------ 7 </code> Refer to the examples for <link>BITAND&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions021.htm#i98000</link> for information on reversing this process by extracting multiple values from a single column value. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions020.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "POWER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c POWER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> POWER(n2, n1) </eps> \n The Purpose is: \n <code>POWER</code> returns <code>n2</code> raised to the <code>n1</code> power. The base <code>n2</code> and the exponent <code>n1</code> can be any numbers, but if <code>n2</code> is negative, then <code>n1</code> must be an integer. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise, the function returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns 3 squared: <code>SELECT POWER(3,2) \"Raised\" FROM DUAL; Raised ---------- 9 </code> ",
        "detail": "The Syntax is: \n <eps> POWER(n2, n1) </eps> \n The Purpose is: \n <code>POWER</code> returns <code>n2</code> raised to the <code>n1</code> power. The base <code>n2</code> and the exponent <code>n1</code> can be any numbers, but if <code>n2</code> is negative, then <code>n1</code> must be an integer. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise, the function returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns 3 squared: <code>SELECT POWER(3,2) \"Raised\" FROM DUAL; Raised ---------- 9 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions129.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "USERENV",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c USERENV))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> USERENV('parameter') </eps> \n The Purpose is: \n Note: <code>USERENV</code> is a legacy function that is retained for backward compatibility. Oracle recommends that you use the <code>SYS_CONTEXT</code> function with the built-in <code>USERENV</code> namespace for current functionality. See <link>SYS_CONTEXT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions184.htm#i1038176</link> for more information. <code>USERENV</code> returns information about the current session. This information can be useful for writing an application-specific audit trail table or for determining the language-specific characters currently used by your session. You cannot use <code>USERENV</code> in the condition of a <code>CHECK</code> constraint. <link>Table 5-13&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions228.htm#g1513939</link> describes the values for the <code>parameter</code> argument. All calls to <code>USERENV</code> return <code>VARCHAR2</code> data except for calls with the <code>SESSIONID</code>, <code>SID</code>, and <code>ENTRYID</code> parameters, which return <code>NUMBER</code>. Table 5-13 Parameters of the USERENV Function <table> <thead> <tr> <th>Parameter</th> <th>Return Value</th> </tr> </thead> <tbody> <tr> <td> CLIENT_INFO </td> <td> CLIENT_INFO returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. Caution: Some commercial applications may be using this context value. Refer to the applicable documentation for those applications to determine what restrictions they may impose on use of this context area. See Also: Oracle Database Security Guide for more information on application context CREATE CONTEXT and SYS_CONTEXT </td> </tr> <tr> <td> ENTRYID </td> <td> The current audit entry number. The audit entryid sequence is shared between fine-grained audit records and regular audit records. You cannot use this attribute in distributed SQL statements. </td> </tr> <tr> <td> ISDBA </td> <td> ISDBA returns 'TRUE' if the user has been authenticated as having DBA privileges either through the operating system or through a password file. </td> </tr> <tr> <td> LANG </td> <td> LANG returns the ISO abbreviation for the language name, a shorter form than the existing 'LANGUAGE' parameter. </td> </tr> <tr> <td> LANGUAGE </td> <td> LANGUAGE returns the language and territory used by the current session along with the database character set in this form: language_territory.characterset </td> </tr> <tr> <td> SESSIONID </td> <td> SESSIONID returns the auditing session identifier. You cannot specify this parameter in distributed SQL statements. </td> </tr> <tr> <td> SID </td> <td> SID returns the session ID. </td> </tr> <tr> <td> TERMINAL </td> <td> TERMINAL returns the operating system identifier for the terminal of the current session. In distributed SQL statements, this parameter returns the identifier for your local session. In a distributed environment, this parameter is supported only for remote SELECT statements, not for remote INSERT, UPDATE, or DELETE operations. </td> </tr> </tbody> </table> \n The Examples is: \n The following example returns the <code>LANGUAGE</code> parameter of the current session: <code>SELECT USERENV('LANGUAGE') \"Language\" FROM DUAL; Language ----------------------------------- AMERICAN_AMERICA.WE8ISO8859P1 </code> ",
        "detail": "The Syntax is: \n <eps> USERENV('parameter') </eps> \n The Purpose is: \n Note: <code>USERENV</code> is a legacy function that is retained for backward compatibility. Oracle recommends that you use the <code>SYS_CONTEXT</code> function with the built-in <code>USERENV</code> namespace for current functionality. See <link>SYS_CONTEXT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions184.htm#i1038176</link> for more information. <code>USERENV</code> returns information about the current session. This information can be useful for writing an application-specific audit trail table or for determining the language-specific characters currently used by your session. You cannot use <code>USERENV</code> in the condition of a <code>CHECK</code> constraint. <link>Table 5-13&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions228.htm#g1513939</link> describes the values for the <code>parameter</code> argument. All calls to <code>USERENV</code> return <code>VARCHAR2</code> data except for calls with the <code>SESSIONID</code>, <code>SID</code>, and <code>ENTRYID</code> parameters, which return <code>NUMBER</code>. Table 5-13 Parameters of the USERENV Function <table> <thead> <tr> <th>Parameter</th> <th>Return Value</th> </tr> </thead> <tbody> <tr> <td> CLIENT_INFO </td> <td> CLIENT_INFO returns up to 64 bytes of user session information that can be stored by an application using the DBMS_APPLICATION_INFO package. Caution: Some commercial applications may be using this context value. Refer to the applicable documentation for those applications to determine what restrictions they may impose on use of this context area. See Also: Oracle Database Security Guide for more information on application context CREATE CONTEXT and SYS_CONTEXT </td> </tr> <tr> <td> ENTRYID </td> <td> The current audit entry number. The audit entryid sequence is shared between fine-grained audit records and regular audit records. You cannot use this attribute in distributed SQL statements. </td> </tr> <tr> <td> ISDBA </td> <td> ISDBA returns 'TRUE' if the user has been authenticated as having DBA privileges either through the operating system or through a password file. </td> </tr> <tr> <td> LANG </td> <td> LANG returns the ISO abbreviation for the language name, a shorter form than the existing 'LANGUAGE' parameter. </td> </tr> <tr> <td> LANGUAGE </td> <td> LANGUAGE returns the language and territory used by the current session along with the database character set in this form: language_territory.characterset </td> </tr> <tr> <td> SESSIONID </td> <td> SESSIONID returns the auditing session identifier. You cannot specify this parameter in distributed SQL statements. </td> </tr> <tr> <td> SID </td> <td> SID returns the session ID. </td> </tr> <tr> <td> TERMINAL </td> <td> TERMINAL returns the operating system identifier for the terminal of the current session. In distributed SQL statements, this parameter returns the identifier for your local session. In a distributed environment, this parameter is supported only for remote SELECT statements, not for remote INSERT, UPDATE, or DELETE operations. </td> </tr> </tbody> </table> \n The Examples is: \n The following example returns the <code>LANGUAGE</code> parameter of the current session: <code>SELECT USERENV('LANGUAGE') \"Language\" FROM DUAL; Language ----------------------------------- AMERICAN_AMERICA.WE8ISO8859P1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions228.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LAST_VALUE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LAST_VALUE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LAST_VALUE { (expr) [ { RESPECT | IGNORE } NULLS ] | (expr [ { RESPECT | IGNORE } NULLS ]) OVER (analytic_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>expr</code> \n The Purpose is: \n <code>LAST_VALUE</code> is an analytic function that is useful for data densification. It returns the last value in an ordered set of values. Note: The two forms of this syntax have the same behavior. The top branch is the ANSI format, which Oracle recommends. The bottom branch is deprecated but is supported for backward compatibility. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. If the last value in the set is null, then the function returns <code>NULL</code> unless you specify <code>IGNORE</code> <code>NULLS</code>. If you specify <code>IGNORE NULLS</code>, then <code>LAST_VALUE</code> returns the last non-null value in the set, or <code>NULL</code> if all values are null. Refer to <link>\"Using Partitioned Outer Joins: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2177515</link> for an example of data densification. You cannot nest analytic functions by using <code>LAST_VALUE</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. Refer to <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>. If you omit the <code>windowing_clause</code> of the <code>analytic_clause</code>, it defaults to <code>RANGE</code> <code>BETWEEN</code> <code>UNBOUNDED</code> <code>PRECEDING</code> <code>AND</code> <code>CURRENT</code> <code>ROW</code>. This default sometimes returns an unexpected value, because the last value in the window is at the bottom of the window, which is not fixed. It keeps changing as the current row changes. For expected results, specify the <code>windowing_clause</code> as <code>RANGE</code> <code>BETWEEN</code> <code>UNBOUNDED</code> <code>PRECEDING</code> <code>AND</code> <code>UNBOUNDED</code> <code>FOLLOWING</code>. Alternatively, you can specify the <code>windowing_clause</code> as <code>RANGE</code> <code>BETWEEN</code> <code>CURRENT</code> <code>ROW</code> <code>AND</code> <code>UNBOUNDED</code> <code>FOLLOWING</code>. \n The Examples is: \n The following example returns, for each row, the hire date of the employee earning the highest salary: <code>SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date); LAST_NAME SALARY HIRE_DATE LV --------------- ---------- --------- --------- De Haan 17000 13-JAN-01 17-JUN-03 Kochhar 17000 21-SEP-05 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 </code> This example illustrates the nondeterministic nature of the <code>LAST_VALUE</code> function. Kochhar and De Haan have the same salary, so they are in adjacent rows. Kochhar appears first because the rows in the subquery are ordered by <code>hire_date</code>. However, if the rows are ordered by <code>hire_date</code> in descending order, as in the next example, then the function returns a different value: <code>SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date DESC); LAST_NAME SALARY HIRE_DATE LV --------------- ---------- --------- --------- Kochhar 17000 21-SEP-05 17-JUN-03 De Haan 17000 13-JAN-01 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 </code> The following two examples show how to make the <code>LAST_VALUE</code> function deterministic by ordering on a unique key. By ordering within the function by both <code>salary</code> and <code>hire_date</code>, you can ensure the same result regardless of the ordering in the subquery. <code>SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary, hire_date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date) ORDER BY last_name, salary, hire_date; LAST_NAME SALARY HIRE_DATE LV --------------- ---------- --------- --------- De Haan 17000 13-JAN-01 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 Kochhar 17000 21-SEP-05 17-JUN-03 SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary, hire_date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date DESC) ORDER BY last_name, salary, hire_date; LAST_NAME SALARY HIRE_DATE LV --------------- ---------- --------- --------- De Haan 17000 13-JAN-01 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 Kochhar 17000 21-SEP-05 17-JUN-03 </code> When you use a logical offset (<code>RANGE</code> instead of <code>ROWS</code>), the function is deterministic. When duplicates are found for the <code>ORDER</code> <code>BY</code> expression, the <code>LAST_VALUE</code> is the highest value of <code>expr</code>: <code>SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date DESC); LAST_NAME SALARY HIRE_DATE LV ------------------------- ---------- --------- --------- De Haan 17000 13-JAN-01 17-JUN-03 Kochhar 17000 21-SEP-05 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 </code> ",
        "detail": "The Syntax is: \n <eps> LAST_VALUE { (expr) [ { RESPECT | IGNORE } NULLS ] | (expr [ { RESPECT | IGNORE } NULLS ]) OVER (analytic_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>expr</code> \n The Purpose is: \n <code>LAST_VALUE</code> is an analytic function that is useful for data densification. It returns the last value in an ordered set of values. Note: The two forms of this syntax have the same behavior. The top branch is the ANSI format, which Oracle recommends. The bottom branch is deprecated but is supported for backward compatibility. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. If the last value in the set is null, then the function returns <code>NULL</code> unless you specify <code>IGNORE</code> <code>NULLS</code>. If you specify <code>IGNORE NULLS</code>, then <code>LAST_VALUE</code> returns the last non-null value in the set, or <code>NULL</code> if all values are null. Refer to <link>\"Using Partitioned Outer Joins: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2177515</link> for an example of data densification. You cannot nest analytic functions by using <code>LAST_VALUE</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. Refer to <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>. If you omit the <code>windowing_clause</code> of the <code>analytic_clause</code>, it defaults to <code>RANGE</code> <code>BETWEEN</code> <code>UNBOUNDED</code> <code>PRECEDING</code> <code>AND</code> <code>CURRENT</code> <code>ROW</code>. This default sometimes returns an unexpected value, because the last value in the window is at the bottom of the window, which is not fixed. It keeps changing as the current row changes. For expected results, specify the <code>windowing_clause</code> as <code>RANGE</code> <code>BETWEEN</code> <code>UNBOUNDED</code> <code>PRECEDING</code> <code>AND</code> <code>UNBOUNDED</code> <code>FOLLOWING</code>. Alternatively, you can specify the <code>windowing_clause</code> as <code>RANGE</code> <code>BETWEEN</code> <code>CURRENT</code> <code>ROW</code> <code>AND</code> <code>UNBOUNDED</code> <code>FOLLOWING</code>. \n The Examples is: \n The following example returns, for each row, the hire date of the employee earning the highest salary: <code>SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date); LAST_NAME SALARY HIRE_DATE LV --------------- ---------- --------- --------- De Haan 17000 13-JAN-01 17-JUN-03 Kochhar 17000 21-SEP-05 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 </code> This example illustrates the nondeterministic nature of the <code>LAST_VALUE</code> function. Kochhar and De Haan have the same salary, so they are in adjacent rows. Kochhar appears first because the rows in the subquery are ordered by <code>hire_date</code>. However, if the rows are ordered by <code>hire_date</code> in descending order, as in the next example, then the function returns a different value: <code>SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date DESC); LAST_NAME SALARY HIRE_DATE LV --------------- ---------- --------- --------- Kochhar 17000 21-SEP-05 17-JUN-03 De Haan 17000 13-JAN-01 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 </code> The following two examples show how to make the <code>LAST_VALUE</code> function deterministic by ordering on a unique key. By ordering within the function by both <code>salary</code> and <code>hire_date</code>, you can ensure the same result regardless of the ordering in the subquery. <code>SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary, hire_date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date) ORDER BY last_name, salary, hire_date; LAST_NAME SALARY HIRE_DATE LV --------------- ---------- --------- --------- De Haan 17000 13-JAN-01 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 Kochhar 17000 21-SEP-05 17-JUN-03 SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary, hire_date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date DESC) ORDER BY last_name, salary, hire_date; LAST_NAME SALARY HIRE_DATE LV --------------- ---------- --------- --------- De Haan 17000 13-JAN-01 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 Kochhar 17000 21-SEP-05 17-JUN-03 </code> When you use a logical offset (<code>RANGE</code> instead of <code>ROWS</code>), the function is deterministic. When duplicates are found for the <code>ORDER</code> <code>BY</code> expression, the <code>LAST_VALUE</code> is the highest value of <code>expr</code>: <code>SELECT last_name, salary, hire_date, LAST_VALUE(hire_date) OVER (ORDER BY salary RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lv FROM (SELECT * FROM employees WHERE department_id = 90 ORDER BY hire_date DESC); LAST_NAME SALARY HIRE_DATE LV ------------------------- ---------- --------- --------- De Haan 17000 13-JAN-01 17-JUN-03 Kochhar 17000 21-SEP-05 17-JUN-03 King 24000 17-JUN-03 17-JUN-03 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions085.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NVL",
        "tree": "(string_function NVL ( ))",
        "description": "The Syntax is: \n <eps> NVL(expr1, expr2) </eps> \n The Purpose is: \n <code>NVL</code> lets you replace null (returned as a blank) with a string in the results of a query. If <code>expr1</code> is null, then <code>NVL</code> returns <code>expr2</code>. If <code>expr1</code> is not null, then <code>NVL</code> returns <code>expr1</code>. The arguments <code>expr1</code> and <code>expr2</code> can have any data type. If their data types are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. The implicit conversion is implemented as follows: If <code>expr1</code> is character data, then Oracle Database converts <code>expr2</code> to the data type of <code>expr1</code> before comparing them and returns <code>VARCHAR2</code> in the character set of <code>expr1</code>. If <code>expr1</code> is numeric, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence <link>\"COALESCE\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions030.htm#i1001341</link> and <link>\"CASE Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm#i1033392</link>, which provide functionality similar to that of <code>NVL</code> \n The Examples is: \n The following example returns a list of employee names and commissions, substituting \"Not Applicable\" if the employee receives no commission: <code>SELECT last_name, NVL(TO_CHAR(commission_pct), 'Not Applicable') commission FROM employees WHERE last_name LIKE 'B%' ORDER BY last_name; LAST_NAME COMMISSION ------------------------- ---------------------------------------- Baer Not Applicable Baida Not Applicable Banda .1 Bates .15 Bell Not Applicable Bernstein .25 Bissot Not Applicable Bloom .2 Bull Not Applicable </code> ",
        "detail": "The Syntax is: \n <eps> NVL(expr1, expr2) </eps> \n The Purpose is: \n <code>NVL</code> lets you replace null (returned as a blank) with a string in the results of a query. If <code>expr1</code> is null, then <code>NVL</code> returns <code>expr2</code>. If <code>expr1</code> is not null, then <code>NVL</code> returns <code>expr1</code>. The arguments <code>expr1</code> and <code>expr2</code> can have any data type. If their data types are different, then Oracle Database implicitly converts one to the other. If they cannot be converted implicitly, then the database returns an error. The implicit conversion is implemented as follows: If <code>expr1</code> is character data, then Oracle Database converts <code>expr2</code> to the data type of <code>expr1</code> before comparing them and returns <code>VARCHAR2</code> in the character set of <code>expr1</code>. If <code>expr1</code> is numeric, then Oracle Database determines which argument has the highest numeric precedence, implicitly converts the other argument to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence <link>\"COALESCE\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions030.htm#i1001341</link> and <link>\"CASE Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions004.htm#i1033392</link>, which provide functionality similar to that of <code>NVL</code> \n The Examples is: \n The following example returns a list of employee names and commissions, substituting \"Not Applicable\" if the employee receives no commission: <code>SELECT last_name, NVL(TO_CHAR(commission_pct), 'Not Applicable') commission FROM employees WHERE last_name LIKE 'B%' ORDER BY last_name; LAST_NAME COMMISSION ------------------------- ---------------------------------------- Baer Not Applicable Baida Not Applicable Banda .1 Bates .15 Bell Not Applicable Bernstein .25 Bissot Not Applicable Bloom .2 Bull Not Applicable </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions119.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PREDICTION_SET",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PREDICTION_SET))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PREDICTION_SET ( [ schema . ] model [ , bestN [ , cutoff ] ] [ cost_matrix_clause ] mining_attribute_clause ) </eps> cost_matrix_clause::= <eps> COST { MODEL [AUTO] | ( class_value [, class_value]... ) VALUES ( ( cost_value [, cost_value]...) [ , (cost_value [, cost_value]... ) ]... ) } </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with classification models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It is not valid with other types of models. It returns a varray of objects containing all classes in a multiclass classification scenario. The object fields are named <code>PREDICTION</code>, <code>PROBABILITY</code>, and <code>COST</code>. The data type of the <code>PREDICTION</code> field depends on the target value type used during the build of the model. The other two fields are both Oracle <code>NUMBER</code>. The elements are returned in the order of best prediction to worst prediction. For <code>bestN</code>, specify a positive integer to restrict the returned target classes to the <code>N</code> having the highest probability, or lowest cost if cost matrix clause is specified. If multiple classes are tied in the Nth value, then the database still returns only <code>N</code> values. If you want to filter only by <code>cutoff</code>, specify <code>NULL</code> for this parameter. For <code>cutoff</code>, specify a <code>NUMBER</code> value to restrict the returned target classes to those with a probability greater than or equal to (or a cost less than or equal to if cost matrix clause is specified) to the specified cutoff value. You can filter solely by <code>cutoff</code> by specifying <code>NULL</code> for <code>bestN</code>. When you specify values for both <code>bestN</code> and <code>cutoff</code>, you restrict the returned predictions to only those that are the <code>bestN</code> and have a probability (or cost when the <code>cost_matrix_clause</code> is specified) surpassing the threshold. The <code>cost_matrix_clause</code> clause is relevant for all classification models. When you specify this clause, both <code>bestN</code> and <code>cutoff</code> are treated with respect to the prediction cost, not the prediction probability. The value of <code>bestN</code> restricts the result to the target classes having the <code>N</code> best (lowest) costs, and <code>cutoff</code> restricts the target classes to those with a cost less than or equal to the specified cutoff. When you specify this clause, each object in the collection is a triplet of scalar values containing the prediction value (the data type of which depends on the target value type used during model build), the prediction probability, and the prediction cost (both Oracle <code>NUMBER</code>). If you omit this clause, then each object in the varray is a pair of scalars containing the prediction value and prediction probability. The data types returned are as described in the preceding paragraph. Specify <code>COST</code> <code>MODEL</code> to indicate that the scoring should be performed by taking into account the scoring cost matrix associated with the model. If no such cost matrix exists, then the database returns an error. Specify <code>COST</code> <code>MODEL</code> <code>AUTO</code> if the existence of a cost matrix is unknown. In this case: If the stored cost matrix exists, then the result is the same as with <code>COST</code> <code>MODEL</code>. If no stored cost matrix exists, then the result is almost the same as without the <code>cost_matrix_clause</code>, except the object in the collection is a triplet and the cost value is computed based on the unit cost matrix (0's on the diagonal and 1's everywhere else). This is equivalent to one minus probability for the given class. The cutoff parameter is ignored if no stored cost matrix exists. Use the <code>VALUES</code> clause (the bottom branch of the <code>cost_matrix_clause</code>) to specify an inline cost matrix. You can use an inline cost matrix regardless of whether the model has an associated scoring cost matrix. Refer to <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG243</link> for an example of an inline cost matrix The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example lists, for ten customers, the likelihood and cost of using or rejecting an affinity card. This example has a binary target, but such a query is also useful in multiclass classification such as Low, Med, and High. This example and the prerequisite data mining operations can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT T.cust_id, S.prediction, S.probability, S.cost FROM (SELECT cust_id, PREDICTION_SET(dt_sh_clas_sample COST MODEL USING *) pset FROM mining_data_apply_v WHERE cust_id < 100011) T, TABLE(T.pset) S ORDER BY cust_id, S.prediction; CUST_ID PREDICTION PROBABILITY COST ---------- ---------- ----------- ----- 100001 0 .96682 .27 100001 1 .03318 .97 100002 0 .74038 2.08 100002 1 .25962 .74 100003 0 .90909 .73 100003 1 .09091 .91 100004 0 .90909 .73 100004 1 .09091 .91 100005 0 .27236 5.82 100005 1 .72764 .27 100006 0 1.00000 .00 100006 1 .00000 1.00 100007 0 .90909 .73 100007 1 .09091 .91 100008 0 .90909 .73 100008 1 .09091 .91 100009 0 .27236 5.82 100009 1 .72764 .27 100010 0 .80808 1.54 100010 1 .19192 .81 20 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> PREDICTION_SET ( [ schema . ] model [ , bestN [ , cutoff ] ] [ cost_matrix_clause ] mining_attribute_clause ) </eps> cost_matrix_clause::= <eps> COST { MODEL [AUTO] | ( class_value [, class_value]... ) VALUES ( ( cost_value [, cost_value]...) [ , (cost_value [, cost_value]... ) ]... ) } </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with classification models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It is not valid with other types of models. It returns a varray of objects containing all classes in a multiclass classification scenario. The object fields are named <code>PREDICTION</code>, <code>PROBABILITY</code>, and <code>COST</code>. The data type of the <code>PREDICTION</code> field depends on the target value type used during the build of the model. The other two fields are both Oracle <code>NUMBER</code>. The elements are returned in the order of best prediction to worst prediction. For <code>bestN</code>, specify a positive integer to restrict the returned target classes to the <code>N</code> having the highest probability, or lowest cost if cost matrix clause is specified. If multiple classes are tied in the Nth value, then the database still returns only <code>N</code> values. If you want to filter only by <code>cutoff</code>, specify <code>NULL</code> for this parameter. For <code>cutoff</code>, specify a <code>NUMBER</code> value to restrict the returned target classes to those with a probability greater than or equal to (or a cost less than or equal to if cost matrix clause is specified) to the specified cutoff value. You can filter solely by <code>cutoff</code> by specifying <code>NULL</code> for <code>bestN</code>. When you specify values for both <code>bestN</code> and <code>cutoff</code>, you restrict the returned predictions to only those that are the <code>bestN</code> and have a probability (or cost when the <code>cost_matrix_clause</code> is specified) surpassing the threshold. The <code>cost_matrix_clause</code> clause is relevant for all classification models. When you specify this clause, both <code>bestN</code> and <code>cutoff</code> are treated with respect to the prediction cost, not the prediction probability. The value of <code>bestN</code> restricts the result to the target classes having the <code>N</code> best (lowest) costs, and <code>cutoff</code> restricts the target classes to those with a cost less than or equal to the specified cutoff. When you specify this clause, each object in the collection is a triplet of scalar values containing the prediction value (the data type of which depends on the target value type used during model build), the prediction probability, and the prediction cost (both Oracle <code>NUMBER</code>). If you omit this clause, then each object in the varray is a pair of scalars containing the prediction value and prediction probability. The data types returned are as described in the preceding paragraph. Specify <code>COST</code> <code>MODEL</code> to indicate that the scoring should be performed by taking into account the scoring cost matrix associated with the model. If no such cost matrix exists, then the database returns an error. Specify <code>COST</code> <code>MODEL</code> <code>AUTO</code> if the existence of a cost matrix is unknown. In this case: If the stored cost matrix exists, then the result is the same as with <code>COST</code> <code>MODEL</code>. If no stored cost matrix exists, then the result is almost the same as without the <code>cost_matrix_clause</code>, except the object in the collection is a triplet and the cost value is computed based on the unit cost matrix (0's on the diagonal and 1's everywhere else). This is equivalent to one minus probability for the given class. The cutoff parameter is ignored if no stored cost matrix exists. Use the <code>VALUES</code> clause (the bottom branch of the <code>cost_matrix_clause</code>) to specify an inline cost matrix. You can use an inline cost matrix regardless of whether the model has an associated scoring cost matrix. Refer to <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG243</link> for an example of an inline cost matrix The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example lists, for ten customers, the likelihood and cost of using or rejecting an affinity card. This example has a binary target, but such a query is also useful in multiclass classification such as Low, Med, and High. This example and the prerequisite data mining operations can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT T.cust_id, S.prediction, S.probability, S.cost FROM (SELECT cust_id, PREDICTION_SET(dt_sh_clas_sample COST MODEL USING *) pset FROM mining_data_apply_v WHERE cust_id < 100011) T, TABLE(T.pset) S ORDER BY cust_id, S.prediction; CUST_ID PREDICTION PROBABILITY COST ---------- ---------- ----------- ----- 100001 0 .96682 .27 100001 1 .03318 .97 100002 0 .74038 2.08 100002 1 .25962 .74 100003 0 .90909 .73 100003 1 .09091 .91 100004 0 .90909 .73 100004 1 .09091 .91 100005 0 .27236 5.82 100005 1 .72764 .27 100006 0 1.00000 .00 100006 1 .00000 1.00 100007 0 .90909 .73 100007 1 .09091 .91 100008 0 .90909 .73 100008 1 .09091 .91 100009 0 .27236 5.82 100009 1 .72764 .27 100010 0 .80808 1.54 100010 1 .19192 .81 20 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions137.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYSTIMESTAMP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYSTIMESTAMP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYSTIMESTAMP </eps> \n The Purpose is: \n <code>SYSTIMESTAMP</code> returns the system date, including fractional seconds and time zone, of the system on which the database resides. The return type is <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>. \n The Examples is: \n The following example returns the system timestamp: <code>SELECT SYSTIMESTAMP FROM DUAL; SYSTIMESTAMP ------------------------------------------------------------------ 28-MAR-00 12.38.55.538741 PM -08:00 </code> The following example shows how to explicitly specify fractional seconds: <code>SELECT TO_CHAR(SYSTIMESTAMP, 'SSSSS.FF') FROM DUAL; TO_CHAR(SYSTIME --------------- 55615.449255 </code> The following example returns the current timestamp in a specified time zone: <code>SELECT SYSTIMESTAMP AT TIME ZONE 'UTC' FROM DUAL; SYSTIMESTAMPATTIMEZONE'UTC' --------------------------------------------------------------------------- 08-07-21 20:39:52,743557 UTC </code> The output format in this example depends on the <code>NLS_TIMESTAMP_TZ_FORMAT</code> for the session. ",
        "detail": "The Syntax is: \n <eps> SYSTIMESTAMP </eps> \n The Purpose is: \n <code>SYSTIMESTAMP</code> returns the system date, including fractional seconds and time zone, of the system on which the database resides. The return type is <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>. \n The Examples is: \n The following example returns the system timestamp: <code>SELECT SYSTIMESTAMP FROM DUAL; SYSTIMESTAMP ------------------------------------------------------------------ 28-MAR-00 12.38.55.538741 PM -08:00 </code> The following example shows how to explicitly specify fractional seconds: <code>SELECT TO_CHAR(SYSTIMESTAMP, 'SSSSS.FF') FROM DUAL; TO_CHAR(SYSTIME --------------- 55615.449255 </code> The following example returns the current timestamp in a specified time zone: <code>SELECT SYSTIMESTAMP AT TIME ZONE 'UTC' FROM DUAL; SYSTIMESTAMPATTIMEZONE'UTC' --------------------------------------------------------------------------- 08-07-21 20:39:52,743557 UTC </code> The output format in this example depends on the <code>NLS_TIMESTAMP_TZ_FORMAT</code> for the session. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions192.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LN(n) </eps> \n The Purpose is: \n <code>LN</code> returns the natural logarithm of <code>n</code>, where <code>n</code> is greater than 0. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the natural logarithm of 95: <code>SELECT LN(95) \"Natural log of 95\" FROM DUAL; Natural log of 95 ----------------- 4.55387689 </code> ",
        "detail": "The Syntax is: \n <eps> LN(n) </eps> \n The Purpose is: \n <code>LN</code> returns the natural logarithm of <code>n</code>, where <code>n</code> is greater than 0. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the natural logarithm of 95: <code>SELECT LN(95) \"Natural log of 95\" FROM DUAL; Natural log of 95 ----------------- 4.55387689 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions090.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_DSINTERVAL",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_DSINTERVAL))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_DSINTERVAL ( ' { sql_format | ds_iso_format } ' ) </eps> sql_format::= <eps> [+ | -] days hours : minutes : seconds [. frac_secs ] </eps> ds_iso_format::= <eps> [-] P [days D] [T [hours H] [minutes M] [seconds [. frac_secs] S ] ] </eps> Note: In earlier releases, the <code>TO_DSINTERVAL</code> function accepted an optional <code>nlsparam</code> clause. This clause is still accepted for backward compatibility, but has no effect. \n The Purpose is: \n <code>TO_DSINTERVAL</code> converts a character string of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to an <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> type. <code>TO_DSINTERVAL</code> accepts argument in one of the two formats: SQL interval format compatible with the SQL standard (ISO/IEC 9075:2003) ISO duration format compatible with the ISO 8601:2004 standard In the SQL format, <code>days</code> is an integer between 0 and 999999999, <code>hours</code> is an integer between 0 and 23, and <code>minutes</code> and <code>seconds</code> are integers between 0 and 59. <code>frac_secs</code> is the fractional part of seconds between .0 and .999999999. One or more blanks separate days from hours. Additional blanks are allowed between format elements. In the ISO format, <code>days</code>, <code>hours</code>, <code>minutes</code> and <code>seconds</code> are integers between 0 and 999999999. <code>frac_secs</code> is the fractional part of seconds between .0 and .999999999. No blanks are allowed in the value. If you specify <code>T</code>, then you must specify at least one of the <code>hours</code>, <code>minutes</code>, or <code>seconds</code> values. \n The Examples is: \n The following example uses the SQL format to select from the <code>hr.employees</code> table the employees who had worked for the company for at least 100 days on November 1, 2002: <code>SELECT employee_id, last_name FROM employees WHERE hire_date + TO_DSINTERVAL('100 00:00:00') <= DATE '2002-11-01' ORDER BY employee_id; EMPLOYEE_ID LAST_NAME ----------- --------------- 102 De Haan 203 Mavris 204 Baer 205 Higgins 206 Giet </code> The following example uses the ISO format to display the timestamp 100 days and 5 hours after the beginning of the year 2009: <code>SELECT TO_CHAR(TIMESTAMP '2009-01-01 00:00:00' + TO_DSINTERVAL('P100DT05H'), 'YYYY-MM-DD HH24:MI:SS') \"Time Stamp\" FROM DUAL; Time Stamp ------------------- 2009-04-11 05:00:00 </code> ",
        "detail": "The Syntax is: \n <eps> TO_DSINTERVAL ( ' { sql_format | ds_iso_format } ' ) </eps> sql_format::= <eps> [+ | -] days hours : minutes : seconds [. frac_secs ] </eps> ds_iso_format::= <eps> [-] P [days D] [T [hours H] [minutes M] [seconds [. frac_secs] S ] ] </eps> Note: In earlier releases, the <code>TO_DSINTERVAL</code> function accepted an optional <code>nlsparam</code> clause. This clause is still accepted for backward compatibility, but has no effect. \n The Purpose is: \n <code>TO_DSINTERVAL</code> converts a character string of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to an <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> type. <code>TO_DSINTERVAL</code> accepts argument in one of the two formats: SQL interval format compatible with the SQL standard (ISO/IEC 9075:2003) ISO duration format compatible with the ISO 8601:2004 standard In the SQL format, <code>days</code> is an integer between 0 and 999999999, <code>hours</code> is an integer between 0 and 23, and <code>minutes</code> and <code>seconds</code> are integers between 0 and 59. <code>frac_secs</code> is the fractional part of seconds between .0 and .999999999. One or more blanks separate days from hours. Additional blanks are allowed between format elements. In the ISO format, <code>days</code>, <code>hours</code>, <code>minutes</code> and <code>seconds</code> are integers between 0 and 999999999. <code>frac_secs</code> is the fractional part of seconds between .0 and .999999999. No blanks are allowed in the value. If you specify <code>T</code>, then you must specify at least one of the <code>hours</code>, <code>minutes</code>, or <code>seconds</code> values. \n The Examples is: \n The following example uses the SQL format to select from the <code>hr.employees</code> table the employees who had worked for the company for at least 100 days on November 1, 2002: <code>SELECT employee_id, last_name FROM employees WHERE hire_date + TO_DSINTERVAL('100 00:00:00') <= DATE '2002-11-01' ORDER BY employee_id; EMPLOYEE_ID LAST_NAME ----------- --------------- 102 De Haan 203 Mavris 204 Baer 205 Higgins 206 Giet </code> The following example uses the ISO format to display the timestamp 100 days and 5 hours after the beginning of the year 2009: <code>SELECT TO_CHAR(TIMESTAMP '2009-01-01 00:00:00' + TO_DSINTERVAL('P100DT05H'), 'YYYY-MM-DD HH24:MI:SS') \"Time Stamp\" FROM DUAL; Time Stamp ------------------- 2009-04-11 05:00:00 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions204.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "GROUPING",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c GROUPING))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> GROUPING(expr) </eps> \n The Purpose is: \n <code>GROUPING</code> distinguishes superaggregate rows from regular grouped rows. <code>GROUP</code> <code>BY</code> extensions such as <code>ROLLUP</code> and <code>CUBE</code> produce superaggregate rows where the set of all values is represented by null. Using the <code>GROUPING</code> function, you can distinguish a null representing the set of all values in a superaggregate row from a null in a regular row. The <code>expr</code> in the <code>GROUPING</code> function must match one of the expressions in the <code>GROUP</code> <code>BY</code> clause. The function returns a value of 1 if the value of <code>expr</code> in the row is a null representing the set of all values. Otherwise, it returns zero. The data type of the value returned by the <code>GROUPING</code> function is Oracle <code>NUMBER</code>. Refer to the <code>SELECT</code> <link>group_by_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2182483</link> for a discussion of these terms. \n The Examples is: \n In the following example, which uses the sample tables <code>hr.departments</code> and <code>hr.employees</code>, if the <code>GROUPING</code> function returns 1 (indicating a superaggregate row rather than a regular row from the table), then the string \"All Jobs\" appears in the \"JOB\" column instead of the null that would otherwise appear: <code>SELECT DECODE(GROUPING(department_name), 1, 'ALL DEPARTMENTS', department_name) AS department, DECODE(GROUPING(job_id), 1, 'All Jobs', job_id) AS job, COUNT(*) \"Total Empl\", AVG(salary) * 12 \"Average Sal\" FROM employees e, departments d WHERE d.department_id = e.department_id GROUP BY ROLLUP (department_name, job_id) ORDER BY department, job; DEPARTMENT JOB Total Empl Average Sal ------------------------------ ---------- ---------- ----------- ALL DEPARTMENTS All Jobs 106 77481.0566 Accounting AC_ACCOUNT 1 99600 Accounting AC_MGR 1 144096 Accounting All Jobs 2 121848 Administration AD_ASST 1 52800 Administration All Jobs 1 52800 Executive AD_PRES 1 288000 Executive AD_VP 2 204000 Executive All Jobs 3 232000 Finance All Jobs 6 103216 Finance FI_ACCOUNT 5 95040 . . . </code> ",
        "detail": "The Syntax is: \n <eps> GROUPING(expr) </eps> \n The Purpose is: \n <code>GROUPING</code> distinguishes superaggregate rows from regular grouped rows. <code>GROUP</code> <code>BY</code> extensions such as <code>ROLLUP</code> and <code>CUBE</code> produce superaggregate rows where the set of all values is represented by null. Using the <code>GROUPING</code> function, you can distinguish a null representing the set of all values in a superaggregate row from a null in a regular row. The <code>expr</code> in the <code>GROUPING</code> function must match one of the expressions in the <code>GROUP</code> <code>BY</code> clause. The function returns a value of 1 if the value of <code>expr</code> in the row is a null representing the set of all values. Otherwise, it returns zero. The data type of the value returned by the <code>GROUPING</code> function is Oracle <code>NUMBER</code>. Refer to the <code>SELECT</code> <link>group_by_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2182483</link> for a discussion of these terms. \n The Examples is: \n In the following example, which uses the sample tables <code>hr.departments</code> and <code>hr.employees</code>, if the <code>GROUPING</code> function returns 1 (indicating a superaggregate row rather than a regular row from the table), then the string \"All Jobs\" appears in the \"JOB\" column instead of the null that would otherwise appear: <code>SELECT DECODE(GROUPING(department_name), 1, 'ALL DEPARTMENTS', department_name) AS department, DECODE(GROUPING(job_id), 1, 'All Jobs', job_id) AS job, COUNT(*) \"Total Empl\", AVG(salary) * 12 \"Average Sal\" FROM employees e, departments d WHERE d.department_id = e.department_id GROUP BY ROLLUP (department_name, job_id) ORDER BY department, job; DEPARTMENT JOB Total Empl Average Sal ------------------------------ ---------- ---------- ----------- ALL DEPARTMENTS All Jobs 106 77481.0566 Accounting AC_ACCOUNT 1 99600 Accounting AC_MGR 1 144096 Accounting All Jobs 2 121848 Administration AD_ASST 1 52800 Administration All Jobs 1 52800 Executive AD_PRES 1 288000 Executive AD_VP 2 204000 Executive All Jobs 3 232000 Finance All Jobs 6 103216 Finance FI_ACCOUNT 5 95040 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions071.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "FIRST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c FIRST))) (function_argument ( )))",
        "description": "The Syntax is: \n first::= <eps> aggregate_function KEEP (DENSE_RANK FIRST ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) [ OVER ( [query_partition_clause] ) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>ORDER</code> <code>BY</code> clause and <code>OVER</code> clause \n The Purpose is: \n <code>FIRST</code> and <code>LAST</code> are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the <code>FIRST</code> or <code>LAST</code> with respect to a given sorting specification. If only one row ranks as <code>FIRST</code> or <code>LAST</code>, then the aggregate operates on the set with only one element. If you omit the <code>OVER</code> clause, then the <code>FIRST</code> and <code>LAST</code> functions are treated as aggregate functions. You can use these functions as analytic functions by specifying the <code>OVER</code> clause. The <code>query_partition_clause</code> is the only part of the <code>OVER</code> clause valid with these functions. If you include the <code>OVER</code> clause but omit the <code>query_partition_clause</code>, then the function is treated as an analytic function, but the window defined for analysis is the entire table. These functions take as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. When you need a value from the first or last row of a sorted group, but the needed value is not the sort key, the <code>FIRST</code> and <code>LAST</code> functions eliminate the need for self-joins or views and enable better performance. The <code>aggregate_function</code> argument is any one of the <code>MIN</code>, <code>MAX</code>, <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, <code>VARIANCE</code>, or <code>STDDEV</code> functions. It operates on values from the rows that rank either <code>FIRST</code> or <code>LAST</code>. If only one row ranks as <code>FIRST</code> or <code>LAST</code>, then the aggregate operates on a singleton (nonaggregate) set. The <code>KEEP</code> keyword is for semantic clarity. It qualifies <code>aggregate_function</code>, indicating that only the <code>FIRST</code> or <code>LAST</code> values of <code>aggregate_function</code> will be returned. <code>DENSE_RANK</code> <code>FIRST</code> or <code>DENSE_RANK</code> <code>LAST</code> indicates that Oracle Database will aggregate over only those rows with the minimum (<code>FIRST</code>) or the maximum (<code>LAST</code>) dense rank (also called olympic rank). See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>LAST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions083.htm#i1000905</link> Aggregate Example The following example returns, within each department of the sample table <code>hr.employees</code>, the minimum salary among the employees who make the lowest commission and the maximum salary among the employees who make the highest commission: <code>SELECT department_id, MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct) \"Worst\", MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct) \"Best\" FROM employees GROUP BY department_id ORDER BY department_id; DEPARTMENT_ID Worst Best ------------- ---------- ---------- 10 4400 4400 20 6000 13000 30 2500 11000 40 6500 6500 50 2100 8200 60 4200 9000 70 10000 10000 80 6100 14000 90 17000 24000 100 6900 12008 110 8300 12008 7000 7000 </code> Analytic Example The next example makes the same calculation as the previous example but returns the result for each employee within the department: <code>SELECT last_name, department_id, salary, MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct) OVER (PARTITION BY department_id) \"Worst\", MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct) OVER (PARTITION BY department_id) \"Best\" FROM employees ORDER BY department_id, salary, last_name; LAST_NAME DEPARTMENT_ID SALARY Worst Best ------------------- ------------- ---------- ---------- ---------- Whalen 10 4400 4400 4400 Fay 20 6000 6000 13000 Hartstein 20 13000 6000 13000 . . . Gietz 110 8300 8300 12008 Higgins 110 12008 8300 12008 Grant 7000 7000 7000 </code> ",
        "detail": "The Syntax is: \n first::= <eps> aggregate_function KEEP (DENSE_RANK FIRST ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) [ OVER ( [query_partition_clause] ) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>ORDER</code> <code>BY</code> clause and <code>OVER</code> clause \n The Purpose is: \n <code>FIRST</code> and <code>LAST</code> are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the <code>FIRST</code> or <code>LAST</code> with respect to a given sorting specification. If only one row ranks as <code>FIRST</code> or <code>LAST</code>, then the aggregate operates on the set with only one element. If you omit the <code>OVER</code> clause, then the <code>FIRST</code> and <code>LAST</code> functions are treated as aggregate functions. You can use these functions as analytic functions by specifying the <code>OVER</code> clause. The <code>query_partition_clause</code> is the only part of the <code>OVER</code> clause valid with these functions. If you include the <code>OVER</code> clause but omit the <code>query_partition_clause</code>, then the function is treated as an analytic function, but the window defined for analysis is the entire table. These functions take as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. When you need a value from the first or last row of a sorted group, but the needed value is not the sort key, the <code>FIRST</code> and <code>LAST</code> functions eliminate the need for self-joins or views and enable better performance. The <code>aggregate_function</code> argument is any one of the <code>MIN</code>, <code>MAX</code>, <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, <code>VARIANCE</code>, or <code>STDDEV</code> functions. It operates on values from the rows that rank either <code>FIRST</code> or <code>LAST</code>. If only one row ranks as <code>FIRST</code> or <code>LAST</code>, then the aggregate operates on a singleton (nonaggregate) set. The <code>KEEP</code> keyword is for semantic clarity. It qualifies <code>aggregate_function</code>, indicating that only the <code>FIRST</code> or <code>LAST</code> values of <code>aggregate_function</code> will be returned. <code>DENSE_RANK</code> <code>FIRST</code> or <code>DENSE_RANK</code> <code>LAST</code> indicates that Oracle Database will aggregate over only those rows with the minimum (<code>FIRST</code>) or the maximum (<code>LAST</code>) dense rank (also called olympic rank). See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>LAST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions083.htm#i1000905</link> Aggregate Example The following example returns, within each department of the sample table <code>hr.employees</code>, the minimum salary among the employees who make the lowest commission and the maximum salary among the employees who make the highest commission: <code>SELECT department_id, MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct) \"Worst\", MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct) \"Best\" FROM employees GROUP BY department_id ORDER BY department_id; DEPARTMENT_ID Worst Best ------------- ---------- ---------- 10 4400 4400 20 6000 13000 30 2500 11000 40 6500 6500 50 2100 8200 60 4200 9000 70 10000 10000 80 6100 14000 90 17000 24000 100 6900 12008 110 8300 12008 7000 7000 </code> Analytic Example The next example makes the same calculation as the previous example but returns the result for each employee within the department: <code>SELECT last_name, department_id, salary, MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct) OVER (PARTITION BY department_id) \"Worst\", MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct) OVER (PARTITION BY department_id) \"Best\" FROM employees ORDER BY department_id, salary, last_name; LAST_NAME DEPARTMENT_ID SALARY Worst Best ------------------- ------------- ---------- ---------- ---------- Whalen 10 4400 4400 4400 Fay 20 6000 6000 13000 Hartstein 20 13000 6000 13000 . . . Gietz 110 8300 8300 12008 Higgins 110 12008 8300 12008 Grant 7000 7000 7000 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions065.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NLS_LOWER",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NLS_LOWER))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NLS_LOWER(char [, 'nlsparam' ]) </eps> \n The Purpose is: \n <code>NLS_LOWER</code> returns <code>char</code>, with all letters lowercase. Both <code>char</code> and <code>'nlsparam'</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>char</code> is a character data type and a LOB if <code>char</code> is a LOB data type. The return string is in the same character set as <code>char</code>. The <code>'nlsparam'</code> can have the same form and serve the same purpose as in the <code>NLS_INITCAP</code> function. \n The Examples is: \n The following statement returns the lowercase form of the character string '<code>NOKTASINDA</code>' using the XTurkish linguistic sort sequence. The Turkish uppercase I becoming a small, dotless i. <code>SELECT NLS_LOWER('NOKTASINDA', 'NLS_SORT = XTurkish') \"Lowercase\" FROM DUAL; </code> ",
        "detail": "The Syntax is: \n <eps> NLS_LOWER(char [, 'nlsparam' ]) </eps> \n The Purpose is: \n <code>NLS_LOWER</code> returns <code>char</code>, with all letters lowercase. Both <code>char</code> and <code>'nlsparam'</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>char</code> is a character data type and a LOB if <code>char</code> is a LOB data type. The return string is in the same character set as <code>char</code>. The <code>'nlsparam'</code> can have the same form and serve the same purpose as in the <code>NLS_INITCAP</code> function. \n The Examples is: \n The following statement returns the lowercase form of the character string '<code>NOKTASINDA</code>' using the XTurkish linguistic sort sequence. The Turkish uppercase I becoming a small, dotless i. <code>SELECT NLS_LOWER('NOKTASINDA', 'NLS_SORT = XTurkish') \"Lowercase\" FROM DUAL; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions111.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TRUNC_(number)",
        "tree": "(general_element_part (id_expression (regular_id TRUNC_)) (function_argument ( )))",
        "description": "The Syntax is: \n trunc_number::= <eps> TRUNC(n1 [, n2 ]) </eps> \n The Purpose is: \n The <code>TRUNC</code> (number) function returns <code>n1</code> truncated to <code>n2</code> decimal places. If <code>n2</code> is omitted, then <code>n1</code> is truncated to 0 places. <code>n2</code> can be negative to truncate (make zero) <code>n2</code> digits left of the decimal point. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit <code>n2</code>, then the function returns the same data type as the numeric data type of the argument. If you include <code>n2</code>, then the function returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following examples truncate numbers: <code>SELECT TRUNC(15.79,1) \"Truncate\" FROM DUAL; Truncate ---------- 15.7 SELECT TRUNC(15.79,-1) \"Truncate\" FROM DUAL; Truncate ---------- 10 </code> ",
        "detail": "The Syntax is: \n trunc_number::= <eps> TRUNC(n1 [, n2 ]) </eps> \n The Purpose is: \n The <code>TRUNC</code> (number) function returns <code>n1</code> truncated to <code>n2</code> decimal places. If <code>n2</code> is omitted, then <code>n1</code> is truncated to 0 places. <code>n2</code> can be negative to truncate (make zero) <code>n2</code> digits left of the decimal point. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit <code>n2</code>, then the function returns the same data type as the numeric data type of the argument. If you include <code>n2</code>, then the function returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following examples truncate numbers: <code>SELECT TRUNC(15.79,1) \"Truncate\" FROM DUAL; Truncate ---------- 15.7 SELECT TRUNC(15.79,-1) \"Truncate\" FROM DUAL; Truncate ---------- 10 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions221.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLCOLATTVAL",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLCOLATTVAL))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLCOLATTVAL (value_expr [ AS { c_alias | EVALNAME value_expr } ] [, value_expr [ AS { c_alias | EVALNAME value_expr } ] ]... ) </eps> \n The Purpose is: \n <code>XMLColAttVal</code> creates an XML fragment and then expands the resulting XML so that each XML fragment has the name <code>column</code> with the attribute <code>name</code>. You can use the <code>AS</code> clause to change the value of the <code>name</code> attribute to something other than the column name. You can do this by specifying <code>c_alias</code>, which is a string literal, or by specifying <code>EVALNAME</code> <code>value_expr</code>. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the alias. The alias can be up to 4000 characters. You must specify a value for <code>value_expr</code>. If <code>value_expr</code> is null, then no element is returned. Restriction on XMLColAttVal You cannot specify an object type column for <code>value_expr</code>. \n The Examples is: \n The following example creates an <code>Emp</code> element for a subset of employees, with nested <code>employee_id</code>, <code>last_name</code>, and <code>salary</code> elements as the contents of <code>Emp</code>. Each nested element is named <code>column</code> and has a <code>name</code> attribute with the column name as the attribute value: <code>SELECT XMLELEMENT(\"Emp\", XMLCOLATTVAL(e.employee_id, e.last_name, e.salary)) \"Emp Element\" FROM employees e WHERE employee_id = 204; Emp Element -------------------------------------------------------------------- <Emp> <column name=\"EMPLOYEE_ID\">204</column> <column name=\"LAST_NAME\">Baer</column> <column name=\"SALARY\">10000</column> </Emp> </code> Refer to the example for <link>XMLFOREST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions244.htm#i1172404</link> to compare the output of these two functions. ",
        "detail": "The Syntax is: \n <eps> XMLCOLATTVAL (value_expr [ AS { c_alias | EVALNAME value_expr } ] [, value_expr [ AS { c_alias | EVALNAME value_expr } ] ]... ) </eps> \n The Purpose is: \n <code>XMLColAttVal</code> creates an XML fragment and then expands the resulting XML so that each XML fragment has the name <code>column</code> with the attribute <code>name</code>. You can use the <code>AS</code> clause to change the value of the <code>name</code> attribute to something other than the column name. You can do this by specifying <code>c_alias</code>, which is a string literal, or by specifying <code>EVALNAME</code> <code>value_expr</code>. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the alias. The alias can be up to 4000 characters. You must specify a value for <code>value_expr</code>. If <code>value_expr</code> is null, then no element is returned. Restriction on XMLColAttVal You cannot specify an object type column for <code>value_expr</code>. \n The Examples is: \n The following example creates an <code>Emp</code> element for a subset of employees, with nested <code>employee_id</code>, <code>last_name</code>, and <code>salary</code> elements as the contents of <code>Emp</code>. Each nested element is named <code>column</code> and has a <code>name</code> attribute with the column name as the attribute value: <code>SELECT XMLELEMENT(\"Emp\", XMLCOLATTVAL(e.employee_id, e.last_name, e.salary)) \"Emp Element\" FROM employees e WHERE employee_id = 204; Emp Element -------------------------------------------------------------------- <Emp> <column name=\"EMPLOYEE_ID\">204</column> <column name=\"LAST_NAME\">Baer</column> <column name=\"SALARY\">10000</column> </Emp> </code> Refer to the example for <link>XMLFOREST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions244.htm#i1172404</link> to compare the output of these two functions. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions238.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ASCII",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ASCII))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ASCII(char) </eps> \n The Purpose is: \n <code>ASCII</code> returns the decimal representation in the database character set of the first character of <code>char</code>. <code>char</code> can be of data type <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The value returned is of data type <code>NUMBER</code>. If your database character set is 7-bit ASCII, then this function returns an ASCII value. If your database character set is EBCDIC Code, then this function returns an EBCDIC value. There is no corresponding EBCDIC character function. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following example returns employees whose last names begin with the letter L, whose ASCII equivalent is 76: <code>SELECT last_name FROM employees WHERE ASCII(SUBSTR(last_name, 1, 1)) = 76 ORDER BY last_name; LAST_NAME ------------------------- Ladwig Landry Lee Livingston Lorentz </code> ",
        "detail": "The Syntax is: \n <eps> ASCII(char) </eps> \n The Purpose is: \n <code>ASCII</code> returns the decimal representation in the database character set of the first character of <code>char</code>. <code>char</code> can be of data type <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The value returned is of data type <code>NUMBER</code>. If your database character set is 7-bit ASCII, then this function returns an ASCII value. If your database character set is EBCDIC Code, then this function returns an EBCDIC value. There is no corresponding EBCDIC character function. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information \n The Examples is: \n The following example returns employees whose last names begin with the letter L, whose ASCII equivalent is 76: <code>SELECT last_name FROM employees WHERE ASCII(SUBSTR(last_name, 1, 1)) = 76 ORDER BY last_name; LAST_NAME ------------------------- Ladwig Landry Lee Livingston Lorentz </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions013.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PREDICTION_DETAILS",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PREDICTION_DETAILS))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PREDICTION_DETAILS ( [ schema . ] model mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with decision tree models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns an XML string containing model-specific information related to the scoring of the input row. In this release, the return value takes the following form: <code><Node id= \"integer\"/> </code> where <code>integer</code> is the identifier of a data mining tree node. The form of the output is subject to change. It may be enhanced to provide additional prediction information in future releases. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example uses all attributes from the <code>mining_data_apply_v</code> view that are relevant predictors for the <code>DT_SH_Clas_sample</code> decision tree model. For customers who work in technical support and are under age 25, it returns the tree node that results from scoring those records with the <code>DT_SH_Clas_sample</code> model. This example, and the prerequisite data mining operations, including the creation of the view, can be found in the demo files <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT cust_id, education, PREDICTION_DETAILS(DT_SH_Clas_sample using *) treenode FROM mining_data_apply_v WHERE occupation = 'TechSup' AND age < 25 ORDER BY cust_id; CUST_ID EDUCATION TREENODE ---------- --------------------- ------------------------- 100234 < Bach. <Node id=\"21\"/> 100320 < Bach. <Node id=\"21\"/> 100349 < Bach. <Node id=\"21\"/> 100419 < Bach. <Node id=\"21\"/> 100583 < Bach. <Node id=\"13\"/> 100657 HS-grad <Node id=\"21\"/> 101171 < Bach. <Node id=\"21\"/> 101225 < Bach. <Node id=\"21\"/> 101338 < Bach. <Node id=\"21\"/> 9 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> PREDICTION_DETAILS ( [ schema . ] model mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with decision tree models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns an XML string containing model-specific information related to the scoring of the input row. In this release, the return value takes the following form: <code><Node id= \"integer\"/> </code> where <code>integer</code> is the identifier of a data mining tree node. The form of the output is subject to change. It may be enhanced to provide additional prediction information in future releases. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example uses all attributes from the <code>mining_data_apply_v</code> view that are relevant predictors for the <code>DT_SH_Clas_sample</code> decision tree model. For customers who work in technical support and are under age 25, it returns the tree node that results from scoring those records with the <code>DT_SH_Clas_sample</code> model. This example, and the prerequisite data mining operations, including the creation of the view, can be found in the demo files <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT cust_id, education, PREDICTION_DETAILS(DT_SH_Clas_sample using *) treenode FROM mining_data_apply_v WHERE occupation = 'TechSup' AND age < 25 ORDER BY cust_id; CUST_ID EDUCATION TREENODE ---------- --------------------- ------------------------- 100234 < Bach. <Node id=\"21\"/> 100320 < Bach. <Node id=\"21\"/> 100349 < Bach. <Node id=\"21\"/> 100419 < Bach. <Node id=\"21\"/> 100583 < Bach. <Node id=\"13\"/> 100657 HS-grad <Node id=\"21\"/> 101171 < Bach. <Node id=\"21\"/> 101225 < Bach. <Node id=\"21\"/> 101338 < Bach. <Node id=\"21\"/> 9 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions135.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SOUNDEX",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SOUNDEX))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SOUNDEX(char) </eps> \n The Purpose is: \n <code>SOUNDEX</code> returns a character string containing the phonetic representation of <code>char</code>. This function lets you compare words that are spelled differently, but sound alike in English. The phonetic representation is defined in The Art of Computer Programming, Volume 3: Sorting and Searching, by Donald E. Knuth, as follows: Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y. Assign numbers to the remaining letters (after the first) as follows: <code>b, f, p, v = 1 c, g, j, k, q, s, x, z = 2 d, t = 3 l = 4 m, n = 5 r = 6 </code> If two or more letters with the same number were adjacent in the original name (before step 1), or adjacent except for any intervening h and w, then retain the first letter and omit rest of all the adjacent letters with same number. Return the first four bytes padded with 0. <code>char</code> can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The return value is the same data type as <code>char</code>. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example returns the employees whose last names are a phonetic representation of \"Smyth\": <code>SELECT last_name, first_name FROM hr.employees WHERE SOUNDEX(last_name) = SOUNDEX('SMYTHE') ORDER BY last_name, first_name; LAST_NAME FIRST_NAME ---------- ---------- Smith Lindsey Smith William </code> ",
        "detail": "The Syntax is: \n <eps> SOUNDEX(char) </eps> \n The Purpose is: \n <code>SOUNDEX</code> returns a character string containing the phonetic representation of <code>char</code>. This function lets you compare words that are spelled differently, but sound alike in English. The phonetic representation is defined in The Art of Computer Programming, Volume 3: Sorting and Searching, by Donald E. Knuth, as follows: Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y. Assign numbers to the remaining letters (after the first) as follows: <code>b, f, p, v = 1 c, g, j, k, q, s, x, z = 2 d, t = 3 l = 4 m, n = 5 r = 6 </code> If two or more letters with the same number were adjacent in the original name (before step 1), or adjacent except for any intervening h and w, then retain the first letter and omit rest of all the adjacent letters with same number. Return the first four bytes padded with 0. <code>char</code> can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The return value is the same data type as <code>char</code>. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example returns the employees whose last names are a phonetic representation of \"Smyth\": <code>SELECT last_name, first_name FROM hr.employees WHERE SOUNDEX(last_name) = SOUNDEX('SMYTHE') ORDER BY last_name, first_name; LAST_NAME FIRST_NAME ---------- ---------- Smith Lindsey Smith William </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions167.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_NCHAR_(number)",
        "tree": "(general_element_part (id_expression (regular_id TO_NCHAR_)) (function_argument ( )))",
        "description": "The Syntax is: \n to_nchar_number::= <eps> TO_NCHAR(n [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_NCHAR</code> (number) converts <code>n</code> to a string in the national character set. The value <code>n</code> can be of type <code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>. The function returns a value of the same type as the argument. The optional <code>fmt</code> and <code>'nlsparam'</code> corresponding to <code>n</code> can be of <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, <code>INTERVAL</code> <code>MONTH</code> <code>TO</code> <code>YEAR</code>, or <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> data type. See Also: <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> \n The Examples is: \n The following example converts the <code>customer_id</code> values from the sample table <code>oe.orders</code> to the national character set: <code>SELECT TO_NCHAR(customer_id) \"NCHAR_Customer_ID\" FROM orders WHERE order_status > 9 ORDER BY \"NCHAR_Customer_ID\"; NCHAR_Customer_ID ---------------------------------------- 102 103 148 148 149 </code> ",
        "detail": "The Syntax is: \n to_nchar_number::= <eps> TO_NCHAR(n [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_NCHAR</code> (number) converts <code>n</code> to a string in the national character set. The value <code>n</code> can be of type <code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>. The function returns a value of the same type as the argument. The optional <code>fmt</code> and <code>'nlsparam'</code> corresponding to <code>n</code> can be of <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, <code>INTERVAL</code> <code>MONTH</code> <code>TO</code> <code>YEAR</code>, or <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code> data type. See Also: <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> \n The Examples is: \n The following example converts the <code>customer_id</code> values from the sample table <code>oe.orders</code> to the national character set: <code>SELECT TO_NCHAR(customer_id) \"NCHAR_Customer_ID\" FROM orders WHERE order_status > 9 ORDER BY \"NCHAR_Customer_ID\"; NCHAR_Customer_ID ---------------------------------------- 102 103 148 148 149 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions209.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CLUSTER_ID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CLUSTER_ID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CLUSTER_ID ( [ schema . ] model mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with clustering models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns the cluster identifier of the predicted cluster with the highest probability for the set of predictors specified in the <code>mining_attribute_clause</code>. The value returned is an Oracle <code>NUMBER</code>. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the clusters into which customers of a given dataset have been grouped. This example, and the prerequisite data mining operations, including the creation of the <code>km_sh_clus_sample</code> model and the <code>mining_data_apply_v</code> view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmkmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT CLUSTER_ID(km_sh_clus_sample USING *) AS clus, COUNT(*) AS cnt FROM mining_data_apply_v GROUP BY CLUSTER_ID(km_sh_clus_sample USING *) ORDER BY cnt DESC; CLUS CNT ---------- ---------- 2 580 10 216 6 186 8 115 19 110 12 101 18 81 16 39 17 38 14 34 10 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> CLUSTER_ID ( [ schema . ] model mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with clustering models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns the cluster identifier of the predicted cluster with the highest probability for the set of predictors specified in the <code>mining_attribute_clause</code>. The value returned is an Oracle <code>NUMBER</code>. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the clusters into which customers of a given dataset have been grouped. This example, and the prerequisite data mining operations, including the creation of the <code>km_sh_clus_sample</code> model and the <code>mining_data_apply_v</code> view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmkmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT CLUSTER_ID(km_sh_clus_sample USING *) AS clus, COUNT(*) AS cnt FROM mining_data_apply_v GROUP BY CLUSTER_ID(km_sh_clus_sample USING *) ORDER BY cnt DESC; CLUS CNT ---------- ---------- 2 580 10 216 6 186 8 115 19 110 12 101 18 81 16 39 17 38 14 34 10 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions027.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "COSH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c COSH))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> COSH(n) </eps> \n The Purpose is: \n <code>COSH</code> returns the hyperbolic cosine of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the hyperbolic cosine of zero: <code>SELECT COSH(0) \"Hyperbolic cosine of 0\" FROM DUAL; Hyperbolic cosine of 0 ---------------------- 1 </code> ",
        "detail": "The Syntax is: \n <eps> COSH(n) </eps> \n The Purpose is: \n <code>COSH</code> returns the hyperbolic cosine of <code>n</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the hyperbolic cosine of zero: <code>SELECT COSH(0) \"Hyperbolic cosine of 0\" FROM DUAL; Hyperbolic cosine of 0 ---------------------- 1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions038.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SIGN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SIGN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SIGN(n) </eps> \n The Purpose is: \n <code>SIGN</code> returns the sign of <code>n</code>. This function takes as an argument any numeric data type, or any nonnumeric data type that can be implicitly converted to <code>NUMBER</code>, and returns <code>NUMBER</code>. For value of <code>NUMBER</code> type, the sign is: -1 if <code>n</code><0 0 if <code>n</code>=0 1 if <code>n</code>>0 For binary floating-point numbers (<code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code>), this function returns the sign bit of the number. The sign bit is: -1 if <code>n</code><0 +1 if <code>n</code>>=0 or <code>n</code>=<code>NaN</code> \n The Examples is: \n The following example indicates that the argument of the function (<code>-15</code>) is <0: <code>SELECT SIGN(-15) \"Sign\" FROM DUAL; Sign ---------- -1 </code> ",
        "detail": "The Syntax is: \n <eps> SIGN(n) </eps> \n The Purpose is: \n <code>SIGN</code> returns the sign of <code>n</code>. This function takes as an argument any numeric data type, or any nonnumeric data type that can be implicitly converted to <code>NUMBER</code>, and returns <code>NUMBER</code>. For value of <code>NUMBER</code> type, the sign is: -1 if <code>n</code><0 0 if <code>n</code>=0 1 if <code>n</code>>0 For binary floating-point numbers (<code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code>), this function returns the sign bit of the number. The sign bit is: -1 if <code>n</code><0 +1 if <code>n</code>>=0 or <code>n</code>=<code>NaN</code> \n The Examples is: \n The following example indicates that the argument of the function (<code>-15</code>) is <0: <code>SELECT SIGN(-15) \"Sign\" FROM DUAL; Sign ---------- -1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions164.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ORA_DST_CONVERT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ORA_DST_CONVERT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ORA_DST_CONVERT(datetime_expr [, integer [, integer ]]) </eps> \n The Purpose is: \n <code>ORA_DST_CONVERT</code> is useful when you are changing the time zone data file for your database. The function lets you specify error handling for a specified datetime expression. For <code>datetime_expr</code>, specify a datetime expression that resolves to a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value or a <code>VARRAY</code> object that contains <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values. The optional second argument specifies handling of \"duplicate time\" errors. Specify <code>0</code> (false) to suppress the error by returning the source datetime value. This is the default. Specify <code>1</code> (true) to allow the database to return the duplicate time error. The optional third argument specifies handling of \"nonexisting time\" errors. Specify <code>0</code> (false) to suppress the error by returning the source datetime value. This is the default. Specify <code>1</code> (true) to allow the database to return the nonexisting time error. If no error occurs, this function returns a value of the same data type as <code>datetime_expr</code> (a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value or a <code>VARRAY</code> object that contains <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values). The returned datetime value when interpreted with the new time zone file corresponds to <code>datetime_expr</code> interpreted with the old time zone file. This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the <code>DBMS_DST</code>.<code>BEGIN_UPGRADE</code> and the <code>DBMS_DST</code>.<code>END_UPGRADE</code> procedures. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm#NLSPG259</link> for more information on time zone datafiles and on how Oracle Database handles daylight saving time, and <link>Oracle Database PL/SQL Packages and Types Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_dst.htm#ARPLS234</link> for information on the <code>DBMS_DST</code> package ",
        "detail": "The Syntax is: \n <eps> ORA_DST_CONVERT(datetime_expr [, integer [, integer ]]) </eps> \n The Purpose is: \n <code>ORA_DST_CONVERT</code> is useful when you are changing the time zone data file for your database. The function lets you specify error handling for a specified datetime expression. For <code>datetime_expr</code>, specify a datetime expression that resolves to a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value or a <code>VARRAY</code> object that contains <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values. The optional second argument specifies handling of \"duplicate time\" errors. Specify <code>0</code> (false) to suppress the error by returning the source datetime value. This is the default. Specify <code>1</code> (true) to allow the database to return the duplicate time error. The optional third argument specifies handling of \"nonexisting time\" errors. Specify <code>0</code> (false) to suppress the error by returning the source datetime value. This is the default. Specify <code>1</code> (true) to allow the database to return the nonexisting time error. If no error occurs, this function returns a value of the same data type as <code>datetime_expr</code> (a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value or a <code>VARRAY</code> object that contains <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values). The returned datetime value when interpreted with the new time zone file corresponds to <code>datetime_expr</code> interpreted with the old time zone file. This function can be issued only when changing the time zone data file of the database and upgrading the timestamp with the time zone data, and only between the execution of the <code>DBMS_DST</code>.<code>BEGIN_UPGRADE</code> and the <code>DBMS_DST</code>.<code>END_UPGRADE</code> procedures. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm#NLSPG259</link> for more information on time zone datafiles and on how Oracle Database handles daylight saving time, and <link>Oracle Database PL/SQL Packages and Types Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_dst.htm#ARPLS234</link> for information on the <code>DBMS_DST</code> package ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions122.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "EXTRACT_(XML)",
        "tree": "(general_element_part (id_expression (regular_id EXTRACT_)) (function_argument ( )))",
        "description": "Note: The <code>EXTRACT</code> (XML) function is deprecated. It is still supported for backward compatibility. However, Oracle recommends that you use the <code>XMLQUERY</code> function instead. See <link>XMLQUERY&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions249.htm#CIHHFFGG</link> for more information. The Syntax is: \n extract_xml::= <eps> EXTRACT(XMLType_instance, XPath_string [, namespace_string ]) </eps> \n The Purpose is: \n <code>EXTRACT</code> (XML) is similar to the <code>EXISTSNODE</code> function. It applies a <code>VARCHAR2</code> XPath string and returns an <code>XMLType</code> instance containing an XML fragment. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. The optional <code>namespace_string</code> is required if the XML you are handling uses a namespace prefix. This argument must resolve to a <code>VARCHAR2</code> value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s). \n The Examples is: \n The following example extracts the value of the <code>/Warehouse/Dock</code> node of the XML path of the <code>warehouse_spec</code> column in the sample table <code>oe.warehouses</code>: <code>SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks') \"Number of Docks\" FROM warehouses WHERE warehouse_spec IS NOT NULL ORDER BY warehouse_name; WAREHOUSE_NAME Number of Docks ------------------------- ------------------------- New Jersey San Francisco <Docks>1</Docks> Seattle, Washington <Docks>3</Docks> Southlake, Texas <Docks>2</Docks> </code> Compare this example with the example for <link>EXTRACTVALUE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions061.htm#i1131042</link>, which returns the scalar value of the XML fragment. ",
        "detail": "Note: The <code>EXTRACT</code> (XML) function is deprecated. It is still supported for backward compatibility. However, Oracle recommends that you use the <code>XMLQUERY</code> function instead. See <link>XMLQUERY&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions249.htm#CIHHFFGG</link> for more information. The Syntax is: \n extract_xml::= <eps> EXTRACT(XMLType_instance, XPath_string [, namespace_string ]) </eps> \n The Purpose is: \n <code>EXTRACT</code> (XML) is similar to the <code>EXISTSNODE</code> function. It applies a <code>VARCHAR2</code> XPath string and returns an <code>XMLType</code> instance containing an XML fragment. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. The optional <code>namespace_string</code> is required if the XML you are handling uses a namespace prefix. This argument must resolve to a <code>VARCHAR2</code> value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s). \n The Examples is: \n The following example extracts the value of the <code>/Warehouse/Dock</code> node of the XML path of the <code>warehouse_spec</code> column in the sample table <code>oe.warehouses</code>: <code>SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks') \"Number of Docks\" FROM warehouses WHERE warehouse_spec IS NOT NULL ORDER BY warehouse_name; WAREHOUSE_NAME Number of Docks ------------------------- ------------------------- New Jersey San Francisco <Docks>1</Docks> Seattle, Washington <Docks>3</Docks> Southlake, Texas <Docks>2</Docks> </code> Compare this example with the example for <link>EXTRACTVALUE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions061.htm#i1131042</link>, which returns the scalar value of the XML fragment. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions060.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_BINARY_DOUBLE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_BINARY_DOUBLE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_BINARY_DOUBLE(expr [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_BINARY_DOUBLE</code> returns a double-precision floating-point number. <code>expr</code> can be a character string or a numeric value of type <code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>. If <code>expr</code> is <code>BINARY_DOUBLE</code>, then the function returns <code>expr</code>. The optional '<code>fmt</code>' and '<code>nlsparam</code>' arguments are valid only if <code>expr</code> is a character string. They serve the same purpose as for the <code>TO_CHAR</code> (number) function. The case-insensitive string '<code>INF</code>' is converted to positive infinity. The case-insensitive string '-<code>INF</code>' is converted to negative identity. The case-insensitive string '<code>NaN</code>' is converted to <code>NaN</code> (not a number). You cannot use a floating-point number format element (<code>F</code>, <code>f</code>, <code>D</code>, or <code>d</code>) in a character string <code>expr</code>. Conversions from character strings or <code>NUMBER</code> to <code>BINARY_DOUBLE</code> can be inexact, because the <code>NUMBER</code> and character types use decimal precision to represent the numeric value, and <code>BINARY_DOUBLE</code> uses binary precision. Conversions from <code>BINARY_FLOAT</code> to <code>BINARY_DOUBLE</code> are exact. See Also: <link>TO_CHAR (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm#i79330</link> and <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> \n The Examples is: \n The examples that follow are based on a table with three columns, each with a different numeric data type: <code>CREATE TABLE float_point_demo (dec_num NUMBER(10,2), bin_double BINARY_DOUBLE, bin_float BINARY_FLOAT); INSERT INTO float_point_demo VALUES (1234.56,1234.56,1234.56); SELECT * FROM float_point_demo; DEC_NUM BIN_DOUBLE BIN_FLOAT ---------- ---------- ---------- 1234.56 1.235E+003 1.235E+003 </code> The following example converts a value of data type <code>NUMBER</code> to a value of data type <code>BINARY_DOUBLE</code>: <code>SELECT dec_num, TO_BINARY_DOUBLE(dec_num) FROM float_point_demo; DEC_NUM TO_BINARY_DOUBLE(DEC_NUM) ---------- ------------------------- 1234.56 1.235E+003 </code> The following example compares extracted dump information from the <code>dec_num</code> and <code>bin_double</code> columns: <code>SELECT DUMP(dec_num) \"Decimal\", DUMP(bin_double) \"Double\" FROM float_point_demo; Decimal Double --------------------------- --------------------------------------------- Typ=2 Len=4: 194,13,35,57 Typ=101 Len=8: 192,147,74,61,112,163,215,10 </code> ",
        "detail": "The Syntax is: \n <eps> TO_BINARY_DOUBLE(expr [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_BINARY_DOUBLE</code> returns a double-precision floating-point number. <code>expr</code> can be a character string or a numeric value of type <code>NUMBER</code>, <code>BINARY_FLOAT</code>, or <code>BINARY_DOUBLE</code>. If <code>expr</code> is <code>BINARY_DOUBLE</code>, then the function returns <code>expr</code>. The optional '<code>fmt</code>' and '<code>nlsparam</code>' arguments are valid only if <code>expr</code> is a character string. They serve the same purpose as for the <code>TO_CHAR</code> (number) function. The case-insensitive string '<code>INF</code>' is converted to positive infinity. The case-insensitive string '-<code>INF</code>' is converted to negative identity. The case-insensitive string '<code>NaN</code>' is converted to <code>NaN</code> (not a number). You cannot use a floating-point number format element (<code>F</code>, <code>f</code>, <code>D</code>, or <code>d</code>) in a character string <code>expr</code>. Conversions from character strings or <code>NUMBER</code> to <code>BINARY_DOUBLE</code> can be inexact, because the <code>NUMBER</code> and character types use decimal precision to represent the numeric value, and <code>BINARY_DOUBLE</code> uses binary precision. Conversions from <code>BINARY_FLOAT</code> to <code>BINARY_DOUBLE</code> are exact. See Also: <link>TO_CHAR (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm#i79330</link> and <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> \n The Examples is: \n The examples that follow are based on a table with three columns, each with a different numeric data type: <code>CREATE TABLE float_point_demo (dec_num NUMBER(10,2), bin_double BINARY_DOUBLE, bin_float BINARY_FLOAT); INSERT INTO float_point_demo VALUES (1234.56,1234.56,1234.56); SELECT * FROM float_point_demo; DEC_NUM BIN_DOUBLE BIN_FLOAT ---------- ---------- ---------- 1234.56 1.235E+003 1.235E+003 </code> The following example converts a value of data type <code>NUMBER</code> to a value of data type <code>BINARY_DOUBLE</code>: <code>SELECT dec_num, TO_BINARY_DOUBLE(dec_num) FROM float_point_demo; DEC_NUM TO_BINARY_DOUBLE(DEC_NUM) ---------- ------------------------- 1234.56 1.235E+003 </code> The following example compares extracted dump information from the <code>dec_num</code> and <code>bin_double</code> columns: <code>SELECT DUMP(dec_num) \"Decimal\", DUMP(bin_double) \"Double\" FROM float_point_demo; Decimal Double --------------------------- --------------------------------------------- Typ=2 Len=4: 194,13,35,57 Typ=101 Len=8: 192,147,74,61,112,163,215,10 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions196.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "EXTRACT_(datetime)",
        "tree": "(general_element_part (id_expression (regular_id EXTRACT_)) (function_argument ( )))",
        "description": "The Syntax is: \n extract_datetime::= <eps> EXTRACT( { YEAR | MONTH | DAY | HOUR | MINUTE | SECOND | TIMEZONE_HOUR | TIMEZONE_MINUTE | TIMEZONE_REGION | TIMEZONE_ABBR } FROM { expr } ) </eps> \n The Purpose is: \n <code>EXTRACT</code> extracts and returns the value of a specified datetime field from a datetime or interval expression. The <code>expr</code> can be any expression that evaluates to a datetime or interval data type compatible with the requested field: If <code>YEAR</code> or <code>MONTH</code> is requested, then <code>expr</code> must evaluate to an expression of data type <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, or <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code>. If <code>DAY</code> is requested, then <code>expr</code> must evaluate to an expression of data type <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, or <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>. If <code>HOUR</code>, <code>MINUTE</code>, or <code>SECOND</code> is requested, then <code>expr</code> must evaluate to an expression of data type <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, or <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>. <code>DATE</code> is not valid here, because Oracle Database treats it as ANSI <code>DATE</code> data type, which has no time fields. If <code>TIMEZONE_HOUR</code>, <code>TIMEZONE_MINUTE</code>, <code>TIMEZONE_ABBR</code>, <code>TIMEZONE_REGION</code>, or <code>TIMEZONE_OFFSET</code> is requested, then <code>expr</code> must evaluate to an expression of data type <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> or <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>. <code>EXTRACT</code> interprets <code>expr</code> as an ANSI datetime data type. For example, <code>EXTRACT</code> treats <code>DATE</code> not as legacy Oracle <code>DATE</code> but as ANSI <code>DATE</code>, without time elements. Therefore, you can extract only <code>YEAR</code>, <code>MONTH</code>, and <code>DAY</code> from a <code>DATE</code> value. Likewise, you can extract <code>TIMEZONE_HOUR</code> and <code>TIMEZONE_MINUTE</code> only from the <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> data type. When you specify <code>TIMEZONE_REGION</code> or <code>TIMEZONE_ABBR</code> (abbreviation), the value returned is a <code>VARCHAR2</code> string containing the appropriate time zone region name or abbreviation. When you specify any of the other datetime fields, the value returned is an integer value of <code>NUMBER</code> data type representing the datetime value in the Gregorian calendar. When extracting from a datetime with a time zone value, the value returned is in UTC. For a listing of time zone region names and their corresponding abbreviations, query the <code>V$TIMEZONE_NAMES</code> dynamic performance view. This function can be very useful for manipulating datetime field values in very large tables, as shown in the first example below. Note: Time zone region names are needed by the daylight saving feature. These names are stored in two types of time zone files: one large and one small. One of these files is the default file, depending on your environment and the release of Oracle Database you are using. For more information regarding time zone files and names, see <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG014</link>. Some combinations of datetime field and datetime or interval value expression result in ambiguity. In these cases, Oracle Database returns <code>UNKNOWN</code> (see the examples that follow for additional information). See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG0141</link> for a complete listing of the time zone region names in both files <link>\"Datetime/Interval Arithmetic\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i48042</link> for a description of <code>datetime_value_expr</code> and <code>interval_value_expr</code> <link>Oracle Database Reference&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e40402/dynviews_part.htm#REFRN003</link> for information on the dynamic performance views \n The Examples is: \n The following example returns from the <code>oe.orders</code> table the number of orders placed in each month: <code>SELECT EXTRACT(month FROM order_date) \"Month\", COUNT(order_date) \"No. of Orders\" FROM orders GROUP BY EXTRACT(month FROM order_date) ORDER BY \"No. of Orders\" DESC, \"Month\"; Month No. of Orders ---------- ------------- 11 15 6 14 7 14 3 11 5 10 2 9 9 9 8 7 10 6 1 5 12 4 4 1 12 rows selected. </code> The following example returns the year 1998. <code>SELECT EXTRACT(YEAR FROM DATE '1998-03-07') FROM DUAL; EXTRACT(YEARFROMDATE'1998-03-07') --------------------------------- 1998 </code> The following example selects from the sample table <code>hr.employees</code> all employees who were hired after 2007: <code>SELECT last_name, employee_id, hire_date FROM employees WHERE EXTRACT(YEAR FROM TO_DATE(hire_date, 'DD-MON-RR')) > 2007 ORDER BY hire_date; LAST_NAME EMPLOYEE_ID HIRE_DATE ------------------------- ----------- --------- Johnson 179 04-JAN-08 Grant 199 13-JAN-08 Marvins 164 24-JAN-08 . . . </code> The following example results in ambiguity, so Oracle returns <code>UNKNOWN</code>: <code>SELECT EXTRACT(TIMEZONE_REGION FROM TIMESTAMP '1999-01-01 10:00:00 -08:00') FROM DUAL; EXTRACT(TIMEZONE_REGIONFROMTIMESTAMP'1999-01-0110:00:00-08:00') ---------------------------------------------------------------- UNKNOWN </code> The ambiguity arises because the time zone numerical offset is provided in the expression, and that numerical offset may map to more than one time zone region name. ",
        "detail": "The Syntax is: \n extract_datetime::= <eps> EXTRACT( { YEAR | MONTH | DAY | HOUR | MINUTE | SECOND | TIMEZONE_HOUR | TIMEZONE_MINUTE | TIMEZONE_REGION | TIMEZONE_ABBR } FROM { expr } ) </eps> \n The Purpose is: \n <code>EXTRACT</code> extracts and returns the value of a specified datetime field from a datetime or interval expression. The <code>expr</code> can be any expression that evaluates to a datetime or interval data type compatible with the requested field: If <code>YEAR</code> or <code>MONTH</code> is requested, then <code>expr</code> must evaluate to an expression of data type <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, or <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code>. If <code>DAY</code> is requested, then <code>expr</code> must evaluate to an expression of data type <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, or <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>. If <code>HOUR</code>, <code>MINUTE</code>, or <code>SECOND</code> is requested, then <code>expr</code> must evaluate to an expression of data type <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, or <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>. <code>DATE</code> is not valid here, because Oracle Database treats it as ANSI <code>DATE</code> data type, which has no time fields. If <code>TIMEZONE_HOUR</code>, <code>TIMEZONE_MINUTE</code>, <code>TIMEZONE_ABBR</code>, <code>TIMEZONE_REGION</code>, or <code>TIMEZONE_OFFSET</code> is requested, then <code>expr</code> must evaluate to an expression of data type <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> or <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>. <code>EXTRACT</code> interprets <code>expr</code> as an ANSI datetime data type. For example, <code>EXTRACT</code> treats <code>DATE</code> not as legacy Oracle <code>DATE</code> but as ANSI <code>DATE</code>, without time elements. Therefore, you can extract only <code>YEAR</code>, <code>MONTH</code>, and <code>DAY</code> from a <code>DATE</code> value. Likewise, you can extract <code>TIMEZONE_HOUR</code> and <code>TIMEZONE_MINUTE</code> only from the <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> data type. When you specify <code>TIMEZONE_REGION</code> or <code>TIMEZONE_ABBR</code> (abbreviation), the value returned is a <code>VARCHAR2</code> string containing the appropriate time zone region name or abbreviation. When you specify any of the other datetime fields, the value returned is an integer value of <code>NUMBER</code> data type representing the datetime value in the Gregorian calendar. When extracting from a datetime with a time zone value, the value returned is in UTC. For a listing of time zone region names and their corresponding abbreviations, query the <code>V$TIMEZONE_NAMES</code> dynamic performance view. This function can be very useful for manipulating datetime field values in very large tables, as shown in the first example below. Note: Time zone region names are needed by the daylight saving feature. These names are stored in two types of time zone files: one large and one small. One of these files is the default file, depending on your environment and the release of Oracle Database you are using. For more information regarding time zone files and names, see <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG014</link>. Some combinations of datetime field and datetime or interval value expression result in ambiguity. In these cases, Oracle Database returns <code>UNKNOWN</code> (see the examples that follow for additional information). See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG0141</link> for a complete listing of the time zone region names in both files <link>\"Datetime/Interval Arithmetic\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i48042</link> for a description of <code>datetime_value_expr</code> and <code>interval_value_expr</code> <link>Oracle Database Reference&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e40402/dynviews_part.htm#REFRN003</link> for information on the dynamic performance views \n The Examples is: \n The following example returns from the <code>oe.orders</code> table the number of orders placed in each month: <code>SELECT EXTRACT(month FROM order_date) \"Month\", COUNT(order_date) \"No. of Orders\" FROM orders GROUP BY EXTRACT(month FROM order_date) ORDER BY \"No. of Orders\" DESC, \"Month\"; Month No. of Orders ---------- ------------- 11 15 6 14 7 14 3 11 5 10 2 9 9 9 8 7 10 6 1 5 12 4 4 1 12 rows selected. </code> The following example returns the year 1998. <code>SELECT EXTRACT(YEAR FROM DATE '1998-03-07') FROM DUAL; EXTRACT(YEARFROMDATE'1998-03-07') --------------------------------- 1998 </code> The following example selects from the sample table <code>hr.employees</code> all employees who were hired after 2007: <code>SELECT last_name, employee_id, hire_date FROM employees WHERE EXTRACT(YEAR FROM TO_DATE(hire_date, 'DD-MON-RR')) > 2007 ORDER BY hire_date; LAST_NAME EMPLOYEE_ID HIRE_DATE ------------------------- ----------- --------- Johnson 179 04-JAN-08 Grant 199 13-JAN-08 Marvins 164 24-JAN-08 . . . </code> The following example results in ambiguity, so Oracle returns <code>UNKNOWN</code>: <code>SELECT EXTRACT(TIMEZONE_REGION FROM TIMESTAMP '1999-01-01 10:00:00 -08:00') FROM DUAL; EXTRACT(TIMEZONE_REGIONFROMTIMESTAMP'1999-01-0110:00:00-08:00') ---------------------------------------------------------------- UNKNOWN </code> The ambiguity arises because the time zone numerical offset is provided in the expression, and that numerical offset may map to more than one time zone region name. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions059.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PERCENTILE_CONT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PERCENTILE_CONT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PERCENTILE_CONT(expr) WITHIN GROUP (ORDER BY expr [ DESC | ASC ]) [ OVER (query_partition_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>OVER</code> clause \n The Purpose is: \n <code>PERCENTILE_CONT</code> is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion The first <code>expr</code> must evaluate to a numeric value between 0 and 1, because it is a percentile value. This <code>expr</code> must be constant within each aggregation group. The <code>ORDER</code> <code>BY</code> clause takes a single expression that must be a numeric or datetime value, as these are the types over which Oracle can perform interpolation. The result of <code>PERCENTILE_CONT</code> is computed by linear interpolation between values after ordering them. Using the percentile value (P) and the number of rows (N) in the aggregation group, you can compute the row number you are interested in after ordering the rows with respect to the sort specification. This row number (RN) is computed according to the formula <code>RN</code> <code>=</code> <code>(1+(P*(N-1))</code>. The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers <code>CRN</code> <code>=</code> <code>CEILING(RN)</code> and <code>FRN</code> <code>=</code> <code>FLOOR(RN)</code>. The final result will be: <code> If (CRN = FRN = RN) then the result is (value of expression from row at RN) Otherwise the result is (CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN) </code> You can use the <code>PERCENTILE_CONT</code> function as an analytic function. You can specify only the <code>query_partitioning_clause</code> in its <code>OVER</code> clause. It returns, for each row, the value that would fall into the specified percentile among a set of values within each partition. The <code>MEDIAN</code> function is a specific case of <code>PERCENTILE_CONT</code> where the percentile value defaults to 0.5. For more information, refer to <link>MEDIAN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions099.htm#i1279886</link>. Aggregate Example The following example computes the median salary in each department: <code>SELECT department_id, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary DESC) \"Median cont\", PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY salary DESC) \"Median disc\" FROM employees GROUP BY department_id ORDER BY department_id; DEPARTMENT_ID Median cont Median disc ------------- ----------- ----------- 10 4400 4400 20 9500 13000 30 2850 2900 40 6500 6500 50 3100 3100 60 4800 4800 70 10000 10000 80 8900 9000 90 17000 17000 100 8000 8200 110 10154 12008 7000 7000 </code> <code>PERCENTILE_CONT</code> and <code>PERCENTILE_DISC</code> may return different results. <code>PERCENTILE_CONT</code> returns a computed result after doing linear interpolation. <code>PERCENTILE_DISC</code> simply returns a value from the set of values that are aggregated over. When the percentile value is 0.5, as in this example, <code>PERCENTILE_CONT</code> returns the average of the two middle values for groups with even number of elements, whereas <code>PERCENTILE_DISC</code> returns the value of the first one among the two middle values. For aggregate groups with an odd number of elements, both functions return the value of the middle element. Analytic Example In the following example, the median for Department 60 is 4800, which has a corresponding percentile (<code>Percent_Rank</code>) of 0.5. None of the salaries in Department 30 have a percentile of 0.5, so the median value must be interpolated between 2900 (percentile 0.4) and 2800 (percentile 0.6), which evaluates to 2850. <code>SELECT last_name, salary, department_id, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary DESC) OVER (PARTITION BY department_id) \"Percentile_Cont\", PERCENT_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) \"Percent_Rank\" FROM employees WHERE department_id IN (30, 60) ORDER BY last_name, salary, department_id; LAST_NAME SALARY DEPARTMENT_ID Percentile_Cont Percent_Rank ------------------------- ---------- ------------- --------------- ------------ Austin 4800 60 4800 .5 Baida 2900 30 2850 .4 Colmenares 2500 30 2850 1 Ernst 6000 60 4800 .25 Himuro 2600 30 2850 .8 Hunold 9000 60 4800 0 Khoo 3100 30 2850 .2 Lorentz 4200 60 4800 1 Pataballa 4800 60 4800 .5 Raphaely 11000 30 2850 0 Tobias 2800 30 2850 .6 </code> ",
        "detail": "The Syntax is: \n <eps> PERCENTILE_CONT(expr) WITHIN GROUP (ORDER BY expr [ DESC | ASC ]) [ OVER (query_partition_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>OVER</code> clause \n The Purpose is: \n <code>PERCENTILE_CONT</code> is an inverse distribution function that assumes a continuous distribution model. It takes a percentile value and a sort specification, and returns an interpolated value that would fall into that percentile value with respect to the sort specification. Nulls are ignored in the calculation. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion The first <code>expr</code> must evaluate to a numeric value between 0 and 1, because it is a percentile value. This <code>expr</code> must be constant within each aggregation group. The <code>ORDER</code> <code>BY</code> clause takes a single expression that must be a numeric or datetime value, as these are the types over which Oracle can perform interpolation. The result of <code>PERCENTILE_CONT</code> is computed by linear interpolation between values after ordering them. Using the percentile value (P) and the number of rows (N) in the aggregation group, you can compute the row number you are interested in after ordering the rows with respect to the sort specification. This row number (RN) is computed according to the formula <code>RN</code> <code>=</code> <code>(1+(P*(N-1))</code>. The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers <code>CRN</code> <code>=</code> <code>CEILING(RN)</code> and <code>FRN</code> <code>=</code> <code>FLOOR(RN)</code>. The final result will be: <code> If (CRN = FRN = RN) then the result is (value of expression from row at RN) Otherwise the result is (CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN) </code> You can use the <code>PERCENTILE_CONT</code> function as an analytic function. You can specify only the <code>query_partitioning_clause</code> in its <code>OVER</code> clause. It returns, for each row, the value that would fall into the specified percentile among a set of values within each partition. The <code>MEDIAN</code> function is a specific case of <code>PERCENTILE_CONT</code> where the percentile value defaults to 0.5. For more information, refer to <link>MEDIAN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions099.htm#i1279886</link>. Aggregate Example The following example computes the median salary in each department: <code>SELECT department_id, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary DESC) \"Median cont\", PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY salary DESC) \"Median disc\" FROM employees GROUP BY department_id ORDER BY department_id; DEPARTMENT_ID Median cont Median disc ------------- ----------- ----------- 10 4400 4400 20 9500 13000 30 2850 2900 40 6500 6500 50 3100 3100 60 4800 4800 70 10000 10000 80 8900 9000 90 17000 17000 100 8000 8200 110 10154 12008 7000 7000 </code> <code>PERCENTILE_CONT</code> and <code>PERCENTILE_DISC</code> may return different results. <code>PERCENTILE_CONT</code> returns a computed result after doing linear interpolation. <code>PERCENTILE_DISC</code> simply returns a value from the set of values that are aggregated over. When the percentile value is 0.5, as in this example, <code>PERCENTILE_CONT</code> returns the average of the two middle values for groups with even number of elements, whereas <code>PERCENTILE_DISC</code> returns the value of the first one among the two middle values. For aggregate groups with an odd number of elements, both functions return the value of the middle element. Analytic Example In the following example, the median for Department 60 is 4800, which has a corresponding percentile (<code>Percent_Rank</code>) of 0.5. None of the salaries in Department 30 have a percentile of 0.5, so the median value must be interpolated between 2900 (percentile 0.4) and 2800 (percentile 0.6), which evaluates to 2850. <code>SELECT last_name, salary, department_id, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary DESC) OVER (PARTITION BY department_id) \"Percentile_Cont\", PERCENT_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) \"Percent_Rank\" FROM employees WHERE department_id IN (30, 60) ORDER BY last_name, salary, department_id; LAST_NAME SALARY DEPARTMENT_ID Percentile_Cont Percent_Rank ------------------------- ---------- ------------- --------------- ------------ Austin 4800 60 4800 .5 Baida 2900 30 2850 .4 Colmenares 2500 30 2850 1 Ernst 6000 60 4800 .25 Himuro 2600 30 2850 .8 Hunold 9000 60 4800 0 Khoo 3100 30 2850 .2 Lorentz 4200 60 4800 1 Pataballa 4800 60 4800 .5 Raphaely 11000 30 2850 0 Tobias 2800 30 2850 .6 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions127.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_F_TEST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_F_TEST))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STATS_F_TEST(expr1, expr2 [, { { STATISTIC | DF_NUM | DF_DEN | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG } ] ) </eps> \n The Purpose is: \n <code>STATS_F_TEST</code> tests whether two variances are significantly different. The observed value of f is the ratio of one variance to the other, so values very different from 1 usually indicate significant differences. This function takes three arguments: <code>expr1</code> is the grouping or independent variable and <code>expr2</code> is the sample of values. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-5&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm#g1514122</link>. Table 5-5 STATS_F_TEST Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> STATISTIC </td> <td> The observed value of f </td> </tr> <tr> <td> DF_NUM </td> <td> Degree of freedom for the numerator </td> </tr> <tr> <td> DF_DEN </td> <td> Degree of freedom for the denominator </td> </tr> <tr> <td> ONE_SIDED_SIG </td> <td> One-tailed significance of f </td> </tr> <tr> <td> TWO_SIDED_SIG </td> <td> Two-tailed significance of f </td> </tr> </tbody> </table> The one-tailed significance is always in relation to the upper tail. The final argument, <code>expr3</code>, indicates which of the two groups specified by expr1 is the high value or numerator (the value whose rejection region is the upper tail). The observed value of f is the ratio of the variance of one group to the variance of the second group. The significance of the observed value of f is the probability that the variances are different just by chance\u2014a number between 0 and 1. A small value for the significance indicates that the variances are significantly different. The degree of freedom for each of the variances is the number of observations in the sample minus 1. STATS_F_TEST Example The following example determines whether the variance in credit limit between men and women is significantly different. The results, a p_value not close to zero, and an f_statistic close to 1, indicate that the difference between credit limits for men and women are not significant. <code>SELECT VARIANCE(DECODE(cust_gender, 'M', cust_credit_limit, null)) var_men, VARIANCE(DECODE(cust_gender, 'F', cust_credit_limit, null)) var_women, STATS_F_TEST(cust_gender, cust_credit_limit, 'STATISTIC', 'F') f_statistic, STATS_F_TEST(cust_gender, cust_credit_limit) two_sided_p_value FROM sh.customers; VAR_MEN VAR_WOMEN F_STATISTIC TWO_SIDED_P_VALUE ---------- ---------- ----------- ----------------- 12879896.7 13046865 1.01296348 .311928071 </code> ",
        "detail": "The Syntax is: \n <eps> STATS_F_TEST(expr1, expr2 [, { { STATISTIC | DF_NUM | DF_DEN | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG } ] ) </eps> \n The Purpose is: \n <code>STATS_F_TEST</code> tests whether two variances are significantly different. The observed value of f is the ratio of one variance to the other, so values very different from 1 usually indicate significant differences. This function takes three arguments: <code>expr1</code> is the grouping or independent variable and <code>expr2</code> is the sample of values. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-5&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm#g1514122</link>. Table 5-5 STATS_F_TEST Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> STATISTIC </td> <td> The observed value of f </td> </tr> <tr> <td> DF_NUM </td> <td> Degree of freedom for the numerator </td> </tr> <tr> <td> DF_DEN </td> <td> Degree of freedom for the denominator </td> </tr> <tr> <td> ONE_SIDED_SIG </td> <td> One-tailed significance of f </td> </tr> <tr> <td> TWO_SIDED_SIG </td> <td> Two-tailed significance of f </td> </tr> </tbody> </table> The one-tailed significance is always in relation to the upper tail. The final argument, <code>expr3</code>, indicates which of the two groups specified by expr1 is the high value or numerator (the value whose rejection region is the upper tail). The observed value of f is the ratio of the variance of one group to the variance of the second group. The significance of the observed value of f is the probability that the variances are different just by chance\u2014a number between 0 and 1. A small value for the significance indicates that the variances are significantly different. The degree of freedom for each of the variances is the number of observations in the sample minus 1. STATS_F_TEST Example The following example determines whether the variance in credit limit between men and women is significantly different. The results, a p_value not close to zero, and an f_statistic close to 1, indicate that the difference between credit limits for men and women are not significant. <code>SELECT VARIANCE(DECODE(cust_gender, 'M', cust_credit_limit, null)) var_men, VARIANCE(DECODE(cust_gender, 'F', cust_credit_limit, null)) var_women, STATS_F_TEST(cust_gender, cust_credit_limit, 'STATISTIC', 'F') f_statistic, STATS_F_TEST(cust_gender, cust_credit_limit) two_sided_p_value FROM sh.customers; VAR_MEN VAR_WOMEN F_STATISTIC TWO_SIDED_P_VALUE ---------- ---------- ----------- ----------------- 12879896.7 13046865 1.01296348 .311928071 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CEIL",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CEIL))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CEIL(n) </eps> \n The Purpose is: \n <code>CEIL</code> returns the smallest integer that is greater than or equal to <code>n</code>. The number <code>n</code> can always be written as the difference of an integer <code>k</code> and a positive fraction <code>f</code> such that 0 <= <code>f</code> < 1 and <code>n</code> = <code>k</code> - <code>f</code>. The value of <code>CEIL</code> is the integer <code>k</code>. Thus, the value of <code>CEIL</code> is <code>n</code> itself if and only if <code>n</code> is precisely an integer. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>FLOOR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions067.htm#i77449</link> \n The Examples is: \n The following example returns the smallest integer greater than or equal to the order total of a specified order: <code>SELECT order_total, CEIL(order_total) FROM orders WHERE order_id = 2434; ORDER_TOTAL CEIL(ORDER_TOTAL) ----------- ----------------- 268651.8 268652 </code> ",
        "detail": "The Syntax is: \n <eps> CEIL(n) </eps> \n The Purpose is: \n <code>CEIL</code> returns the smallest integer that is greater than or equal to <code>n</code>. The number <code>n</code> can always be written as the difference of an integer <code>k</code> and a positive fraction <code>f</code> such that 0 <= <code>f</code> < 1 and <code>n</code> = <code>k</code> - <code>f</code>. The value of <code>CEIL</code> is the integer <code>k</code>. Thus, the value of <code>CEIL</code> is <code>n</code> itself if and only if <code>n</code> is precisely an integer. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>FLOOR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions067.htm#i77449</link> \n The Examples is: \n The following example returns the smallest integer greater than or equal to the order total of a specified order: <code>SELECT order_total, CEIL(order_total) FROM orders WHERE order_id = 2434; ORDER_TOTAL CEIL(ORDER_TOTAL) ----------- ----------------- 268651.8 268652 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions024.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DBTIMEZONE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c DBTIMEZONE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> DBTIMEZONE </eps> \n The Purpose is: \n <code>DBTIMEZONE</code> returns the value of the database time zone. The return type is a time zone offset (a character type in the format <code>'[+|-]TZH:TZM'</code>) or a time zone region name, depending on how the user specified the database time zone value in the most recent <code>CREATE</code> <code>DATABASE</code> or <code>ALTER</code> <code>DATABASE</code> statement. \n The Examples is: \n The following example assumes that the database time zone is set to UTC time zone: <code>SELECT DBTIMEZONE FROM DUAL; DBTIME ------ +00:00 </code> ",
        "detail": "The Syntax is: \n <eps> DBTIMEZONE </eps> \n The Purpose is: \n <code>DBTIMEZONE</code> returns the value of the database time zone. The return type is a time zone offset (a character type in the format <code>'[+|-]TZH:TZM'</code>) or a time zone region name, depending on how the user specified the database time zone value in the most recent <code>CREATE</code> <code>DATABASE</code> or <code>ALTER</code> <code>DATABASE</code> statement. \n The Examples is: \n The following example assumes that the database time zone is set to UTC time zone: <code>SELECT DBTIMEZONE FROM DUAL; DBTIME ------ +00:00 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions048.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TRANSLATE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TRANSLATE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TRANSLATE(expr, from_string, to_string) </eps> \n The Purpose is: \n <code>TRANSLATE</code> returns <code>expr</code> with all occurrences of each character in <code>from_string</code> replaced by its corresponding character in <code>to_string</code>. Characters in <code>expr</code> that are not in <code>from_string</code> are not replaced. The argument <code>from_string</code> can contain more characters than <code>to_string</code>. In this case, the extra characters at the end of <code>from_string</code> have no corresponding characters in <code>to_string</code>. If these extra characters appear in <code>expr</code>, then they are removed from the return value. If a character appears multiple times in <code>from_string</code>, then the <code>to_string</code> mapping corresponding to the first occurrence is used. You cannot use an empty string for <code>to_string</code> to remove all characters in <code>from_string</code> from the return value. Oracle Database interprets the empty string as null, and if this function has a null argument, then it returns null. To remove all characters in <code>from_string</code>, concatenate another character to the beginning of <code>from_string</code> and specify this character as the <code>to_string</code>. For example, <code>TRANSLATE</code>(<code>expr</code>, '<code>x0123456789</code>', '<code>x</code>') removes all digits from <code>expr</code>. <code>TRANSLATE</code> provides functionality related to that provided by the <code>REPLACE</code> function. <code>REPLACE</code> lets you substitute a single string for another single string, as well as remove character strings. <code>TRANSLATE</code> lets you make several single-character, one-to-one substitutions in one operation. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information and <link>REPLACE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions153.htm#i78608</link> \n The Examples is: \n The following statement translates a book title into a string that could be used (for example) as a filename. The <code>from_string</code> contains four characters: a space, asterisk, slash, and apostrophe (with an extra apostrophe as the escape character). The <code>to_string</code> contains only three underscores. This leaves the fourth character in the <code>from_string</code> without a corresponding replacement, so apostrophes are dropped from the returned value. <code>SELECT TRANSLATE('SQL*Plus User''s Guide', ' */''', '___') FROM DUAL; TRANSLATE('SQL*PLUSU -------------------- SQL_Plus_Users_Guide </code> ",
        "detail": "The Syntax is: \n <eps> TRANSLATE(expr, from_string, to_string) </eps> \n The Purpose is: \n <code>TRANSLATE</code> returns <code>expr</code> with all occurrences of each character in <code>from_string</code> replaced by its corresponding character in <code>to_string</code>. Characters in <code>expr</code> that are not in <code>from_string</code> are not replaced. The argument <code>from_string</code> can contain more characters than <code>to_string</code>. In this case, the extra characters at the end of <code>from_string</code> have no corresponding characters in <code>to_string</code>. If these extra characters appear in <code>expr</code>, then they are removed from the return value. If a character appears multiple times in <code>from_string</code>, then the <code>to_string</code> mapping corresponding to the first occurrence is used. You cannot use an empty string for <code>to_string</code> to remove all characters in <code>from_string</code> from the return value. Oracle Database interprets the empty string as null, and if this function has a null argument, then it returns null. To remove all characters in <code>from_string</code>, concatenate another character to the beginning of <code>from_string</code> and specify this character as the <code>to_string</code>. For example, <code>TRANSLATE</code>(<code>expr</code>, '<code>x0123456789</code>', '<code>x</code>') removes all digits from <code>expr</code>. <code>TRANSLATE</code> provides functionality related to that provided by the <code>REPLACE</code> function. <code>REPLACE</code> lets you substitute a single string for another single string, as well as remove character strings. <code>TRANSLATE</code> lets you make several single-character, one-to-one substitutions in one operation. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information and <link>REPLACE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions153.htm#i78608</link> \n The Examples is: \n The following statement translates a book title into a string that could be used (for example) as a filename. The <code>from_string</code> contains four characters: a space, asterisk, slash, and apostrophe (with an extra apostrophe as the escape character). The <code>to_string</code> contains only three underscores. This leaves the fourth character in the <code>from_string</code> without a corresponding replacement, so apostrophes are dropped from the returned value. <code>SELECT TRANSLATE('SQL*Plus User''s Guide', ' */''', '___') FROM DUAL; TRANSLATE('SQL*PLUSU -------------------- SQL_Plus_Users_Guide </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions216.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLPATCH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLPATCH))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLPATCH ( XMLType_document, XMLType_document ) </eps> \n The Purpose is: \n The <code>XMLPatch</code> function is the SQL interface for the XmlPatch C API. This function patches an XML document with the changes specified. A patched <code>XMLType</code> document is returned. For the first argument, specify the name of the input <code>XMLType</code> document For the second argument, specify the XMLType document containing the changes to be applied to the first document. The changes should conform to the Xdiff XML schema For <code>string</code>, specify the flags that control the behavior of the function. These flags are specified by one or more names separated by semicolon. The names are the same as the names of constants for XmlPatch C function. See Also: <link>Oracle XML Developer's Kit Programmer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23582/adx_c_diff.htm#ADXDK2520</link> for more information on using this function, including examples, and <link>Oracle Database XML C API Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e10770/xmldiff.htm#CAXML6192</link> for information on the XML APIs for C \n The Examples is: \n The following example patches an <code>XMLType</code> document with the changes specified in another <code>XMLType</code> and returns a patched <code>XMLType</code> document: <code>SELECT XMLPATCH( XMLTYPE('<?xml version=\"1.0\"?> <bk:book xmlns:bk=\"http://example.com\"> <bk:tr> <bk:td> <bk:chapter> Chapter 1. </bk:chapter> </bk:td> <bk:td> <bk:chapter> Chapter 2. </bk:chapter> </bk:td> </bk:tr> </bk:book>'), XMLTYPE('<?xml version=\"1.0\"?> <xd:xdiff xsi:schemaLocation=\"http://xmlns.oracle.com/xdb/xdiff.xsd http://xmlns.oracle.com/xdb/xdiff.xsd\" xmlns:xd=\"http://xmlns.oracle.com/xdb/xdiff.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:bk=\"http://example.com\"> <?oracle-xmldiff operations-in-docorder=\"true\" output-model=\"snapshot\" diff-algorithm=\"global\"?> <xd:delete-node xd:node-type=\"element\" xd:xpath=\"/bk:book[1]/bk:tr[1]/bk:td[2]/bk:chapter[1]\"/> </xd:xdiff>') ) FROM DUAL; </code> ",
        "detail": "The Syntax is: \n <eps> XMLPATCH ( XMLType_document, XMLType_document ) </eps> \n The Purpose is: \n The <code>XMLPatch</code> function is the SQL interface for the XmlPatch C API. This function patches an XML document with the changes specified. A patched <code>XMLType</code> document is returned. For the first argument, specify the name of the input <code>XMLType</code> document For the second argument, specify the XMLType document containing the changes to be applied to the first document. The changes should conform to the Xdiff XML schema For <code>string</code>, specify the flags that control the behavior of the function. These flags are specified by one or more names separated by semicolon. The names are the same as the names of constants for XmlPatch C function. See Also: <link>Oracle XML Developer's Kit Programmer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23582/adx_c_diff.htm#ADXDK2520</link> for more information on using this function, including examples, and <link>Oracle Database XML C API Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e10770/xmldiff.htm#CAXML6192</link> for information on the XML APIs for C \n The Examples is: \n The following example patches an <code>XMLType</code> document with the changes specified in another <code>XMLType</code> and returns a patched <code>XMLType</code> document: <code>SELECT XMLPATCH( XMLTYPE('<?xml version=\"1.0\"?> <bk:book xmlns:bk=\"http://example.com\"> <bk:tr> <bk:td> <bk:chapter> Chapter 1. </bk:chapter> </bk:td> <bk:td> <bk:chapter> Chapter 2. </bk:chapter> </bk:td> </bk:tr> </bk:book>'), XMLTYPE('<?xml version=\"1.0\"?> <xd:xdiff xsi:schemaLocation=\"http://xmlns.oracle.com/xdb/xdiff.xsd http://xmlns.oracle.com/xdb/xdiff.xsd\" xmlns:xd=\"http://xmlns.oracle.com/xdb/xdiff.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:bk=\"http://example.com\"> <?oracle-xmldiff operations-in-docorder=\"true\" output-model=\"snapshot\" diff-algorithm=\"global\"?> <xd:delete-node xd:node-type=\"element\" xd:xpath=\"/bk:book[1]/bk:tr[1]/bk:td[2]/bk:chapter[1]\"/> </xd:xdiff>') ) FROM DUAL; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions247.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "FEATURE_VALUE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c FEATURE_VALUE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> FEATURE_VALUE( [ schema . ] model [, feature_id ] mining_attribute_clause ) </eps> mining_attribute_clause:= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with feature extraction models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns the value of a given feature. If you omit the <code>feature_id</code> argument, then the function returns the highest feature value. You can use this form in conjunction with the <code>FEATURE_ID</code> function to obtain the largest feature/value combination. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the customers that correspond to feature 3, ordered by match quality. This example and the prerequisite data mining operations, including the creation of the model and view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmnmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT * FROM (SELECT cust_id, FEATURE_VALUE(nmf_sh_sample, 3 USING *) match_quality FROM nmf_sh_sample_apply_prepared ORDER BY match_quality DESC) WHERE ROWNUM < 11; CUST_ID MATCH_QUALITY ---------- ------------- 100210 19.4101627 100962 15.2482251 101151 14.5685197 101499 14.4186292 100363 14.4037396 100372 14.3335148 100982 14.1716545 101039 14.1079914 100759 14.0913761 100953 14.0799737 10 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> FEATURE_VALUE( [ schema . ] model [, feature_id ] mining_attribute_clause ) </eps> mining_attribute_clause:= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with feature extraction models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns the value of a given feature. If you omit the <code>feature_id</code> argument, then the function returns the highest feature value. You can use this form in conjunction with the <code>FEATURE_ID</code> function to obtain the largest feature/value combination. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions \n The Examples is: \n The following example lists the customers that correspond to feature 3, ordered by match quality. This example and the prerequisite data mining operations, including the creation of the model and view, can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmnmdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT * FROM (SELECT cust_id, FEATURE_VALUE(nmf_sh_sample, 3 USING *) match_quality FROM nmf_sh_sample_apply_prepared ORDER BY match_quality DESC) WHERE ROWNUM < 11; CUST_ID MATCH_QUALITY ---------- ------------- 100210 19.4101627 100962 15.2482251 101151 14.5685197 101499 14.4186292 100363 14.4037396 100372 14.3335148 100982 14.1716545 101039 14.1079914 100759 14.0913761 100953 14.0799737 10 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions064.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "MAX",
        "tree": "(numeric_function MAX ( ))",
        "description": "The Syntax is: \n <eps> MAX([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>MAX</code> returns maximum value of <code>expr</code>. You can use it as an aggregate or analytic function. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>, <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics, and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example determines the highest salary in the <code>hr.employees</code> table: <code>SELECT MAX(salary) \"Maximum\" FROM employees; Maximum ---------- 24000 </code> Analytic \n The Examples is: \n The following example calculates, for each employee, the highest salary of the employees reporting to the same manager as the employee. <code>SELECT manager_id, last_name, salary, MAX(salary) OVER (PARTITION BY manager_id) AS mgr_max FROM employees ORDER BY manager_id, last_name, salary; MANAGER_ID LAST_NAME SALARY MGR_MAX ---------- ------------------------- ---------- ---------- 100 Cambrault 11000 17000 100 De Haan 17000 17000 100 Errazuriz 12000 17000 100 Fripp 8200 17000 100 Hartstein 13000 17000 100 Kaufling 7900 17000 100 Kochhar 17000 17000 . . . </code> If you enclose this query in the parent query with a predicate, then you can determine the employee who makes the highest salary in each department: <code>SELECT manager_id, last_name, salary FROM (SELECT manager_id, last_name, salary, MAX(salary) OVER (PARTITION BY manager_id) AS rmax_sal FROM employees) WHERE salary = rmax_sal ORDER BY manager_id, last_name, salary; MANAGER_ID LAST_NAME SALARY ---------- ------------------------- ---------- 100 De Haan 17000 100 Kochhar 17000 101 Greenberg 12008 101 Higgins 12008 102 Hunold 9000 103 Ernst 6000 108 Faviet 9000 114 Khoo 3100 120 Nayer 3200 120 Taylor 3200 121 Sarchand 4200 122 Chung 3800 123 Bell 4000 124 Rajs 3500 145 Tucker 10000 146 King 10000 147 Vishney 10500 148 Ozer 11500 149 Abel 11000 201 Fay 6000 205 Gietz 8300 King 24000 22 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> MAX([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>MAX</code> returns maximum value of <code>expr</code>. You can use it as an aggregate or analytic function. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>, <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics, and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example determines the highest salary in the <code>hr.employees</code> table: <code>SELECT MAX(salary) \"Maximum\" FROM employees; Maximum ---------- 24000 </code> Analytic \n The Examples is: \n The following example calculates, for each employee, the highest salary of the employees reporting to the same manager as the employee. <code>SELECT manager_id, last_name, salary, MAX(salary) OVER (PARTITION BY manager_id) AS mgr_max FROM employees ORDER BY manager_id, last_name, salary; MANAGER_ID LAST_NAME SALARY MGR_MAX ---------- ------------------------- ---------- ---------- 100 Cambrault 11000 17000 100 De Haan 17000 17000 100 Errazuriz 12000 17000 100 Fripp 8200 17000 100 Hartstein 13000 17000 100 Kaufling 7900 17000 100 Kochhar 17000 17000 . . . </code> If you enclose this query in the parent query with a predicate, then you can determine the employee who makes the highest salary in each department: <code>SELECT manager_id, last_name, salary FROM (SELECT manager_id, last_name, salary, MAX(salary) OVER (PARTITION BY manager_id) AS rmax_sal FROM employees) WHERE salary = rmax_sal ORDER BY manager_id, last_name, salary; MANAGER_ID LAST_NAME SALARY ---------- ------------------------- ---------- 100 De Haan 17000 100 Kochhar 17000 101 Greenberg 12008 101 Higgins 12008 102 Hunold 9000 103 Ernst 6000 108 Faviet 9000 114 Khoo 3100 120 Nayer 3200 120 Taylor 3200 121 Sarchand 4200 122 Chung 3800 123 Bell 4000 124 Rajs 3500 145 Tucker 10000 146 King 10000 147 Vishney 10500 148 Ozer 11500 149 Abel 11000 201 Fay 6000 205 Gietz 8300 King 24000 22 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions098.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "AVG",
        "tree": "(numeric_function AVG ( ))",
        "description": "The Syntax is: \n <eps> AVG([ DISTINCT | ALL ] expr) [ OVER(analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>AVG</code> returns average value of <code>expr</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example calculates the average salary of all employees in the <code>hr.employees</code> table: <code>SELECT AVG(salary) \"Average\" FROM employees; Average -------------- 6461.83178 </code> Analytic Example The following example calculates, for each employee in the <code>employees</code> table, the average salary of the employees reporting to the same manager who were hired in the range just before through just after the employee: <code>SELECT manager_id, last_name, hire_date, salary, AVG(salary) OVER (PARTITION BY manager_id ORDER BY hire_date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS c_mavg FROM employees ORDER BY manager_id, hire_date, salary; MANAGER_ID LAST_NAME HIRE_DATE SALARY C_MAVG ---------- ------------------------- --------- ---------- ---------- 100 De Haan 13-JAN-01 17000 14000 100 Raphaely 07-DEC-02 11000 11966.6667 100 Kaufling 01-MAY-03 7900 10633.3333 100 Hartstein 17-FEB-04 13000 9633.33333 100 Weiss 18-JUL-04 8000 11666.6667 100 Russell 01-OCT-04 14000 11833.3333 100 Partners 05-JAN-05 13500 13166.6667 100 Errazuriz 10-MAR-05 12000 11233.3333 . . . </code> ",
        "detail": "The Syntax is: \n <eps> AVG([ DISTINCT | ALL ] expr) [ OVER(analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>AVG</code> returns average value of <code>expr</code>. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example calculates the average salary of all employees in the <code>hr.employees</code> table: <code>SELECT AVG(salary) \"Average\" FROM employees; Average -------------- 6461.83178 </code> Analytic Example The following example calculates, for each employee in the <code>employees</code> table, the average salary of the employees reporting to the same manager who were hired in the range just before through just after the employee: <code>SELECT manager_id, last_name, hire_date, salary, AVG(salary) OVER (PARTITION BY manager_id ORDER BY hire_date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS c_mavg FROM employees ORDER BY manager_id, hire_date, salary; MANAGER_ID LAST_NAME HIRE_DATE SALARY C_MAVG ---------- ------------------------- --------- ---------- ---------- 100 De Haan 13-JAN-01 17000 14000 100 Raphaely 07-DEC-02 11000 11966.6667 100 Kaufling 01-MAY-03 7900 10633.3333 100 Hartstein 17-FEB-04 13000 9633.33333 100 Weiss 18-JUL-04 8000 11666.6667 100 Russell 01-OCT-04 14000 11833.3333 100 Partners 05-JAN-05 13500 13166.6667 100 Errazuriz 10-MAR-05 12000 11233.3333 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions018.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CHARTOROWID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CHARTOROWID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CHARTOROWID(char) </eps> \n The Purpose is: \n <code>CHARTOROWID</code> converts a value from <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to <code>ROWID</code> data type. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example converts a character rowid representation to a rowid. (The actual rowid is different for each database instance.) <code>SELECT last_name FROM employees WHERE ROWID = CHARTOROWID('AAAFd1AAFAAAABSAA/'); LAST_NAME ------------------------- Greene </code> ",
        "detail": "The Syntax is: \n <eps> CHARTOROWID(char) </eps> \n The Purpose is: \n <code>CHARTOROWID</code> converts a value from <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to <code>ROWID</code> data type. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example converts a character rowid representation to a rowid. (The actual rowid is different for each database instance.) <code>SELECT last_name FROM employees WHERE ROWID = CHARTOROWID('AAAFd1AAFAAAABSAA/'); LAST_NAME ------------------------- Greene </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions025.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ROUND(number)",
        "tree": "(numeric_function ROUND ( ))",
        "description": "The Syntax is: \n round_number::= <eps> ROUND(n [, integer ]) </eps> \n The Purpose is: \n <code>ROUND</code> returns <code>n</code> rounded to <code>integer</code> places to the right of the decimal point. If you omit <code>integer</code>, then <code>n</code> is rounded to zero places. If <code>integer</code> is negative, then <code>n</code> is rounded off to the left of the decimal point. <code>n</code> can be any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit <code>integer</code>, then the function returns the value <code>ROUND</code>(n, 0) in the same data type as the numeric data type of <code>n</code>. If you include <code>integer</code>, then the function returns <code>NUMBER</code>. <code>ROUND</code> is implemented using the following rules: If <code>n</code> is 0, then <code>ROUND</code> always returns 0 regardless of <code>integer</code>. If <code>n</code> is negative, then <code>ROUND</code>(n, integer) returns -<code>ROUND</code>(-n, integer). If <code>n</code> is positive, then <code>ROUND(n, integer) = FLOOR(n * POWER(10, integer) + 0.5) * POWER(10, -integer) </code> <code>ROUND</code> applied to a <code>NUMBER</code> value may give a slightly different result from <code>ROUND</code> applied to the same value expressed in floating-point. The different results arise from differences in internal representations of <code>NUMBER</code> and floating point values. The difference will be 1 in the rounded digit if a difference occurs. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for more information on how Oracle Database handles <code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code> values <link>FLOOR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions067.htm#i77449</link> and <link>CEIL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions024.htm#i97801</link>, <link>TRUNC (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions221.htm#i79729</link> and <link>MOD&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions101.htm#i77996</link> for information on functions that perform related operations \n The Examples is: \n The following example rounds a number to one decimal point: <code>SELECT ROUND(15.193,1) \"Round\" FROM DUAL; Round ---------- 15.2 </code> The following example rounds a number one digit to the left of the decimal point: <code>SELECT ROUND(15.193,-1) \"Round\" FROM DUAL; Round ---------- 20 </code> ",
        "detail": "The Syntax is: \n round_number::= <eps> ROUND(n [, integer ]) </eps> \n The Purpose is: \n <code>ROUND</code> returns <code>n</code> rounded to <code>integer</code> places to the right of the decimal point. If you omit <code>integer</code>, then <code>n</code> is rounded to zero places. If <code>integer</code> is negative, then <code>n</code> is rounded off to the left of the decimal point. <code>n</code> can be any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you omit <code>integer</code>, then the function returns the value <code>ROUND</code>(n, 0) in the same data type as the numeric data type of <code>n</code>. If you include <code>integer</code>, then the function returns <code>NUMBER</code>. <code>ROUND</code> is implemented using the following rules: If <code>n</code> is 0, then <code>ROUND</code> always returns 0 regardless of <code>integer</code>. If <code>n</code> is negative, then <code>ROUND</code>(n, integer) returns -<code>ROUND</code>(-n, integer). If <code>n</code> is positive, then <code>ROUND(n, integer) = FLOOR(n * POWER(10, integer) + 0.5) * POWER(10, -integer) </code> <code>ROUND</code> applied to a <code>NUMBER</code> value may give a slightly different result from <code>ROUND</code> applied to the same value expressed in floating-point. The different results arise from differences in internal representations of <code>NUMBER</code> and floating point values. The difference will be 1 in the rounded digit if a difference occurs. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for more information on how Oracle Database handles <code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code> values <link>FLOOR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions067.htm#i77449</link> and <link>CEIL&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions024.htm#i97801</link>, <link>TRUNC (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions221.htm#i79729</link> and <link>MOD&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions101.htm#i77996</link> for information on functions that perform related operations \n The Examples is: \n The following example rounds a number to one decimal point: <code>SELECT ROUND(15.193,1) \"Round\" FROM DUAL; Round ---------- 15.2 </code> The following example rounds a number one digit to the left of the decimal point: <code>SELECT ROUND(15.193,-1) \"Round\" FROM DUAL; Round ---------- 20 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions155.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "UPDATEXML",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c UPDATEXML))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> UPDATEXML (XMLType_instance, XPath_string, value_expr [, XPath_string, value_expr ]... [, namespace_string ] ) </eps> \n The Purpose is: \n <code>UPDATEXML</code> takes as arguments an <code>XMLType</code> instance and an XPath-value pair and returns an <code>XMLType</code> instance with the updated value. If <code>XPath_string</code> is an XML element, then the corresponding <code>value_expr</code> must be an <code>XMLType</code> instance. If <code>XPath_string</code> is an attribute or text node, then the <code>value_expr</code> can be any scalar data type. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. The data types of the target of each <code>XPath_string</code> and its corresponding <code>value_expr</code> must match. The optional <code>namespace_string</code> must resolve to a <code>VARCHAR2</code> value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s). If you update an XML element to null, then Oracle removes the attributes and children of the element, and the element becomes empty. If you update the text node of an element to null, Oracle removes the text value of the element, and the element itself remains but is empty. In most cases, this function materializes an XML document in memory and updates the value. However, <code>UPDATEXML</code> is optimized for <code>UPDATE</code> statements on object-relational columns so that the function updates the value directly in the column. This optimization requires the following conditions: The <code>XMLType_instance</code> must be the same as the column in the <code>UPDATE</code> ... <code>SET</code> clause. The <code>XPath_string</code> must resolve to scalar content. \n The Examples is: \n The following example updates to 4 the number of docks in the San Francisco warehouse in the sample schema <code>OE</code>, which has a <code>warehouse_spec</code> column of type <code>XMLType</code>: <code>SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks') \"Number of Docks\" FROM warehouses WHERE warehouse_name = 'San Francisco'; WAREHOUSE_NAME Number of Docks -------------------- -------------------- San Francisco <Docks>1</Docks> UPDATE warehouses SET warehouse_spec = UPDATEXML(warehouse_spec, '/Warehouse/Docks/text()',4) WHERE warehouse_name = 'San Francisco'; 1 row updated. SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks') \"Number of Docks\" FROM warehouses WHERE warehouse_name = 'San Francisco'; WAREHOUSE_NAME Number of Docks -------------------- -------------------- San Francisco <Docks>4</Docks> </code> ",
        "detail": "The Syntax is: \n <eps> UPDATEXML (XMLType_instance, XPath_string, value_expr [, XPath_string, value_expr ]... [, namespace_string ] ) </eps> \n The Purpose is: \n <code>UPDATEXML</code> takes as arguments an <code>XMLType</code> instance and an XPath-value pair and returns an <code>XMLType</code> instance with the updated value. If <code>XPath_string</code> is an XML element, then the corresponding <code>value_expr</code> must be an <code>XMLType</code> instance. If <code>XPath_string</code> is an attribute or text node, then the <code>value_expr</code> can be any scalar data type. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. The data types of the target of each <code>XPath_string</code> and its corresponding <code>value_expr</code> must match. The optional <code>namespace_string</code> must resolve to a <code>VARCHAR2</code> value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s). If you update an XML element to null, then Oracle removes the attributes and children of the element, and the element becomes empty. If you update the text node of an element to null, Oracle removes the text value of the element, and the element itself remains but is empty. In most cases, this function materializes an XML document in memory and updates the value. However, <code>UPDATEXML</code> is optimized for <code>UPDATE</code> statements on object-relational columns so that the function updates the value directly in the column. This optimization requires the following conditions: The <code>XMLType_instance</code> must be the same as the column in the <code>UPDATE</code> ... <code>SET</code> clause. The <code>XPath_string</code> must resolve to scalar content. \n The Examples is: \n The following example updates to 4 the number of docks in the San Francisco warehouse in the sample schema <code>OE</code>, which has a <code>warehouse_spec</code> column of type <code>XMLType</code>: <code>SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks') \"Number of Docks\" FROM warehouses WHERE warehouse_name = 'San Francisco'; WAREHOUSE_NAME Number of Docks -------------------- -------------------- San Francisco <Docks>1</Docks> UPDATE warehouses SET warehouse_spec = UPDATEXML(warehouse_spec, '/Warehouse/Docks/text()',4) WHERE warehouse_name = 'San Francisco'; 1 row updated. SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks') \"Number of Docks\" FROM warehouses WHERE warehouse_name = 'San Francisco'; WAREHOUSE_NAME Number of Docks -------------------- -------------------- San Francisco <Docks>4</Docks> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions225.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "COVAR_POP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c COVAR_POP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> COVAR_POP(expr1, expr2) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>COVAR_POP</code> returns the population covariance of a set of number pairs. You can use it as an aggregate or analytic function. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle Database applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Then Oracle makes the following computation: <code>(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / n </code> where <code>n</code> is the number of (<code>expr1</code>, <code>expr2</code>) pairs where neither <code>expr1</code> nor <code>expr2</code> is null. The function returns a value of type <code>NUMBER</code>. If the function is applied to an empty set, then it returns null. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example calculates the population covariance and sample covariance for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, COVAR_POP(SYSDATE-hire_date, salary) AS covar_pop, COVAR_SAMP(SYSDATE-hire_date, salary) AS covar_samp FROM employees WHERE department_id in (50, 80) GROUP BY job_id ORDER BY job_id, covar_pop, covar_samp; JOB_ID COVAR_POP COVAR_SAMP ---------- ----------- ----------- SA_MAN 660700 825875 SA_REP 579988.466 600702.34 SH_CLERK 212432.5 223613.158 ST_CLERK 176577.25 185870.789 ST_MAN 436092 545115 </code> Analytic Example The following example calculates cumulative sample covariance of the list price and minimum price of the products in the sample schema <code>oe</code>: <code>SELECT product_id, supplier_id, COVAR_POP(list_price, min_price) OVER (ORDER BY product_id, supplier_id) AS CUM_COVP, COVAR_SAMP(list_price, min_price) OVER (ORDER BY product_id, supplier_id) AS CUM_COVS FROM product_information p WHERE category_id = 29 ORDER BY product_id, supplier_id; PRODUCT_ID SUPPLIER_ID CUM_COVP CUM_COVS ---------- ----------- ---------- ---------- 1774 103088 0 1775 103087 1473.25 2946.5 1794 103096 1702.77778 2554.16667 1825 103093 1926.25 2568.33333 2004 103086 1591.4 1989.25 2005 103086 1512.5 1815 2416 103088 1475.97959 1721.97619 . . . </code> ",
        "detail": "The Syntax is: \n <eps> COVAR_POP(expr1, expr2) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>COVAR_POP</code> returns the population covariance of a set of number pairs. You can use it as an aggregate or analytic function. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle Database applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Then Oracle makes the following computation: <code>(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / n </code> where <code>n</code> is the number of (<code>expr1</code>, <code>expr2</code>) pairs where neither <code>expr1</code> nor <code>expr2</code> is null. The function returns a value of type <code>NUMBER</code>. If the function is applied to an empty set, then it returns null. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example calculates the population covariance and sample covariance for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, COVAR_POP(SYSDATE-hire_date, salary) AS covar_pop, COVAR_SAMP(SYSDATE-hire_date, salary) AS covar_samp FROM employees WHERE department_id in (50, 80) GROUP BY job_id ORDER BY job_id, covar_pop, covar_samp; JOB_ID COVAR_POP COVAR_SAMP ---------- ----------- ----------- SA_MAN 660700 825875 SA_REP 579988.466 600702.34 SH_CLERK 212432.5 223613.158 ST_CLERK 176577.25 185870.789 ST_MAN 436092 545115 </code> Analytic Example The following example calculates cumulative sample covariance of the list price and minimum price of the products in the sample schema <code>oe</code>: <code>SELECT product_id, supplier_id, COVAR_POP(list_price, min_price) OVER (ORDER BY product_id, supplier_id) AS CUM_COVP, COVAR_SAMP(list_price, min_price) OVER (ORDER BY product_id, supplier_id) AS CUM_COVS FROM product_information p WHERE category_id = 29 ORDER BY product_id, supplier_id; PRODUCT_ID SUPPLIER_ID CUM_COVP CUM_COVS ---------- ----------- ---------- ---------- 1774 103088 0 1775 103087 1473.25 2946.5 1794 103096 1702.77778 2554.16667 1825 103093 1926.25 2568.33333 2004 103086 1591.4 1989.25 2005 103086 1512.5 1815 2416 103088 1475.97959 1721.97619 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions040.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CHR",
        "tree": "(string_function CHR ( ))",
        "description": "The Syntax is: \n <eps> CHR(n [ USING NCHAR_CS ]) </eps> \n The Purpose is: \n <code>CHR</code> returns the character having the binary equivalent to <code>n</code> as a <code>VARCHAR2</code> value in either the database character set or, if you specify <code>USING</code> <code>NCHAR_CS</code>, the national character set. For single-byte character sets, if <code>n</code> > 256, then Oracle Database returns the binary equivalent of <code>n</code> <code>mod</code> <code>256</code>. For multibyte character sets, <code>n</code> must resolve to one entire code point. Invalid code points are not validated, and the result of specifying invalid code points is indeterminate. This function takes as an argument a <code>NUMBER</code> value, or any value that can be implicitly converted to <code>NUMBER</code>, and returns a character. Note: Use of the <code>CHR</code> function (either with or without the optional <code>USING</code> <code>NCHAR_CS</code> clause) results in code that is not portable between ASCII- and EBCDIC-based machine architectures. See Also: <link>NCHR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions104.htm#i1273067</link> and <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example is run on an ASCII-based machine with the database character set defined as WE8ISO8859P1: <code>SELECT CHR(67)||CHR(65)||CHR(84) \"Dog\" FROM DUAL; Dog --- CAT </code> To produce the same results on an EBCDIC-based machine with the WE8EBCDIC1047 character set, the preceding example would have to be modified as follows: <code>SELECT CHR(195)||CHR(193)||CHR(227) \"Dog\" FROM DUAL; Dog --- CAT </code> For multibyte character sets, this sort of concatenation gives different results. For example, given a multibyte character whose hexadecimal value is <code>a1a2</code> (<code>a1</code> representing the first byte and <code>a2</code> the second byte), you must specify for <code>n</code> the decimal equivalent of '<code>a1a2</code>', or 41378: <code>SELECT CHR(41378) FROM DUAL; </code> You cannot specify the decimal equivalent of a1 concatenated with the decimal equivalent of a2, as in the following example: <code>SELECT CHR(161)||CHR(162) FROM DUAL; </code> However, you can concatenate whole multibyte code points, as in the following example, which concatenates the multibyte characters whose hexadecimal values are <code>a1a2</code> and <code>a1a3</code>: <code>SELECT CHR(41378)||CHR(41379) FROM DUAL; </code> The following example assumes that the national character set is UTF16: <code>SELECT CHR (196 USING NCHAR_CS) FROM DUAL; CH -- \u00c4 </code> ",
        "detail": "The Syntax is: \n <eps> CHR(n [ USING NCHAR_CS ]) </eps> \n The Purpose is: \n <code>CHR</code> returns the character having the binary equivalent to <code>n</code> as a <code>VARCHAR2</code> value in either the database character set or, if you specify <code>USING</code> <code>NCHAR_CS</code>, the national character set. For single-byte character sets, if <code>n</code> > 256, then Oracle Database returns the binary equivalent of <code>n</code> <code>mod</code> <code>256</code>. For multibyte character sets, <code>n</code> must resolve to one entire code point. Invalid code points are not validated, and the result of specifying invalid code points is indeterminate. This function takes as an argument a <code>NUMBER</code> value, or any value that can be implicitly converted to <code>NUMBER</code>, and returns a character. Note: Use of the <code>CHR</code> function (either with or without the optional <code>USING</code> <code>NCHAR_CS</code> clause) results in code that is not portable between ASCII- and EBCDIC-based machine architectures. See Also: <link>NCHR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions104.htm#i1273067</link> and <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example is run on an ASCII-based machine with the database character set defined as WE8ISO8859P1: <code>SELECT CHR(67)||CHR(65)||CHR(84) \"Dog\" FROM DUAL; Dog --- CAT </code> To produce the same results on an EBCDIC-based machine with the WE8EBCDIC1047 character set, the preceding example would have to be modified as follows: <code>SELECT CHR(195)||CHR(193)||CHR(227) \"Dog\" FROM DUAL; Dog --- CAT </code> For multibyte character sets, this sort of concatenation gives different results. For example, given a multibyte character whose hexadecimal value is <code>a1a2</code> (<code>a1</code> representing the first byte and <code>a2</code> the second byte), you must specify for <code>n</code> the decimal equivalent of '<code>a1a2</code>', or 41378: <code>SELECT CHR(41378) FROM DUAL; </code> You cannot specify the decimal equivalent of a1 concatenated with the decimal equivalent of a2, as in the following example: <code>SELECT CHR(161)||CHR(162) FROM DUAL; </code> However, you can concatenate whole multibyte code points, as in the following example, which concatenates the multibyte characters whose hexadecimal values are <code>a1a2</code> and <code>a1a3</code>: <code>SELECT CHR(41378)||CHR(41379) FROM DUAL; </code> The following example assumes that the national character set is UTF16: <code>SELECT CHR (196 USING NCHAR_CS) FROM DUAL; CH -- \u00c4 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions026.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ROWIDTONCHAR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ROWIDTONCHAR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ROWIDTONCHAR(rowid) </eps> \n The Purpose is: \n <code>ROWIDTONCHAR</code> converts a rowid value to <code>NVARCHAR2</code> data type. The result of this conversion is always in the national character set and is 18 characters long. \n The Examples is: \n The following example converts a rowid value to an <code>NVARCHAR2</code> string: <code>SELECT LENGTHB( ROWIDTONCHAR(ROWID) ) Length, ROWIDTONCHAR(ROWID) FROM employees ORDER BY length; LENGTH ROWIDTONCHAR(ROWID ---------- ------------------ 36 AAAL52AAFAAAABSABD 36 AAAL52AAFAAAABSABV . . . </code> ",
        "detail": "The Syntax is: \n <eps> ROWIDTONCHAR(rowid) </eps> \n The Purpose is: \n <code>ROWIDTONCHAR</code> converts a rowid value to <code>NVARCHAR2</code> data type. The result of this conversion is always in the national character set and is 18 characters long. \n The Examples is: \n The following example converts a rowid value to an <code>NVARCHAR2</code> string: <code>SELECT LENGTHB( ROWIDTONCHAR(ROWID) ) Length, ROWIDTONCHAR(ROWID) FROM employees ORDER BY length; LENGTH ROWIDTONCHAR(ROWID ---------- ------------------ 36 AAAL52AAFAAAABSABD 36 AAAL52AAFAAAABSABV . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions158.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLTABLE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLTABLE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLTABLE ( [ XMLnamespaces_clause , ] XQuery_string XMLTABLE_options ) </eps> XMLnamespaces_clause::= <eps> XMLNAMESPACES ( { string AS identifier } | { DEFAULT string } [, { string AS identifier } | { DEFAULT string } ]... ) </eps> Note: You can specify at most one <code>DEFAULT</code> <code>string</code> clause. XMLTABLE_options::= <eps> [ XML_passing_clause ] [ COLUMNS XML_table_column [, XML_table_column]...] </eps> XML_passing_clause::= <eps> PASSING [ BY VALUE ] expr [ AS identifier ] [, expr [ AS identifier ] ]... </eps> XML_table_column::= <eps> column { FOR ORDINALITY | datatype [ PATH string ] [ DEFAULT expr ] } </eps> \n The Purpose is: \n <code>XMLTable</code> maps the result of an XQuery evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL. The <code>XMLNAMESPACES</code> clause contains a set of XML namespace declarations. These declarations are referenced by the XQuery expression (the evaluated <code>XQuery_string</code>), which computes the row, and by the XPath expression in the <code>PATH</code> clause of <code>XML_table_column</code>, which computes the columns for the entire <code>XMLTable</code> function. If you want to use qualified names in the <code>PATH</code> expressions of the <code>COLUMNS</code> clause, then you need to specify the <code>XMLNAMESPACES</code> clause. <code>XQuery_string</code> is a complete XQuery expression and can include prolog declarations. The <code>expr</code> in the <code>XML_passing_clause</code> is an expression returning an <code>XMLType</code> or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one <code>expr</code> in the <code>PASSING</code> clause without an identifier. The result of evaluating each <code>expr</code> is bound to the corresponding identifier in the <code>XQuery_string</code>. If any <code>expr</code> that is not followed by an <code>AS</code> clause, then the result of evaluating that expression is used as the context item for evaluating the <code>XQuery_string</code>. The optional <code>COLUMNS</code> clause defines the columns of the virtual table to be created by <code>XMLTable</code>. If you omit the <code>COLUMNS</code> clause, then <code>XMLTable</code> returns a row with a single <code>XMLType</code> pseudocolumn named <code>COLUMN_VALUE</code>. <code>FOR</code> <code>ORDINALITY</code> specifies that column is to be a column of generated row numbers. There must be at most one <code>FOR</code> <code>ORDINALITY</code> clause. It is created as a <code>NUMBER</code> column. For each resulting column except the <code>FOR</code> <code>ORDINALITY</code> column, you must specify the column <code>datatype</code>, which can be <code>XMLType</code> or any other data type. The optional <code>PATH</code> clause specifies that the portion of the XQuery result that is addressed by XQuery expression string is to be used as the column content. If you omit <code>PATH</code>, then the XQuery expression <code>column</code> is assumed. For example: <code>XMLTable(... COLUMNS xyz </code> is equivalent to <code>XMLTable(... COLUMNS xyz PATH 'XYZ') </code> You can use different <code>PATH</code> clauses to split the XQuery result into different virtual-table columns. The optional <code>DEFAULT</code> clause specifies the value to use when the <code>PATH</code> expression results in an empty sequence. Its <code>expr</code> is an XQuery expression that is evaluated to produce the default value. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb_xquery.htm#ADXDB1700</link> for more information on the <code>XMLTable</code> function, including additional examples, and on XQuery in general \n The Examples is: \n The following example converts the result of applying the XQuery <code>'/Warehouse'</code> to each value in the <code>warehouse_spec</code> column of the <code>warehouses</code> table into a virtual relational table with columns <code>Water</code> and <code>Rail</code>: <code>SELECT warehouse_name warehouse, warehouse2.\"Water\", warehouse2.\"Rail\" FROM warehouses, XMLTABLE('/Warehouse' PASSING warehouses.warehouse_spec COLUMNS \"Water\" varchar2(6) PATH '/Warehouse/WaterAccess', \"Rail\" varchar2(6) PATH '/Warehouse/RailAccess') warehouse2; WAREHOUSE Water Rail ----------------------------------- ------ ------ Southlake, Texas Y N San Francisco Y N New Jersey N N Seattle, Washington N Y </code> ",
        "detail": "The Syntax is: \n <eps> XMLTABLE ( [ XMLnamespaces_clause , ] XQuery_string XMLTABLE_options ) </eps> XMLnamespaces_clause::= <eps> XMLNAMESPACES ( { string AS identifier } | { DEFAULT string } [, { string AS identifier } | { DEFAULT string } ]... ) </eps> Note: You can specify at most one <code>DEFAULT</code> <code>string</code> clause. XMLTABLE_options::= <eps> [ XML_passing_clause ] [ COLUMNS XML_table_column [, XML_table_column]...] </eps> XML_passing_clause::= <eps> PASSING [ BY VALUE ] expr [ AS identifier ] [, expr [ AS identifier ] ]... </eps> XML_table_column::= <eps> column { FOR ORDINALITY | datatype [ PATH string ] [ DEFAULT expr ] } </eps> \n The Purpose is: \n <code>XMLTable</code> maps the result of an XQuery evaluation into relational rows and columns. You can query the result returned by the function as a virtual relational table using SQL. The <code>XMLNAMESPACES</code> clause contains a set of XML namespace declarations. These declarations are referenced by the XQuery expression (the evaluated <code>XQuery_string</code>), which computes the row, and by the XPath expression in the <code>PATH</code> clause of <code>XML_table_column</code>, which computes the columns for the entire <code>XMLTable</code> function. If you want to use qualified names in the <code>PATH</code> expressions of the <code>COLUMNS</code> clause, then you need to specify the <code>XMLNAMESPACES</code> clause. <code>XQuery_string</code> is a complete XQuery expression and can include prolog declarations. The <code>expr</code> in the <code>XML_passing_clause</code> is an expression returning an <code>XMLType</code> or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one <code>expr</code> in the <code>PASSING</code> clause without an identifier. The result of evaluating each <code>expr</code> is bound to the corresponding identifier in the <code>XQuery_string</code>. If any <code>expr</code> that is not followed by an <code>AS</code> clause, then the result of evaluating that expression is used as the context item for evaluating the <code>XQuery_string</code>. The optional <code>COLUMNS</code> clause defines the columns of the virtual table to be created by <code>XMLTable</code>. If you omit the <code>COLUMNS</code> clause, then <code>XMLTable</code> returns a row with a single <code>XMLType</code> pseudocolumn named <code>COLUMN_VALUE</code>. <code>FOR</code> <code>ORDINALITY</code> specifies that column is to be a column of generated row numbers. There must be at most one <code>FOR</code> <code>ORDINALITY</code> clause. It is created as a <code>NUMBER</code> column. For each resulting column except the <code>FOR</code> <code>ORDINALITY</code> column, you must specify the column <code>datatype</code>, which can be <code>XMLType</code> or any other data type. The optional <code>PATH</code> clause specifies that the portion of the XQuery result that is addressed by XQuery expression string is to be used as the column content. If you omit <code>PATH</code>, then the XQuery expression <code>column</code> is assumed. For example: <code>XMLTable(... COLUMNS xyz </code> is equivalent to <code>XMLTable(... COLUMNS xyz PATH 'XYZ') </code> You can use different <code>PATH</code> clauses to split the XQuery result into different virtual-table columns. The optional <code>DEFAULT</code> clause specifies the value to use when the <code>PATH</code> expression results in an empty sequence. Its <code>expr</code> is an XQuery expression that is evaluated to produce the default value. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb_xquery.htm#ADXDB1700</link> for more information on the <code>XMLTable</code> function, including additional examples, and on XQuery in general \n The Examples is: \n The following example converts the result of applying the XQuery <code>'/Warehouse'</code> to each value in the <code>warehouse_spec</code> column of the <code>warehouses</code> table into a virtual relational table with columns <code>Water</code> and <code>Rail</code>: <code>SELECT warehouse_name warehouse, warehouse2.\"Water\", warehouse2.\"Rail\" FROM warehouses, XMLTABLE('/Warehouse' PASSING warehouses.warehouse_spec COLUMNS \"Water\" varchar2(6) PATH '/Warehouse/WaterAccess', \"Rail\" varchar2(6) PATH '/Warehouse/RailAccess') warehouse2; WAREHOUSE Water Rail ----------------------------------- ------ ------ Southlake, Texas Y N San Francisco Y N New Jersey N N Seattle, Washington N Y </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions253.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_MULTI_BYTE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_MULTI_BYTE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_MULTI_BYTE(char) </eps> \n The Purpose is: \n <code>TO_MULTI_BYTE</code> returns <code>char</code> with all of its single-byte characters converted to their corresponding multibyte characters. <code>char</code> can be of data type <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The value returned is in the same data type as <code>char</code>. Any single-byte characters in <code>char</code> that have no multibyte equivalents appear in the output string as single-byte characters. This function is useful only if your database character set contains both single-byte and multibyte characters. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example illustrates converting from a single byte <code>A</code> to a multibyte <code>A</code> in UTF8: <code>SELECT dump(TO_MULTI_BYTE( 'A')) FROM DUAL; DUMP(TO_MULTI_BYTE('A')) ------------------------ Typ=1 Len=3: 239,188,161 </code> ",
        "detail": "The Syntax is: \n <eps> TO_MULTI_BYTE(char) </eps> \n The Purpose is: \n <code>TO_MULTI_BYTE</code> returns <code>char</code> with all of its single-byte characters converted to their corresponding multibyte characters. <code>char</code> can be of data type <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The value returned is in the same data type as <code>char</code>. Any single-byte characters in <code>char</code> that have no multibyte equivalents appear in the output string as single-byte characters. This function is useful only if your database character set contains both single-byte and multibyte characters. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example illustrates converting from a single byte <code>A</code> to a multibyte <code>A</code> in UTF8: <code>SELECT dump(TO_MULTI_BYTE( 'A')) FROM DUAL; DUMP(TO_MULTI_BYTE('A')) ------------------------ Typ=1 Len=3: 239,188,161 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions206.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "MEDIAN",
        "tree": "(other_function (over_clause_keyword MEDIAN) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> MEDIAN(expr) [ OVER (query_partition_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>MEDIAN</code> is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you specify only <code>expr</code>, then the function returns the same data type as the numeric data type of the argument. If you specify the <code>OVER</code> clause, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence The result of <code>MEDIAN</code> is computed by first ordering the rows. Using <code>N</code> as the number of rows in the group, Oracle calculates the row number (<code>RN</code>) of interest with the formula <code>RN</code> = (<code>1</code> + (0.<code>5</code>*(<code>N</code>-<code>1</code>)). The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers <code>CRN</code> = <code>CEILING</code>(<code>RN</code>) and <code>FRN</code> = <code>FLOOR</code>(<code>RN</code>). The final result will be: <code> if (CRN = FRN = RN) then (value of expression from row at RN) else (CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN) </code> You can use <code>MEDIAN</code> as an analytic function. You can specify only the <code>query_partition_clause</code> in its <code>OVER</code> clause. It returns, for each row, the value that would fall in the middle among a set of values within each partition. Compare this function with these functions: <link>PERCENTILE_CONT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions127.htm#i1000909</link>, which returns, for a given percentile, the value that corresponds to that percentile by way of interpolation. <code>MEDIAN</code> is the specific case of <code>PERCENTILE_CONT</code> where the percentile value defaults to 0.5. <link>PERCENTILE_DISC&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions128.htm#i1000913</link>, which is useful for finding values for a given percentile without interpolation. Aggregate Example The following query returns the median salary for each department in the <code>hr.employees</code> table: <code>SELECT department_id, MEDIAN(salary) FROM employees GROUP BY department_id ORDER BY department_id; DEPARTMENT_ID MEDIAN(SALARY) ------------- -------------- 10 4400 20 9500 30 2850 40 6500 50 3100 60 4800 70 10000 80 8900 90 17000 100 8000 110 10154 7000 </code> Analytic Example The following query returns the median salary for each manager in a subset of departments in the <code>hr.employees</code> table: <code>SELECT manager_id, employee_id, salary, MEDIAN(salary) OVER (PARTITION BY manager_id) \"Median by Mgr\" FROM employees WHERE department_id > 60 ORDER BY manager_id, employee_id; MANAGER_ID EMPLOYEE_ID SALARY Median by Mgr ---------- ----------- ---------- ------------- 100 101 17000 13500 100 102 17000 13500 100 145 14000 13500 100 146 13500 13500 100 147 12000 13500 100 148 11000 13500 100 149 10500 13500 101 108 12008 12008 101 204 10000 12008 101 205 12008 12008 108 109 9000 7800 108 110 8200 7800 108 111 7700 7800 108 112 7800 7800 108 113 6900 7800 145 150 10000 8500 145 151 9500 8500 145 152 9000 8500 . . . </code> ",
        "detail": "The Syntax is: \n <eps> MEDIAN(expr) [ OVER (query_partition_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>MEDIAN</code> is an inverse distribution function that assumes a continuous distribution model. It takes a numeric or datetime value and returns the middle value or an interpolated value that would be the middle value once the values are sorted. Nulls are ignored in the calculation. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If you specify only <code>expr</code>, then the function returns the same data type as the numeric data type of the argument. If you specify the <code>OVER</code> clause, then Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence The result of <code>MEDIAN</code> is computed by first ordering the rows. Using <code>N</code> as the number of rows in the group, Oracle calculates the row number (<code>RN</code>) of interest with the formula <code>RN</code> = (<code>1</code> + (0.<code>5</code>*(<code>N</code>-<code>1</code>)). The final result of the aggregate function is computed by linear interpolation between the values from rows at row numbers <code>CRN</code> = <code>CEILING</code>(<code>RN</code>) and <code>FRN</code> = <code>FLOOR</code>(<code>RN</code>). The final result will be: <code> if (CRN = FRN = RN) then (value of expression from row at RN) else (CRN - RN) * (value of expression for row at FRN) + (RN - FRN) * (value of expression for row at CRN) </code> You can use <code>MEDIAN</code> as an analytic function. You can specify only the <code>query_partition_clause</code> in its <code>OVER</code> clause. It returns, for each row, the value that would fall in the middle among a set of values within each partition. Compare this function with these functions: <link>PERCENTILE_CONT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions127.htm#i1000909</link>, which returns, for a given percentile, the value that corresponds to that percentile by way of interpolation. <code>MEDIAN</code> is the specific case of <code>PERCENTILE_CONT</code> where the percentile value defaults to 0.5. <link>PERCENTILE_DISC&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions128.htm#i1000913</link>, which is useful for finding values for a given percentile without interpolation. Aggregate Example The following query returns the median salary for each department in the <code>hr.employees</code> table: <code>SELECT department_id, MEDIAN(salary) FROM employees GROUP BY department_id ORDER BY department_id; DEPARTMENT_ID MEDIAN(SALARY) ------------- -------------- 10 4400 20 9500 30 2850 40 6500 50 3100 60 4800 70 10000 80 8900 90 17000 100 8000 110 10154 7000 </code> Analytic Example The following query returns the median salary for each manager in a subset of departments in the <code>hr.employees</code> table: <code>SELECT manager_id, employee_id, salary, MEDIAN(salary) OVER (PARTITION BY manager_id) \"Median by Mgr\" FROM employees WHERE department_id > 60 ORDER BY manager_id, employee_id; MANAGER_ID EMPLOYEE_ID SALARY Median by Mgr ---------- ----------- ---------- ------------- 100 101 17000 13500 100 102 17000 13500 100 145 14000 13500 100 146 13500 13500 100 147 12000 13500 100 148 11000 13500 100 149 10500 13500 101 108 12008 12008 101 204 10000 12008 101 205 12008 12008 108 109 9000 7800 108 110 8200 7800 108 111 7700 7800 108 112 7800 7800 108 113 6900 7800 145 150 10000 8500 145 151 9500 8500 145 152 9000 8500 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions099.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "WIDTH_BUCKET",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c WIDTH_BUCKET))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> WIDTH_BUCKET (expr, min_value, max_value, num_buckets) </eps> \n The Purpose is: \n <code>WIDTH_BUCKET</code> lets you construct equiwidth histograms, in which the histogram range is divided into intervals that have identical size. (Compare this function with <code>NTILE</code>, which creates equiheight histograms.) Ideally each bucket is a closed-open interval of the real number line. For example, a bucket can be assigned to scores between 10.00 and 19.999 ... to indicate that 10 is included in the interval and 20 is excluded. This is sometimes denoted [10, 20). For a given expression, <code>WIDTH_BUCKET</code> returns the bucket number into which the value of this expression would fall after being evaluated. <code>expr</code> is the expression for which the histogram is being created. This expression must evaluate to a numeric or datetime value or to a value that can be implicitly converted to a numeric or datetime value. If <code>expr</code> evaluates to null, then the expression returns null. <code>min_value</code> and <code>max_value</code> are expressions that resolve to the end points of the acceptable range for <code>expr</code>. Both of these expressions must also evaluate to numeric or datetime values, and neither can evaluate to null. <code>num_buckets</code> is an expression that resolves to a constant indicating the number of buckets. This expression must evaluate to a positive integer. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion When needed, Oracle Database creates an underflow bucket numbered 0 and an overflow bucket numbered <code>num_buckets</code>+1. These buckets handle values less than <code>min_value</code> and more than <code>max_value</code> and are helpful in checking the reasonableness of endpoints. \n The Examples is: \n The following example creates a ten-bucket histogram on the <code>credit_limit</code> column for customers in Switzerland in the sample table <code>oe.customers</code> and returns the bucket number (\"Credit Group\") for each customer. Customers with credit limits greater than or equal to the maximum value are assigned to the overflow bucket, 11: <code>SELECT customer_id, cust_last_name, credit_limit, WIDTH_BUCKET(credit_limit, 100, 5000, 10) \"Credit Group\" FROM customers WHERE nls_territory = 'SWITZERLAND' ORDER BY \"Credit Group\", customer_id, cust_last_name, credit_limit; CUSTOMER_ID CUST_LAST_NAME CREDIT_LIMIT Credit Group ----------- -------------------- ------------ ------------ 825 Dreyfuss 500 1 826 Barkin 500 1 827 Siegel 500 1 853 Palin 400 1 843 Oates 700 2 844 Julius 700 2 835 Eastwood 1200 3 836 Berenger 1200 3 837 Stanton 1200 3 840 Elliott 1400 3 841 Boyer 1400 3 842 Stern 1400 3 848 Olmos 1800 4 849 Kaurusmdki 1800 4 828 Minnelli 2300 5 829 Hunter 2300 5 850 Finney 2300 5 851 Brown 2300 5 852 Tanner 2300 5 830 Dutt 3500 7 831 Bel Geddes 3500 7 832 Spacek 3500 7 833 Moranis 3500 7 834 Idle 3500 7 838 Nicholson 3500 7 839 Johnson 3500 7 845 Fawcett 5000 11 846 Brando 5000 11 847 Streep 5000 11 </code> ",
        "detail": "The Syntax is: \n <eps> WIDTH_BUCKET (expr, min_value, max_value, num_buckets) </eps> \n The Purpose is: \n <code>WIDTH_BUCKET</code> lets you construct equiwidth histograms, in which the histogram range is divided into intervals that have identical size. (Compare this function with <code>NTILE</code>, which creates equiheight histograms.) Ideally each bucket is a closed-open interval of the real number line. For example, a bucket can be assigned to scores between 10.00 and 19.999 ... to indicate that 10 is included in the interval and 20 is excluded. This is sometimes denoted [10, 20). For a given expression, <code>WIDTH_BUCKET</code> returns the bucket number into which the value of this expression would fall after being evaluated. <code>expr</code> is the expression for which the histogram is being created. This expression must evaluate to a numeric or datetime value or to a value that can be implicitly converted to a numeric or datetime value. If <code>expr</code> evaluates to null, then the expression returns null. <code>min_value</code> and <code>max_value</code> are expressions that resolve to the end points of the acceptable range for <code>expr</code>. Both of these expressions must also evaluate to numeric or datetime values, and neither can evaluate to null. <code>num_buckets</code> is an expression that resolves to a constant indicating the number of buckets. This expression must evaluate to a positive integer. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion When needed, Oracle Database creates an underflow bucket numbered 0 and an overflow bucket numbered <code>num_buckets</code>+1. These buckets handle values less than <code>min_value</code> and more than <code>max_value</code> and are helpful in checking the reasonableness of endpoints. \n The Examples is: \n The following example creates a ten-bucket histogram on the <code>credit_limit</code> column for customers in Switzerland in the sample table <code>oe.customers</code> and returns the bucket number (\"Credit Group\") for each customer. Customers with credit limits greater than or equal to the maximum value are assigned to the overflow bucket, 11: <code>SELECT customer_id, cust_last_name, credit_limit, WIDTH_BUCKET(credit_limit, 100, 5000, 10) \"Credit Group\" FROM customers WHERE nls_territory = 'SWITZERLAND' ORDER BY \"Credit Group\", customer_id, cust_last_name, credit_limit; CUSTOMER_ID CUST_LAST_NAME CREDIT_LIMIT Credit Group ----------- -------------------- ------------ ------------ 825 Dreyfuss 500 1 826 Barkin 500 1 827 Siegel 500 1 853 Palin 400 1 843 Oates 700 2 844 Julius 700 2 835 Eastwood 1200 3 836 Berenger 1200 3 837 Stanton 1200 3 840 Elliott 1400 3 841 Boyer 1400 3 842 Stern 1400 3 848 Olmos 1800 4 849 Kaurusmdki 1800 4 828 Minnelli 2300 5 829 Hunter 2300 5 850 Finney 2300 5 851 Brown 2300 5 852 Tanner 2300 5 830 Dutt 3500 7 831 Bel Geddes 3500 7 832 Spacek 3500 7 833 Moranis 3500 7 834 Idle 3500 7 838 Nicholson 3500 7 839 Johnson 3500 7 845 Fawcett 5000 11 846 Brando 5000 11 847 Streep 5000 11 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions234.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "UID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c UID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> UID </eps> \n The Purpose is: \n <code>UID</code> returns an integer that uniquely identifies the session user (the user who logged on). \n The Examples is: \n The following example returns the UID of the current user: <code>SELECT UID FROM DUAL; </code> ",
        "detail": "The Syntax is: \n <eps> UID </eps> \n The Purpose is: \n <code>UID</code> returns an integer that uniquely identifies the session user (the user who logged on). \n The Examples is: \n The following example returns the UID of the current user: <code>SELECT UID FROM DUAL; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions223.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "UNISTR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c UNISTR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> UNISTR( string ) </eps> \n The Purpose is: \n <code>UNISTR</code> takes as its argument a text literal or an expression that resolves to character data and returns it in the national character set. The national character set of the database can be either AL16UTF16 or UTF8. <code>UNISTR</code> provides support for Unicode string literals by letting you specify the Unicode encoding value of characters in the string. This is useful, for example, for inserting data into <code>NCHAR</code> columns. The Unicode encoding value has the form '\\xxxx' where 'xxxx' is the hexadecimal value of a character in UCS-2 encoding format. Supplementary characters are encoded as two code units, the first from the high-surrogates range (U+D800 to U+DBFF), and the second from the low-surrogates range (U+DC00 to U+DFFF). To include the backslash in the string itself, precede it with another backslash (\\\\). For portability and data preservation, Oracle recommends that in the <code>UNISTR</code> string argument you specify only ASCII characters and the Unicode encoding values. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch6unicode.htm#NLSPG006</link> for information on Unicode and national character sets \n The Examples is: \n The following example passes both ASCII characters and Unicode encoding values to the <code>UNISTR</code> function, which returns the string in the national character set: <code>SELECT UNISTR('abc\\00e5\\00f1\\00f6') FROM DUAL; UNISTR ------ abc\u00e5\u00f1\u00f6 </code> ",
        "detail": "The Syntax is: \n <eps> UNISTR( string ) </eps> \n The Purpose is: \n <code>UNISTR</code> takes as its argument a text literal or an expression that resolves to character data and returns it in the national character set. The national character set of the database can be either AL16UTF16 or UTF8. <code>UNISTR</code> provides support for Unicode string literals by letting you specify the Unicode encoding value of characters in the string. This is useful, for example, for inserting data into <code>NCHAR</code> columns. The Unicode encoding value has the form '\\xxxx' where 'xxxx' is the hexadecimal value of a character in UCS-2 encoding format. Supplementary characters are encoded as two code units, the first from the high-surrogates range (U+D800 to U+DBFF), and the second from the low-surrogates range (U+DC00 to U+DFFF). To include the backslash in the string itself, precede it with another backslash (\\\\). For portability and data preservation, Oracle recommends that in the <code>UNISTR</code> string argument you specify only ASCII characters and the Unicode encoding values. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch6unicode.htm#NLSPG006</link> for information on Unicode and national character sets \n The Examples is: \n The following example passes both ASCII characters and Unicode encoding values to the <code>UNISTR</code> function, which returns the string in the national character set: <code>SELECT UNISTR('abc\\00e5\\00f1\\00f6') FROM DUAL; UNISTR ------ abc\u00e5\u00f1\u00f6 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions224.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "REPLACE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REPLACE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> REPLACE(char, search_string [, replacement_string ] ) </eps> \n The Purpose is: \n <code>REPLACE</code> returns <code>char</code> with every occurrence of <code>search_string</code> replaced with <code>replacement_string</code>. If <code>replacement_string</code> is omitted or null, then all occurrences of <code>search_string</code> are removed. If <code>search_string</code> is null, then <code>char</code> is returned. Both <code>search_string</code> and <code>replacement_string</code>, as well as <code>char</code>, can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is in the same character set as <code>char</code>. The function returns <code>VARCHAR2</code> if the first argument is not a LOB and returns <code>CLOB</code> if the first argument is a LOB. <code>REPLACE</code> provides functionality related to that provided by the <code>TRANSLATE</code> function. <code>TRANSLATE</code> provides single-character, one-to-one substitution. <code>REPLACE</code> lets you substitute one string for another as well as to remove character strings. See Also: <link>TRANSLATE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions216.htm#i1501659</link> \n The Examples is: \n The following example replaces occurrences of <code>J</code> with <code>BL</code>: <code>SELECT REPLACE('JACK and JUE','J','BL') \"Changes\" FROM DUAL; Changes -------------- BLACK and BLUE </code> ",
        "detail": "The Syntax is: \n <eps> REPLACE(char, search_string [, replacement_string ] ) </eps> \n The Purpose is: \n <code>REPLACE</code> returns <code>char</code> with every occurrence of <code>search_string</code> replaced with <code>replacement_string</code>. If <code>replacement_string</code> is omitted or null, then all occurrences of <code>search_string</code> are removed. If <code>search_string</code> is null, then <code>char</code> is returned. Both <code>search_string</code> and <code>replacement_string</code>, as well as <code>char</code>, can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is in the same character set as <code>char</code>. The function returns <code>VARCHAR2</code> if the first argument is not a LOB and returns <code>CLOB</code> if the first argument is a LOB. <code>REPLACE</code> provides functionality related to that provided by the <code>TRANSLATE</code> function. <code>TRANSLATE</code> provides single-character, one-to-one substitution. <code>REPLACE</code> lets you substitute one string for another as well as to remove character strings. See Also: <link>TRANSLATE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions216.htm#i1501659</link> \n The Examples is: \n The following example replaces occurrences of <code>J</code> with <code>BL</code>: <code>SELECT REPLACE('JACK and JUE','J','BL') \"Changes\" FROM DUAL; Changes -------------- BLACK and BLUE </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions153.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "VARIANCE",
        "tree": "(other_function (over_clause_keyword VARIANCE) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> VARIANCE([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>VARIANCE</code> returns the variance of <code>expr</code>. You can use it as an aggregate or analytic function. Oracle Database calculates the variance of <code>expr</code> as follows: 0 if the number of rows in <code>expr</code> = 1 <code>VAR_SAMP</code> if the number of rows in <code>expr</code> > 1 If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion, <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example calculates the variance of all salaries in the sample <code>employees</code> table: <code>SELECT VARIANCE(salary) \"Variance\" FROM employees; Variance ---------- 15283140.5 </code> Analytic Example The following example returns the cumulative variance of salary values in Department 30 ordered by hire date. <code>SELECT last_name, salary, VARIANCE(salary) OVER (ORDER BY hire_date) \"Variance\" FROM employees WHERE department_id = 30 ORDER BY last_name, salary, \"Variance\"; LAST_NAME SALARY Variance ------------------------- ---------- ---------- Baida 2900 16283333.3 Colmenares 2500 11307000 Himuro 2600 13317000 Khoo 3100 31205000 Raphaely 11000 0 Tobias 2800 21623333.3 </code> ",
        "detail": "The Syntax is: \n <eps> VARIANCE([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>VARIANCE</code> returns the variance of <code>expr</code>. You can use it as an aggregate or analytic function. Oracle Database calculates the variance of <code>expr</code> as follows: 0 if the number of rows in <code>expr</code> = 1 <code>VAR_SAMP</code> if the number of rows in <code>expr</code> > 1 If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion, <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example calculates the variance of all salaries in the sample <code>employees</code> table: <code>SELECT VARIANCE(salary) \"Variance\" FROM employees; Variance ---------- 15283140.5 </code> Analytic Example The following example returns the cumulative variance of salary values in Department 30 ordered by hire date. <code>SELECT last_name, salary, VARIANCE(salary) OVER (ORDER BY hire_date) \"Variance\" FROM employees WHERE department_id = 30 ORDER BY last_name, salary, \"Variance\"; LAST_NAME SALARY Variance ------------------------- ---------- ---------- Baida 2900 16283333.3 Colmenares 2500 11307000 Himuro 2600 13317000 Khoo 3100 31205000 Raphaely 11000 0 Tobias 2800 21623333.3 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions232.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "REGEXP_COUNT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGEXP_COUNT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> REGEXP_COUNT (source_char, pattern [, position [, match_param]]) </eps> \n The Purpose is: \n <code>REGEXP_COUNT</code> complements the functionality of the <code>REGEXP_INSTR</code> function by returning the number of times a pattern occurs in a source string. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the number of occurrences of <code>pattern</code>. If no match is found, then the function returns 0. <code>source_char</code> is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. <code>pattern</code> is the regular expression. It is usually a text literal and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. It can contain up to 512 bytes. If the data type of <code>pattern</code> is different from the data type of <code>source_char</code>, then Oracle Database converts <code>pattern</code> to the data type of <code>source_char</code>. <code>REGEXP_COUNT</code> ignores subexpression parentheses in <code>pattern</code>. For example, the pattern <code>'(123(45))'</code> is equivalent to <code>'12345'</code>. For a listing of the operators you can specify in <code>pattern</code>, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>position</code> is a positive integer indicating the character of <code>source_char</code> where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of <code>source_char</code>. After finding the first occurrence of <code>pattern</code>, the database searches for a second occurrence beginning with the first character following the first occurrence. <code>match_param</code> is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for <code>match_param</code>: <code>'i'</code> specifies case-insensitive matching. <code>'c'</code> specifies case-sensitive matching. <code>'n'</code> allows the period (.), which is the match-any-character character, to match the newline character. If you omit this parameter, then the period does not match the newline character. <code>'m'</code> treats the source string as multiple lines. Oracle interprets the caret (<code>^</code>) and dollar sign (<code>$</code>) as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then Oracle treats the source string as a single line. <code>'x'</code> ignores whitespace characters. By default, whitespace characters match themselves. If you specify multiple contradictory values, then Oracle uses the last value. For example, if you specify <code>'ic'</code>, then Oracle uses case-sensitive matching. If you specify a character other than those shown above, then Oracle returns an error. If you omit <code>match_param</code>, then: The default case sensitivity is determined by the value of the <code>NLS_SORT</code> parameter. A period (.) does not match the newline character. The source string is treated as a single line. \n The Examples is: \n The following example shows that subexpressions parentheses in pattern are ignored: <code>SELECT REGEXP_COUNT('123123123123123', '(12)3', 1, 'i') REGEXP_COUNT FROM DUAL; REGEXP_COUNT ------------ 5 </code> In the following example, the function begins to evaluate the source string at the third character, so skips over the first occurrence of pattern: <code>SELECT REGEXP_COUNT('123123123123', '123', 3, 'i') COUNT FROM DUAL; COUNT ---------- 3 </code> ",
        "detail": "The Syntax is: \n <eps> REGEXP_COUNT (source_char, pattern [, position [, match_param]]) </eps> \n The Purpose is: \n <code>REGEXP_COUNT</code> complements the functionality of the <code>REGEXP_INSTR</code> function by returning the number of times a pattern occurs in a source string. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the number of occurrences of <code>pattern</code>. If no match is found, then the function returns 0. <code>source_char</code> is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. <code>pattern</code> is the regular expression. It is usually a text literal and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. It can contain up to 512 bytes. If the data type of <code>pattern</code> is different from the data type of <code>source_char</code>, then Oracle Database converts <code>pattern</code> to the data type of <code>source_char</code>. <code>REGEXP_COUNT</code> ignores subexpression parentheses in <code>pattern</code>. For example, the pattern <code>'(123(45))'</code> is equivalent to <code>'12345'</code>. For a listing of the operators you can specify in <code>pattern</code>, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>position</code> is a positive integer indicating the character of <code>source_char</code> where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of <code>source_char</code>. After finding the first occurrence of <code>pattern</code>, the database searches for a second occurrence beginning with the first character following the first occurrence. <code>match_param</code> is a text literal that lets you change the default matching behavior of the function. You can specify one or more of the following values for <code>match_param</code>: <code>'i'</code> specifies case-insensitive matching. <code>'c'</code> specifies case-sensitive matching. <code>'n'</code> allows the period (.), which is the match-any-character character, to match the newline character. If you omit this parameter, then the period does not match the newline character. <code>'m'</code> treats the source string as multiple lines. Oracle interprets the caret (<code>^</code>) and dollar sign (<code>$</code>) as the start and end, respectively, of any line anywhere in the source string, rather than only at the start or end of the entire source string. If you omit this parameter, then Oracle treats the source string as a single line. <code>'x'</code> ignores whitespace characters. By default, whitespace characters match themselves. If you specify multiple contradictory values, then Oracle uses the last value. For example, if you specify <code>'ic'</code>, then Oracle uses case-sensitive matching. If you specify a character other than those shown above, then Oracle returns an error. If you omit <code>match_param</code>, then: The default case sensitivity is determined by the value of the <code>NLS_SORT</code> parameter. A period (.) does not match the newline character. The source string is treated as a single line. \n The Examples is: \n The following example shows that subexpressions parentheses in pattern are ignored: <code>SELECT REGEXP_COUNT('123123123123123', '(12)3', 1, 'i') REGEXP_COUNT FROM DUAL; REGEXP_COUNT ------------ 5 </code> In the following example, the function begins to evaluate the source string at the third character, so skips over the first occurrence of pattern: <code>SELECT REGEXP_COUNT('123123123123', '123', 3, 'i') COUNT FROM DUAL; COUNT ---------- 3 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions147.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PREDICTION_BOUNDS",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PREDICTION_BOUNDS))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PREDICTION_BOUNDS ( [schema.] model [, confidence_level [, class_value]] mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n The <code>PREDICTION_BOUNDS</code> function is for use with generalized linear models (GLM) created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns an object with two <code>NUMBER</code> fields <code>LOWER</code> and <code>UPPER</code>. For a regression mining function, the bounds apply to value of the prediction. For a classification mining function, the bounds apply to the probability value. If the GLM was built using ridge regression, or if the covariance matrix is found to be singular during the build, then this function returns <code>NULL</code> for both fields. For <code>confidence_level</code>, specify a number in the range (0,1). If you omit this clause, then the default value is 0.95. The <code>class_value</code> argument is valid for classification models but not for regression models. By default, the function returns the bounds for the prediction with the highest probability. You can use the <code>class_value</code> argument to filter out the bounds value specific to a target value. You can specify <code>class_value</code> while leaving <code>confidence_level</code> at its default by specifying <code>NULL</code> for <code>confidence_level</code>. The <code>mining_attribute_clause</code> has the same behavior for <code>PREDICTION_BOUNDS</code> that it has for <code>PREDICTION</code>. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: Oracle Data Mining Concepts for detailed information about <link>Oracle Data Mining&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> and about <link>generalized linear models&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/algo_glm.htm#DMCON022</link> <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example returns the distribution of customers whose ages are predicted to be between 25 and 45 years with 98% confidence. This example and the prerequisite data mining operations can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmglcdem.sql</code>. The example is presented here to illustrate the syntactic use of the function. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. <code>SELECT count(cust_id) cust_count, cust_marital_status FROM (SELECT cust_id, cust_marital_status FROM mining_data_apply_v WHERE PREDICTION_BOUNDS(glmr_sh_regr_sample,0.98 USING *).LOWER > 24 AND PREDICTION_BOUNDS(glmr_sh_regr_sample,0.98 USING *).UPPER < 46) GROUP BY cust_marital_status; CUST_COUNT CUST_MARITAL_STATUS -------------- -------------------- 46 NeverM 7 Mabsent 5 Separ. 35 Divorc. 72 Married </code> ",
        "detail": "The Syntax is: \n <eps> PREDICTION_BOUNDS ( [schema.] model [, confidence_level [, class_value]] mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n The <code>PREDICTION_BOUNDS</code> function is for use with generalized linear models (GLM) created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns an object with two <code>NUMBER</code> fields <code>LOWER</code> and <code>UPPER</code>. For a regression mining function, the bounds apply to value of the prediction. For a classification mining function, the bounds apply to the probability value. If the GLM was built using ridge regression, or if the covariance matrix is found to be singular during the build, then this function returns <code>NULL</code> for both fields. For <code>confidence_level</code>, specify a number in the range (0,1). If you omit this clause, then the default value is 0.95. The <code>class_value</code> argument is valid for classification models but not for regression models. By default, the function returns the bounds for the prediction with the highest probability. You can use the <code>class_value</code> argument to filter out the bounds value specific to a target value. You can specify <code>class_value</code> while leaving <code>confidence_level</code> at its default by specifying <code>NULL</code> for <code>confidence_level</code>. The <code>mining_attribute_clause</code> has the same behavior for <code>PREDICTION_BOUNDS</code> that it has for <code>PREDICTION</code>. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: Oracle Data Mining Concepts for detailed information about <link>Oracle Data Mining&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> and about <link>generalized linear models&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/algo_glm.htm#DMCON022</link> <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example returns the distribution of customers whose ages are predicted to be between 25 and 45 years with 98% confidence. This example and the prerequisite data mining operations can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmglcdem.sql</code>. The example is presented here to illustrate the syntactic use of the function. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. <code>SELECT count(cust_id) cust_count, cust_marital_status FROM (SELECT cust_id, cust_marital_status FROM mining_data_apply_v WHERE PREDICTION_BOUNDS(glmr_sh_regr_sample,0.98 USING *).LOWER > 24 AND PREDICTION_BOUNDS(glmr_sh_regr_sample,0.98 USING *).UPPER < 46) GROUP BY cust_marital_status; CUST_COUNT CUST_MARITAL_STATUS -------------- -------------------- 46 NeverM 7 Mabsent 5 Separ. 35 Divorc. 72 Married </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions133.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STDDEV_SAMP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STDDEV_SAMP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STDDEV_SAMP(expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>STDDEV_SAMP</code> computes the cumulative sample standard deviation and returns the square root of the sample variance. You can use it as both an aggregate and analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion This function is same as the square root of the <code>VAR_SAMP</code> function. When <code>VAR_SAMP</code> returns null, this function returns null. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>VAR_SAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions231.htm#i87169</link> <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> Aggregate Example Refer to the aggregate example for <link>STDDEV_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions179.htm#i86639</link>. Analytic Example The following example returns the sample standard deviation of salaries in the <code>employees</code> table by department: <code>SELECT department_id, last_name, hire_date, salary, STDDEV_SAMP(salary) OVER (PARTITION BY department_id ORDER BY hire_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cum_sdev FROM employees ORDER BY department_id, last_name, hire_date, salary, cum_sdev; DEPARTMENT_ID LAST_NAME HIRE_DATE SALARY CUM_SDEV ------------- --------------- --------- ---------- ---------- 10 Whalen 17-SEP-03 4400 20 Fay 17-AUG-05 6000 4949.74747 20 Hartstein 17-FEB-04 13000 30 Baida 24-DEC-05 2900 4035.26125 30 Colmenares 10-AUG-07 2500 3362.58829 30 Himuro 15-NOV-06 2600 3649.2465 30 Khoo 18-MAY-03 3100 5586.14357 30 Raphaely 07-DEC-02 11000 . . . 100 Greenberg 17-AUG-02 12008 2126.9772 100 Popp 07-DEC-07 6900 1804.13155 100 Sciarra 30-SEP-05 7700 1929.76233 100 Urman 07-MAR-06 7800 1788.92504 110 Gietz 07-JUN-02 8300 2621.95194 110 Higgins 07-JUN-02 12008 Grant 24-MAY-07 7000 </code> ",
        "detail": "The Syntax is: \n <eps> STDDEV_SAMP(expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>STDDEV_SAMP</code> computes the cumulative sample standard deviation and returns the square root of the sample variance. You can use it as both an aggregate and analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion This function is same as the square root of the <code>VAR_SAMP</code> function. When <code>VAR_SAMP</code> returns null, this function returns null. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>VAR_SAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions231.htm#i87169</link> <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> Aggregate Example Refer to the aggregate example for <link>STDDEV_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions179.htm#i86639</link>. Analytic Example The following example returns the sample standard deviation of salaries in the <code>employees</code> table by department: <code>SELECT department_id, last_name, hire_date, salary, STDDEV_SAMP(salary) OVER (PARTITION BY department_id ORDER BY hire_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cum_sdev FROM employees ORDER BY department_id, last_name, hire_date, salary, cum_sdev; DEPARTMENT_ID LAST_NAME HIRE_DATE SALARY CUM_SDEV ------------- --------------- --------- ---------- ---------- 10 Whalen 17-SEP-03 4400 20 Fay 17-AUG-05 6000 4949.74747 20 Hartstein 17-FEB-04 13000 30 Baida 24-DEC-05 2900 4035.26125 30 Colmenares 10-AUG-07 2500 3362.58829 30 Himuro 15-NOV-06 2600 3649.2465 30 Khoo 18-MAY-03 3100 5586.14357 30 Raphaely 07-DEC-02 11000 . . . 100 Greenberg 17-AUG-02 12008 2126.9772 100 Popp 07-DEC-07 6900 1804.13155 100 Sciarra 30-SEP-05 7700 1929.76233 100 Urman 07-MAR-06 7800 1788.92504 110 Gietz 07-JUN-02 8300 2621.95194 110 Higgins 07-JUN-02 12008 Grant 24-MAY-07 7000 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions180.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NLS_CHARSET_ID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NLS_CHARSET_ID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NLS_CHARSET_ID(string) </eps> \n The Purpose is: \n <code>NLS_CHARSET_ID</code> returns the character set ID number corresponding to character set name <code>string</code>. The <code>string</code> argument is a run-time <code>VARCHAR2</code> value. The <code>string</code> value '<code>CHAR_CS</code>' returns the database character set ID number of the server. The <code>string</code> value '<code>NCHAR_CS</code>' returns the national character set ID number of the server. Invalid character set names return null. \n The Examples is: \n The following example returns the character set ID of a character set: <code>SELECT NLS_CHARSET_ID('ja16euc') FROM DUAL; NLS_CHARSET_ID('JA16EUC') ------------------------- 830 </code> See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG584</link> for a list of character sets ",
        "detail": "The Syntax is: \n <eps> NLS_CHARSET_ID(string) </eps> \n The Purpose is: \n <code>NLS_CHARSET_ID</code> returns the character set ID number corresponding to character set name <code>string</code>. The <code>string</code> argument is a run-time <code>VARCHAR2</code> value. The <code>string</code> value '<code>CHAR_CS</code>' returns the database character set ID number of the server. The <code>string</code> value '<code>NCHAR_CS</code>' returns the national character set ID number of the server. Invalid character set names return null. \n The Examples is: \n The following example returns the character set ID of a character set: <code>SELECT NLS_CHARSET_ID('ja16euc') FROM DUAL; NLS_CHARSET_ID('JA16EUC') ------------------------- 830 </code> See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG584</link> for a list of character sets ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions108.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "RATIO_TO_REPORT",
        "tree": "(other_function (over_clause_keyword RATIO_TO_REPORT) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> RATIO_TO_REPORT(expr) OVER ([ query_partition_clause ]) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>expr</code> \n The Purpose is: \n <code>RATIO_TO_REPORT</code> is an analytic function. It computes the ratio of a value to the sum of a set of values. If <code>expr</code> evaluates to null, then the ratio-to-report value also evaluates to null. The set of values is determined by the <code>query_partition_clause</code>. If you omit that clause, then the ratio-to-report is computed over all rows returned by the query. You cannot nest analytic functions by using <code>RATIO_TO_REPORT</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. Refer to <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>. \n The Examples is: \n The following example calculates the ratio-to-report value of each purchasing clerk's salary to the total of all purchasing clerks' salaries: <code>SELECT last_name, salary, RATIO_TO_REPORT(salary) OVER () AS rr FROM employees WHERE job_id = 'PU_CLERK' ORDER BY last_name, salary, rr; LAST_NAME SALARY RR ------------------------- ---------- ---------- Baida 2900 .208633094 Colmenares 2500 .179856115 Himuro 2600 .18705036 Khoo 3100 .223021583 Tobias 2800 .201438849 </code> ",
        "detail": "The Syntax is: \n <eps> RATIO_TO_REPORT(expr) OVER ([ query_partition_clause ]) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>expr</code> \n The Purpose is: \n <code>RATIO_TO_REPORT</code> is an analytic function. It computes the ratio of a value to the sum of a set of values. If <code>expr</code> evaluates to null, then the ratio-to-report value also evaluates to null. The set of values is determined by the <code>query_partition_clause</code>. If you omit that clause, then the ratio-to-report is computed over all rows returned by the query. You cannot nest analytic functions by using <code>RATIO_TO_REPORT</code> or any other analytic function for <code>expr</code>. However, you can use other built-in function expressions for <code>expr</code>. Refer to <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code>. \n The Examples is: \n The following example calculates the ratio-to-report value of each purchasing clerk's salary to the total of all purchasing clerks' salaries: <code>SELECT last_name, salary, RATIO_TO_REPORT(salary) OVER () AS rr FROM employees WHERE job_id = 'PU_CLERK' ORDER BY last_name, salary, rr; LAST_NAME SALARY RR ------------------------- ---------- ---------- Baida 2900 .208633094 Colmenares 2500 .179856115 Himuro 2600 .18705036 Khoo 3100 .223021583 Tobias 2800 .201438849 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions142.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "REGEXP_INSTR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGEXP_INSTR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> REGEXP_INSTR (source_char, pattern [, position [, occurrence [, return_opt [, match_param [, subexpr] ] ] ] ] </eps> \n The Purpose is: \n <code>REGEXP_INSTR</code> extends the functionality of the <code>INSTR</code> function by letting you search a string for a regular expression pattern. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the beginning or ending position of the matched substring, depending on the value of the <code>return_option</code> argument. If no match is found, then the function returns 0. This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>source_char</code> is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. <code>pattern</code> is the regular expression. It is usually a text literal and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. It can contain up to 512 bytes. If the data type of <code>pattern</code> is different from the data type of <code>source_char</code>, then Oracle Database converts <code>pattern</code> to the data type of <code>source_char</code>. For a listing of the operators you can specify in <code>pattern</code>, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>position</code> is a positive integer indicating the character of <code>source_char</code> where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of <code>source_char</code>. <code>occurrence</code> is a positive integer indicating which occurrence of <code>pattern</code> in <code>source_char</code> Oracle should search for. The default is 1, meaning that Oracle searches for the first occurrence of <code>pattern</code>. If <code>occurrence</code> is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of <code>pattern</code>, and so forth. This behavior is different from the <code>INSTR</code> function, which begins its search for the second occurrence at the second character of the first occurrence. <code>return_option</code> lets you specify what Oracle should return in relation to the occurrence: If you specify 0, then Oracle returns the position of the first character of the occurrence. This is the default. If you specify 1, then Oracle returns the position of the character following the occurrence. <code>match_parameter</code> is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for <code>REGEXP_COUNT</code>. Refer to <link>REGEXP_COUNT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions147.htm#CIHDAIHJ</link> for detailed information. For a <code>pattern</code> with subexpressions, <code>subexpr</code> is an integer from 0 to 9 indicating which subexpression in <code>pattern</code> is the target of the function. The <code>subexpr</code> is a fragment of pattern enclosed in parentheses. Subexpressions can be nested. Subexpressions are numbered in order in which their left parentheses appear in pattern. For example, consider the following expression: <code>0123(((abc)(de)f)ghi)45(678) </code> This expression has five subexpressions in the following order: \"abcdefghi\" followed by \"abcdef\", \"abc\", \"de\" and \"678\". If <code>subexpr</code> is zero, then the position of the entire substring that matches the <code>pattern</code> is returned. If <code>subexpr</code> is greater than zero, then the position of the substring fragment that corresponds to subexpression number <code>subexpr</code> in the matched substring is returned. If <code>pattern</code> does not have at least <code>subexpr</code> subexpressions, the function returns zero. A null <code>subexpr</code> value returns <code>NULL</code>. The default value for <code>subexpr</code> is zero. See Also: <link>INSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions080.htm#i77598</link> and <link>REGEXP_SUBSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions150.htm#i1239858</link> <link>REGEXP_REPLACE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions149.htm#i1305521</link> and <link>REGEXP_LIKE Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions007.htm#i1048942</link> \n The Examples is: \n The following example examines the string, looking for occurrences of one or more non-blank characters. Oracle begins searching at the first character in the string and returns the starting position (default) of the sixth occurrence of one or more non-blank characters. <code>SELECT REGEXP_INSTR('500 Oracle Parkway, Redwood Shores, CA', '[^ ]+', 1, 6) \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------ 37 </code> The following example examines the string, looking for occurrences of words beginning with <code>s</code>, <code>r</code>, or <code>p</code>, regardless of case, followed by any six alphabetic characters. Oracle begins searching at the third character in the string and returns the position in the string of the character following the second occurrence of a seven-letter word beginning with <code>s</code>, <code>r</code>, or <code>p</code>, regardless of case. <code>SELECT REGEXP_INSTR('500 Oracle Parkway, Redwood Shores, CA', '[s|r|p][[:alpha:]]{6}', 3, 2, 1, 'i') \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------ 28 </code> The following examples use the <code>subexpr</code> argument to search for a particular subexpression in <code>pattern</code>. The first statement returns the position in the source string of the first character in the first subexpression, which is '123': <code>SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 1) \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------------- 1 </code> The next statement returns the position in the source string of the first character in the second subexpression, which is '45678': <code>SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 2) \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------------- 4 </code> The next statement returns the position in the source string of the first character in the fourth subexpression, which is '78': <code>SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 4) \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------------- 7 </code> ",
        "detail": "The Syntax is: \n <eps> REGEXP_INSTR (source_char, pattern [, position [, occurrence [, return_opt [, match_param [, subexpr] ] ] ] ] </eps> \n The Purpose is: \n <code>REGEXP_INSTR</code> extends the functionality of the <code>INSTR</code> function by letting you search a string for a regular expression pattern. The function evaluates strings using characters as defined by the input character set. It returns an integer indicating the beginning or ending position of the matched substring, depending on the value of the <code>return_option</code> argument. If no match is found, then the function returns 0. This function complies with the POSIX regular expression standard and the Unicode Regular Expression Guidelines. For more information, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>source_char</code> is a character expression that serves as the search value. It is commonly a character column and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. <code>pattern</code> is the regular expression. It is usually a text literal and can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. It can contain up to 512 bytes. If the data type of <code>pattern</code> is different from the data type of <code>source_char</code>, then Oracle Database converts <code>pattern</code> to the data type of <code>source_char</code>. For a listing of the operators you can specify in <code>pattern</code>, refer to <link>Appendix D, \"Oracle Regular Expression Support\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_posix.htm#g693775</link>. <code>position</code> is a positive integer indicating the character of <code>source_char</code> where Oracle should begin the search. The default is 1, meaning that Oracle begins the search at the first character of <code>source_char</code>. <code>occurrence</code> is a positive integer indicating which occurrence of <code>pattern</code> in <code>source_char</code> Oracle should search for. The default is 1, meaning that Oracle searches for the first occurrence of <code>pattern</code>. If <code>occurrence</code> is greater than 1, then the database searches for the second occurrence beginning with the first character following the first occurrence of <code>pattern</code>, and so forth. This behavior is different from the <code>INSTR</code> function, which begins its search for the second occurrence at the second character of the first occurrence. <code>return_option</code> lets you specify what Oracle should return in relation to the occurrence: If you specify 0, then Oracle returns the position of the first character of the occurrence. This is the default. If you specify 1, then Oracle returns the position of the character following the occurrence. <code>match_parameter</code> is a text literal that lets you change the default matching behavior of the function. The behavior of this parameter is the same for this function as for <code>REGEXP_COUNT</code>. Refer to <link>REGEXP_COUNT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions147.htm#CIHDAIHJ</link> for detailed information. For a <code>pattern</code> with subexpressions, <code>subexpr</code> is an integer from 0 to 9 indicating which subexpression in <code>pattern</code> is the target of the function. The <code>subexpr</code> is a fragment of pattern enclosed in parentheses. Subexpressions can be nested. Subexpressions are numbered in order in which their left parentheses appear in pattern. For example, consider the following expression: <code>0123(((abc)(de)f)ghi)45(678) </code> This expression has five subexpressions in the following order: \"abcdefghi\" followed by \"abcdef\", \"abc\", \"de\" and \"678\". If <code>subexpr</code> is zero, then the position of the entire substring that matches the <code>pattern</code> is returned. If <code>subexpr</code> is greater than zero, then the position of the substring fragment that corresponds to subexpression number <code>subexpr</code> in the matched substring is returned. If <code>pattern</code> does not have at least <code>subexpr</code> subexpressions, the function returns zero. A null <code>subexpr</code> value returns <code>NULL</code>. The default value for <code>subexpr</code> is zero. See Also: <link>INSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions080.htm#i77598</link> and <link>REGEXP_SUBSTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions150.htm#i1239858</link> <link>REGEXP_REPLACE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions149.htm#i1305521</link> and <link>REGEXP_LIKE Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions007.htm#i1048942</link> \n The Examples is: \n The following example examines the string, looking for occurrences of one or more non-blank characters. Oracle begins searching at the first character in the string and returns the starting position (default) of the sixth occurrence of one or more non-blank characters. <code>SELECT REGEXP_INSTR('500 Oracle Parkway, Redwood Shores, CA', '[^ ]+', 1, 6) \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------ 37 </code> The following example examines the string, looking for occurrences of words beginning with <code>s</code>, <code>r</code>, or <code>p</code>, regardless of case, followed by any six alphabetic characters. Oracle begins searching at the third character in the string and returns the position in the string of the character following the second occurrence of a seven-letter word beginning with <code>s</code>, <code>r</code>, or <code>p</code>, regardless of case. <code>SELECT REGEXP_INSTR('500 Oracle Parkway, Redwood Shores, CA', '[s|r|p][[:alpha:]]{6}', 3, 2, 1, 'i') \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------ 28 </code> The following examples use the <code>subexpr</code> argument to search for a particular subexpression in <code>pattern</code>. The first statement returns the position in the source string of the first character in the first subexpression, which is '123': <code>SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 1) \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------------- 1 </code> The next statement returns the position in the source string of the first character in the second subexpression, which is '45678': <code>SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 2) \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------------- 4 </code> The next statement returns the position in the source string of the first character in the fourth subexpression, which is '78': <code>SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))', 1, 1, 0, 'i', 4) \"REGEXP_INSTR\" FROM DUAL; REGEXP_INSTR ------------------- 7 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions148.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_NCHAR_(character)",
        "tree": "(general_element_part (id_expression (regular_id TO_NCHAR_)) (function_argument ( )))",
        "description": "The Syntax is: \n to_nchar_char::= <eps> TO_NCHAR({char | clob | nclob}) </eps> \n The Purpose is: \n <code>TO_NCHAR</code> (character) converts a character string, <code>CHAR</code>, <code>VARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code> value to the national character set. The value returned is always <code>NVARCHAR2</code>. This function is equivalent to the <code>TRANSLATE</code> ... <code>USING</code> function with a <code>USING</code> clause in the national character set. See Also: <link>\"Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i46862</link> and <link>TRANSLATE ... USING&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions217.htm#i79617</link> \n The Examples is: \n The following example converts <code>VARCHAR2</code> data from the <code>oe.customers</code> table to the national character set: <code>SELECT TO_NCHAR(cust_last_name) FROM customers WHERE customer_id=103; TO_NCHAR(CUST_LAST_NAME) -------------------------------------------------- Taylor </code> ",
        "detail": "The Syntax is: \n to_nchar_char::= <eps> TO_NCHAR({char | clob | nclob}) </eps> \n The Purpose is: \n <code>TO_NCHAR</code> (character) converts a character string, <code>CHAR</code>, <code>VARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code> value to the national character set. The value returned is always <code>NVARCHAR2</code>. This function is equivalent to the <code>TRANSLATE</code> ... <code>USING</code> function with a <code>USING</code> clause in the national character set. See Also: <link>\"Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i46862</link> and <link>TRANSLATE ... USING&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions217.htm#i79617</link> \n The Examples is: \n The following example converts <code>VARCHAR2</code> data from the <code>oe.customers</code> table to the national character set: <code>SELECT TO_NCHAR(cust_last_name) FROM customers WHERE customer_id=103; TO_NCHAR(CUST_LAST_NAME) -------------------------------------------------- Taylor </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions207.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYS_DBURIGEN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYS_DBURIGEN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYS_DBURIGEN({ column | attribute } [ rowid ] [, { column | attribute } [ rowid ] ]... [, 'text ( )' ] ) </eps> \n The Purpose is: \n <code>SYS_DBURIGen</code> takes as its argument one or more columns or attributes, and optionally a rowid, and generates a URL of data type <code>DBURIType</code> to a particular column or row object. You can then use the URL to retrieve an XML document from the database. All columns or attributes referenced must reside in the same table. They must perform the function of a primary key. They need not actually match the primary key of the table, but they must reference a unique value. If you specify multiple columns, then all but the final column identify the row in the database, and the last column specified identifies the column within the row. By default the URL points to a formatted XML document. If you want the URL to point only to the text of the document, then specify the optional '<code>text()</code>'. Note: In this XML context, the lowercase <code>text</code> is a keyword, not a syntactic placeholder. If the table or view containing the columns or attributes does not have a schema specified in the context of the query, then Oracle Database interprets the table or view name as a public synonym. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb03usg.htm#ADXDB4168</link> for information on the <code>URIType</code> data type and XML documents in the database \n The Examples is: \n The following example uses the <code>SYS_DBURIGen</code> function to generate a URL of data type <code>DBURIType</code> to the <code>email</code> column of the row in the sample table <code>hr.employees</code> where the <code>employee_id</code> = 206: <code>SELECT SYS_DBURIGEN(employee_id, email) FROM employees WHERE employee_id = 206; SYS_DBURIGEN(EMPLOYEE_ID,EMAIL)(URL, SPARE) -------------------------------------------------------------------- DBURITYPE('/PUBLIC/EMPLOYEES/ROW[EMPLOYEE_ID=''206'']/EMAIL', NULL) </code> ",
        "detail": "The Syntax is: \n <eps> SYS_DBURIGEN({ column | attribute } [ rowid ] [, { column | attribute } [ rowid ] ]... [, 'text ( )' ] ) </eps> \n The Purpose is: \n <code>SYS_DBURIGen</code> takes as its argument one or more columns or attributes, and optionally a rowid, and generates a URL of data type <code>DBURIType</code> to a particular column or row object. You can then use the URL to retrieve an XML document from the database. All columns or attributes referenced must reside in the same table. They must perform the function of a primary key. They need not actually match the primary key of the table, but they must reference a unique value. If you specify multiple columns, then all but the final column identify the row in the database, and the last column specified identifies the column within the row. By default the URL points to a formatted XML document. If you want the URL to point only to the text of the document, then specify the optional '<code>text()</code>'. Note: In this XML context, the lowercase <code>text</code> is a keyword, not a syntactic placeholder. If the table or view containing the columns or attributes does not have a schema specified in the context of the query, then Oracle Database interprets the table or view name as a public synonym. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb03usg.htm#ADXDB4168</link> for information on the <code>URIType</code> data type and XML documents in the database \n The Examples is: \n The following example uses the <code>SYS_DBURIGen</code> function to generate a URL of data type <code>DBURIType</code> to the <code>email</code> column of the row in the sample table <code>hr.employees</code> where the <code>employee_id</code> = 206: <code>SELECT SYS_DBURIGEN(employee_id, email) FROM employees WHERE employee_id = 206; SYS_DBURIGEN(EMPLOYEE_ID,EMAIL)(URL, SPARE) -------------------------------------------------------------------- DBURITYPE('/PUBLIC/EMPLOYEES/ROW[EMPLOYEE_ID=''206'']/EMAIL', NULL) </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions185.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "REFTOHEX",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REFTOHEX))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> REFTOHEX (expr) </eps> \n The Purpose is: \n <code>REFTOHEX</code> converts argument <code>expr</code> to a character value containing its hexadecimal equivalent. <code>expr</code> must return a <code>REF</code>. \n The Examples is: \n The sample schema <code>oe</code> contains a <code>warehouse_typ</code>. The following example builds on that type to illustrate how to convert the <code>REF</code> value of a column to a character value containing its hexadecimal equivalent: <code>CREATE TABLE warehouse_table OF warehouse_typ (PRIMARY KEY (warehouse_id)); CREATE TABLE location_table (location_number NUMBER, building REF warehouse_typ SCOPE IS warehouse_table); INSERT INTO warehouse_table VALUES (1, 'Downtown', 99); INSERT INTO location_table SELECT 10, REF(w) FROM warehouse_table w; SELECT REFTOHEX(building) FROM location_table; REFTOHEX(BUILDING) -------------------------------------------------------------------------- 0000220208859B5E9255C31760E034080020825436859B5E9255C21760E034080020825436 </code> ",
        "detail": "The Syntax is: \n <eps> REFTOHEX (expr) </eps> \n The Purpose is: \n <code>REFTOHEX</code> converts argument <code>expr</code> to a character value containing its hexadecimal equivalent. <code>expr</code> must return a <code>REF</code>. \n The Examples is: \n The sample schema <code>oe</code> contains a <code>warehouse_typ</code>. The following example builds on that type to illustrate how to convert the <code>REF</code> value of a column to a character value containing its hexadecimal equivalent: <code>CREATE TABLE warehouse_table OF warehouse_typ (PRIMARY KEY (warehouse_id)); CREATE TABLE location_table (location_number NUMBER, building REF warehouse_typ SCOPE IS warehouse_table); INSERT INTO warehouse_table VALUES (1, 'Downtown', 99); INSERT INTO location_table SELECT 10, REF(w) FROM warehouse_table w; SELECT REFTOHEX(building) FROM location_table; REFTOHEX(BUILDING) -------------------------------------------------------------------------- 0000220208859B5E9255C31760E034080020825436859B5E9255C21760E034080020825436 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions146.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PRESENTNNV",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PRESENTNNV))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PRESENTNNV(cell_reference, expr1, expr2) </eps> \n The Purpose is: \n The <code>PRESENTNNV</code> function can be used only in the <code>model_clause</code> of the <code>SELECT</code> statement and then only on the right-hand side of a model rule. It returns <code>expr1</code> when <code>cell_reference</code> exists prior to the execution of the <code>model_clause</code> and is not null when <code>PRESENTNNV</code> is evaluated. Otherwise it returns <code>expr2</code>. This function differs from <code>NVL2</code> in that <code>NVL2</code> evaluates the data at the time it is executed, rather than evaluating the data as it was prior to the execution of the <code>model_clause</code>. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics <link>NVL2&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions120.htm#i91806</link> for comparison \n The Examples is: \n In the following example, if a row containing sales for the Mouse Pad for the year 2002 exists, and the sales value is not null, then the sales value remains unchanged. If the row exists and the sales value is null, then the sales value is set to 10. If the row does not exist, then the row is created with the sales value set to 10. <code>SELECT country, prod, year, s FROM sales_view_ref MODEL PARTITION BY (country) DIMENSION BY (prod, year) MEASURES (sale s) IGNORE NAV UNIQUE DIMENSION RULES UPSERT SEQUENTIAL ORDER ( s['Mouse Pad', 2002] = PRESENTNNV(s['Mouse Pad', 2002], s['Mouse Pad', 2002], 10) ) ORDER BY country, prod, year; COUNTRY PROD YEAR S ---------- ----------------------------------- -------- --------- France Mouse Pad 1998 2509.42 France Mouse Pad 1999 3678.69 France Mouse Pad 2000 3000.72 France Mouse Pad 2001 3269.09 France Mouse Pad 2002 10 France Standard Mouse 1998 2390.83 France Standard Mouse 1999 2280.45 France Standard Mouse 2000 1274.31 France Standard Mouse 2001 2164.54 Germany Mouse Pad 1998 5827.87 Germany Mouse Pad 1999 8346.44 Germany Mouse Pad 2000 7375.46 Germany Mouse Pad 2001 9535.08 Germany Mouse Pad 2002 10 Germany Standard Mouse 1998 7116.11 Germany Standard Mouse 1999 6263.14 Germany Standard Mouse 2000 2637.31 Germany Standard Mouse 2001 6456.13 18 rows selected. </code> The preceding example requires the view <code>sales_view_ref</code>. Refer to <link>\"\n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2066378</link> to create this view. ",
        "detail": "The Syntax is: \n <eps> PRESENTNNV(cell_reference, expr1, expr2) </eps> \n The Purpose is: \n The <code>PRESENTNNV</code> function can be used only in the <code>model_clause</code> of the <code>SELECT</code> statement and then only on the right-hand side of a model rule. It returns <code>expr1</code> when <code>cell_reference</code> exists prior to the execution of the <code>model_clause</code> and is not null when <code>PRESENTNNV</code> is evaluated. Otherwise it returns <code>expr2</code>. This function differs from <code>NVL2</code> in that <code>NVL2</code> evaluates the data at the time it is executed, rather than evaluating the data as it was prior to the execution of the <code>model_clause</code>. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics <link>NVL2&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions120.htm#i91806</link> for comparison \n The Examples is: \n In the following example, if a row containing sales for the Mouse Pad for the year 2002 exists, and the sales value is not null, then the sales value remains unchanged. If the row exists and the sales value is null, then the sales value is set to 10. If the row does not exist, then the row is created with the sales value set to 10. <code>SELECT country, prod, year, s FROM sales_view_ref MODEL PARTITION BY (country) DIMENSION BY (prod, year) MEASURES (sale s) IGNORE NAV UNIQUE DIMENSION RULES UPSERT SEQUENTIAL ORDER ( s['Mouse Pad', 2002] = PRESENTNNV(s['Mouse Pad', 2002], s['Mouse Pad', 2002], 10) ) ORDER BY country, prod, year; COUNTRY PROD YEAR S ---------- ----------------------------------- -------- --------- France Mouse Pad 1998 2509.42 France Mouse Pad 1999 3678.69 France Mouse Pad 2000 3000.72 France Mouse Pad 2001 3269.09 France Mouse Pad 2002 10 France Standard Mouse 1998 2390.83 France Standard Mouse 1999 2280.45 France Standard Mouse 2000 1274.31 France Standard Mouse 2001 2164.54 Germany Mouse Pad 1998 5827.87 Germany Mouse Pad 1999 8346.44 Germany Mouse Pad 2000 7375.46 Germany Mouse Pad 2001 9535.08 Germany Mouse Pad 2002 10 Germany Standard Mouse 1998 7116.11 Germany Standard Mouse 1999 6263.14 Germany Standard Mouse 2000 2637.31 Germany Standard Mouse 2001 6456.13 18 rows selected. </code> The preceding example requires the view <code>sales_view_ref</code>. Refer to <link>\"\n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2066378</link> to create this view. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions138.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLELEMENT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLELEMENT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLELEMENT ( [ ENTITYESCAPING | NOENTITYESCAPING ] [ NAME ] { identifier | EVALNAME value_expr } [, XML_attributes_clause ] [, value_expr [ [AS] c_alias ]]... ) </eps> XML_attributes_clause::= <eps> XMLATTRIBUTES ( [ ENTITYESCAPING | NOENTITYESCAPING ] [ SCHEMACHECK | NOSCHEMACHECK ] value_expr [ { [AS] c_alias } | { AS EVALNAME value_expr } ] [, value_expr [ { [AS] c_alias } | { AS EVALNAME value_expr } ] ]... ) </eps> \n The Purpose is: \n <code>XMLElement</code> takes an element name for <code>identifier</code> or evaluates an element name for <code>EVALNAME</code> <code>value_expr</code>, an optional collection of attributes for the element, and arguments that make up the content of the element. It returns an instance of type <code>XMLType</code>. <code>XMLElement</code> is similar to <code>SYS_XMLGen</code> except that <code>XMLElement</code> can include attributes in the XML returned, but it does not accept formatting using the <code>XMLFormat</code> object. The <code>XMLElement</code> function is typically nested to produce an XML document with a nested structure, as in the example in the following section. For an explanation of the <code>ENTITYESCAPING</code> and <code>NONENTITYESCAPING</code> keywords, refer to <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link>. You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying <code>identifier</code>, which is a string literal, or by specifying <code>EVALNAME</code> <code>value_expr</code>. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier can be up to 4000 characters and does not have to be a column name or column reference. It cannot be an expression or null. The objects that make up the element content follow the <code>XMLATTRIBUTES</code> keyword. In the <code>XML_attributes_clause</code>, if the <code>value_expr</code> is null, then no attribute is created for that value expression. The type of <code>value_expr</code> cannot be an object type or collection. If you specify an alias for <code>value_expr</code> using the <code>AS</code> clause, then the <code>c_alias</code> or the evaluated value expression (<code>EVALNAME</code> <code>value_expr</code>) can be up to 4000 characters. For the optional <code>value_expr</code> that follows the <code>XML_attributes_clause</code> in the diagram: If <code>value_expr</code> is a scalar expression, then you can omit the <code>AS</code> clause, and Oracle uses the column name as the element name. If <code>value_expr</code> is an object type or collection, then the <code>AS</code> clause is mandatory, and Oracle uses the specified <code>c_alias</code> as the enclosing tag. If <code>value_expr</code> is null, then no element is created for that value expression. See Also: <link>SYS_XMLGEN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions190.htm#i1004367</link> \n The Examples is: \n The following example produces an <code>Emp</code> element for a series of employees, with nested elements that provide the employee's name and hire date: <code>SELECT XMLELEMENT(\"Emp\", XMLELEMENT(\"Name\", e.job_id||' '||e.last_name), XMLELEMENT(\"Hiredate\", e.hire_date)) as \"Result\" FROM employees e WHERE employee_id > 200; Result ------------------------------------------------------------------- <Emp> <Name>MK_MAN Hartstein</Name> <Hiredate>2004-02-17</Hiredate> </Emp> <Emp> <Name>MK_REP Fay</Name> <Hiredate>2005-08-17</Hiredate> </Emp> <Emp> <Name>HR_REP Mavris</Name> <Hiredate>2002-06-07</Hiredate> </Emp> <Emp> <Name>PR_REP Baer</Name> <Hiredate>2002-06-07</Hiredate> </Emp> <Emp> <Name>AC_MGR Higgins</Name> <Hiredate>2002-06-07</Hiredate> </Emp> <Emp> <Name>AC_ACCOUNT Gietz</Name> <Hiredate>2002-06-07</Hiredate> </Emp> 6 rows selected. </code> The following similar example uses the <code>XMLElement</code> function with the <code>XML_attributes_clause</code> to create nested XML elements with attribute values for the top-level element: <code>SELECT XMLELEMENT(\"Emp\", XMLATTRIBUTES(e.employee_id AS \"ID\", e.last_name), XMLELEMENT(\"Dept\", e.department_id), XMLELEMENT(\"Salary\", e.salary)) AS \"Emp Element\" FROM employees e WHERE e.employee_id = 206; Emp Element --------------------------------------------------------------- <Emp ID=\"206\" LAST_NAME=\"Gietz\"> <Dept>110</Dept> <Salary>8300</Salary> </Emp> </code> Notice that the <code>AS</code> <code>identifier</code> clause was not specified for the <code>last_name</code> column. As a result, the XML returned uses the column name <code>last_name</code> as the default. Finally, the next example uses a subquery within the <code>XML_attributes_clause</code> to retrieve information from another table into the attributes of an element: <code>SELECT XMLELEMENT(\"Emp\", XMLATTRIBUTES(e.employee_id, e.last_name), XMLELEMENT(\"Dept\", XMLATTRIBUTES(e.department_id, (SELECT d.department_name FROM departments d WHERE d.department_id = e.department_id) as \"Dept_name\")), XMLELEMENT(\"salary\", e.salary), XMLELEMENT(\"Hiredate\", e.hire_date)) AS \"Emp Element\" FROM employees e WHERE employee_id = 205; Emp Element ------------------------------------------------------------------- <Emp EMPLOYEE_ID=\"205\" LAST_NAME=\"Higgins\"> <Dept DEPARTMENT_ID=\"110\" Dept_name=\"Accounting\"/> <salary>12008</salary> <Hiredate>2002-06-07</Hiredate> </Emp> </code> ",
        "detail": "The Syntax is: \n <eps> XMLELEMENT ( [ ENTITYESCAPING | NOENTITYESCAPING ] [ NAME ] { identifier | EVALNAME value_expr } [, XML_attributes_clause ] [, value_expr [ [AS] c_alias ]]... ) </eps> XML_attributes_clause::= <eps> XMLATTRIBUTES ( [ ENTITYESCAPING | NOENTITYESCAPING ] [ SCHEMACHECK | NOSCHEMACHECK ] value_expr [ { [AS] c_alias } | { AS EVALNAME value_expr } ] [, value_expr [ { [AS] c_alias } | { AS EVALNAME value_expr } ] ]... ) </eps> \n The Purpose is: \n <code>XMLElement</code> takes an element name for <code>identifier</code> or evaluates an element name for <code>EVALNAME</code> <code>value_expr</code>, an optional collection of attributes for the element, and arguments that make up the content of the element. It returns an instance of type <code>XMLType</code>. <code>XMLElement</code> is similar to <code>SYS_XMLGen</code> except that <code>XMLElement</code> can include attributes in the XML returned, but it does not accept formatting using the <code>XMLFormat</code> object. The <code>XMLElement</code> function is typically nested to produce an XML document with a nested structure, as in the example in the following section. For an explanation of the <code>ENTITYESCAPING</code> and <code>NONENTITYESCAPING</code> keywords, refer to <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link>. You must specify a value for Oracle Database to use an the enclosing tag. You can do this by specifying <code>identifier</code>, which is a string literal, or by specifying <code>EVALNAME</code> <code>value_expr</code>. In the latter case, the value expression is evaluated and the result, which must be a string literal, is used as the identifier. The identifier can be up to 4000 characters and does not have to be a column name or column reference. It cannot be an expression or null. The objects that make up the element content follow the <code>XMLATTRIBUTES</code> keyword. In the <code>XML_attributes_clause</code>, if the <code>value_expr</code> is null, then no attribute is created for that value expression. The type of <code>value_expr</code> cannot be an object type or collection. If you specify an alias for <code>value_expr</code> using the <code>AS</code> clause, then the <code>c_alias</code> or the evaluated value expression (<code>EVALNAME</code> <code>value_expr</code>) can be up to 4000 characters. For the optional <code>value_expr</code> that follows the <code>XML_attributes_clause</code> in the diagram: If <code>value_expr</code> is a scalar expression, then you can omit the <code>AS</code> clause, and Oracle uses the column name as the element name. If <code>value_expr</code> is an object type or collection, then the <code>AS</code> clause is mandatory, and Oracle uses the specified <code>c_alias</code> as the enclosing tag. If <code>value_expr</code> is null, then no element is created for that value expression. See Also: <link>SYS_XMLGEN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions190.htm#i1004367</link> \n The Examples is: \n The following example produces an <code>Emp</code> element for a series of employees, with nested elements that provide the employee's name and hire date: <code>SELECT XMLELEMENT(\"Emp\", XMLELEMENT(\"Name\", e.job_id||' '||e.last_name), XMLELEMENT(\"Hiredate\", e.hire_date)) as \"Result\" FROM employees e WHERE employee_id > 200; Result ------------------------------------------------------------------- <Emp> <Name>MK_MAN Hartstein</Name> <Hiredate>2004-02-17</Hiredate> </Emp> <Emp> <Name>MK_REP Fay</Name> <Hiredate>2005-08-17</Hiredate> </Emp> <Emp> <Name>HR_REP Mavris</Name> <Hiredate>2002-06-07</Hiredate> </Emp> <Emp> <Name>PR_REP Baer</Name> <Hiredate>2002-06-07</Hiredate> </Emp> <Emp> <Name>AC_MGR Higgins</Name> <Hiredate>2002-06-07</Hiredate> </Emp> <Emp> <Name>AC_ACCOUNT Gietz</Name> <Hiredate>2002-06-07</Hiredate> </Emp> 6 rows selected. </code> The following similar example uses the <code>XMLElement</code> function with the <code>XML_attributes_clause</code> to create nested XML elements with attribute values for the top-level element: <code>SELECT XMLELEMENT(\"Emp\", XMLATTRIBUTES(e.employee_id AS \"ID\", e.last_name), XMLELEMENT(\"Dept\", e.department_id), XMLELEMENT(\"Salary\", e.salary)) AS \"Emp Element\" FROM employees e WHERE e.employee_id = 206; Emp Element --------------------------------------------------------------- <Emp ID=\"206\" LAST_NAME=\"Gietz\"> <Dept>110</Dept> <Salary>8300</Salary> </Emp> </code> Notice that the <code>AS</code> <code>identifier</code> clause was not specified for the <code>last_name</code> column. As a result, the XML returned uses the column name <code>last_name</code> as the default. Finally, the next example uses a subquery within the <code>XML_attributes_clause</code> to retrieve information from another table into the attributes of an element: <code>SELECT XMLELEMENT(\"Emp\", XMLATTRIBUTES(e.employee_id, e.last_name), XMLELEMENT(\"Dept\", XMLATTRIBUTES(e.department_id, (SELECT d.department_name FROM departments d WHERE d.department_id = e.department_id) as \"Dept_name\")), XMLELEMENT(\"salary\", e.salary), XMLELEMENT(\"Hiredate\", e.hire_date)) AS \"Emp Element\" FROM employees e WHERE employee_id = 205; Emp Element ------------------------------------------------------------------- <Emp EMPLOYEE_ID=\"205\" LAST_NAME=\"Higgins\"> <Dept DEPARTMENT_ID=\"110\" Dept_name=\"Accounting\"/> <salary>12008</salary> <Hiredate>2002-06-07</Hiredate> </Emp> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions242.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PREVIOUS",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PREVIOUS))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PREVIOUS(cell_reference) </eps> \n The Purpose is: \n The <code>PREVIOUS</code> function can be used only in the <code>model_clause</code> of the <code>SELECT</code> statement and then only in the <code>ITERATE</code> ... [ <code>UNTIL</code> <code>]</code> clause of the <code>model_rules_clause</code>. It returns the value of <code>cell_reference</code> at the beginning of each iteration. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics \n The Examples is: \n The following example repeats the rules, up to 1000 times, until the difference between the values of <code>cur_val</code> at the beginning and at the end of an iteration is less than one: <code>SELECT dim_col, cur_val, num_of_iterations FROM (SELECT 1 AS dim_col, 10 AS cur_val FROM dual) MODEL DIMENSION BY (dim_col) MEASURES (cur_val, 0 num_of_iterations) IGNORE NAV UNIQUE DIMENSION RULES ITERATE (1000) UNTIL (PREVIOUS(cur_val[1]) - cur_val[1] < 1) ( cur_val[1] = cur_val[1]/2, num_of_iterations[1] = num_of_iterations[1] + 1 ); DIM_COL CUR_VAL NUM_OF_ITERATIONS ---------- ---------- ----------------- 1 .625 4 </code> ",
        "detail": "The Syntax is: \n <eps> PREVIOUS(cell_reference) </eps> \n The Purpose is: \n The <code>PREVIOUS</code> function can be used only in the <code>model_clause</code> of the <code>SELECT</code> statement and then only in the <code>ITERATE</code> ... [ <code>UNTIL</code> <code>]</code> clause of the <code>model_rules_clause</code>. It returns the value of <code>cell_reference</code> at the beginning of each iteration. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics \n The Examples is: \n The following example repeats the rules, up to 1000 times, until the difference between the values of <code>cur_val</code> at the beginning and at the end of an iteration is less than one: <code>SELECT dim_col, cur_val, num_of_iterations FROM (SELECT 1 AS dim_col, 10 AS cur_val FROM dual) MODEL DIMENSION BY (dim_col) MEASURES (cur_val, 0 num_of_iterations) IGNORE NAV UNIQUE DIMENSION RULES ITERATE (1000) UNTIL (PREVIOUS(cur_val[1]) - cur_val[1] < 1) ( cur_val[1] = cur_val[1]/2, num_of_iterations[1] = num_of_iterations[1] + 1 ); DIM_COL CUR_VAL NUM_OF_ITERATIONS ---------- ---------- ----------------- 1 .625 4 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions140.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYS_TYPEID",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYS_TYPEID))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYS_TYPEID(object_type_value) </eps> \n The Purpose is: \n <code>SYS_TYPEID</code> returns the typeid of the most specific type of the operand. This value is used primarily to identify the type-discriminant column underlying a substitutable column. For example, you can use the value returned by <code>SYS_TYPEID</code> to build an index on the type-discriminant column. You can use this function only on object type operands. All final root object types\u2014final types not belonging to a type hierarchy\u2014have a null typeid. Oracle Database assigns to all types belonging to a type hierarchy a unique non-null typeid. See Also: <link>Oracle Database Object-Relational Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e11822/adobjbas.htm#ADOBJ002</link> for more information on typeids \n The Examples is: \n The following examples use the tables <code>persons</code> and <code>books</code>, which are created in <link>\"Substitutable Table and Column \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm#i2090577</link>. The first query returns the most specific types of the object instances stored in the <code>persons</code> table. <code>SELECT name, SYS_TYPEID(VALUE(p)) \"Type_id\" FROM persons p; NAME Type_id ------------------------- -------------------------------- Bob 01 Joe 02 Tim 03 </code> The next query returns the most specific types of authors stored in the table <code>books</code>: <code>SELECT b.title, b.author.name, SYS_TYPEID(author) \"Type_ID\" FROM books b; TITLE AUTHOR.NAME Type_ID ------------------------- -------------------- ------------------- An Autobiography Bob 01 Business Rules Joe 02 Mixing School and Work Tim 03 </code> You can use the <code>SYS_TYPEID</code> function to create an index on the type-discriminant column of a table. For an example, see <link>\"Indexing on Substitutable Columns: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_5012.htm#i2089060</link>. ",
        "detail": "The Syntax is: \n <eps> SYS_TYPEID(object_type_value) </eps> \n The Purpose is: \n <code>SYS_TYPEID</code> returns the typeid of the most specific type of the operand. This value is used primarily to identify the type-discriminant column underlying a substitutable column. For example, you can use the value returned by <code>SYS_TYPEID</code> to build an index on the type-discriminant column. You can use this function only on object type operands. All final root object types\u2014final types not belonging to a type hierarchy\u2014have a null typeid. Oracle Database assigns to all types belonging to a type hierarchy a unique non-null typeid. See Also: <link>Oracle Database Object-Relational Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e11822/adobjbas.htm#ADOBJ002</link> for more information on typeids \n The Examples is: \n The following examples use the tables <code>persons</code> and <code>books</code>, which are created in <link>\"Substitutable Table and Column \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_7002.htm#i2090577</link>. The first query returns the most specific types of the object instances stored in the <code>persons</code> table. <code>SELECT name, SYS_TYPEID(VALUE(p)) \"Type_id\" FROM persons p; NAME Type_id ------------------------- -------------------------------- Bob 01 Joe 02 Tim 03 </code> The next query returns the most specific types of authors stored in the table <code>books</code>: <code>SELECT b.title, b.author.name, SYS_TYPEID(author) \"Type_ID\" FROM books b; TITLE AUTHOR.NAME Type_ID ------------------------- -------------------- ------------------- An Autobiography Bob 01 Business Rules Joe 02 Mixing School and Work Tim 03 </code> You can use the <code>SYS_TYPEID</code> function to create an index on the type-discriminant column of a table. For an example, see <link>\"Indexing on Substitutable Columns: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_5012.htm#i2089060</link>. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions188.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PREDICTION_COST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PREDICTION_COST))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PREDICTION_COST ( [ schema . ] model [ , class ] cost_matrix_clause mining_attribute_clause ) </eps> cost_matrix_clause::= <eps> COST { MODEL [AUTO] | ( class_value [, class_value]... ) VALUES ( ( cost_value [, cost_value]...) [ , (cost_value [, cost_value]... ) ]... ) } </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with classification models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns a measure of cost for a given prediction as an Oracle <code>NUMBER</code>. If you specify the optional <code>class</code> parameter, then the function returns the cost for the specified class. If you omit the <code>class</code> parameter, then the function returns the cost associated with the best prediction. You can use this form in conjunction with the <code>PREDICTION</code> function to obtain the best pair of prediction value and cost. The <code>COST</code> clause is relevant for all classification models. Specify <code>COST</code> <code>MODEL</code> to indicate that the scoring should be performed by taking into account the scoring cost matrix associated with the model. If no such scoring cost matrix exists, then the database returns an error. Specify <code>COST</code> <code>MODEL</code> <code>AUTO</code> if the existence of a cost matrix is unknown. In this case: If the stored cost matrix exists, then the function returns the cost using the stored cost matrix. If no stored cost matrix exists, then the function applies the unit cost matrix (0's on the diagonal and 1's everywhere else). This is equivalent to one minus probability for the given class. Use the <code>VALUES</code> clause (the bottom branch of the <code>cost_matrix_clause</code>) to specify an inline cost matrix. You can use an inline cost matrix regardless of whether the model has an associated scoring cost matrix. Refer to <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG243</link> for an example of an inline cost matrix The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: Oracle Data Mining Concepts for detailed information about <link>Oracle Data Mining&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> in general and about <link>costs&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/classify.htm#DMCON032</link> in particular <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example finds the ten customers living in Italy who are least expensive to convince to use an affinity card. This example and the prerequisite data mining operations can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>WITH cust_italy AS ( SELECT cust_id FROM mining_data_apply_v WHERE country_name = 'Italy' ORDER BY PREDICTION_COST(DT_SH_Clas_sample, 1 COST MODEL USING *) ASC, 1 ) SELECT cust_id FROM cust_italy WHERE rownum < 11; CUST_ID ---------- 100081 100179 100185 100324 100344 100554 100662 100733 101250 101306 10 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> PREDICTION_COST ( [ schema . ] model [ , class ] cost_matrix_clause mining_attribute_clause ) </eps> cost_matrix_clause::= <eps> COST { MODEL [AUTO] | ( class_value [, class_value]... ) VALUES ( ( cost_value [, cost_value]...) [ , (cost_value [, cost_value]... ) ]... ) } </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with classification models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It returns a measure of cost for a given prediction as an Oracle <code>NUMBER</code>. If you specify the optional <code>class</code> parameter, then the function returns the cost for the specified class. If you omit the <code>class</code> parameter, then the function returns the cost associated with the best prediction. You can use this form in conjunction with the <code>PREDICTION</code> function to obtain the best pair of prediction value and cost. The <code>COST</code> clause is relevant for all classification models. Specify <code>COST</code> <code>MODEL</code> to indicate that the scoring should be performed by taking into account the scoring cost matrix associated with the model. If no such scoring cost matrix exists, then the database returns an error. Specify <code>COST</code> <code>MODEL</code> <code>AUTO</code> if the existence of a cost matrix is unknown. In this case: If the stored cost matrix exists, then the function returns the cost using the stored cost matrix. If no stored cost matrix exists, then the function applies the unit cost matrix (0's on the diagonal and 1's everywhere else). This is equivalent to one minus probability for the given class. Use the <code>VALUES</code> clause (the bottom branch of the <code>cost_matrix_clause</code>) to specify an inline cost matrix. You can use an inline cost matrix regardless of whether the model has an associated scoring cost matrix. Refer to <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG243</link> for an example of an inline cost matrix The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: Oracle Data Mining Concepts for detailed information about <link>Oracle Data Mining&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> in general and about <link>costs&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/classify.htm#DMCON032</link> in particular <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example finds the ten customers living in Italy who are least expensive to convince to use an affinity card. This example and the prerequisite data mining operations can be found in the demo file <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>WITH cust_italy AS ( SELECT cust_id FROM mining_data_apply_v WHERE country_name = 'Italy' ORDER BY PREDICTION_COST(DT_SH_Clas_sample, 1 COST MODEL USING *) ASC, 1 ) SELECT cust_id FROM cust_italy WHERE rownum < 11; CUST_ID ---------- 100081 100179 100185 100324 100344 100554 100662 100733 101250 101306 10 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions134.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ATAN2",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ATAN2))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ATAN2(n1 , n2) </eps> \n The Purpose is: \n <code>ATAN2</code> returns the arc tangent of <code>n1</code> and <code>n2</code>. The argument <code>n1</code> can be in an unbounded range and returns a value in the range of -pi to pi, depending on the signs of <code>n1</code> and <code>n2</code>, expressed in radians. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns <code>NUMBER</code>. See Also: <link>ATAN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions016.htm#i76792</link> for information on the <code>ATAN</code> function and <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the arc tangent of .3 and .2: <code>SELECT ATAN2(.3, .2) \"Arc_Tangent2\" FROM DUAL; Arc_Tangent2 ------------ .982793723 </code> ",
        "detail": "The Syntax is: \n <eps> ATAN2(n1 , n2) </eps> \n The Purpose is: \n <code>ATAN2</code> returns the arc tangent of <code>n1</code> and <code>n2</code>. The argument <code>n1</code> can be in an unbounded range and returns a value in the range of -pi to pi, depending on the signs of <code>n1</code> and <code>n2</code>, expressed in radians. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns <code>NUMBER</code>. See Also: <link>ATAN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions016.htm#i76792</link> for information on the <code>ATAN</code> function and <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the arc tangent of .3 and .2: <code>SELECT ATAN2(.3, .2) \"Arc_Tangent2\" FROM DUAL; Arc_Tangent2 ------------ .982793723 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions017.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "COVAR_SAMP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c COVAR_SAMP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> COVAR_SAMP(expr1, expr2) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>COVAR_SAMP</code> returns the sample covariance of a set of number pairs. You can use it as an aggregate or analytic function. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle Database applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Then Oracle makes the following computation: <code>(SUM(expr1 * expr2) - SUM(expr1) * SUM(expr2) / n) / (n-1) </code> where <code>n</code> is the number of (<code>expr1</code>, <code>expr2</code>) pairs where neither <code>expr1</code> nor <code>expr2</code> is null. The function returns a value of type <code>NUMBER</code>. If the function is applied to an empty set, then it returns null. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example Refer to the aggregate example for <link>COVAR_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions040.htm#i1008854</link>. Analytic Example Refer to the analytic example for <link>COVAR_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions040.htm#i1008854</link>. ",
        "detail": "The Syntax is: \n <eps> COVAR_SAMP(expr1, expr2) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>COVAR_SAMP</code> returns the sample covariance of a set of number pairs. You can use it as an aggregate or analytic function. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle Database applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Then Oracle makes the following computation: <code>(SUM(expr1 * expr2) - SUM(expr1) * SUM(expr2) / n) / (n-1) </code> where <code>n</code> is the number of (<code>expr1</code>, <code>expr2</code>) pairs where neither <code>expr1</code> nor <code>expr2</code> is null. The function returns a value of type <code>NUMBER</code>. If the function is applied to an empty set, then it returns null. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example Refer to the aggregate example for <link>COVAR_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions040.htm#i1008854</link>. Analytic Example Refer to the analytic example for <link>COVAR_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions040.htm#i1008854</link>. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions041.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "RTRIM",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c RTRIM))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> RTRIM(char [, set ]) </eps> \n The Purpose is: \n <code>RTRIM</code> removes from the right end of <code>char</code> all of the characters that appear in <code>set</code>. This function is useful for formatting the output of a query. If you do not specify <code>set</code>, then it defaults to a single blank. If <code>char</code> is a character literal, then you must enclose it in single quotation marks. <code>RTRIM</code> works similarly to <code>LTRIM</code>. Both <code>char</code> and <code>set</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>char</code> is a character data type, <code>NVARCHAR2</code> if <code>char</code> is a national character data type, and a LOB if <code>char</code> is a LOB data type. See Also: <link>LTRIM&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions096.htm#i77875</link> \n The Examples is: \n The following example trims all the right-most occurrences of less than sign (<code><</code>), greater than sign (<code>></code>) , and equal sign (<code>=</code>) from a string: <code>SELECT RTRIM('<=====>BROWNING<=====>', '<>=') \"RTRIM Example\" FROM DUAL; RTRIM Example --------------- <=====>BROWNING </code> ",
        "detail": "The Syntax is: \n <eps> RTRIM(char [, set ]) </eps> \n The Purpose is: \n <code>RTRIM</code> removes from the right end of <code>char</code> all of the characters that appear in <code>set</code>. This function is useful for formatting the output of a query. If you do not specify <code>set</code>, then it defaults to a single blank. If <code>char</code> is a character literal, then you must enclose it in single quotation marks. <code>RTRIM</code> works similarly to <code>LTRIM</code>. Both <code>char</code> and <code>set</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>char</code> is a character data type, <code>NVARCHAR2</code> if <code>char</code> is a national character data type, and a LOB if <code>char</code> is a LOB data type. See Also: <link>LTRIM&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions096.htm#i77875</link> \n The Examples is: \n The following example trims all the right-most occurrences of less than sign (<code><</code>), greater than sign (<code>></code>) , and equal sign (<code>=</code>) from a string: <code>SELECT RTRIM('<=====>BROWNING<=====>', '<>=') \"RTRIM Example\" FROM DUAL; RTRIM Example --------------- <=====>BROWNING </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions160.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLTRANSFORM",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLTRANSFORM))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLTRANSFORM(XMLType_instance, { XMLType_instance | string } ) </eps> \n The Purpose is: \n <code>XMLTransform</code> takes as arguments an <code>XMLType</code> instance and an XSL style sheet, which is itself a form of <code>XMLType</code> instance. It applies the style sheet to the instance and returns an <code>XMLType</code>. This function is useful for organizing data according to a style sheet as you are retrieving it from the database. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb08tra.htm#ADXDB0900</link> for more information on this function \n The Examples is: \n The <code>XMLTransform</code> function requires the existence of an XSL style sheet. Here is an example of a very simple style sheet that alphabetizes elements within a node: <code>CREATE TABLE xsl_tab (col1 XMLTYPE); INSERT INTO xsl_tab VALUES ( XMLTYPE.createxml( '<?xml version=\"1.0\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" > <xsl:output encoding=\"utf-8\"/> <!-- alphabetizes an xml tree --> <xsl:template match=\"*\"> <xsl:copy> <xsl:apply-templates select=\"*|text()\"> <xsl:sort select=\"name(.)\" data-type=\"text\" order=\"ascending\"/> </xsl:apply-templates> </xsl:copy> </xsl:template> <xsl:template match=\"text()\"> <xsl:value-of select=\"normalize-space(.)\"/> </xsl:template> </xsl:stylesheet> ')); 1 row created. </code> The next example uses the <code>xsl_tab</code> XSL style sheet to alphabetize the elements in one <code>warehouse_spec</code> of the sample table <code>oe.warehouses</code>: <code>SELECT XMLTRANSFORM(w.warehouse_spec, x.col1).GetClobVal() FROM warehouses w, xsl_tab x WHERE w.warehouse_name = 'San Francisco'; XMLTRANSFORM(W.WAREHOUSE_SPEC,X.COL1).GETCLOBVAL() -------------------------------------------------------------------------------- <Warehouse> <Area>50000</Area> <Building>Rented</Building> <DockType>Side load</DockType> <Docks>1</Docks> <Parking>Lot</Parking> <RailAccess>N</RailAccess> <VClearance>12 ft</VClearance> <WaterAccess>Y</WaterAccess> </Warehouse> </code> ",
        "detail": "The Syntax is: \n <eps> XMLTRANSFORM(XMLType_instance, { XMLType_instance | string } ) </eps> \n The Purpose is: \n <code>XMLTransform</code> takes as arguments an <code>XMLType</code> instance and an XSL style sheet, which is itself a form of <code>XMLType</code> instance. It applies the style sheet to the instance and returns an <code>XMLType</code>. This function is useful for organizing data according to a style sheet as you are retrieving it from the database. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb08tra.htm#ADXDB0900</link> for more information on this function \n The Examples is: \n The <code>XMLTransform</code> function requires the existence of an XSL style sheet. Here is an example of a very simple style sheet that alphabetizes elements within a node: <code>CREATE TABLE xsl_tab (col1 XMLTYPE); INSERT INTO xsl_tab VALUES ( XMLTYPE.createxml( '<?xml version=\"1.0\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" > <xsl:output encoding=\"utf-8\"/> <!-- alphabetizes an xml tree --> <xsl:template match=\"*\"> <xsl:copy> <xsl:apply-templates select=\"*|text()\"> <xsl:sort select=\"name(.)\" data-type=\"text\" order=\"ascending\"/> </xsl:apply-templates> </xsl:copy> </xsl:template> <xsl:template match=\"text()\"> <xsl:value-of select=\"normalize-space(.)\"/> </xsl:template> </xsl:stylesheet> ')); 1 row created. </code> The next example uses the <code>xsl_tab</code> XSL style sheet to alphabetize the elements in one <code>warehouse_spec</code> of the sample table <code>oe.warehouses</code>: <code>SELECT XMLTRANSFORM(w.warehouse_spec, x.col1).GetClobVal() FROM warehouses w, xsl_tab x WHERE w.warehouse_name = 'San Francisco'; XMLTRANSFORM(W.WAREHOUSE_SPEC,X.COL1).GETCLOBVAL() -------------------------------------------------------------------------------- <Warehouse> <Area>50000</Area> <Building>Rented</Building> <DockType>Side load</DockType> <Docks>1</Docks> <Parking>Lot</Parking> <RailAccess>N</RailAccess> <VClearance>12 ft</VClearance> <WaterAccess>Y</WaterAccess> </Warehouse> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions254.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LEAD",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LEAD))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LEAD { ( value_expr [, offset [, default]] ) [ { RESPECT | IGNORE } NULLS ] | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] ) } OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>value_expr</code> \n The Purpose is: \n <code>LEAD</code> is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, <code>LEAD</code> provides access to a row at a given physical offset beyond that position. If you do not specify <code>offset</code>, then its default is 1. The optional <code>default</code> value is returned if the offset goes beyond the scope of the table. If you do not specify <code>default</code>, then its default value is null. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>value_expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. You cannot nest analytic functions by using <code>LEAD</code> or any other analytic function for <code>value_expr</code>. However, you can use other built-in function expressions for <code>value_expr</code>. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>LAG&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions082.htm#i1327527</link> \n The Examples is: \n The following example provides, for each employee in Department 30 in the <code>employees</code> table, the hire date of the employee hired just after: <code>SELECT hire_date, last_name, LEAD(hire_date, 1) OVER (ORDER BY hire_date) AS \"Next Hired\" FROM employees WHERE department_id = 30 ORDER BY hire_date; HIRE_DATE LAST_NAME Next Hired --------- ------------------------- ---------- 07-DEC-02 Raphaely 18-MAY-03 18-MAY-03 Khoo 24-JUL-05 24-JUL-05 Tobias 24-DEC-05 24-DEC-05 Baida 15-NOV-06 15-NOV-06 Himuro 10-AUG-07 10-AUG-07 Colmenares </code> ",
        "detail": "The Syntax is: \n <eps> LEAD { ( value_expr [, offset [, default]] ) [ { RESPECT | IGNORE } NULLS ] | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] ) } OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions, including valid forms of <code>value_expr</code> \n The Purpose is: \n <code>LEAD</code> is an analytic function. It provides access to more than one row of a table at the same time without a self join. Given a series of rows returned from a query and a position of the cursor, <code>LEAD</code> provides access to a row at a given physical offset beyond that position. If you do not specify <code>offset</code>, then its default is 1. The optional <code>default</code> value is returned if the offset goes beyond the scope of the table. If you do not specify <code>default</code>, then its default value is null. {<code>RESPECT</code> | <code>IGNORE</code>} <code>NULLS</code> determines whether null values of <code>value_expr</code> are included in or eliminated from the calculation. The default is <code>RESPECT</code> <code>NULLS</code>. You cannot nest analytic functions by using <code>LEAD</code> or any other analytic function for <code>value_expr</code>. However, you can use other built-in function expressions for <code>value_expr</code>. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>LAG&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions082.htm#i1327527</link> \n The Examples is: \n The following example provides, for each employee in Department 30 in the <code>employees</code> table, the hire date of the employee hired just after: <code>SELECT hire_date, last_name, LEAD(hire_date, 1) OVER (ORDER BY hire_date) AS \"Next Hired\" FROM employees WHERE department_id = 30 ORDER BY hire_date; HIRE_DATE LAST_NAME Next Hired --------- ------------------------- ---------- 07-DEC-02 Raphaely 18-MAY-03 18-MAY-03 Khoo 24-JUL-05 24-JUL-05 Tobias 24-DEC-05 24-DEC-05 Baida 15-NOV-06 15-NOV-06 Himuro 10-AUG-07 10-AUG-07 Colmenares </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions086.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CONVERT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CONVERT))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CONVERT(char, dest_char_set[, source_char_set ]) </eps> \n The Purpose is: \n <code>CONVERT</code> converts a character string from one character set to another. The <code>char</code> argument is the value to be converted. It can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The <code>dest_char_set</code> argument is the name of the character set to which <code>char</code> is converted. The <code>source_char_set</code> argument is the name of the character set in which <code>char</code> is stored in the database. The default value is the database character set. The return value for <code>CHAR</code> and <code>VARCHAR2</code> is <code>VARCHAR2</code>. For <code>NCHAR</code> and <code>NVARCHAR2</code>, it is <code>NVARCHAR2</code>. For <code>CLOB</code>, it is <code>CLOB</code>, and for <code>NCLOB</code>, it is <code>NCLOB</code>. Both the destination and source character set arguments can be either literals or columns containing the name of the character set. For complete correspondence in character conversion, it is essential that the destination character set contains a representation of all the characters defined in the source character set. Where a character does not exist in the destination character set, a replacement character appears. Replacement characters can be defined as part of a character set definition. Note: Oracle discourages the use of the <code>CONVERT</code> function in the current Oracle Database release. The return value of <code>CONVERT</code> has a character data type, so it should be either in the database character set or in the national character set, depending on the data type. Any <code>dest_char_set</code> that is not one of these two character sets is unsupported. The <code>char</code> argument and the <code>source_char_set</code> have the same requirements. Therefore, the only practical use of the function is to correct data that has been stored in a wrong character set. Values that are in neither the database nor the national character set should be processed and stored as <code>RAW</code> or <code>BLOB</code>. Procedures in the PL/SQL packages <code>UTL_RAW</code> and <code>UTL_I18N</code>\u2014for example, <code>UTL_RAW.CONVERT</code>\u2014allow limited processing of such values. Procedures accepting a <code>RAW</code> argument in the packages <code>UTL_FILE</code>, <code>UTL_TCP</code>, <code>UTL_HTTP</code>, and <code>UTL_SMTP</code> can be used to output the processed data. \n The Examples is: \n The following example illustrates character set conversion by converting a Latin-1 string to ASCII. The result is the same as importing the same string from a WE8ISO8859P1 database to a US7ASCII database. <code>SELECT CONVERT('\u00c4 \u00ca \u00cd \u00d5 \u00d8 A B C D E ', 'US7ASCII', 'WE8ISO8859P1') FROM DUAL; CONVERT('\u00c4\u00ca\u00cd\u00d5\u00d8ABCDE' --------------------- A E I ? ? A B C D E ? </code> Common character sets include: US7ASCII: US 7-bit ASCII character set WE8ISO8859P1: ISO 8859-1 West European 8-bit character set EE8MSWIN1250: Microsoft Windows East European Code Page 1250 WE8MSWIN1252: Microsoft Windows West European Code Page 1252 WE8EBCDIC1047: IBM West European EBCDIC Code Page 1047 JA16SJISTILDE: Japanese Shift-JIS Character Set, compatible with MS Code Page 932 ZHT16MSWIN950: Microsoft Windows Traditional Chinese Code Page 950 UTF8: Unicode 3.0 Universal character set CESU-8 encoding form AL32UTF8: Unicode 5.0 Universal character set UTF-8 encoding form You can query the <code>V$NLS_VALID_VALUES</code> view to get a listing of valid character sets, as follows: <code>SELECT * FROM V$NLS_VALID_VALUES WHERE parameter = 'CHARACTERSET'; </code> See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG014</link> for information on supported character sets and <link>Oracle Database Reference&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e40402/dynviews_2076.htm#REFRN30160</link> for information on the <code>V$NLS_VALID_VALUES</code> view ",
        "detail": "The Syntax is: \n <eps> CONVERT(char, dest_char_set[, source_char_set ]) </eps> \n The Purpose is: \n <code>CONVERT</code> converts a character string from one character set to another. The <code>char</code> argument is the value to be converted. It can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The <code>dest_char_set</code> argument is the name of the character set to which <code>char</code> is converted. The <code>source_char_set</code> argument is the name of the character set in which <code>char</code> is stored in the database. The default value is the database character set. The return value for <code>CHAR</code> and <code>VARCHAR2</code> is <code>VARCHAR2</code>. For <code>NCHAR</code> and <code>NVARCHAR2</code>, it is <code>NVARCHAR2</code>. For <code>CLOB</code>, it is <code>CLOB</code>, and for <code>NCLOB</code>, it is <code>NCLOB</code>. Both the destination and source character set arguments can be either literals or columns containing the name of the character set. For complete correspondence in character conversion, it is essential that the destination character set contains a representation of all the characters defined in the source character set. Where a character does not exist in the destination character set, a replacement character appears. Replacement characters can be defined as part of a character set definition. Note: Oracle discourages the use of the <code>CONVERT</code> function in the current Oracle Database release. The return value of <code>CONVERT</code> has a character data type, so it should be either in the database character set or in the national character set, depending on the data type. Any <code>dest_char_set</code> that is not one of these two character sets is unsupported. The <code>char</code> argument and the <code>source_char_set</code> have the same requirements. Therefore, the only practical use of the function is to correct data that has been stored in a wrong character set. Values that are in neither the database nor the national character set should be processed and stored as <code>RAW</code> or <code>BLOB</code>. Procedures in the PL/SQL packages <code>UTL_RAW</code> and <code>UTL_I18N</code>\u2014for example, <code>UTL_RAW.CONVERT</code>\u2014allow limited processing of such values. Procedures accepting a <code>RAW</code> argument in the packages <code>UTL_FILE</code>, <code>UTL_TCP</code>, <code>UTL_HTTP</code>, and <code>UTL_SMTP</code> can be used to output the processed data. \n The Examples is: \n The following example illustrates character set conversion by converting a Latin-1 string to ASCII. The result is the same as importing the same string from a WE8ISO8859P1 database to a US7ASCII database. <code>SELECT CONVERT('\u00c4 \u00ca \u00cd \u00d5 \u00d8 A B C D E ', 'US7ASCII', 'WE8ISO8859P1') FROM DUAL; CONVERT('\u00c4\u00ca\u00cd\u00d5\u00d8ABCDE' --------------------- A E I ? ? A B C D E ? </code> Common character sets include: US7ASCII: US 7-bit ASCII character set WE8ISO8859P1: ISO 8859-1 West European 8-bit character set EE8MSWIN1250: Microsoft Windows East European Code Page 1250 WE8MSWIN1252: Microsoft Windows West European Code Page 1252 WE8EBCDIC1047: IBM West European EBCDIC Code Page 1047 JA16SJISTILDE: Japanese Shift-JIS Character Set, compatible with MS Code Page 932 ZHT16MSWIN950: Microsoft Windows Traditional Chinese Code Page 950 UTF8: Unicode 3.0 Universal character set CESU-8 encoding form AL32UTF8: Unicode 5.0 Universal character set UTF-8 encoding form You can query the <code>V$NLS_VALID_VALUES</code> view to get a listing of valid character sets, as follows: <code>SELECT * FROM V$NLS_VALID_VALUES WHERE parameter = 'CHARACTERSET'; </code> See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG014</link> for information on supported character sets and <link>Oracle Database Reference&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e40402/dynviews_2076.htm#REFRN30160</link> for information on the <code>V$NLS_VALID_VALUES</code> view ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions034.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYS_XMLGEN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYS_XMLGEN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYS_XMLGEN(expr [, fmt ]) </eps> \n The Purpose is: \n <code>SYS_XMLGen</code> takes an expression that evaluates to a particular row and column of the database, and returns an instance of type <code>XMLType</code> containing an XML document. The <code>expr</code> can be a scalar value, a user-defined type, or an <code>XMLType</code> instance. If <code>expr</code> is a scalar value, then the function returns an XML element containing the scalar value. If <code>expr</code> is a type, then the function maps the user-defined type attributes to XML elements. If <code>expr</code> is an <code>XMLType</code> instance, then the function encloses the document in an XML element whose default tag name is <code>ROW</code>. By default the elements of the XML document match the elements of <code>expr</code>. For example, if <code>expr</code> resolves to a column name, then the enclosing XML element will be the same column name. If you want to format the XML document differently, then specify <code>fmt</code>, which is an instance of the <code>XMLFormat</code> object. See Also: <link>\"XML Format Model\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i54997</link> for a description of the <code>XMLFormat</code> type and how to use its attributes to format <code>SYS_XMLGen</code> results \n The Examples is: \n The following example retrieves the employee email ID from the sample table <code>oe.employees</code> where the <code>employee_id</code> value is 205, and generates an instance of an <code>XMLType</code> containing an XML document with an <code>EMAIL</code> element. <code>SELECT SYS_XMLGEN(email) FROM employees WHERE employee_id = 205; SYS_XMLGEN(EMAIL) ------------------------------------------------------------------- <?xml version=\"1.0\"?> <EMAIL>SHIGGINS</EMAIL> </code> ",
        "detail": "The Syntax is: \n <eps> SYS_XMLGEN(expr [, fmt ]) </eps> \n The Purpose is: \n <code>SYS_XMLGen</code> takes an expression that evaluates to a particular row and column of the database, and returns an instance of type <code>XMLType</code> containing an XML document. The <code>expr</code> can be a scalar value, a user-defined type, or an <code>XMLType</code> instance. If <code>expr</code> is a scalar value, then the function returns an XML element containing the scalar value. If <code>expr</code> is a type, then the function maps the user-defined type attributes to XML elements. If <code>expr</code> is an <code>XMLType</code> instance, then the function encloses the document in an XML element whose default tag name is <code>ROW</code>. By default the elements of the XML document match the elements of <code>expr</code>. For example, if <code>expr</code> resolves to a column name, then the enclosing XML element will be the same column name. If you want to format the XML document differently, then specify <code>fmt</code>, which is an instance of the <code>XMLFormat</code> object. See Also: <link>\"XML Format Model\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i54997</link> for a description of the <code>XMLFormat</code> type and how to use its attributes to format <code>SYS_XMLGen</code> results \n The Examples is: \n The following example retrieves the employee email ID from the sample table <code>oe.employees</code> where the <code>employee_id</code> value is 205, and generates an instance of an <code>XMLType</code> containing an XML document with an <code>EMAIL</code> element. <code>SELECT SYS_XMLGEN(email) FROM employees WHERE employee_id = 205; SYS_XMLGEN(EMAIL) ------------------------------------------------------------------- <?xml version=\"1.0\"?> <EMAIL>SHIGGINS</EMAIL> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions190.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "GREATEST",
        "tree": "(numeric_function GREATEST ( ))",
        "description": "The Syntax is: \n <eps> GREATEST(expr [, expr ]...) </eps> \n The Purpose is: \n <code>GREATEST</code> returns the greatest of a list of one or more expressions. Oracle Database uses the first <code>expr</code> to determine the return type. If the first <code>expr</code> is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first <code>expr</code> is not numeric, then each <code>expr</code> after the first is implicitly converted to the data type of the first <code>expr</code> before the comparison. Oracle Database compares each <code>expr</code> using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the <code>NLS_COMP</code> parameter is set to <code>LINGUISTIC</code> and the <code>NLS_SORT</code> parameter has a setting other than <code>BINARY</code>. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is <code>VARCHAR2</code> if the first <code>expr</code> is a character data type and <code>NVARCHAR2</code> if the first <code>expr</code> is a national character data type. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information on character comparison <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics <link>\"LEAST\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions087.htm#i77700</link>, which returns the least of a list of one or more expressions \n The Examples is: \n The following statement selects the string with the greatest value: <code>SELECT GREATEST('HARRY', 'HARRIOT', 'HAROLD') \"Greatest\" FROM DUAL; Greatest -------- HARRY </code> In the following statement, the first argument is numeric. Oracle Database determines that the argument with the highest numeric precedence is the second argument, converts the remaining arguments to the data type of the second argument, and returns the greatest value as that data type: <code>SELECT GREATEST (1, '3.925', '2.4') \"Greatest\" FROM DUAL; Greatest -------- 3.925 </code> ",
        "detail": "The Syntax is: \n <eps> GREATEST(expr [, expr ]...) </eps> \n The Purpose is: \n <code>GREATEST</code> returns the greatest of a list of one or more expressions. Oracle Database uses the first <code>expr</code> to determine the return type. If the first <code>expr</code> is numeric, then Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type before the comparison, and returns that data type. If the first <code>expr</code> is not numeric, then each <code>expr</code> after the first is implicitly converted to the data type of the first <code>expr</code> before the comparison. Oracle Database compares each <code>expr</code> using nonpadded comparison semantics. The comparison is binary by default and is linguistic if the <code>NLS_COMP</code> parameter is set to <code>LINGUISTIC</code> and the <code>NLS_SORT</code> parameter has a setting other than <code>BINARY</code>. Character comparison is based on the numerical codes of the characters in the database character set and is performed on whole strings treated as one sequence of bytes, rather than character by character. If the value returned by this function is character data, then its data type is <code>VARCHAR2</code> if the first <code>expr</code> is a character data type and <code>NVARCHAR2</code> if the first <code>expr</code> is a national character data type. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information on character comparison <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Floating-Point Numbers\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i140176</link> for information on binary-float comparison semantics <link>\"LEAST\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions087.htm#i77700</link>, which returns the least of a list of one or more expressions \n The Examples is: \n The following statement selects the string with the greatest value: <code>SELECT GREATEST('HARRY', 'HARRIOT', 'HAROLD') \"Greatest\" FROM DUAL; Greatest -------- HARRY </code> In the following statement, the first argument is numeric. Oracle Database determines that the argument with the highest numeric precedence is the second argument, converts the remaining arguments to the data type of the second argument, and returns the greatest value as that data type: <code>SELECT GREATEST (1, '3.925', '2.4') \"Greatest\" FROM DUAL; Greatest -------- 3.925 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions069.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLSEQUENCE",
        "tree": "(general_element_part (id_expression (regular_id XMLSEQUENCE)) (function_argument ( )))",
        "description": "Note: The <code>XMLSEQUENCE</code> function is deprecated. It is still supported for backward compatibility. However, Oracle recommends that you use the <code>XMLTABLE</code> function instead. See <link>XMLTABLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions253.htm#CIHGGHFB</link> for more information. The Syntax is: \n <eps> XMLSEQUENCE( XMLType_instance | sys_refcursor_instance [, fmt ] ) </eps> \n The Purpose is: \n <code>XMLSequence</code> has two forms: The first form takes as input an <code>XMLType</code> instance and returns a varray of the top-level nodes in the <code>XMLType</code>. This form is effectively superseded by the SQL/XML standard function <code>XMLTable</code>, which provides for more readable SQL code. Prior to Oracle Database 10g Release 2, <code>XMLSequence</code> was used with SQL function <code>TABLE</code> to do some of what can now be done better with the <code>XMLTable</code> function. The second form takes as input a <code>REFCURSOR</code> instance, with an optional instance of the <code>XMLFormat</code> object, and returns as an <code>XMLSequence</code> type an XML document for each row of the cursor. Because <code>XMLSequence</code> returns a collection of <code>XMLType</code>, you can use this function in a <code>TABLE</code> clause to unnest the collection values into multiple rows, which can in turn be further processed in the SQL query. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function, and <link>XMLTABLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions253.htm#CIHGGHFB</link> \n The Examples is: \n The following example shows how <code>XMLSequence</code> divides up an XML document with multiple elements into <code>VARRAY</code> single-element documents. In this example, the <code>TABLE</code> keyword instructs Oracle Database to consider the collection a table value that can be used in the <code>FROM</code> clause of the subquery: <code>SELECT EXTRACT(warehouse_spec, '/Warehouse') as \"Warehouse\" FROM warehouses WHERE warehouse_name = 'San Francisco'; Warehouse ------------------------------------------------------------ <Warehouse> <Building>Rented</Building> <Area>50000</Area> <Docks>1</Docks> <DockType>Side load</DockType> <WaterAccess>Y</WaterAccess> <RailAccess>N</RailAccess> <Parking>Lot</Parking> <VClearance>12 ft</VClearance> </Warehouse> 1 row selected. SELECT VALUE(p) FROM warehouses w, TABLE(XMLSEQUENCE(EXTRACT(warehouse_spec, '/Warehouse/*'))) p WHERE w.warehouse_name = 'San Francisco'; VALUE(P) ---------------------------------------------------------------- <Building>Rented</Building> <Area>50000</Area> <Docks>1</Docks> <DockType>Side load</DockType> <WaterAccess>Y</WaterAccess> <RailAccess>N</RailAccess> <Parking>Lot</Parking> <VClearance>12 ft</VClearance> 8 rows selected. </code> ",
        "detail": "Note: The <code>XMLSEQUENCE</code> function is deprecated. It is still supported for backward compatibility. However, Oracle recommends that you use the <code>XMLTABLE</code> function instead. See <link>XMLTABLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions253.htm#CIHGGHFB</link> for more information. The Syntax is: \n <eps> XMLSEQUENCE( XMLType_instance | sys_refcursor_instance [, fmt ] ) </eps> \n The Purpose is: \n <code>XMLSequence</code> has two forms: The first form takes as input an <code>XMLType</code> instance and returns a varray of the top-level nodes in the <code>XMLType</code>. This form is effectively superseded by the SQL/XML standard function <code>XMLTable</code>, which provides for more readable SQL code. Prior to Oracle Database 10g Release 2, <code>XMLSequence</code> was used with SQL function <code>TABLE</code> to do some of what can now be done better with the <code>XMLTable</code> function. The second form takes as input a <code>REFCURSOR</code> instance, with an optional instance of the <code>XMLFormat</code> object, and returns as an <code>XMLSequence</code> type an XML document for each row of the cursor. Because <code>XMLSequence</code> returns a collection of <code>XMLType</code>, you can use this function in a <code>TABLE</code> clause to unnest the collection values into multiple rows, which can in turn be further processed in the SQL query. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function, and <link>XMLTABLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions253.htm#CIHGGHFB</link> \n The Examples is: \n The following example shows how <code>XMLSequence</code> divides up an XML document with multiple elements into <code>VARRAY</code> single-element documents. In this example, the <code>TABLE</code> keyword instructs Oracle Database to consider the collection a table value that can be used in the <code>FROM</code> clause of the subquery: <code>SELECT EXTRACT(warehouse_spec, '/Warehouse') as \"Warehouse\" FROM warehouses WHERE warehouse_name = 'San Francisco'; Warehouse ------------------------------------------------------------ <Warehouse> <Building>Rented</Building> <Area>50000</Area> <Docks>1</Docks> <DockType>Side load</DockType> <WaterAccess>Y</WaterAccess> <RailAccess>N</RailAccess> <Parking>Lot</Parking> <VClearance>12 ft</VClearance> </Warehouse> 1 row selected. SELECT VALUE(p) FROM warehouses w, TABLE(XMLSEQUENCE(EXTRACT(warehouse_spec, '/Warehouse/*'))) p WHERE w.warehouse_name = 'San Francisco'; VALUE(P) ---------------------------------------------------------------- <Building>Rented</Building> <Area>50000</Area> <Docks>1</Docks> <DockType>Side load</DockType> <WaterAccess>Y</WaterAccess> <RailAccess>N</RailAccess> <Parking>Lot</Parking> <VClearance>12 ft</VClearance> 8 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions251.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLQUERY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLQUERY))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLQUERY ( XQuery_string [ XML_passing_clause ] RETURNING CONTENT [NULL ON EMPTY] ) </eps> XML_passing_clause::= <eps> PASSING [ BY VALUE ] expr [ AS identifier ] [, expr [ AS identifier ] ]... </eps> \n The Purpose is: \n <code>XMLQUERY</code> lets you query XML data in SQL statements. It takes an XQuery expression as a string literal, an optional context item, and other bind variables and returns the result of evaluating the XQuery expression using these input values. <code>XQuery_string</code> is a complete XQuery expression, including prolog. The <code>expr</code> in the <code>XML_passing_clause</code> is an expression returning an <code>XMLType</code> or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one <code>expr</code> in the <code>PASSING</code> clause without an identifier. The result of evaluating each <code>expr</code> is bound to the corresponding identifier in the <code>XQuery_string</code>. If any <code>expr</code> that is not followed by an <code>AS</code> clause, then the result of evaluating that expression is used as the context item for evaluating the <code>XQuery_string</code>. <code>RETURNING</code> <code>CONTENT</code> indicates that the result from the XQuery evaluation is either an XML 1.0 document or a document fragment conforming to the XML 1.0 semantics. If the result set is empty, then the function returns the SQL <code>NULL</code> value. The <code>NULL</code> <code>ON</code> <code>EMPTY</code> keywords are implemented by default and are shown for syntactic clarity. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following statement specifies the <code>warehouse_spec</code> column of the <code>oe.warehouses</code> table in the <code>XML_passing_clause</code> as a context item. The statement returns specific information about the warehouses with area greater than 50K. <code>SELECT warehouse_name, EXTRACTVALUE(warehouse_spec, '/Warehouse/Area'), XMLQuery( 'for $i in /Warehouse where $i/Area > 50000 return <Details> <Docks num=\"{$i/Docks}\"/> <Rail> { if ($i/RailAccess = \"Y\") then \"true\" else \"false\" } </Rail> </Details>' PASSING warehouse_spec RETURNING CONTENT) \"Big_warehouses\" FROM warehouses; WAREHOUSE_ID Area Big_warehouses ------------ --------- -------------------------------------------------------- 1 25000 2 50000 3 85700 <Details><Docks></Docks><Rail>false</Rail></Details> 4 103000 <Details><Docks num=\"3\"></Docks><Rail>true</Rail></Details> . . . </code> ",
        "detail": "The Syntax is: \n <eps> XMLQUERY ( XQuery_string [ XML_passing_clause ] RETURNING CONTENT [NULL ON EMPTY] ) </eps> XML_passing_clause::= <eps> PASSING [ BY VALUE ] expr [ AS identifier ] [, expr [ AS identifier ] ]... </eps> \n The Purpose is: \n <code>XMLQUERY</code> lets you query XML data in SQL statements. It takes an XQuery expression as a string literal, an optional context item, and other bind variables and returns the result of evaluating the XQuery expression using these input values. <code>XQuery_string</code> is a complete XQuery expression, including prolog. The <code>expr</code> in the <code>XML_passing_clause</code> is an expression returning an <code>XMLType</code> or an instance of a SQL scalar data type that is used as the context for evaluating the XQuery expression. You can specify only one <code>expr</code> in the <code>PASSING</code> clause without an identifier. The result of evaluating each <code>expr</code> is bound to the corresponding identifier in the <code>XQuery_string</code>. If any <code>expr</code> that is not followed by an <code>AS</code> clause, then the result of evaluating that expression is used as the context item for evaluating the <code>XQuery_string</code>. <code>RETURNING</code> <code>CONTENT</code> indicates that the result from the XQuery evaluation is either an XML 1.0 document or a document fragment conforming to the XML 1.0 semantics. If the result set is empty, then the function returns the SQL <code>NULL</code> value. The <code>NULL</code> <code>ON</code> <code>EMPTY</code> keywords are implemented by default and are shown for syntactic clarity. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following statement specifies the <code>warehouse_spec</code> column of the <code>oe.warehouses</code> table in the <code>XML_passing_clause</code> as a context item. The statement returns specific information about the warehouses with area greater than 50K. <code>SELECT warehouse_name, EXTRACTVALUE(warehouse_spec, '/Warehouse/Area'), XMLQuery( 'for $i in /Warehouse where $i/Area > 50000 return <Details> <Docks num=\"{$i/Docks}\"/> <Rail> { if ($i/RailAccess = \"Y\") then \"true\" else \"false\" } </Rail> </Details>' PASSING warehouse_spec RETURNING CONTENT) \"Big_warehouses\" FROM warehouses; WAREHOUSE_ID Area Big_warehouses ------------ --------- -------------------------------------------------------- 1 25000 2 50000 3 85700 <Details><Docks></Docks><Rail>false</Rail></Details> 4 103000 <Details><Docks num=\"3\"></Docks><Rail>true</Rail></Details> . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions249.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ASIN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ASIN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ASIN(n) </eps> \n The Purpose is: \n <code>ASIN</code> returns the arc sine of <code>n</code>. The argument <code>n</code> must be in the range of -1 to 1, and the function returns a value in the range of -pi/2 to pi/2, expressed in radians. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the arc sine of .3: <code>SELECT ASIN(.3) \"Arc_Sine\" FROM DUAL; Arc_Sine ---------- .304692654 </code> ",
        "detail": "The Syntax is: \n <eps> ASIN(n) </eps> \n The Purpose is: \n <code>ASIN</code> returns the arc sine of <code>n</code>. The argument <code>n</code> must be in the range of -1 to 1, and the function returns a value in the range of -pi/2 to pi/2, expressed in radians. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If the argument is <code>BINARY_FLOAT</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns the same numeric data type as the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the arc sine of .3: <code>SELECT ASIN(.3) \"Arc_Sine\" FROM DUAL; Arc_Sine ---------- .304692654 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions015.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CV",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CV))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> CV([ dimension_column ]) </eps> \n The Purpose is: \n The <code>CV</code> function can be used only in the <code>model_clause</code> of a <code>SELECT</code> statement and then only on the right-hand side of a model rule. It returns the current value of a dimension column or a partitioning column carried from the left-hand side to the right-hand side of a rule. This function is used in the <code>model_clause</code> to provide relative indexing with respect to the dimension column. The return type is that of the data type of the dimension column. If you omit the argument, then it defaults to the dimension column associated with the relative position of the function within the cell reference. The <code>CV</code> function can be used outside a cell reference. In this case, <code>dimension_column</code> is required. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics \n The Examples is: \n The following example assigns the sum of the sales of the product represented by the current value of the dimension column (Mouse Pad or Standard Mouse) for years 1999 and 2000 to the sales of that product for year 2001: <code>SELECT country, prod, year, s FROM sales_view_ref MODEL PARTITION BY (country) DIMENSION BY (prod, year) MEASURES (sale s) IGNORE NAV UNIQUE DIMENSION RULES UPSERT SEQUENTIAL ORDER ( s[FOR prod IN ('Mouse Pad', 'Standard Mouse'), 2001] = s[CV( ), 1999] + s[CV( ), 2000] ) ORDER BY country, prod, year; COUNTRY PROD YEAR S ---------- ----------------------------------- -------- --------- France Mouse Pad 1998 2509.42 France Mouse Pad 1999 3678.69 France Mouse Pad 2000 3000.72 France Mouse Pad 2001 6679.41 France Standard Mouse 1998 2390.83 France Standard Mouse 1999 2280.45 France Standard Mouse 2000 1274.31 France Standard Mouse 2001 3554.76 Germany Mouse Pad 1998 5827.87 Germany Mouse Pad 1999 8346.44 Germany Mouse Pad 2000 7375.46 Germany Mouse Pad 2001 15721.9 Germany Standard Mouse 1998 7116.11 Germany Standard Mouse 1999 6263.14 Germany Standard Mouse 2000 2637.31 Germany Standard Mouse 2001 8900.45 16 rows selected. </code> The preceding example requires the view <code>sales_view_ref</code>. Refer to <link>\"The MODEL clause: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2171160</link> to create this view. ",
        "detail": "The Syntax is: \n <eps> CV([ dimension_column ]) </eps> \n The Purpose is: \n The <code>CV</code> function can be used only in the <code>model_clause</code> of a <code>SELECT</code> statement and then only on the right-hand side of a model rule. It returns the current value of a dimension column or a partitioning column carried from the left-hand side to the right-hand side of a rule. This function is used in the <code>model_clause</code> to provide relative indexing with respect to the dimension column. The return type is that of the data type of the dimension column. If you omit the argument, then it defaults to the dimension column associated with the relative position of the function within the cell reference. The <code>CV</code> function can be used outside a cell reference. In this case, <code>dimension_column</code> is required. See Also: <link>model_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2172805</link> and <link>\"Model Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions010.htm#i1049969</link> for the syntax and semantics \n The Examples is: \n The following example assigns the sum of the sales of the product represented by the current value of the dimension column (Mouse Pad or Standard Mouse) for years 1999 and 2000 to the sales of that product for year 2001: <code>SELECT country, prod, year, s FROM sales_view_ref MODEL PARTITION BY (country) DIMENSION BY (prod, year) MEASURES (sale s) IGNORE NAV UNIQUE DIMENSION RULES UPSERT SEQUENTIAL ORDER ( s[FOR prod IN ('Mouse Pad', 'Standard Mouse'), 2001] = s[CV( ), 1999] + s[CV( ), 2000] ) ORDER BY country, prod, year; COUNTRY PROD YEAR S ---------- ----------------------------------- -------- --------- France Mouse Pad 1998 2509.42 France Mouse Pad 1999 3678.69 France Mouse Pad 2000 3000.72 France Mouse Pad 2001 6679.41 France Standard Mouse 1998 2390.83 France Standard Mouse 1999 2280.45 France Standard Mouse 2000 1274.31 France Standard Mouse 2001 3554.76 Germany Mouse Pad 1998 5827.87 Germany Mouse Pad 1999 8346.44 Germany Mouse Pad 2000 7375.46 Germany Mouse Pad 2001 15721.9 Germany Standard Mouse 1998 7116.11 Germany Standard Mouse 1999 6263.14 Germany Standard Mouse 2000 2637.31 Germany Standard Mouse 2001 8900.45 16 rows selected. </code> The preceding example requires the view <code>sales_view_ref</code>. Refer to <link>\"The MODEL clause: \n The Examples is: \n\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/statements_10002.htm#i2171160</link> to create this view. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions046.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SUM",
        "tree": "(numeric_function SUM ( ))",
        "description": "The Syntax is: \n <eps> SUM([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>SUM</code> returns the sum of values of <code>expr</code>. You can use it as an aggregate or analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example calculates the sum of all salaries in the sample <code>hr.employees</code> table: <code>SELECT SUM(salary) \"Total\" FROM employees; Total ---------- 691400 </code> Analytic Example The following example calculates, for each manager in the sample table <code>hr.employees</code>, a cumulative total of salaries of employees who answer to that manager that are equal to or less than the current salary. You can see that Raphaely and Cambrault have the same cumulative total. This is because Raphaely and Cambrault have the identical salaries, so Oracle Database adds together their salary values and applies the same cumulative total to both rows. <code>SELECT manager_id, last_name, salary, SUM(salary) OVER (PARTITION BY manager_id ORDER BY salary RANGE UNBOUNDED PRECEDING) l_csum FROM employees ORDER BY manager_id, last_name, salary, l_csum; MANAGER_ID LAST_NAME SALARY L_CSUM ---------- --------------- ---------- ---------- MANAGER_ID LAST_NAME SALARY L_CSUM ---------- ------------------------- ---------- ---------- 100 Cambrault 11000 68900 100 De Haan 17000 155400 100 Errazuriz 12000 80900 100 Fripp 8200 36400 100 Hartstein 13000 93900 100 Kaufling 7900 20200 100 Kochhar 17000 155400 100 Mourgos 5800 5800 100 Partners 13500 107400 100 Raphaely 11000 68900 100 Russell 14000 121400 . . . 149 Hutton 8800 39000 149 Johnson 6200 6200 149 Livingston 8400 21600 149 Taylor 8600 30200 201 Fay 6000 6000 205 Gietz 8300 8300 King 24000 24000 </code> ",
        "detail": "The Syntax is: \n <eps> SUM([ DISTINCT | ALL ] expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>SUM</code> returns the sum of values of <code>expr</code>. You can use it as an aggregate or analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example calculates the sum of all salaries in the sample <code>hr.employees</code> table: <code>SELECT SUM(salary) \"Total\" FROM employees; Total ---------- 691400 </code> Analytic Example The following example calculates, for each manager in the sample table <code>hr.employees</code>, a cumulative total of salaries of employees who answer to that manager that are equal to or less than the current salary. You can see that Raphaely and Cambrault have the same cumulative total. This is because Raphaely and Cambrault have the identical salaries, so Oracle Database adds together their salary values and applies the same cumulative total to both rows. <code>SELECT manager_id, last_name, salary, SUM(salary) OVER (PARTITION BY manager_id ORDER BY salary RANGE UNBOUNDED PRECEDING) l_csum FROM employees ORDER BY manager_id, last_name, salary, l_csum; MANAGER_ID LAST_NAME SALARY L_CSUM ---------- --------------- ---------- ---------- MANAGER_ID LAST_NAME SALARY L_CSUM ---------- ------------------------- ---------- ---------- 100 Cambrault 11000 68900 100 De Haan 17000 155400 100 Errazuriz 12000 80900 100 Fripp 8200 36400 100 Hartstein 13000 93900 100 Kaufling 7900 20200 100 Kochhar 17000 155400 100 Mourgos 5800 5800 100 Partners 13500 107400 100 Raphaely 11000 68900 100 Russell 14000 121400 . . . 149 Hutton 8800 39000 149 Johnson 6200 6200 149 Livingston 8400 21600 149 Taylor 8600 30200 201 Fay 6000 6000 205 Gietz 8300 8300 King 24000 24000 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions182.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SESSIONTIMEZONE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SESSIONTIMEZONE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SESSIONTIMEZONE </eps> \n The Purpose is: \n <code>SESSIONTIMEZONE</code> returns the time zone of the current session. The return type is a time zone offset (a character type in the format <code>'[+|-]TZH:TZM'</code>) or a time zone region name, depending on how the user specified the session time zone value in the most recent <code>ALTER</code> <code>SESSION</code> statement. Note: The default client session time zone is an offset even if the client operating system uses a named time zone. If you want the default session time zone to use a named time zone, then set the <code>ORA_SDTZ</code> variable in the client environment to an Oracle time zone region name. Refer to <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch3globenv.htm#NLSPG003</link> for more information on this variable. \n The Examples is: \n The following example returns the time zone of the current session: <code>SELECT SESSIONTIMEZONE FROM DUAL; SESSION ------- -08:00 </code> ",
        "detail": "The Syntax is: \n <eps> SESSIONTIMEZONE </eps> \n The Purpose is: \n <code>SESSIONTIMEZONE</code> returns the time zone of the current session. The return type is a time zone offset (a character type in the format <code>'[+|-]TZH:TZM'</code>) or a time zone region name, depending on how the user specified the session time zone value in the most recent <code>ALTER</code> <code>SESSION</code> statement. Note: The default client session time zone is an offset even if the client operating system uses a named time zone. If you want the default session time zone to use a named time zone, then set the <code>ORA_SDTZ</code> variable in the client environment to an Oracle time zone region name. Refer to <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch3globenv.htm#NLSPG003</link> for more information on this variable. \n The Examples is: \n The following example returns the time zone of the current session: <code>SELECT SESSIONTIMEZONE FROM DUAL; SESSION ------- -08:00 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions162.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "VAR_POP",
        "tree": "(other_function (over_clause_keyword VAR_POP) (function_argument_analytic ( )))",
        "description": "The Syntax is: \n <eps> VAR_POP(expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>VAR_POP</code> returns the population variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If the function is applied to an empty set, then it returns null. The function makes the following calculation: <code>SUM((expr - (SUM(expr) / COUNT(expr)))2) / COUNT(expr) </code> See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example returns the population variance of the salaries in the <code>employees</code> table: <code>SELECT VAR_POP(salary) FROM employees; VAR_POP(SALARY) --------------- 15141964.9 </code> Analytic Example The following example calculates the cumulative population and sample variances in the <code>sh.sales</code> table of the monthly sales in 1998: <code>SELECT t.calendar_month_desc, VAR_POP(SUM(s.amount_sold)) OVER (ORDER BY t.calendar_month_desc) \"Var_Pop\", VAR_SAMP(SUM(s.amount_sold)) OVER (ORDER BY t.calendar_month_desc) \"Var_Samp\" FROM sales s, times t WHERE s.time_id = t.time_id AND t.calendar_year = 1998 GROUP BY t.calendar_month_desc ORDER BY t.calendar_month_desc, \"Var_Pop\", \"Var_Samp\"; CALENDAR Var_Pop Var_Samp -------- ---------- ---------- 1998-01 0 1998-02 2269111326 4538222653 1998-03 5.5849E+10 8.3774E+10 1998-04 4.8252E+10 6.4336E+10 1998-05 6.0020E+10 7.5025E+10 1998-06 5.4091E+10 6.4909E+10 1998-07 4.7150E+10 5.5009E+10 1998-08 4.1345E+10 4.7252E+10 1998-09 3.9591E+10 4.4540E+10 1998-10 3.9995E+10 4.4439E+10 1998-11 3.6870E+10 4.0558E+10 1998-12 4.0216E+10 4.3872E+10 </code> ",
        "detail": "The Syntax is: \n <eps> VAR_POP(expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>VAR_POP</code> returns the population variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If the function is applied to an empty set, then it returns null. The function makes the following calculation: <code>SUM((expr - (SUM(expr) / COUNT(expr)))2) / COUNT(expr) </code> See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example returns the population variance of the salaries in the <code>employees</code> table: <code>SELECT VAR_POP(salary) FROM employees; VAR_POP(SALARY) --------------- 15141964.9 </code> Analytic Example The following example calculates the cumulative population and sample variances in the <code>sh.sales</code> table of the monthly sales in 1998: <code>SELECT t.calendar_month_desc, VAR_POP(SUM(s.amount_sold)) OVER (ORDER BY t.calendar_month_desc) \"Var_Pop\", VAR_SAMP(SUM(s.amount_sold)) OVER (ORDER BY t.calendar_month_desc) \"Var_Samp\" FROM sales s, times t WHERE s.time_id = t.time_id AND t.calendar_year = 1998 GROUP BY t.calendar_month_desc ORDER BY t.calendar_month_desc, \"Var_Pop\", \"Var_Samp\"; CALENDAR Var_Pop Var_Samp -------- ---------- ---------- 1998-01 0 1998-02 2269111326 4538222653 1998-03 5.5849E+10 8.3774E+10 1998-04 4.8252E+10 6.4336E+10 1998-05 6.0020E+10 7.5025E+10 1998-06 5.4091E+10 6.4909E+10 1998-07 4.7150E+10 5.5009E+10 1998-08 4.1345E+10 4.7252E+10 1998-09 3.9591E+10 4.4540E+10 1998-10 3.9995E+10 4.4439E+10 1998-11 3.6870E+10 4.0558E+10 1998-12 4.0216E+10 4.3872E+10 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions230.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "EXTRACTVALUE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c EXTRACTVALUE))) (function_argument ( )))",
        "description": "Note: The <code>EXTRACTVALUE</code> function is deprecated. It is still supported for backward compatibility. However, Oracle recommends that you use the <code>XMLTABLE</code> function, or the <code>XMLCAST</code> and <code>XMLQUERY</code> functions instead. See <link>XMLTABLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions253.htm#CIHGGHFB</link>, <link>XMLCAST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions236.htm#CIHHHACJ</link>, and <link>XMLQUERY&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions249.htm#CIHHFFGG</link> for more information. The Syntax is: \n <eps> EXTRACTVALUE(XMLType_instance, XPath_string [, namespace_string ]) </eps> The <code>EXTRACTVALUE</code> function takes as arguments an <code>XMLType</code> instance and an XPath expression and returns a scalar value of the resultant node. The result must be a single node and be either a text node, attribute, or element. If the result is an element, then the element must have a single text node as its child, and it is this value that the function returns. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, the context of the relative path defaults to the root node. If the specified XPath points to a node with more than one child, or if the node pointed to has a non-text node child, then Oracle returns an error. The optional <code>namespace_string</code> must resolve to a <code>VARCHAR2</code> value that specifies a default mapping or namespace mapping for prefixes, which Oracle uses when evaluating the XPath expression(s). For documents based on XML schemas, if Oracle can infer the type of the return value, then a scalar value of the appropriate type is returned. Otherwise, the result is of type <code>VARCHAR2</code>. For documents that are not based on XML schemas, the return type is always <code>VARCHAR2</code>. \n The Examples is: \n The following example takes as input the same arguments as the example for <link>EXTRACT (XML)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions060.htm#i1006712</link>. Instead of returning an XML fragment, as does the <code>EXTRACT</code> function, it returns the scalar value of the XML fragment: <code>SELECT warehouse_name, EXTRACTVALUE(e.warehouse_spec, '/Warehouse/Docks') \"Docks\" FROM warehouses e WHERE warehouse_spec IS NOT NULL ORDER BY warehouse_name; WAREHOUSE_NAME Docks -------------------- ------------ New Jersey San Francisco 1 Seattle, Washington 3 Southlake, Texas 2 </code> ",
        "detail": "Note: The <code>EXTRACTVALUE</code> function is deprecated. It is still supported for backward compatibility. However, Oracle recommends that you use the <code>XMLTABLE</code> function, or the <code>XMLCAST</code> and <code>XMLQUERY</code> functions instead. See <link>XMLTABLE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions253.htm#CIHGGHFB</link>, <link>XMLCAST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions236.htm#CIHHHACJ</link>, and <link>XMLQUERY&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions249.htm#CIHHFFGG</link> for more information. The Syntax is: \n <eps> EXTRACTVALUE(XMLType_instance, XPath_string [, namespace_string ]) </eps> The <code>EXTRACTVALUE</code> function takes as arguments an <code>XMLType</code> instance and an XPath expression and returns a scalar value of the resultant node. The result must be a single node and be either a text node, attribute, or element. If the result is an element, then the element must have a single text node as its child, and it is this value that the function returns. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, the context of the relative path defaults to the root node. If the specified XPath points to a node with more than one child, or if the node pointed to has a non-text node child, then Oracle returns an error. The optional <code>namespace_string</code> must resolve to a <code>VARCHAR2</code> value that specifies a default mapping or namespace mapping for prefixes, which Oracle uses when evaluating the XPath expression(s). For documents based on XML schemas, if Oracle can infer the type of the return value, then a scalar value of the appropriate type is returned. Otherwise, the result is of type <code>VARCHAR2</code>. For documents that are not based on XML schemas, the return type is always <code>VARCHAR2</code>. \n The Examples is: \n The following example takes as input the same arguments as the example for <link>EXTRACT (XML)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions060.htm#i1006712</link>. Instead of returning an XML fragment, as does the <code>EXTRACT</code> function, it returns the scalar value of the XML fragment: <code>SELECT warehouse_name, EXTRACTVALUE(e.warehouse_spec, '/Warehouse/Docks') \"Docks\" FROM warehouses e WHERE warehouse_spec IS NOT NULL ORDER BY warehouse_name; WAREHOUSE_NAME Docks -------------------- ------------ New Jersey San Francisco 1 Seattle, Washington 3 Southlake, Texas 2 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions061.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "INSERTCHILDXMLBEFORE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c INSERTCHILDXMLBEFORE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> INSERTCHILDXMLBEFORE ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ] ) </eps> \n The Purpose is: \n <code>INSERTXMLCHILDBEFORE</code> inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately before a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based. <code>XMLType_instance</code> identifies the XML data that is the target of the insertion. <code>XPath_string</code> locates the parent elements within target-data; child-data is inserted under each parent element. <code>child_expr</code> is a relative XPath 1.0 expression that locates the existing child that will follow the inserted child-data. It must name a child element of the element indicated by parent-xpath, and it can include a predicate. <code>value_expr</code> is the XMLType child element data to insert. Each top-level element node in this argument must have the same data type as the element indicated by child_expr. The optional <code>namespace_string</code> specifies the namespace for the parent elements, existing child element, and child element XML data to be inserted. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example is similar to that for <code>INSERTCHILDXML</code>, but it adds a third <code>/Owner</code> node before the <code>/Owner</code> node added in the other example. The output of the query has been formatted for readability. <code>UPDATE warehouses SET warehouse_spec = INSERTCHILDXMLBEFORE(warehouse_spec, '/Warehouse/Building', 'Owner[2]', XMLType('<Owner>ThirdOwner</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Building/Owner') \"Owners\" FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_NAME Owners ----------------------------------- ------------------------------ New Jersey <Owner>GrandCo</Owner> <Owner>ThirdOwner</Owner> <Owner>LesserCo</Owner> </code> ",
        "detail": "The Syntax is: \n <eps> INSERTCHILDXMLBEFORE ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ] ) </eps> \n The Purpose is: \n <code>INSERTXMLCHILDBEFORE</code> inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately before a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based. <code>XMLType_instance</code> identifies the XML data that is the target of the insertion. <code>XPath_string</code> locates the parent elements within target-data; child-data is inserted under each parent element. <code>child_expr</code> is a relative XPath 1.0 expression that locates the existing child that will follow the inserted child-data. It must name a child element of the element indicated by parent-xpath, and it can include a predicate. <code>value_expr</code> is the XMLType child element data to insert. Each top-level element node in this argument must have the same data type as the element indicated by child_expr. The optional <code>namespace_string</code> specifies the namespace for the parent elements, existing child element, and child element XML data to be inserted. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example is similar to that for <code>INSERTCHILDXML</code>, but it adds a third <code>/Owner</code> node before the <code>/Owner</code> node added in the other example. The output of the query has been formatted for readability. <code>UPDATE warehouses SET warehouse_spec = INSERTCHILDXMLBEFORE(warehouse_spec, '/Warehouse/Building', 'Owner[2]', XMLType('<Owner>ThirdOwner</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Building/Owner') \"Owners\" FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_NAME Owners ----------------------------------- ------------------------------ New Jersey <Owner>GrandCo</Owner> <Owner>ThirdOwner</Owner> <Owner>LesserCo</Owner> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions077.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "MAKE_REF",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c MAKE_REF))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> MAKE_REF({ table | view } , key [, key ]...) </eps> \n The Purpose is: \n <code>MAKE_REF</code> creates a <code>REF</code> to a row of an object view or a row in an object table whose object identifier is primary key based. This function is useful, for example, if you are creating an object view See Also: <link>Oracle Database Object-Relational Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e11822/adobjvew.htm#ADOBJ005</link> for more information about object views and <link>DEREF&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions054.htm#i1152051</link> \n The Examples is: \n The sample schema <code>oe</code> contains an object view <code>oc_inventories</code> based on <code>inventory_typ</code>. The object identifier is <code>product_id</code>. The following example creates a <code>REF</code> to the row in the <code>oc_inventories</code> object view with a <code>product_id</code> of 3003: <code>SELECT MAKE_REF (oc_inventories, 3003) FROM DUAL; MAKE_REF(OC_INVENTORIES,3003) ------------------------------------------------------------------ 00004A038A0046857C14617141109EE03408002082543600000014260100010001 00290090606002A00078401FE0000000B03C21F040000000000000000000000000 0000000000 </code> ",
        "detail": "The Syntax is: \n <eps> MAKE_REF({ table | view } , key [, key ]...) </eps> \n The Purpose is: \n <code>MAKE_REF</code> creates a <code>REF</code> to a row of an object view or a row in an object table whose object identifier is primary key based. This function is useful, for example, if you are creating an object view See Also: <link>Oracle Database Object-Relational Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e11822/adobjvew.htm#ADOBJ005</link> for more information about object views and <link>DEREF&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions054.htm#i1152051</link> \n The Examples is: \n The sample schema <code>oe</code> contains an object view <code>oc_inventories</code> based on <code>inventory_typ</code>. The object identifier is <code>product_id</code>. The following example creates a <code>REF</code> to the row in the <code>oc_inventories</code> object view with a <code>product_id</code> of 3003: <code>SELECT MAKE_REF (oc_inventories, 3003) FROM DUAL; MAKE_REF(OC_INVENTORIES,3003) ------------------------------------------------------------------ 00004A038A0046857C14617141109EE03408002082543600000014260100010001 00290090606002A00078401FE0000000B03C21F040000000000000000000000000 0000000000 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions097.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "VAR_SAMP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c VAR_SAMP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> VAR_SAMP(expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>VAR_SAMP</code> returns the sample variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If the function is applied to an empty set, then it returns null. The function makes the following calculation: <code>(SUM(expr - (SUM(expr) / COUNT(expr)))2) / (COUNT(expr) - 1) </code> This function is similar to <code>VARIANCE</code>, except that given an input set of one element, <code>VARIANCE</code> returns 0 and <code>VAR_SAMP</code> returns null. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example returns the sample variance of the salaries in the sample <code>employees</code> table. <code>SELECT VAR_SAMP(salary) FROM employees; VAR_SAMP(SALARY) ---------------- 15284813.7 </code> Analytic Example Refer to the analytic example for <link>VAR_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions230.htm#i87119</link>. ",
        "detail": "The Syntax is: \n <eps> VAR_SAMP(expr) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>VAR_SAMP</code> returns the sample variance of a set of numbers after discarding the nulls in this set. You can use it as both an aggregate and analytic function. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion If the function is applied to an empty set, then it returns null. The function makes the following calculation: <code>(SUM(expr - (SUM(expr) / COUNT(expr)))2) / (COUNT(expr) - 1) </code> This function is similar to <code>VARIANCE</code>, except that given an input set of one element, <code>VARIANCE</code> returns 0 and <code>VAR_SAMP</code> returns null. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate Example The following example returns the sample variance of the salaries in the sample <code>employees</code> table. <code>SELECT VAR_SAMP(salary) FROM employees; VAR_SAMP(SALARY) ---------------- 15284813.7 </code> Analytic Example Refer to the analytic example for <link>VAR_POP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions230.htm#i87119</link>. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions231.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLPARSE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLPARSE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLPARSE ({ DOCUMENT | CONTENT } value_expr [ WELLFORMED ] ) </eps> \n The Purpose is: \n <code>XMLParse</code> parses and generates an XML instance from the evaluated result of <code>value_expr</code>. The <code>value_expr</code> must resolve to a string. If <code>value_expr</code> resolves to null, then the function returns null. If you specify <code>DOCUMENT</code>, then <code>value_expr</code> must resolve to a singly rooted XML document. If you specify <code>CONTENT</code>, then <code>value_expr</code> must resolve to a valid XML value. When you specify <code>WELLFORMED</code>, you are guaranteeing that <code>value_expr</code> resolves to a well-formed XML document, so the database does not perform validity checks to ensure that the input is well formed. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following example uses the <code>DUAL</code> table to illustrate the syntax of <code>XMLParse</code>: <code>SELECT XMLPARSE(CONTENT '124 <purchaseOrder poNo=\"12435\"> <customerName> Acme Enterprises</customerName> <itemNo>32987457</itemNo> </purchaseOrder>' WELLFORMED) AS PO FROM DUAL; PO ----------------------------------------------------------------- 124 <purchaseOrder poNo=\"12435\"> <customerName> Acme Enterprises</customerName> <itemNo>32987457</itemNo> </purchaseOrder> </code> ",
        "detail": "The Syntax is: \n <eps> XMLPARSE ({ DOCUMENT | CONTENT } value_expr [ WELLFORMED ] ) </eps> \n The Purpose is: \n <code>XMLParse</code> parses and generates an XML instance from the evaluated result of <code>value_expr</code>. The <code>value_expr</code> must resolve to a string. If <code>value_expr</code> resolves to null, then the function returns null. If you specify <code>DOCUMENT</code>, then <code>value_expr</code> must resolve to a singly rooted XML document. If you specify <code>CONTENT</code>, then <code>value_expr</code> must resolve to a valid XML value. When you specify <code>WELLFORMED</code>, you are guaranteeing that <code>value_expr</code> resolves to a well-formed XML document, so the database does not perform validity checks to ensure that the input is well formed. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for more information on this function \n The Examples is: \n The following example uses the <code>DUAL</code> table to illustrate the syntax of <code>XMLParse</code>: <code>SELECT XMLPARSE(CONTENT '124 <purchaseOrder poNo=\"12435\"> <customerName> Acme Enterprises</customerName> <itemNo>32987457</itemNo> </purchaseOrder>' WELLFORMED) AS PO FROM DUAL; PO ----------------------------------------------------------------- 124 <purchaseOrder poNo=\"12435\"> <customerName> Acme Enterprises</customerName> <itemNo>32987457</itemNo> </purchaseOrder> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions246.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LTRIM",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LTRIM))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LTRIM(char [, set ]) </eps> \n The Purpose is: \n <code>LTRIM</code> removes from the left end of <code>char</code> all of the characters contained in <code>set</code>. If you do not specify <code>set</code>, then it defaults to a single blank. If <code>char</code> is a character literal, then you must enclose it in single quotation marks. Oracle Database begins scanning <code>char</code> from its first character and removes all characters that appear in <code>set</code> until reaching a character not in <code>set</code> and then returns the result. Both <code>char</code> and <code>set</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>char</code> is a character data type, <code>NVARCHAR2</code> if <code>char</code> is a national character data type, and a LOB if <code>char</code> is a LOB data type. See Also: <link>RTRIM&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions160.htm#i1018967</link> \n The Examples is: \n The following example trims all the left-most occurrences of less than sign (<code><</code>), greater than sign (<code>></code>) , and equal sign (<code>=</code>) from a string: <code>SELECT LTRIM('<=====>BROWNING<=====>', '<>=') \"LTRIM Example\" FROM DUAL; LTRIM Example --------------- BROWNING<=====> </code> ",
        "detail": "The Syntax is: \n <eps> LTRIM(char [, set ]) </eps> \n The Purpose is: \n <code>LTRIM</code> removes from the left end of <code>char</code> all of the characters contained in <code>set</code>. If you do not specify <code>set</code>, then it defaults to a single blank. If <code>char</code> is a character literal, then you must enclose it in single quotation marks. Oracle Database begins scanning <code>char</code> from its first character and removes all characters that appear in <code>set</code> until reaching a character not in <code>set</code> and then returns the result. Both <code>char</code> and <code>set</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>char</code> is a character data type, <code>NVARCHAR2</code> if <code>char</code> is a national character data type, and a LOB if <code>char</code> is a LOB data type. See Also: <link>RTRIM&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions160.htm#i1018967</link> \n The Examples is: \n The following example trims all the left-most occurrences of less than sign (<code><</code>), greater than sign (<code>></code>) , and equal sign (<code>=</code>) from a string: <code>SELECT LTRIM('<=====>BROWNING<=====>', '<>=') \"LTRIM Example\" FROM DUAL; LTRIM Example --------------- BROWNING<=====> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions096.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "DECOMPOSE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c DECOMPOSE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> DECOMPOSE( string [, { 'CANONICAL' | 'COMPATIBILITY' } ] ) </eps> \n The Purpose is: \n <code>DECOMPOSE</code> is valid only for Unicode characters. <code>DECOMPOSE</code> takes as its argument a string in any data type and returns a Unicode string after decomposition in the same character set as the input. For example, an o-umlaut code point will be returned as the \"o\" code point followed by an umlaut code point. <code>string</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. <code>CANONICAL</code> causes canonical decomposition, which allows recomposition (for example, with the <code>COMPOSE</code> function) to the original string. This is the default and returns the string in NFD normal form. <code>COMPATIBILITY</code> causes decomposition in compatibility mode. In this mode, recomposition is not possible. This mode is useful, for example, when decomposing half-width and full-width katakana characters, where recomposition might not be desirable without external formatting or style information. It returns the string in NFKD normal form. <code>CLOB</code> and <code>NCLOB</code> values are supported through implicit conversion. If <code>char</code> is a character LOB value, then it is converted to a <code>VARCHAR</code> value before the <code>COMPOSE</code> operation. The operation will fail if the size of the LOB value exceeds the supported length of the <code>VARCHAR</code> in the particular development environment. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG014</link> for information on Unicode character sets and character semantics <link>COMPOSE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions032.htm#i1000195</link> \n The Examples is: \n The following example decomposes the string \"<code>Ch\u00e2teaux</code>\" into its component code points: <code>SELECT DECOMPOSE ('Ch\u00e2teaux') FROM DUAL; DECOMPOSE --------- Cha^teaux </code> Note: The results of this example can vary depending on the character set of your operating system. ",
        "detail": "The Syntax is: \n <eps> DECOMPOSE( string [, { 'CANONICAL' | 'COMPATIBILITY' } ] ) </eps> \n The Purpose is: \n <code>DECOMPOSE</code> is valid only for Unicode characters. <code>DECOMPOSE</code> takes as its argument a string in any data type and returns a Unicode string after decomposition in the same character set as the input. For example, an o-umlaut code point will be returned as the \"o\" code point followed by an umlaut code point. <code>string</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. <code>CANONICAL</code> causes canonical decomposition, which allows recomposition (for example, with the <code>COMPOSE</code> function) to the original string. This is the default and returns the string in NFD normal form. <code>COMPATIBILITY</code> causes decomposition in compatibility mode. In this mode, recomposition is not possible. This mode is useful, for example, when decomposing half-width and full-width katakana characters, where recomposition might not be desirable without external formatting or style information. It returns the string in NFKD normal form. <code>CLOB</code> and <code>NCLOB</code> values are supported through implicit conversion. If <code>char</code> is a character LOB value, then it is converted to a <code>VARCHAR</code> value before the <code>COMPOSE</code> operation. The operation will fail if the size of the LOB value exceeds the supported length of the <code>VARCHAR</code> in the particular development environment. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/applocaledata.htm#NLSPG014</link> for information on Unicode character sets and character semantics <link>COMPOSE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions032.htm#i1000195</link> \n The Examples is: \n The following example decomposes the string \"<code>Ch\u00e2teaux</code>\" into its component code points: <code>SELECT DECOMPOSE ('Ch\u00e2teaux') FROM DUAL; DECOMPOSE --------- Cha^teaux </code> Note: The results of this example can vary depending on the character set of your operating system. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions050.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "ASCIISTR",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c ASCIISTR))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> ASCIISTR(char) </eps> \n The Purpose is: \n <code>ASCIISTR</code> takes as its argument a string, or an expression that resolves to a string, in any character set and returns an ASCII version of the string in the database character set. Non-ASCII characters are converted to the form <code>\\xxxx</code>, where <code>xxxx</code> represents a UTF-16 code unit. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch6unicode.htm#NLSPG006</link> for information on Unicode character sets and character semantics \n The Examples is: \n The following example returns the ASCII string equivalent of the text string \"<code>AB\u00c4CDE</code>\": <code>SELECT ASCIISTR('AB\u00c4CDE') FROM DUAL; ASCIISTR(' ---------- AB\\00C4CDE </code> ",
        "detail": "The Syntax is: \n <eps> ASCIISTR(char) </eps> \n The Purpose is: \n <code>ASCIISTR</code> takes as its argument a string, or an expression that resolves to a string, in any character set and returns an ASCII version of the string in the database character set. Non-ASCII characters are converted to the form <code>\\xxxx</code>, where <code>xxxx</code> represents a UTF-16 code unit. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch6unicode.htm#NLSPG006</link> for information on Unicode character sets and character semantics \n The Examples is: \n The following example returns the ASCII string equivalent of the text string \"<code>AB\u00c4CDE</code>\": <code>SELECT ASCIISTR('AB\u00c4CDE') FROM DUAL; ASCIISTR(' ---------- AB\\00C4CDE </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions014.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_MODE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_MODE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STATS_MODE(expr) </eps> \n The Purpose is: \n <code>STATS_MODE</code> takes as its argument a set of values and returns the value that occurs with the greatest frequency. If more than one mode exists, then Oracle Database chooses one and returns only that one value. To obtain multiple modes (if multiple modes exist), you must use a combination of other functions, as shown in the hypothetical query: <code>SELECT x FROM (SELECT x, COUNT(x) AS cnt1 FROM t GROUP BY x) WHERE cnt1 = (SELECT MAX(cnt2) FROM (SELECT COUNT(x) AS cnt2 FROM t GROUP BY x)); </code> \n The Examples is: \n The following example returns the mode of salary per department in the <code>hr.employees</code> table: <code>SELECT department_id, STATS_MODE(salary) FROM employees GROUP BY department_id ORDER BY department_id, stats_mode(salary); DEPARTMENT_ID STATS_MODE(SALARY) ------------- ------------------ 10 4400 20 6000 30 2500 40 6500 50 2500 60 4800 70 10000 80 9500 90 17000 100 6900 110 8300 7000 </code> If you need to retrieve all of the modes (in cases with multiple modes), you can do so using a combination of other functions, as shown in the next example: <code>SELECT commission_pct FROM (SELECT commission_pct, COUNT(commission_pct) AS cnt1 FROM employees GROUP BY commission_pct) WHERE cnt1 = (SELECT MAX (cnt2) FROM (SELECT COUNT(commission_pct) AS cnt2 FROM employees GROUP BY commission_pct)) ORDER BY commission_pct; COMMISSION_PCT -------------- .2 .3 </code> ",
        "detail": "The Syntax is: \n <eps> STATS_MODE(expr) </eps> \n The Purpose is: \n <code>STATS_MODE</code> takes as its argument a set of values and returns the value that occurs with the greatest frequency. If more than one mode exists, then Oracle Database chooses one and returns only that one value. To obtain multiple modes (if multiple modes exist), you must use a combination of other functions, as shown in the hypothetical query: <code>SELECT x FROM (SELECT x, COUNT(x) AS cnt1 FROM t GROUP BY x) WHERE cnt1 = (SELECT MAX(cnt2) FROM (SELECT COUNT(x) AS cnt2 FROM t GROUP BY x)); </code> \n The Examples is: \n The following example returns the mode of salary per department in the <code>hr.employees</code> table: <code>SELECT department_id, STATS_MODE(salary) FROM employees GROUP BY department_id ORDER BY department_id, stats_mode(salary); DEPARTMENT_ID STATS_MODE(SALARY) ------------- ------------------ 10 4400 20 6000 30 2500 40 6500 50 2500 60 4800 70 10000 80 9500 90 17000 100 6900 110 8300 7000 </code> If you need to retrieve all of the modes (in cases with multiple modes), you can do so using a combination of other functions, as shown in the next example: <code>SELECT commission_pct FROM (SELECT commission_pct, COUNT(commission_pct) AS cnt1 FROM employees GROUP BY commission_pct) WHERE cnt1 = (SELECT MAX (cnt2) FROM (SELECT COUNT(commission_pct) AS cnt2 FROM employees GROUP BY commission_pct)) ORDER BY commission_pct; COMMISSION_PCT -------------- .2 .3 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions173.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_CHAR(datetime)",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_CHAR))) (function_argument ( )))",
        "description": "The Syntax is: \n to_char_date::= <eps> TO_CHAR({ datetime | interval } [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_CHAR</code> (datetime) converts a datetime or interval value of <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>, or <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> data type to a value of <code>VARCHAR2</code> data type in the format specified by the date format <code>fmt</code>. If you omit <code>fmt</code>, then <code>date</code> is converted to a <code>VARCHAR2</code> value as follows: <code>DATE</code> values are converted to values in the default date format. <code>TIMESTAMP</code> and <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code> values are converted to values in the default timestamp format. <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values are converted to values in the default timestamp with time zone format. Interval values are converted to the numeric representation of the interval literal. Refer to <link>\"Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34510</link> for information on datetime formats. The <code>'nlsparam'</code> argument specifies the language in which month and day names and abbreviations are returned. This argument can have this form: <code>'NLS_DATE_LANGUAGE = language' </code> If you omit <code>'nlsparam'</code>, then this function uses the default date language for your session. See Also: <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> You can use this function in conjunction with any of the XML functions to generate a date in the database format rather than the XML Schema standard format. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for information about formatting of XML dates and timestamps, including examples <link>\"XML Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions002.htm#CIHGFCGD</link> for a listing of the XML functions \n The Examples is: \n The following example uses this table: <code>CREATE TABLE date_tab ( ts_col TIMESTAMP, tsltz_col TIMESTAMP WITH LOCAL TIME ZONE, tstz_col TIMESTAMP WITH TIME ZONE); </code> The example shows the results of applying <code>TO_CHAR</code> to different <code>TIMESTAMP</code> data types. The result for a <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code> column is sensitive to session time zone, whereas the results for the <code>TIMESTAMP</code> and <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> columns are not sensitive to session time zone: <code>ALTER SESSION SET TIME_ZONE = '-8:00'; INSERT INTO date_tab VALUES ( TIMESTAMP'1999-12-01 10:00:00', TIMESTAMP'1999-12-01 10:00:00', TIMESTAMP'1999-12-01 10:00:00'); INSERT INTO date_tab VALUES ( TIMESTAMP'1999-12-02 10:00:00 -8:00', TIMESTAMP'1999-12-02 10:00:00 -8:00', TIMESTAMP'1999-12-02 10:00:00 -8:00'); SELECT TO_CHAR(ts_col, 'DD-MON-YYYY HH24:MI:SSxFF') AS ts_date, TO_CHAR(tstz_col, 'DD-MON-YYYY HH24:MI:SSxFF TZH:TZM') AS tstz_date FROM date_tab ORDER BY ts_date, tstz_date; TS_DATE TSTZ_DATE ------------------------------ ------------------------------------- 01-DEC-1999 10:00:00.000000 01-DEC-1999 10:00:00.000000 -08:00 02-DEC-1999 10:00:00.000000 02-DEC-1999 10:00:00.000000 -08:00 SELECT SESSIONTIMEZONE, TO_CHAR(tsltz_col, 'DD-MON-YYYY HH24:MI:SSxFF') AS tsltz FROM date_tab ORDER BY sessiontimezone, tsltz; SESSIONTIM TSLTZ ---------- ------------------------------ -08:00 01-DEC-1999 10:00:00.000000 -08:00 02-DEC-1999 10:00:00.000000 ALTER SESSION SET TIME_ZONE = '-5:00'; SELECT TO_CHAR(ts_col, 'DD-MON-YYYY HH24:MI:SSxFF') AS ts_col, TO_CHAR(tstz_col, 'DD-MON-YYYY HH24:MI:SSxFF TZH:TZM') AS tstz_col FROM date_tab ORDER BY ts_col, tstz_col; TS_COL TSTZ_COL ------------------------------ ------------------------------------- 01-DEC-1999 10:00:00.000000 01-DEC-1999 10:00:00.000000 -08:00 02-DEC-1999 10:00:00.000000 02-DEC-1999 10:00:00.000000 -08:00 SELECT SESSIONTIMEZONE, TO_CHAR(tsltz_col, 'DD-MON-YYYY HH24:MI:SSxFF') AS tsltz_col FROM date_tab ORDER BY sessiontimezone, tsltz_col; 2 3 4 SESSIONTIM TSLTZ_COL ---------- ------------------------------ -05:00 01-DEC-1999 13:00:00.000000 -05:00 02-DEC-1999 13:00:00.000000 </code> The following example converts an interval literal into a text literal: <code>SELECT TO_CHAR(INTERVAL '123-2' YEAR(3) TO MONTH) FROM DUAL; TO_CHAR ------- +123-02 </code> ",
        "detail": "The Syntax is: \n to_char_date::= <eps> TO_CHAR({ datetime | interval } [, fmt [, 'nlsparam' ] ]) </eps> \n The Purpose is: \n <code>TO_CHAR</code> (datetime) converts a datetime or interval value of <code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>, <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>, or <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> data type to a value of <code>VARCHAR2</code> data type in the format specified by the date format <code>fmt</code>. If you omit <code>fmt</code>, then <code>date</code> is converted to a <code>VARCHAR2</code> value as follows: <code>DATE</code> values are converted to values in the default date format. <code>TIMESTAMP</code> and <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code> values are converted to values in the default timestamp format. <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> values are converted to values in the default timestamp with time zone format. Interval values are converted to the numeric representation of the interval literal. Refer to <link>\"Format Models\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i34510</link> for information on datetime formats. The <code>'nlsparam'</code> argument specifies the language in which month and day names and abbreviations are returned. This argument can have this form: <code>'NLS_DATE_LANGUAGE = language' </code> If you omit <code>'nlsparam'</code>, then this function uses the default date language for your session. See Also: <link>\"Security Considerations for Data Conversion\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#CIHJCCEB</link> You can use this function in conjunction with any of the XML functions to generate a date in the database format rather than the XML Schema standard format. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb13gen.htm#ADXDB1620</link> for information about formatting of XML dates and timestamps, including examples <link>\"XML Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions002.htm#CIHGFCGD</link> for a listing of the XML functions \n The Examples is: \n The following example uses this table: <code>CREATE TABLE date_tab ( ts_col TIMESTAMP, tsltz_col TIMESTAMP WITH LOCAL TIME ZONE, tstz_col TIMESTAMP WITH TIME ZONE); </code> The example shows the results of applying <code>TO_CHAR</code> to different <code>TIMESTAMP</code> data types. The result for a <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code> column is sensitive to session time zone, whereas the results for the <code>TIMESTAMP</code> and <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> columns are not sensitive to session time zone: <code>ALTER SESSION SET TIME_ZONE = '-8:00'; INSERT INTO date_tab VALUES ( TIMESTAMP'1999-12-01 10:00:00', TIMESTAMP'1999-12-01 10:00:00', TIMESTAMP'1999-12-01 10:00:00'); INSERT INTO date_tab VALUES ( TIMESTAMP'1999-12-02 10:00:00 -8:00', TIMESTAMP'1999-12-02 10:00:00 -8:00', TIMESTAMP'1999-12-02 10:00:00 -8:00'); SELECT TO_CHAR(ts_col, 'DD-MON-YYYY HH24:MI:SSxFF') AS ts_date, TO_CHAR(tstz_col, 'DD-MON-YYYY HH24:MI:SSxFF TZH:TZM') AS tstz_date FROM date_tab ORDER BY ts_date, tstz_date; TS_DATE TSTZ_DATE ------------------------------ ------------------------------------- 01-DEC-1999 10:00:00.000000 01-DEC-1999 10:00:00.000000 -08:00 02-DEC-1999 10:00:00.000000 02-DEC-1999 10:00:00.000000 -08:00 SELECT SESSIONTIMEZONE, TO_CHAR(tsltz_col, 'DD-MON-YYYY HH24:MI:SSxFF') AS tsltz FROM date_tab ORDER BY sessiontimezone, tsltz; SESSIONTIM TSLTZ ---------- ------------------------------ -08:00 01-DEC-1999 10:00:00.000000 -08:00 02-DEC-1999 10:00:00.000000 ALTER SESSION SET TIME_ZONE = '-5:00'; SELECT TO_CHAR(ts_col, 'DD-MON-YYYY HH24:MI:SSxFF') AS ts_col, TO_CHAR(tstz_col, 'DD-MON-YYYY HH24:MI:SSxFF TZH:TZM') AS tstz_col FROM date_tab ORDER BY ts_col, tstz_col; TS_COL TSTZ_COL ------------------------------ ------------------------------------- 01-DEC-1999 10:00:00.000000 01-DEC-1999 10:00:00.000000 -08:00 02-DEC-1999 10:00:00.000000 02-DEC-1999 10:00:00.000000 -08:00 SELECT SESSIONTIMEZONE, TO_CHAR(tsltz_col, 'DD-MON-YYYY HH24:MI:SSxFF') AS tsltz_col FROM date_tab ORDER BY sessiontimezone, tsltz_col; 2 3 4 SESSIONTIM TSLTZ_COL ---------- ------------------------------ -05:00 01-DEC-1999 13:00:00.000000 -05:00 02-DEC-1999 13:00:00.000000 </code> The following example converts an interval literal into a text literal: <code>SELECT TO_CHAR(INTERVAL '123-2' YEAR(3) TO MONTH) FROM DUAL; TO_CHAR ------- +123-02 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions200.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "INITCAP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c INITCAP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> INITCAP(char) </eps> \n The Purpose is: \n <code>INITCAP</code> returns <code>char</code>, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric. <code>char</code> can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The return value is the same data type as <code>char</code>. The database sets the case of the initial characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase and lowercase, refer to <link>NLS_INITCAP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions110.htm#i89841</link>. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example capitalizes each word in the string: <code>SELECT INITCAP('the soap') \"Capitals\" FROM DUAL; Capitals --------- The Soap </code> ",
        "detail": "The Syntax is: \n <eps> INITCAP(char) </eps> \n The Purpose is: \n <code>INITCAP</code> returns <code>char</code>, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric. <code>char</code> can be of any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The return value is the same data type as <code>char</code>. The database sets the case of the initial characters based on the binary mapping defined for the underlying character set. For linguistic-sensitive uppercase and lowercase, refer to <link>NLS_INITCAP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions110.htm#i89841</link>. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following example capitalizes each word in the string: <code>SELECT INITCAP('the soap') \"Capitals\" FROM DUAL; Capitals --------- The Soap </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions074.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_ONE_WAY_ANOVA",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_ONE_WAY_ANOVA))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> STATS_ONE_WAY_ANOVA(expr1, expr2 [, { SUM_SQUARES_BETWEEN | SUM_SQUARES_WITHIN | DF_BETWEEN | DF_WITHIN | MEAN_SQUARES_BETWEEN | MEAN_SQUARES_WITHIN | F_RATIO | SIG } ] ) </eps> \n The Purpose is: \n The one-way analysis of variance function (<code>STATS_ONE_WAY_ANOVA</code>) tests differences in means (for groups or variables) for statistical significance by comparing two different estimates of variance. One estimate is based on the variances within each group or category. This is known as the mean squares within or mean square error. The other estimate is based on the variances among the means of the groups. This is known as the mean squares between. If the means of the groups are significantly different, then the mean squares between will be larger than expected and will not match the mean squares within. If the mean squares of the groups are consistent, then the two variance estimates will be about the same. <code>STATS_ONE_WAY_ANOVA</code> takes three arguments: two expressions and a return value of type <code>VARCHAR2</code>. <code>expr1</code> is an independent or grouping variable that divides the data into a set of groups. <code>expr2</code> is a dependent variable (a numeric expression) containing the values corresponding to each member of a group. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>SIG</code>. The meaning of the return values is shown in <link>Table 5-8&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions175.htm#g1514144</link>. Table 5-8 STATS_ONE_WAY_ANOVA Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> SUM_SQUARES_BETEEN </td> <td> Sum of squares between groups </td> </tr> <tr> <td> SUM_SQUARES_WITHIN </td> <td> Sum of squares within groups </td> </tr> <tr> <td> DF_BETWEEN </td> <td> Degree of freedom between groups </td> </tr> <tr> <td> DF_WITHIN </td> <td> Degree of freedom within groups </td> </tr> <tr> <td> MEAN_SQUARES_BETWEEN </td> <td> Mean squares between groups </td> </tr> <tr> <td> MEAN_SQUARES_WITHIN </td> <td> Mean squares within groups </td> </tr> <tr> <td> F_RATIO </td> <td> Ratio of the mean squares between to the mean squares within (MSB/MSW) </td> </tr> <tr> <td> SIG </td> <td> Significance </td> </tr> </tbody> </table> The significance of one-way analysis of variance is determined by obtaining the one-tailed significance of an f-test on the ratio of the mean squares between and the mean squares within. The f-test should use one-tailed significance, because the mean squares between can be only equal to or larger than the mean squares within. Therefore, the significance returned by <code>STATS_ONE_WAY_ANOVA</code> is the probability that the differences between the groups happened by chance\u2014a number between 0 and 1. The smaller the number, the greater the significance of the difference between the groups. Refer to the <link>STATS_F_TEST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm#i1279901</link> for information on performing an f-test. STATS_ONE_WAY_ANOVA Example The following example determines the significance of the differences in mean sales within an income level and differences in mean sales between income levels. The results, p_values close to zero, indicate that, for both men and women, the difference in the amount of goods sold across different income levels is significant. <code>SELECT cust_gender, STATS_ONE_WAY_ANOVA(cust_income_level, amount_sold, 'F_RATIO') f_ratio, STATS_ONE_WAY_ANOVA(cust_income_level, amount_sold, 'SIG') p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id GROUP BY cust_gender ORDER BY cust_gender; C F_RATIO P_VALUE - ---------- ---------- F 5.59536943 4.7840E-09 M 9.2865001 6.7139E-17 </code> ",
        "detail": "The Syntax is: \n <eps> STATS_ONE_WAY_ANOVA(expr1, expr2 [, { SUM_SQUARES_BETWEEN | SUM_SQUARES_WITHIN | DF_BETWEEN | DF_WITHIN | MEAN_SQUARES_BETWEEN | MEAN_SQUARES_WITHIN | F_RATIO | SIG } ] ) </eps> \n The Purpose is: \n The one-way analysis of variance function (<code>STATS_ONE_WAY_ANOVA</code>) tests differences in means (for groups or variables) for statistical significance by comparing two different estimates of variance. One estimate is based on the variances within each group or category. This is known as the mean squares within or mean square error. The other estimate is based on the variances among the means of the groups. This is known as the mean squares between. If the means of the groups are significantly different, then the mean squares between will be larger than expected and will not match the mean squares within. If the mean squares of the groups are consistent, then the two variance estimates will be about the same. <code>STATS_ONE_WAY_ANOVA</code> takes three arguments: two expressions and a return value of type <code>VARCHAR2</code>. <code>expr1</code> is an independent or grouping variable that divides the data into a set of groups. <code>expr2</code> is a dependent variable (a numeric expression) containing the values corresponding to each member of a group. The function returns one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>SIG</code>. The meaning of the return values is shown in <link>Table 5-8&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions175.htm#g1514144</link>. Table 5-8 STATS_ONE_WAY_ANOVA Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> SUM_SQUARES_BETEEN </td> <td> Sum of squares between groups </td> </tr> <tr> <td> SUM_SQUARES_WITHIN </td> <td> Sum of squares within groups </td> </tr> <tr> <td> DF_BETWEEN </td> <td> Degree of freedom between groups </td> </tr> <tr> <td> DF_WITHIN </td> <td> Degree of freedom within groups </td> </tr> <tr> <td> MEAN_SQUARES_BETWEEN </td> <td> Mean squares between groups </td> </tr> <tr> <td> MEAN_SQUARES_WITHIN </td> <td> Mean squares within groups </td> </tr> <tr> <td> F_RATIO </td> <td> Ratio of the mean squares between to the mean squares within (MSB/MSW) </td> </tr> <tr> <td> SIG </td> <td> Significance </td> </tr> </tbody> </table> The significance of one-way analysis of variance is determined by obtaining the one-tailed significance of an f-test on the ratio of the mean squares between and the mean squares within. The f-test should use one-tailed significance, because the mean squares between can be only equal to or larger than the mean squares within. Therefore, the significance returned by <code>STATS_ONE_WAY_ANOVA</code> is the probability that the differences between the groups happened by chance\u2014a number between 0 and 1. The smaller the number, the greater the significance of the difference between the groups. Refer to the <link>STATS_F_TEST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm#i1279901</link> for information on performing an f-test. STATS_ONE_WAY_ANOVA Example The following example determines the significance of the differences in mean sales within an income level and differences in mean sales between income levels. The results, p_values close to zero, indicate that, for both men and women, the difference in the amount of goods sold across different income levels is significant. <code>SELECT cust_gender, STATS_ONE_WAY_ANOVA(cust_income_level, amount_sold, 'F_RATIO') f_ratio, STATS_ONE_WAY_ANOVA(cust_income_level, amount_sold, 'SIG') p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id GROUP BY cust_gender ORDER BY cust_gender; C F_RATIO P_VALUE - ---------- ---------- F 5.59536943 4.7840E-09 M 9.2865001 6.7139E-17 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions175.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "MOD",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c MOD))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> MOD(n2, n1) </eps> \n The Purpose is: \n <code>MOD</code> returns the remainder of <code>n2</code> divided by <code>n1</code>. Returns <code>n2</code> if <code>n1</code> is 0. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence \n The Examples is: \n The following example returns the remainder of 11 divided by 4: <code>SELECT MOD(11,4) \"Modulus\" FROM DUAL; Modulus ---------- 3 </code> This function behaves differently from the classical mathematical modulus function when <code>m</code> is negative. The classical modulus can be expressed using the <code>MOD</code> function with this formula: <code>n2 - n1 * FLOOR(n2/n1) </code> The following table illustrates the difference between the <code>MOD</code> function and the classical modulus: <table> <thead> <tr> <th>n2</th> <th>n1</th> <th>MOD(n2,n1)</th> <th>Classical Modulus</th> </tr> </thead> <tbody> <tr> <td>11</td> <td>4</td> <td>3</td> <td>3</td> </tr> <tr> <td>11</td> <td>-4</td> <td>3</td> <td>-1</td> </tr> <tr> <td>-11</td> <td>4</td> <td>-3</td> <td>1</td> </tr> <tr> <td>-11</td> <td>-4</td> <td>-3</td> <td>-3</td> </tr> </tbody> </table> See Also: <link>FLOOR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions067.htm#i77449</link> and <link>REMAINDER&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions152.htm#i1300767</link>, which is similar to <code>MOD</code>, but uses <code>ROUND</code> in its formula instead of <code>FLOOR</code> ",
        "detail": "The Syntax is: \n <eps> MOD(n2, n1) </eps> \n The Purpose is: \n <code>MOD</code> returns the remainder of <code>n2</code> divided by <code>n1</code>. Returns <code>n2</code> if <code>n1</code> is 0. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence \n The Examples is: \n The following example returns the remainder of 11 divided by 4: <code>SELECT MOD(11,4) \"Modulus\" FROM DUAL; Modulus ---------- 3 </code> This function behaves differently from the classical mathematical modulus function when <code>m</code> is negative. The classical modulus can be expressed using the <code>MOD</code> function with this formula: <code>n2 - n1 * FLOOR(n2/n1) </code> The following table illustrates the difference between the <code>MOD</code> function and the classical modulus: <table> <thead> <tr> <th>n2</th> <th>n1</th> <th>MOD(n2,n1)</th> <th>Classical Modulus</th> </tr> </thead> <tbody> <tr> <td>11</td> <td>4</td> <td>3</td> <td>3</td> </tr> <tr> <td>11</td> <td>-4</td> <td>3</td> <td>-1</td> </tr> <tr> <td>-11</td> <td>4</td> <td>-3</td> <td>1</td> </tr> <tr> <td>-11</td> <td>-4</td> <td>-3</td> <td>-3</td> </tr> </tbody> </table> See Also: <link>FLOOR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions067.htm#i77449</link> and <link>REMAINDER&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions152.htm#i1300767</link>, which is similar to <code>MOD</code>, but uses <code>ROUND</code> in its formula instead of <code>FLOOR</code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions101.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_YMINTERVAL",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TO_YMINTERVAL))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TO_YMINTERVAL ( ' { [+|-] years - months | ym_iso_format } ' ) </eps> ym_iso_format::= <eps> [-] P [ years Y ] [months M] [days D] [T [hours H] [minutes M] [seconds [. frac_secs] S ] ] </eps> \n The Purpose is: \n <code>TO_YMINTERVAL</code> converts a character string of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to an <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> type. <code>TO_YMINTERVAL</code> accepts argument in one of the two formats: SQL interval format compatible with the SQL standard (ISO/IEC 9075:2003) ISO duration format compatible with the ISO 8601:2004 standard In the SQL format, <code>years</code> is an integer between 0 and 999999999, and <code>months</code> is an integer between 0 and 11. Additional blanks are allowed between format elements. In the ISO format, years and months are integers between 0 and 999999999. Days, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, and frac_secs are non-negative integers, and are ignored, if specified. No blanks are allowed in the value. If you specify <code>T</code>, then you must specify at least one of the <code>hours</code>, <code>minutes</code>, or <code>seconds</code> values. \n The Examples is: \n The following example calculates for each employee in the sample <code>hr.employees</code> table a date one year two months after the hire date: <code>SELECT hire_date, hire_date + TO_YMINTERVAL('01-02') \"14 months\" FROM employees; HIRE_DATE 14 months --------- --------- 17-JUN-03 17-AUG-04 21-SEP-05 21-NOV-06 13-JAN-01 13-MAR-02 20-MAY-08 20-JUL-09 21-MAY-07 21-JUL-08 . . . </code> The following example makes the same calculation using the ISO format: <code>SELECT hire_date, hire_date + TO_YMINTERVAL('P1Y2M') FROM employees; </code> ",
        "detail": "The Syntax is: \n <eps> TO_YMINTERVAL ( ' { [+|-] years - months | ym_iso_format } ' ) </eps> ym_iso_format::= <eps> [-] P [ years Y ] [months M] [days D] [T [hours H] [minutes M] [seconds [. frac_secs] S ] ] </eps> \n The Purpose is: \n <code>TO_YMINTERVAL</code> converts a character string of <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code> data type to an <code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code> type. <code>TO_YMINTERVAL</code> accepts argument in one of the two formats: SQL interval format compatible with the SQL standard (ISO/IEC 9075:2003) ISO duration format compatible with the ISO 8601:2004 standard In the SQL format, <code>years</code> is an integer between 0 and 999999999, and <code>months</code> is an integer between 0 and 11. Additional blanks are allowed between format elements. In the ISO format, years and months are integers between 0 and 999999999. Days, <code>hours</code>, <code>minutes</code>, <code>seconds</code>, and frac_secs are non-negative integers, and are ignored, if specified. No blanks are allowed in the value. If you specify <code>T</code>, then you must specify at least one of the <code>hours</code>, <code>minutes</code>, or <code>seconds</code> values. \n The Examples is: \n The following example calculates for each employee in the sample <code>hr.employees</code> table a date one year two months after the hire date: <code>SELECT hire_date, hire_date + TO_YMINTERVAL('01-02') \"14 months\" FROM employees; HIRE_DATE 14 months --------- --------- 17-JUN-03 17-AUG-04 21-SEP-05 21-NOV-06 13-JAN-01 13-MAR-02 20-MAY-08 20-JUL-09 21-MAY-07 21-JUL-08 . . . </code> The following example makes the same calculation using the ISO format: <code>SELECT hire_date, hire_date + TO_YMINTERVAL('P1Y2M') FROM employees; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions215.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "MONTHS_BETWEEN",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c MONTHS_BETWEEN))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> MONTHS_BETWEEN(date1, date2) </eps> \n The Purpose is: \n <code>MONTHS_BETWEEN</code> returns number of months between dates <code>date1</code> and <code>date2</code>. The month and the last day of the month are defined by the parameter <code>NLS_CALENDAR</code>. If <code>date1</code> is later than <code>date2</code>, then the result is positive. If <code>date1</code> is earlier than <code>date2</code>, then the result is negative. If <code>date1</code> and <code>date2</code> are either the same days of the month or both last days of months, then the result is always an integer. Otherwise Oracle Database calculates the fractional portion of the result based on a 31-day month and considers the difference in time components <code>date1</code> and <code>date2</code>. \n The Examples is: \n The following example calculates the months between two dates: <code>SELECT MONTHS_BETWEEN (TO_DATE('02-02-1995','MM-DD-YYYY'), TO_DATE('01-01-1995','MM-DD-YYYY') ) \"Months\" FROM DUAL; Months ---------- 1.03225806 </code> ",
        "detail": "The Syntax is: \n <eps> MONTHS_BETWEEN(date1, date2) </eps> \n The Purpose is: \n <code>MONTHS_BETWEEN</code> returns number of months between dates <code>date1</code> and <code>date2</code>. The month and the last day of the month are defined by the parameter <code>NLS_CALENDAR</code>. If <code>date1</code> is later than <code>date2</code>, then the result is positive. If <code>date1</code> is earlier than <code>date2</code>, then the result is negative. If <code>date1</code> and <code>date2</code> are either the same days of the month or both last days of months, then the result is always an integer. Otherwise Oracle Database calculates the fractional portion of the result based on a 31-day month and considers the difference in time components <code>date1</code> and <code>date2</code>. \n The Examples is: \n The following example calculates the months between two dates: <code>SELECT MONTHS_BETWEEN (TO_DATE('02-02-1995','MM-DD-YYYY'), TO_DATE('01-01-1995','MM-DD-YYYY') ) \"Months\" FROM DUAL; Months ---------- 1.03225806 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions102.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "REF",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REF))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> REF (correlation_variable) </eps> \n The Purpose is: \n <code>REF</code> takes as its argument a correlation variable (table alias) associated with a row of an object table or an object view. A <code>REF</code> value is returned for the object instance that is bound to the variable or row. \n The Examples is: \n The sample schema <code>oe</code> contains a type called <code>cust_address_typ</code>, described as follows: <code> Attribute Type ----------------------------- ---------------- STREET_ADDRESS VARCHAR2(40) POSTAL_CODE VARCHAR2(10) CITY VARCHAR2(30) STATE_PROVINCE VARCHAR2(10) COUNTRY_ID CHAR(2) </code> The following example creates a table based on the sample type <code>oe.cust_address_typ</code>, inserts a row into the table, and retrieves a <code>REF</code> value for the object instance of the type in the addresses table: <code>CREATE TABLE addresses OF cust_address_typ; INSERT INTO addresses VALUES ( '123 First Street', '4GF H1J', 'Our Town', 'Ourcounty', 'US'); SELECT REF(e) FROM addresses e; REF(E) ----------------------------------------------------------------------------------- 00002802097CD1261E51925B60E0340800208254367CD1261E51905B60E034080020825436010101820000 </code> See Also: <link>Oracle Database Object-Relational Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e11822/adobjdes.htm#ADOBJ00805</link> for information on <code>REF</code>s ",
        "detail": "The Syntax is: \n <eps> REF (correlation_variable) </eps> \n The Purpose is: \n <code>REF</code> takes as its argument a correlation variable (table alias) associated with a row of an object table or an object view. A <code>REF</code> value is returned for the object instance that is bound to the variable or row. \n The Examples is: \n The sample schema <code>oe</code> contains a type called <code>cust_address_typ</code>, described as follows: <code> Attribute Type ----------------------------- ---------------- STREET_ADDRESS VARCHAR2(40) POSTAL_CODE VARCHAR2(10) CITY VARCHAR2(30) STATE_PROVINCE VARCHAR2(10) COUNTRY_ID CHAR(2) </code> The following example creates a table based on the sample type <code>oe.cust_address_typ</code>, inserts a row into the table, and retrieves a <code>REF</code> value for the object instance of the type in the addresses table: <code>CREATE TABLE addresses OF cust_address_typ; INSERT INTO addresses VALUES ( '123 First Street', '4GF H1J', 'Our Town', 'Ourcounty', 'US'); SELECT REF(e) FROM addresses e; REF(E) ----------------------------------------------------------------------------------- 00002802097CD1261E51925B60E0340800208254367CD1261E51905B60E034080020825436010101820000 </code> See Also: <link>Oracle Database Object-Relational Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e11822/adobjdes.htm#ADOBJ00805</link> for information on <code>REF</code>s ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions145.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NLS_INITCAP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NLS_INITCAP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NLS_INITCAP(char [, 'nlsparam' ]) </eps> \n The Purpose is: \n <code>NLS_INITCAP</code> returns <code>char</code>, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric. Both <code>char</code> and <code>'nlsparam'</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The string returned is of <code>VARCHAR2</code> data type and is in the same character set as <code>char</code>. The value of <code>'nlsparam'</code> can have this form: <code>'NLS_SORT = sort' </code> where <code>sort</code> is either a linguistic sort sequence or <code>BINARY</code>. The linguistic sort sequence handles special linguistic requirements for case conversions. These requirements can result in a return value of a different length than the <code>char</code>. If you omit <code>'nlsparam'</code>, then this function uses the default sort sequence for your session. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following examples show how the linguistic sort sequence results in a different return value from the function: <code>SELECT NLS_INITCAP('ijsland') \"InitCap\" FROM DUAL; InitCap ------- Ijsland SELECT NLS_INITCAP('ijsland', 'NLS_SORT = XDutch') \"InitCap\" FROM DUAL; InitCap ------- IJsland </code> See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch5lingsort.htm#NLSPG005</link> for information on sort sequences ",
        "detail": "The Syntax is: \n <eps> NLS_INITCAP(char [, 'nlsparam' ]) </eps> \n The Purpose is: \n <code>NLS_INITCAP</code> returns <code>char</code>, with the first letter of each word in uppercase, all other letters in lowercase. Words are delimited by white space or characters that are not alphanumeric. Both <code>char</code> and <code>'nlsparam'</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The string returned is of <code>VARCHAR2</code> data type and is in the same character set as <code>char</code>. The value of <code>'nlsparam'</code> can have this form: <code>'NLS_SORT = sort' </code> where <code>sort</code> is either a linguistic sort sequence or <code>BINARY</code>. The linguistic sort sequence handles special linguistic requirements for case conversions. These requirements can result in a return value of a different length than the <code>char</code>. If you omit <code>'nlsparam'</code>, then this function uses the default sort sequence for your session. This function does not support <code>CLOB</code> data directly. However, <code>CLOB</code>s can be passed in as arguments through implicit data conversion. See Also: <link>\"Data Type Comparison Rules\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i55214</link> for more information. \n The Examples is: \n The following examples show how the linguistic sort sequence results in a different return value from the function: <code>SELECT NLS_INITCAP('ijsland') \"InitCap\" FROM DUAL; InitCap ------- Ijsland SELECT NLS_INITCAP('ijsland', 'NLS_SORT = XDutch') \"InitCap\" FROM DUAL; InitCap ------- IJsland </code> See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch5lingsort.htm#NLSPG005</link> for information on sort sequences ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions110.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TRUNC(date)",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c TRUNC))) (function_argument ( )))",
        "description": "The Syntax is: \n trunc_date::= <eps> TRUNC(date [, fmt ]) </eps> \n The Purpose is: \n The <code>TRUNC</code> (date) function returns <code>date</code> with the time portion of the day truncated to the unit specified by the format model <code>fmt</code>. This function is not sensitive to the <code>NLS_CALENDAR</code> session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type <code>DATE</code>, even if you specify a different datetime data type for <code>date</code>. If you omit <code>fmt</code>, then the default format model '<code>DD</code>' is used and the value returned is <code>date</code> truncated to the day with a time of midnight. Refer to <link>\"ROUND and TRUNC Date Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions255.htm#i1002084</link> for the permitted format models to use in <code>fmt</code>. \n The Examples is: \n The following example truncates a date: <code>SELECT TRUNC(TO_DATE('27-OCT-92','DD-MON-YY'), 'YEAR') \"New Year\" FROM DUAL; New Year --------- 01-JAN-92 </code> ",
        "detail": "The Syntax is: \n trunc_date::= <eps> TRUNC(date [, fmt ]) </eps> \n The Purpose is: \n The <code>TRUNC</code> (date) function returns <code>date</code> with the time portion of the day truncated to the unit specified by the format model <code>fmt</code>. This function is not sensitive to the <code>NLS_CALENDAR</code> session parameter. It operates according to the rules of the Gregorian calendar. The value returned is always of data type <code>DATE</code>, even if you specify a different datetime data type for <code>date</code>. If you omit <code>fmt</code>, then the default format model '<code>DD</code>' is used and the value returned is <code>date</code> truncated to the day with a time of midnight. Refer to <link>\"ROUND and TRUNC Date Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions255.htm#i1002084</link> for the permitted format models to use in <code>fmt</code>. \n The Examples is: \n The following example truncates a date: <code>SELECT TRUNC(TO_DATE('27-OCT-92','DD-MON-YY'), 'YEAR') \"New Year\" FROM DUAL; New Year --------- 01-JAN-92 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions220.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYS_XMLAGG",
        "tree": "(general_element_part (id_expression (regular_id SYS_XMLAGG)) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYS_XMLAGG(expr [, fmt ]) </eps> \n The Purpose is: \n <code>SYS_XMLAgg</code> aggregates all of the XML documents or fragments represented by <code>expr</code> and produces a single XML document. It adds a new enclosing element with a default name <code>ROWSET</code>. If you want to format the XML document differently, then specify <code>fmt</code>, which is an instance of the <code>XMLFormat</code> object. See Also: <link>SYS_XMLGEN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions190.htm#i1004367</link> and <link>\"XML Format Model\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i54997</link> for using the attributes of the <code>XMLFormat</code> type to format <code>SYS_XMLAgg</code> results \n The Examples is: \n The following example uses the <code>SYS_XMLGen</code> function to generate an XML document for each row of the sample table <code>employees</code> where the employee's last name begins with the letter R, and then aggregates all of the rows into a single XML document in the default enclosing element <code>ROWSET</code>: <code>SELECT SYS_XMLAGG(SYS_XMLGEN(last_name)) XMLAGG FROM employees WHERE last_name LIKE 'R%' ORDER BY xmlagg; XMLAGG -------------------------------------------------------------------------------- <?xml version=\"1.0\"?> <ROWSET> <LAST_NAME>Rajs</LAST_NAME> <LAST_NAME>Raphaely</LAST_NAME> <LAST_NAME>Rogers</LAST_NAME> <LAST_NAME>Russell</LAST_NAME> </ROWSET> </code> ",
        "detail": "The Syntax is: \n <eps> SYS_XMLAGG(expr [, fmt ]) </eps> \n The Purpose is: \n <code>SYS_XMLAgg</code> aggregates all of the XML documents or fragments represented by <code>expr</code> and produces a single XML document. It adds a new enclosing element with a default name <code>ROWSET</code>. If you want to format the XML document differently, then specify <code>fmt</code>, which is an instance of the <code>XMLFormat</code> object. See Also: <link>SYS_XMLGEN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions190.htm#i1004367</link> and <link>\"XML Format Model\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements004.htm#i54997</link> for using the attributes of the <code>XMLFormat</code> type to format <code>SYS_XMLAgg</code> results \n The Examples is: \n The following example uses the <code>SYS_XMLGen</code> function to generate an XML document for each row of the sample table <code>employees</code> where the employee's last name begins with the letter R, and then aggregates all of the rows into a single XML document in the default enclosing element <code>ROWSET</code>: <code>SELECT SYS_XMLAGG(SYS_XMLGEN(last_name)) XMLAGG FROM employees WHERE last_name LIKE 'R%' ORDER BY xmlagg; XMLAGG -------------------------------------------------------------------------------- <?xml version=\"1.0\"?> <ROWSET> <LAST_NAME>Rajs</LAST_NAME> <LAST_NAME>Raphaely</LAST_NAME> <LAST_NAME>Rogers</LAST_NAME> <LAST_NAME>Russell</LAST_NAME> </ROWSET> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions189.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "COMPOSE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c COMPOSE))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> COMPOSE(char) </eps> \n The Purpose is: \n <code>COMPOSE</code> takes as its argument a string, or an expression that resolves to a string, in any data type, and returns a Unicode string in the same character set as the input. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. For example, an <code>o</code> code point qualified by an umlaut code point will be returned as the o-umlaut code point. <code>COMPOSE</code> returns the string in NFC normal form. For a more exclusive setting, you can first call <code>DECOMPOSE</code> with the <code>CANONICAL</code> setting and then <code>COMPOSE</code>. This combination returns the string in NFKC normal form. <code>CLOB</code> and <code>NCLOB</code> values are supported through implicit conversion. If <code>char</code> is a character LOB value, then it is converted to a <code>VARCHAR</code> value before the <code>COMPOSE</code> operation. The operation will fail if the size of the LOB value exceeds the supported length of the <code>VARCHAR</code> in the particular development environment. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch6unicode.htm#NLSPG006</link> for information on Unicode character sets and character semantics <link>DECOMPOSE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions050.htm#i1000217</link> \n The Examples is: \n The following example returns the o-umlaut code point: <code>SELECT COMPOSE( 'o' || UNISTR('\\0308') ) FROM DUAL; CO -- \u00f6 </code> See Also: <link>UNISTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions224.htm#i1000165</link> ",
        "detail": "The Syntax is: \n <eps> COMPOSE(char) </eps> \n The Purpose is: \n <code>COMPOSE</code> takes as its argument a string, or an expression that resolves to a string, in any data type, and returns a Unicode string in the same character set as the input. <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. For example, an <code>o</code> code point qualified by an umlaut code point will be returned as the o-umlaut code point. <code>COMPOSE</code> returns the string in NFC normal form. For a more exclusive setting, you can first call <code>DECOMPOSE</code> with the <code>CANONICAL</code> setting and then <code>COMPOSE</code>. This combination returns the string in NFKC normal form. <code>CLOB</code> and <code>NCLOB</code> values are supported through implicit conversion. If <code>char</code> is a character LOB value, then it is converted to a <code>VARCHAR</code> value before the <code>COMPOSE</code> operation. The operation will fail if the size of the LOB value exceeds the supported length of the <code>VARCHAR</code> in the particular development environment. See Also: <link>Oracle Database Globalization Support Guide&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch6unicode.htm#NLSPG006</link> for information on Unicode character sets and character semantics <link>DECOMPOSE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions050.htm#i1000217</link> \n The Examples is: \n The following example returns the o-umlaut code point: <code>SELECT COMPOSE( 'o' || UNISTR('\\0308') ) FROM DUAL; CO -- \u00f6 </code> See Also: <link>UNISTR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions224.htm#i1000165</link> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions032.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "XMLDIFF",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c XMLDIFF))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> XMLDIFF ( XMLType_document, XMLType_document [ , integer, string ] ) </eps> \n The Purpose is: \n The <code>XMLDiff</code> function is the SQL interface for the XmlDiff C API. This function compares two XML documents and captures the differences in XML conforming to an Xdiff schema. The diff document is returned as an XMLType document. For the first two arguments, specify the names of two XMLType documents. For the <code>integer</code>, specify a number representing the hashLevel for a C function XmlDiff. If you do not want hashing, set this argument to 0 or omit it entirely. If you do not want hashing, but you want to specify flags, then you must set this argument to 0. For <code>string</code>, specify the flags that control the behavior of the function. These flags are specified by one or more names separated by semicolon. The names are the same as the names of constants for XmlDiff function. See Also: <link>Oracle XML Developer's Kit Programmer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23582/adx_c_diff.htm#ADXDK2510</link> for more information on using this function, including examples, and <link>Oracle Database XML C API Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e10770/xmldiff.htm#CAXML6192</link> for information on the XML APIs for C \n The Examples is: \n The following example compares two XML documents and returns the difference as an XMLType document: <code>SELECT XMLDIFF( XMLTYPE('<?xml version=\"1.0\"?> <bk:book xmlns:bk=\"http://example.com\"> <bk:tr> <bk:td> <bk:chapter> Chapter 1. </bk:chapter> </bk:td> <bk:td> <bk:chapter> Chapter 2. </bk:chapter> </bk:td> </bk:tr> </bk:book>'), XMLTYPE('<?xml version=\"1.0\"?> <bk:book xmlns:bk=\"http://example.com\"> <bk:tr> <bk:td> <bk:chapter> Chapter 1. </bk:chapter> </bk:td> <bk:td/> </bk:tr> </bk:book>') ) FROM DUAL; </code> ",
        "detail": "The Syntax is: \n <eps> XMLDIFF ( XMLType_document, XMLType_document [ , integer, string ] ) </eps> \n The Purpose is: \n The <code>XMLDiff</code> function is the SQL interface for the XmlDiff C API. This function compares two XML documents and captures the differences in XML conforming to an Xdiff schema. The diff document is returned as an XMLType document. For the first two arguments, specify the names of two XMLType documents. For the <code>integer</code>, specify a number representing the hashLevel for a C function XmlDiff. If you do not want hashing, set this argument to 0 or omit it entirely. If you do not want hashing, but you want to specify flags, then you must set this argument to 0. For <code>string</code>, specify the flags that control the behavior of the function. These flags are specified by one or more names separated by semicolon. The names are the same as the names of constants for XmlDiff function. See Also: <link>Oracle XML Developer's Kit Programmer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23582/adx_c_diff.htm#ADXDK2510</link> for more information on using this function, including examples, and <link>Oracle Database XML C API Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e10770/xmldiff.htm#CAXML6192</link> for information on the XML APIs for C \n The Examples is: \n The following example compares two XML documents and returns the difference as an XMLType document: <code>SELECT XMLDIFF( XMLTYPE('<?xml version=\"1.0\"?> <bk:book xmlns:bk=\"http://example.com\"> <bk:tr> <bk:td> <bk:chapter> Chapter 1. </bk:chapter> </bk:td> <bk:td> <bk:chapter> Chapter 2. </bk:chapter> </bk:td> </bk:tr> </bk:book>'), XMLTYPE('<?xml version=\"1.0\"?> <bk:book xmlns:bk=\"http://example.com\"> <bk:tr> <bk:td> <bk:chapter> Chapter 1. </bk:chapter> </bk:td> <bk:td/> </bk:tr> </bk:book>') ) FROM DUAL; </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions241.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "NEW_TIME",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c NEW_TIME))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> NEW_TIME(date, timezone1, timezone2) </eps> \n The Purpose is: \n <code>NEW_TIME</code> returns the date and time in time zone <code>timezone2</code> when date and time in time zone <code>timezone1</code> are <code>date</code>. Before using this function, you must set the <code>NLS_DATE_FORMAT</code> parameter to display 24-hour time. The return type is always <code>DATE</code>, regardless of the data type of <code>date</code>. Note: This function takes as input only a limited number of time zones. You can have access to a much greater number of time zones by combining the <code>FROM_TZ</code> function and the datetime expression. See <link>FROM_TZ&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions068.htm#i999803</link> and the example for <link>\"Datetime Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions007.htm#i1047500</link>. The arguments <code>timezone1</code> and <code>timezone2</code> can be any of these text strings: AST, ADT: Atlantic Standard or Daylight Time BST, BDT: Bering Standard or Daylight Time CST, CDT: Central Standard or Daylight Time EST, EDT: Eastern Standard or Daylight Time GMT: Greenwich Mean Time HST, HDT: Alaska-Hawaii Standard Time or Daylight Time. MST, MDT: Mountain Standard or Daylight Time NST: Newfoundland Standard Time PST, PDT: Pacific Standard or Daylight Time YST, YDT: Yukon Standard or Daylight Time \n The Examples is: \n The following example returns an Atlantic Standard time, given the Pacific Standard time equivalent: <code>ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS'; SELECT NEW_TIME(TO_DATE('11-10-09 01:23:45', 'MM-DD-YY HH24:MI:SS'), 'AST', 'PST') \"New Date and Time\" FROM DUAL; New Date and Time -------------------- 09-NOV-2009 21:23:45 </code> ",
        "detail": "The Syntax is: \n <eps> NEW_TIME(date, timezone1, timezone2) </eps> \n The Purpose is: \n <code>NEW_TIME</code> returns the date and time in time zone <code>timezone2</code> when date and time in time zone <code>timezone1</code> are <code>date</code>. Before using this function, you must set the <code>NLS_DATE_FORMAT</code> parameter to display 24-hour time. The return type is always <code>DATE</code>, regardless of the data type of <code>date</code>. Note: This function takes as input only a limited number of time zones. You can have access to a much greater number of time zones by combining the <code>FROM_TZ</code> function and the datetime expression. See <link>FROM_TZ&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions068.htm#i999803</link> and the example for <link>\"Datetime Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions007.htm#i1047500</link>. The arguments <code>timezone1</code> and <code>timezone2</code> can be any of these text strings: AST, ADT: Atlantic Standard or Daylight Time BST, BDT: Bering Standard or Daylight Time CST, CDT: Central Standard or Daylight Time EST, EDT: Eastern Standard or Daylight Time GMT: Greenwich Mean Time HST, HDT: Alaska-Hawaii Standard Time or Daylight Time. MST, MDT: Mountain Standard or Daylight Time NST: Newfoundland Standard Time PST, PDT: Pacific Standard or Daylight Time YST, YDT: Yukon Standard or Daylight Time \n The Examples is: \n The following example returns an Atlantic Standard time, given the Pacific Standard time equivalent: <code>ALTER SESSION SET NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS'; SELECT NEW_TIME(TO_DATE('11-10-09 01:23:45', 'MM-DD-YY HH24:MI:SS'), 'AST', 'PST') \"New Date and Time\" FROM DUAL; New Date and Time -------------------- 09-NOV-2009 21:23:45 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions105.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "EXISTSNODE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c EXISTSNODE))) (function_argument ( )))",
        "description": "Note: The <code>EXISTSNODE</code> function is deprecated. It is still supported for backward compatibility. However, Oracle recommends that you use the <code>XMLEXISTS</code> function instead. See <link>XMLEXISTS&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions243.htm#CIHDEFCD</link> for more information. The Syntax is: \n <eps> EXISTSNODE(XMLType_instance, XPath_string [, namespace_string ]) </eps> \n The Purpose is: \n <code>EXISTSNODE</code> determines whether traversal of an XML document using a specified path results in any nodes. It takes as arguments the <code>XMLType</code> instance containing an XML document and a <code>VARCHAR2</code> XPath string designating a path. The optional <code>namespace_string</code> must resolve to a <code>VARCHAR2</code> value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s). The <code>namespace_string</code> argument defaults to the namespace of the root element. If you refer to any subelement in <code>Xpath_string</code>, then you must specify <code>namespace_string</code>, and you must specify the \"who\" prefix in both of these arguments. See Also: <link>\"Using XML in SQL Statements\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_examples002.htm#i686084</link> for examples that specify <code>namespace_string</code> and use the \"who\" prefix. The return value is <code>NUMBER</code>: 0 if no nodes remain after applying the XPath traversal on the document 1 if any nodes remain \n The Examples is: \n The following example tests for the existence of the <code>/Warehouse/Dock</code> node in the XML path of the <code>warehouse_spec</code> column of the sample table <code>oe.warehouses</code>: <code>SELECT warehouse_id, warehouse_name FROM warehouses WHERE EXISTSNODE(warehouse_spec, '/Warehouse/Docks') = 1 ORDER BY warehouse_id; WAREHOUSE_ID WAREHOUSE_NAME ------------ ----------------------------------- 1 Southlake, Texas 2 San Francisco 4 Seattle, Washington </code> ",
        "detail": "Note: The <code>EXISTSNODE</code> function is deprecated. It is still supported for backward compatibility. However, Oracle recommends that you use the <code>XMLEXISTS</code> function instead. See <link>XMLEXISTS&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions243.htm#CIHDEFCD</link> for more information. The Syntax is: \n <eps> EXISTSNODE(XMLType_instance, XPath_string [, namespace_string ]) </eps> \n The Purpose is: \n <code>EXISTSNODE</code> determines whether traversal of an XML document using a specified path results in any nodes. It takes as arguments the <code>XMLType</code> instance containing an XML document and a <code>VARCHAR2</code> XPath string designating a path. The optional <code>namespace_string</code> must resolve to a <code>VARCHAR2</code> value that specifies a default mapping or namespace mapping for prefixes, which Oracle Database uses when evaluating the XPath expression(s). The <code>namespace_string</code> argument defaults to the namespace of the root element. If you refer to any subelement in <code>Xpath_string</code>, then you must specify <code>namespace_string</code>, and you must specify the \"who\" prefix in both of these arguments. See Also: <link>\"Using XML in SQL Statements\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_examples002.htm#i686084</link> for examples that specify <code>namespace_string</code> and use the \"who\" prefix. The return value is <code>NUMBER</code>: 0 if no nodes remain after applying the XPath traversal on the document 1 if any nodes remain \n The Examples is: \n The following example tests for the existence of the <code>/Warehouse/Dock</code> node in the XML path of the <code>warehouse_spec</code> column of the sample table <code>oe.warehouses</code>: <code>SELECT warehouse_id, warehouse_name FROM warehouses WHERE EXISTSNODE(warehouse_spec, '/Warehouse/Docks') = 1 ORDER BY warehouse_id; WAREHOUSE_ID WAREHOUSE_NAME ------------ ----------------------------------- 1 Southlake, Texas 2 San Francisco 4 Seattle, Washington </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions057.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "RAWTONHEX",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c RAWTONHEX))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> RAWTONHEX(raw) </eps> \n The Purpose is: \n <code>RAWTONHEX</code> converts <code>raw</code> to a character value containing its hexadecimal representation. <code>RAWTONHEX</code> (<code>raw</code>) is equivalent to <code>TO_NCHAR</code>(<code>RAWTOHEX</code>(<code>raw</code>)). The value returned is always in the national character set. \n The Examples is: \n The following hypothetical example returns the hexadecimal equivalent of a <code>RAW</code> column value: <code>SELECT RAWTONHEX(raw_column), DUMP ( RAWTONHEX (raw_column) ) \"DUMP\" FROM graphics; RAWTONHEX(RA) DUMP ----------------------- ------------------------------ 7D Typ=1 Len=4: 0,55,0,68 </code> See Also: <link>RAWTOHEX&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions143.htm#i78517</link> ",
        "detail": "The Syntax is: \n <eps> RAWTONHEX(raw) </eps> \n The Purpose is: \n <code>RAWTONHEX</code> converts <code>raw</code> to a character value containing its hexadecimal representation. <code>RAWTONHEX</code> (<code>raw</code>) is equivalent to <code>TO_NCHAR</code>(<code>RAWTOHEX</code>(<code>raw</code>)). The value returned is always in the national character set. \n The Examples is: \n The following hypothetical example returns the hexadecimal equivalent of a <code>RAW</code> column value: <code>SELECT RAWTONHEX(raw_column), DUMP ( RAWTONHEX (raw_column) ) \"DUMP\" FROM graphics; RAWTONHEX(RA) DUMP ----------------------- ------------------------------ 7D Typ=1 Len=4: 0,55,0,68 </code> See Also: <link>RAWTOHEX&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions143.htm#i78517</link> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions144.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PERCENT_RANK",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PERCENT_RANK))) (function_argument ( )))",
        "description": "Aggregate The Syntax is: \n percent_rank_aggregate::= <eps> PERCENT_RANK(expr [, expr ]...) WITHIN GROUP (ORDER BY expr [ DESC | ASC ] [NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [NULLS { FIRST | LAST } ] ]... ) </eps> Analytic The Syntax is: \n percent_rank_analytic::= <eps> PERCENT_RANK( ) OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>PERCENT_RANK</code> is similar to the <code>CUME_DIST</code> (cumulative distribution) function. The range of values returned by <code>PERCENT_RANK</code> is 0 to 1, inclusive. The first row in any set has a <code>PERCENT_RANK</code> of 0. The return value is <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion As an aggregate function, <code>PERCENT_RANK</code> calculates, for a hypothetical row <code>r</code> identified by the arguments of the function and a corresponding sort specification, the rank of row <code>r</code> minus 1 divided by the number of rows in the aggregate group. This calculation is made as if the hypothetical row <code>r</code> were inserted into the group of rows over which Oracle Database is to aggregate. The arguments of the function identify a single hypothetical row within each aggregate group. Therefore, they must all evaluate to constant expressions within each aggregate group. The constant argument expressions and the expressions in the <code>ORDER</code> <code>BY</code> clause of the aggregate match by position. Therefore the number of arguments must be the same and their types must be compatible. As an analytic function, for a row <code>r</code>, <code>PERCENT_RANK</code> calculates the rank of <code>r</code> minus 1, divided by 1 less than the number of rows being evaluated (the entire query result set or a partition). Aggregate Example The following example calculates the percent rank of a hypothetical employee in the sample table <code>hr.employees</code> with a salary of $15,500 and a commission of 5%: <code>SELECT PERCENT_RANK(15000, .05) WITHIN GROUP (ORDER BY salary, commission_pct) \"Percent-Rank\" FROM employees; Percent-Rank ------------ .971962617 </code> Analytic Example The following example calculates, for each employee, the percent rank of the employee's salary within the department: <code>SELECT department_id, last_name, salary, PERCENT_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS pr FROM employees ORDER BY pr, salary, last_name; DEPARTMENT_ID LAST_NAME SALARY PR ------------- ------------------------- ---------- ---------- 10 Whalen 4400 0 40 Mavris 6500 0 Grant 7000 0 . . . 80 Vishney 10500 .181818182 80 Zlotkey 10500 .181818182 30 Khoo 3100 .2 . . . 50 Markle 2200 .954545455 50 Philtanker 2200 .954545455 50 Olson 2100 1 . . . </code> ",
        "detail": "Aggregate The Syntax is: \n percent_rank_aggregate::= <eps> PERCENT_RANK(expr [, expr ]...) WITHIN GROUP (ORDER BY expr [ DESC | ASC ] [NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [NULLS { FIRST | LAST } ] ]... ) </eps> Analytic The Syntax is: \n percent_rank_analytic::= <eps> PERCENT_RANK( ) OVER ([ query_partition_clause ] order_by_clause) </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>PERCENT_RANK</code> is similar to the <code>CUME_DIST</code> (cumulative distribution) function. The range of values returned by <code>PERCENT_RANK</code> is 0 to 1, inclusive. The first row in any set has a <code>PERCENT_RANK</code> of 0. The return value is <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion As an aggregate function, <code>PERCENT_RANK</code> calculates, for a hypothetical row <code>r</code> identified by the arguments of the function and a corresponding sort specification, the rank of row <code>r</code> minus 1 divided by the number of rows in the aggregate group. This calculation is made as if the hypothetical row <code>r</code> were inserted into the group of rows over which Oracle Database is to aggregate. The arguments of the function identify a single hypothetical row within each aggregate group. Therefore, they must all evaluate to constant expressions within each aggregate group. The constant argument expressions and the expressions in the <code>ORDER</code> <code>BY</code> clause of the aggregate match by position. Therefore the number of arguments must be the same and their types must be compatible. As an analytic function, for a row <code>r</code>, <code>PERCENT_RANK</code> calculates the rank of <code>r</code> minus 1, divided by 1 less than the number of rows being evaluated (the entire query result set or a partition). Aggregate Example The following example calculates the percent rank of a hypothetical employee in the sample table <code>hr.employees</code> with a salary of $15,500 and a commission of 5%: <code>SELECT PERCENT_RANK(15000, .05) WITHIN GROUP (ORDER BY salary, commission_pct) \"Percent-Rank\" FROM employees; Percent-Rank ------------ .971962617 </code> Analytic Example The following example calculates, for each employee, the percent rank of the employee's salary within the department: <code>SELECT department_id, last_name, salary, PERCENT_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS pr FROM employees ORDER BY pr, salary, last_name; DEPARTMENT_ID LAST_NAME SALARY PR ------------- ------------------------- ---------- ---------- 10 Whalen 4400 0 40 Mavris 6500 0 Grant 7000 0 . . . 80 Vishney 10500 .181818182 80 Zlotkey 10500 .181818182 30 Khoo 3100 .2 . . . 50 Markle 2200 .954545455 50 Philtanker 2200 .954545455 50 Olson 2100 1 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions126.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SCN_TO_TIMESTAMP",
        "tree": "(general_element_part (id_expression (regular_id SCN_TO_TIMESTAMP)) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SCN_TO_TIMESTAMP(number) </eps> \n The Purpose is: \n <code>SCN_TO_TIMESTAMP</code> takes as an argument a number that evaluates to a system change number (SCN), and returns the approximate timestamp associated with that SCN. The returned value is of <code>TIMESTAMP</code> data type. This function is useful any time you want to know the timestamp associated with an SCN. For example, it can be used in conjunction with the <code>ORA_ROWSCN</code> pseudocolumn to associate a timestamp with the most recent change to a row. Notes: The usual precision of the result value is 3 seconds. The association between an SCN and a timestamp when the SCN is generated is remembered by the database for a limited period of time. This period is the maximum of the auto-tuned undo retention period, if the database runs in the Automatic Undo Management mode, and the retention times of all flashback archives in the database, but no less than 120 hours. The time for the association to become obsolete elapses only when the database is open. An error is returned if the SCN specified for the argument to <code>SCN_TO_TIMESTAMP</code> is too old. See Also: <link>ORA_ROWSCN Pseudocolumn&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/pseudocolumns007.htm#BABFAFIC</link> and <link>TIMESTAMP_TO_SCN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions195.htm#BABFJHAD</link> \n The Examples is: \n The following example uses the <code>ORA_ROWSCN</code> pseudocolumn to determine the system change number of the last update to a row and uses <code>SCN_TO_TIMESTAMP</code> to convert that SCN to a timestamp: <code>SELECT SCN_TO_TIMESTAMP(ORA_ROWSCN) FROM employees WHERE employee_id = 188; </code> You could use such a query to convert a system change number to a timestamp for use in an Oracle Flashback Query: <code>SELECT salary FROM employees WHERE employee_id = 188; SALARY ---------- 3800 UPDATE employees SET salary = salary*10 WHERE employee_id = 188; COMMIT; SELECT salary FROM employees WHERE employee_id = 188; SALARY ---------- 38000 </code> <code>SELECT SCN_TO_TIMESTAMP(ORA_ROWSCN) FROM employees WHERE employee_id = 188; SCN_TO_TIMESTAMP(ORA_ROWSCN) --------------------------------------------------------------------------- 28-AUG-03 01.58.01.000000000 PM FLASHBACK TABLE employees TO TIMESTAMP TO_TIMESTAMP('28-AUG-03 01.00.00.000000000 PM'); SELECT salary FROM employees WHERE employee_id = 188; SALARY ---------- 3800 </code> ",
        "detail": "The Syntax is: \n <eps> SCN_TO_TIMESTAMP(number) </eps> \n The Purpose is: \n <code>SCN_TO_TIMESTAMP</code> takes as an argument a number that evaluates to a system change number (SCN), and returns the approximate timestamp associated with that SCN. The returned value is of <code>TIMESTAMP</code> data type. This function is useful any time you want to know the timestamp associated with an SCN. For example, it can be used in conjunction with the <code>ORA_ROWSCN</code> pseudocolumn to associate a timestamp with the most recent change to a row. Notes: The usual precision of the result value is 3 seconds. The association between an SCN and a timestamp when the SCN is generated is remembered by the database for a limited period of time. This period is the maximum of the auto-tuned undo retention period, if the database runs in the Automatic Undo Management mode, and the retention times of all flashback archives in the database, but no less than 120 hours. The time for the association to become obsolete elapses only when the database is open. An error is returned if the SCN specified for the argument to <code>SCN_TO_TIMESTAMP</code> is too old. See Also: <link>ORA_ROWSCN Pseudocolumn&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/pseudocolumns007.htm#BABFAFIC</link> and <link>TIMESTAMP_TO_SCN&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions195.htm#BABFJHAD</link> \n The Examples is: \n The following example uses the <code>ORA_ROWSCN</code> pseudocolumn to determine the system change number of the last update to a row and uses <code>SCN_TO_TIMESTAMP</code> to convert that SCN to a timestamp: <code>SELECT SCN_TO_TIMESTAMP(ORA_ROWSCN) FROM employees WHERE employee_id = 188; </code> You could use such a query to convert a system change number to a timestamp for use in an Oracle Flashback Query: <code>SELECT salary FROM employees WHERE employee_id = 188; SALARY ---------- 3800 UPDATE employees SET salary = salary*10 WHERE employee_id = 188; COMMIT; SELECT salary FROM employees WHERE employee_id = 188; SALARY ---------- 38000 </code> <code>SELECT SCN_TO_TIMESTAMP(ORA_ROWSCN) FROM employees WHERE employee_id = 188; SCN_TO_TIMESTAMP(ORA_ROWSCN) --------------------------------------------------------------------------- 28-AUG-03 01.58.01.000000000 PM FLASHBACK TABLE employees TO TIMESTAMP TO_TIMESTAMP('28-AUG-03 01.00.00.000000000 PM'); SELECT salary FROM employees WHERE employee_id = 188; SALARY ---------- 3800 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions161.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TO_CHAR(character)",
        "tree": "(string_function TO_CHAR ( ))",
        "description": "The Syntax is: \n to_char_char::= <eps> TO_CHAR(nchar | clob | nclob) </eps> \n The Purpose is: \n <code>TO_CHAR</code> (character) converts <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code> data to the database character set. The value returned is always <code>VARCHAR2</code>. When you use this function to convert a character LOB into the database character set, if the LOB value to be converted is larger than the target type, then the database returns an error. \n The Examples is: \n The following example interprets a simple string as character data: <code>SELECT TO_CHAR('01110') FROM DUAL; TO_CH ----- 01110 </code> Compare this example with the first example for <link>TO_CHAR (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm#i79330</link>. The following example converts some <code>CLOB</code> data from the <code>pm.print_media</code> table to the database character set: <code>SELECT TO_CHAR(ad_sourcetext) FROM print_media WHERE product_id = 2268; TO_CHAR(AD_SOURCETEXT) -------------------------------------------------------------------- ****************************** TIGER2 2268...Standard Hayes Compatible Modem Product ID: 2268 The #1 selling modem in the universe! Tiger2's modem includes call management and Internet voicing. Make real-time full duplex phone calls at the same time you're online. ********************************** </code> ",
        "detail": "The Syntax is: \n to_char_char::= <eps> TO_CHAR(nchar | clob | nclob) </eps> \n The Purpose is: \n <code>TO_CHAR</code> (character) converts <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code> data to the database character set. The value returned is always <code>VARCHAR2</code>. When you use this function to convert a character LOB into the database character set, if the LOB value to be converted is larger than the target type, then the database returns an error. \n The Examples is: \n The following example interprets a simple string as character data: <code>SELECT TO_CHAR('01110') FROM DUAL; TO_CH ----- 01110 </code> Compare this example with the first example for <link>TO_CHAR (number)&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions201.htm#i79330</link>. The following example converts some <code>CLOB</code> data from the <code>pm.print_media</code> table to the database character set: <code>SELECT TO_CHAR(ad_sourcetext) FROM print_media WHERE product_id = 2268; TO_CHAR(AD_SOURCETEXT) -------------------------------------------------------------------- ****************************** TIGER2 2268...Standard Hayes Compatible Modem Product ID: 2268 The #1 selling modem in the universe! Tiger2's modem includes call management and Internet voicing. Make real-time full duplex phone calls at the same time you're online. ********************************** </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions199.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LOG",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LOG))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LOG(n2, n1) </eps> \n The Purpose is: \n <code>LOG</code> returns the logarithm, base <code>n2</code>, of <code>n1</code>. The base <code>n1</code> can be any positive value other than 0 or 1 and <code>n2</code> can be any positive value. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the log of 100: <code>SELECT LOG(10,100) \"Log base 10 of 100\" FROM DUAL; Log base 10 of 100 ------------------ 2 </code> ",
        "detail": "The Syntax is: \n <eps> LOG(n2, n1) </eps> \n The Purpose is: \n <code>LOG</code> returns the logarithm, base <code>n2</code>, of <code>n1</code>. The base <code>n1</code> can be any positive value other than 0 or 1 and <code>n2</code> can be any positive value. This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. If any argument is <code>BINARY_FLOAT</code> or <code>BINARY_DOUBLE</code>, then the function returns <code>BINARY_DOUBLE</code>. Otherwise the function returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion \n The Examples is: \n The following example returns the log of 100: <code>SELECT LOG(10,100) \"Log base 10 of 100\" FROM DUAL; Log base 10 of 100 ------------------ 2 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions093.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PERCENTILE_DISC",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PERCENTILE_DISC))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PERCENTILE_DISC(expr) WITHIN GROUP (ORDER BY expr [ DESC | ASC ]) [ OVER (query_partition_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>OVER</code> clause \n The Purpose is: \n <code>PERCENTILE_DISC</code> is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion The first <code>expr</code> must evaluate to a numeric value between 0 and 1, because it is a percentile value. This expression must be constant within each aggregate group. The <code>ORDER</code> <code>BY</code> clause takes a single expression that can be of any type that can be sorted. For a given percentile value <code>P</code>, <code>PERCENTILE_DISC</code> sorts the values of the expression in the <code>ORDER</code> <code>BY</code> clause and returns the value with the smallest <code>CUME_DIST</code> value (with respect to the same sort specification) that is greater than or equal to <code>P</code>. Aggregate Example See aggregate example for <link>PERCENTILE_CONT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions127.htm#i1000909</link>. Analytic Example The following example calculates the median discrete percentile of the salary of each employee in the sample table <code>hr.employees</code>: <code>SELECT last_name, salary, department_id, PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY salary DESC) OVER (PARTITION BY department_id) \"Percentile_Disc\", CUME_DIST() OVER (PARTITION BY department_id ORDER BY salary DESC) \"Cume_Dist\" FROM employees WHERE department_id in (30, 60) ORDER BY last_name, salary, department_id; LAST_NAME SALARY DEPARTMENT_ID Percentile_Disc Cume_Dist ------------------------- ---------- ------------- --------------- ---------- Austin 4800 60 4800 .8 Baida 2900 30 2900 .5 Colmenares 2500 30 2900 1 Ernst 6000 60 4800 .4 Himuro 2600 30 2900 .833333333 Hunold 9000 60 4800 .2 Khoo 3100 30 2900 .333333333 Lorentz 4200 60 4800 1 Pataballa 4800 60 4800 .8 Raphaely 11000 30 2900 .166666667 Tobias 2800 30 2900 .666666667 </code> The median value for Department 30 is 2900, which is the value whose corresponding percentile (<code>Cume_Dist</code>) is the smallest value greater than or equal to 0.5. The median value for Department 60 is 4800, which is the value whose corresponding percentile is the smallest value greater than or equal to 0.5. ",
        "detail": "The Syntax is: \n <eps> PERCENTILE_DISC(expr) WITHIN GROUP (ORDER BY expr [ DESC | ASC ]) [ OVER (query_partition_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>OVER</code> clause \n The Purpose is: \n <code>PERCENTILE_DISC</code> is an inverse distribution function that assumes a discrete distribution model. It takes a percentile value and a sort specification and returns an element from the set. Nulls are ignored in the calculation. This function takes as an argument any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. The function returns the same data type as the numeric data type of the argument. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion The first <code>expr</code> must evaluate to a numeric value between 0 and 1, because it is a percentile value. This expression must be constant within each aggregate group. The <code>ORDER</code> <code>BY</code> clause takes a single expression that can be of any type that can be sorted. For a given percentile value <code>P</code>, <code>PERCENTILE_DISC</code> sorts the values of the expression in the <code>ORDER</code> <code>BY</code> clause and returns the value with the smallest <code>CUME_DIST</code> value (with respect to the same sort specification) that is greater than or equal to <code>P</code>. Aggregate Example See aggregate example for <link>PERCENTILE_CONT&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions127.htm#i1000909</link>. Analytic Example The following example calculates the median discrete percentile of the salary of each employee in the sample table <code>hr.employees</code>: <code>SELECT last_name, salary, department_id, PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY salary DESC) OVER (PARTITION BY department_id) \"Percentile_Disc\", CUME_DIST() OVER (PARTITION BY department_id ORDER BY salary DESC) \"Cume_Dist\" FROM employees WHERE department_id in (30, 60) ORDER BY last_name, salary, department_id; LAST_NAME SALARY DEPARTMENT_ID Percentile_Disc Cume_Dist ------------------------- ---------- ------------- --------------- ---------- Austin 4800 60 4800 .8 Baida 2900 30 2900 .5 Colmenares 2500 30 2900 1 Ernst 6000 60 4800 .4 Himuro 2600 30 2900 .833333333 Hunold 9000 60 4800 .2 Khoo 3100 30 2900 .333333333 Lorentz 4200 60 4800 1 Pataballa 4800 60 4800 .8 Raphaely 11000 30 2900 .166666667 Tobias 2800 30 2900 .666666667 </code> The median value for Department 30 is 2900, which is the value whose corresponding percentile (<code>Cume_Dist</code>) is the smallest value greater than or equal to 0.5. The median value for Department 60 is 4800, which is the value whose corresponding percentile is the smallest value greater than or equal to 0.5. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions128.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LOCALTIMESTAMP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LOCALTIMESTAMP))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LOCALTIMESTAMP [ (timestamp_precision) ] </eps> \n The Purpose is: \n <code>LOCALTIMESTAMP</code> returns the current date and time in the session time zone in a value of data type <code>TIMESTAMP</code>. The difference between this function and <code>CURRENT_TIMESTAMP</code> is that <code>LOCALTIMESTAMP</code> returns a <code>TIMESTAMP</code> value while <code>CURRENT_TIMESTAMP</code> returns a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value. The optional argument <code>timestamp_precision</code> specifies the fractional second precision of the time value returned. See Also: <link>CURRENT_TIMESTAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions045.htm#i999217</link>, <link>\"TIMESTAMP Data Type\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i53219</link>, and <link>\"TIMESTAMP WITH TIME ZONE Data Type\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#CHDIIEID</link> \n The Examples is: \n This example illustrates the difference between <code>LOCALTIMESTAMP</code> and <code>CURRENT_TIMESTAMP</code>: <code>ALTER SESSION SET TIME_ZONE = '-5:00'; SELECT CURRENT_TIMESTAMP, LOCALTIMESTAMP FROM DUAL; CURRENT_TIMESTAMP LOCALTIMESTAMP ------------------------------------------------------------------- 04-APR-00 01.27.18.999220 PM -05:00 04-APR-00 01.27.19 PM ALTER SESSION SET TIME_ZONE = '-8:00'; SELECT CURRENT_TIMESTAMP, LOCALTIMESTAMP FROM DUAL; CURRENT_TIMESTAMP LOCALTIMESTAMP ----------------------------------- ------------------------------ 04-APR-00 10.27.45.132474 AM -08:00 04-APR-00 10.27.451 AM </code> When you use the <code>LOCALTIMESTAMP</code> with a format mask, take care that the format mask matches the value returned by the function. For example, consider the following table: <code>CREATE TABLE local_test (col1 TIMESTAMP WITH LOCAL TIME ZONE); </code> The following statement fails because the mask does not include the <code>TIME</code> <code>ZONE</code> portion of the return type of the function: <code>INSERT INTO local_test VALUES (TO_TIMESTAMP(LOCALTIMESTAMP, 'DD-MON-RR HH.MI.SSXFF')); </code> The following statement uses the correct format mask to match the return type of <code>LOCALTIMESTAMP</code>: <code>INSERT INTO local_test VALUES (TO_TIMESTAMP(LOCALTIMESTAMP, 'DD-MON-RR HH.MI.SSXFF PM')); </code> ",
        "detail": "The Syntax is: \n <eps> LOCALTIMESTAMP [ (timestamp_precision) ] </eps> \n The Purpose is: \n <code>LOCALTIMESTAMP</code> returns the current date and time in the session time zone in a value of data type <code>TIMESTAMP</code>. The difference between this function and <code>CURRENT_TIMESTAMP</code> is that <code>LOCALTIMESTAMP</code> returns a <code>TIMESTAMP</code> value while <code>CURRENT_TIMESTAMP</code> returns a <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code> value. The optional argument <code>timestamp_precision</code> specifies the fractional second precision of the time value returned. See Also: <link>CURRENT_TIMESTAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions045.htm#i999217</link>, <link>\"TIMESTAMP Data Type\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i53219</link>, and <link>\"TIMESTAMP WITH TIME ZONE Data Type\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#CHDIIEID</link> \n The Examples is: \n This example illustrates the difference between <code>LOCALTIMESTAMP</code> and <code>CURRENT_TIMESTAMP</code>: <code>ALTER SESSION SET TIME_ZONE = '-5:00'; SELECT CURRENT_TIMESTAMP, LOCALTIMESTAMP FROM DUAL; CURRENT_TIMESTAMP LOCALTIMESTAMP ------------------------------------------------------------------- 04-APR-00 01.27.18.999220 PM -05:00 04-APR-00 01.27.19 PM ALTER SESSION SET TIME_ZONE = '-8:00'; SELECT CURRENT_TIMESTAMP, LOCALTIMESTAMP FROM DUAL; CURRENT_TIMESTAMP LOCALTIMESTAMP ----------------------------------- ------------------------------ 04-APR-00 10.27.45.132474 AM -08:00 04-APR-00 10.27.451 AM </code> When you use the <code>LOCALTIMESTAMP</code> with a format mask, take care that the format mask matches the value returned by the function. For example, consider the following table: <code>CREATE TABLE local_test (col1 TIMESTAMP WITH LOCAL TIME ZONE); </code> The following statement fails because the mask does not include the <code>TIME</code> <code>ZONE</code> portion of the return type of the function: <code>INSERT INTO local_test VALUES (TO_TIMESTAMP(LOCALTIMESTAMP, 'DD-MON-RR HH.MI.SSXFF')); </code> The following statement uses the correct format mask to match the return type of <code>LOCALTIMESTAMP</code>: <code>INSERT INTO local_test VALUES (TO_TIMESTAMP(LOCALTIMESTAMP, 'DD-MON-RR HH.MI.SSXFF PM')); </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions092.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "INSERTCHILDXML",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c INSERTCHILDXML))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> INSERTCHILDXML ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ]) </eps> \n The Purpose is: \n <code>INSERTCHILDXML</code> inserts a user-supplied value into the target XML at the node indicated by the XPath expression. Compare this function with <link>INSERTXMLBEFORE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions079.htm#CIHICIAF</link>. <code>XMLType_instance</code> is an instance of <code>XMLType</code>. <code>XPath_string</code> is an Xpath expression indicating one or more nodes into which the one or more child nodes are to be inserted. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. <code>child_expr</code> specifies the one or more element or attribute nodes to be inserted. <code>value_expr</code> is an fragment of <code>XMLType</code> that specifies one or more notes being inserted. It must resolve to a string. The optional <code>namespace_string</code> provides namespace information for the <code>XPath_string</code>. This parameter must be of type <code>VARCHAR2</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example adds a second <code>/Owner</code> node to the <code>warehouse_spec</code> of one of the warehouses updated in the example for <link>APPENDCHILDXML&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions012.htm#CIHEGIFE</link>: <code>UPDATE warehouses SET warehouse_spec = INSERTCHILDXML(warehouse_spec, '/Warehouse/Building', 'Owner', XMLType('<Owner>LesserCo</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_spec FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_SPEC ---------------------------------------------------------------------------- <?xml version=\"1.0\"?> <Warehouse> <Building>Rented <Owner>Grandco</Owner> <Owner>LesserCo</Owner> </Building> <Area>85700</Area> <DockType/> <WaterAccess>N</WaterAccess> <RailAccess>N</RailAccess> <Parking>Street</Parking> <VClearance>11.5 ft</VClearance> </Warehouse> </code> ",
        "detail": "The Syntax is: \n <eps> INSERTCHILDXML ( XMLType_instance, XPath_string, child_expr, value_expr [, namespace_string ]) </eps> \n The Purpose is: \n <code>INSERTCHILDXML</code> inserts a user-supplied value into the target XML at the node indicated by the XPath expression. Compare this function with <link>INSERTXMLBEFORE&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions079.htm#CIHICIAF</link>. <code>XMLType_instance</code> is an instance of <code>XMLType</code>. <code>XPath_string</code> is an Xpath expression indicating one or more nodes into which the one or more child nodes are to be inserted. You can specify an absolute <code>XPath_string</code> with an initial slash or a relative <code>XPath_string</code> by omitting the initial slash. If you omit the initial slash, then the context of the relative path defaults to the root node. <code>child_expr</code> specifies the one or more element or attribute nodes to be inserted. <code>value_expr</code> is an fragment of <code>XMLType</code> that specifies one or more notes being inserted. It must resolve to a string. The optional <code>namespace_string</code> provides namespace information for the <code>XPath_string</code>. This parameter must be of type <code>VARCHAR2</code>. See Also: <link>Oracle XML DB Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e23094/xdb04cre.htm#ADXDB0440</link> for more information about this function \n The Examples is: \n The following example adds a second <code>/Owner</code> node to the <code>warehouse_spec</code> of one of the warehouses updated in the example for <link>APPENDCHILDXML&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions012.htm#CIHEGIFE</link>: <code>UPDATE warehouses SET warehouse_spec = INSERTCHILDXML(warehouse_spec, '/Warehouse/Building', 'Owner', XMLType('<Owner>LesserCo</Owner>')) WHERE warehouse_id = 3; SELECT warehouse_spec FROM warehouses WHERE warehouse_id = 3; WAREHOUSE_SPEC ---------------------------------------------------------------------------- <?xml version=\"1.0\"?> <Warehouse> <Building>Rented <Owner>Grandco</Owner> <Owner>LesserCo</Owner> </Building> <Area>85700</Area> <DockType/> <WaterAccess>N</WaterAccess> <RailAccess>N</RailAccess> <Parking>Street</Parking> <VClearance>11.5 ft</VClearance> </Warehouse> </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions075.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "COUNT",
        "tree": "(numeric_function COUNT ( ))",
        "description": "The Syntax is: \n <eps> COUNT({ * | [ DISTINCT | ALL ] expr }) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>COUNT</code> returns the number of rows returned by the query. You can use it as an aggregate or analytic function. If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. If you specify <code>expr</code>, then <code>COUNT</code> returns the number of rows where <code>expr</code> is not null. You can count either all rows, or only distinct values of <code>expr</code>. If you specify the asterisk (*), then this function returns all rows, including duplicates and nulls. <code>COUNT</code> never returns null. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate \n The Examples is: \n The following examples use <code>COUNT</code> as an aggregate function: <code>SELECT COUNT(*) \"Total\" FROM employees; Total ---------- 107 SELECT COUNT(*) \"Allstars\" FROM employees WHERE commission_pct > 0; Allstars --------- 35 SELECT COUNT(commission_pct) \"Count\" FROM employees; Count ---------- 35 SELECT COUNT(DISTINCT manager_id) \"Managers\" FROM employees; Managers ---------- 18 </code> Analytic Example The following example calculates, for each employee in the <code>employees</code> table, the moving count of employees earning salaries in the range 50 less than through 150 greater than the employee's salary. <code>SELECT last_name, salary, COUNT(*) OVER (ORDER BY salary RANGE BETWEEN 50 PRECEDING AND 150 FOLLOWING) AS mov_count FROM employees ORDER BY salary, last_name; LAST_NAME SALARY MOV_COUNT ------------------------- ---------- ---------- Olson 2100 3 Markle 2200 2 Philtanker 2200 2 Gee 2400 8 Landry 2400 8 Colmenares 2500 10 Marlow 2500 10 Patel 2500 10 . . . </code> ",
        "detail": "The Syntax is: \n <eps> COUNT({ * | [ DISTINCT | ALL ] expr }) [ OVER (analytic_clause) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions \n The Purpose is: \n <code>COUNT</code> returns the number of rows returned by the query. You can use it as an aggregate or analytic function. If you specify <code>DISTINCT</code>, then you can specify only the <code>query_partition_clause</code> of the <code>analytic_clause</code>. The <code>order_by_clause</code> and <code>windowing_clause</code> are not allowed. If you specify <code>expr</code>, then <code>COUNT</code> returns the number of rows where <code>expr</code> is not null. You can count either all rows, or only distinct values of <code>expr</code>. If you specify the asterisk (*), then this function returns all rows, including duplicates and nulls. <code>COUNT</code> never returns null. See Also: <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> and <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> Aggregate \n The Examples is: \n The following examples use <code>COUNT</code> as an aggregate function: <code>SELECT COUNT(*) \"Total\" FROM employees; Total ---------- 107 SELECT COUNT(*) \"Allstars\" FROM employees WHERE commission_pct > 0; Allstars --------- 35 SELECT COUNT(commission_pct) \"Count\" FROM employees; Count ---------- 35 SELECT COUNT(DISTINCT manager_id) \"Managers\" FROM employees; Managers ---------- 18 </code> Analytic Example The following example calculates, for each employee in the <code>employees</code> table, the moving count of employees earning salaries in the range 50 less than through 150 greater than the employee's salary. <code>SELECT last_name, salary, COUNT(*) OVER (ORDER BY salary RANGE BETWEEN 50 PRECEDING AND 150 FOLLOWING) AS mov_count FROM employees ORDER BY salary, last_name; LAST_NAME SALARY MOV_COUNT ------------------------- ---------- ---------- Olson 2100 3 Markle 2200 2 Philtanker 2200 2 Gee 2400 8 Landry 2400 8 Colmenares 2500 10 Marlow 2500 10 Patel 2500 10 . . . </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions039.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PATH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PATH))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PATH(correlation_integer) </eps> \n The Purpose is: \n <code>PATH</code> is an ancillary function used only with the <code>UNDER_PATH</code> and <code>EQUALS_PATH</code> conditions. It returns the relative path that leads to the resource specified in the parent condition. The <code>correlation_integer</code> can be any <code>NUMBER</code> integer and is used to correlate this ancillary function with its primary condition. Values less than 1 are treated as 1. See Also: <link>EQUALS_PATH Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions009.htm#i1051094</link> and <link>UNDER_PATH Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions009.htm#i1041646</link> \n The Examples is: \n Refer to the related function <link>DEPTH&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions053.htm#i1150333</link> for an example using both of these ancillary functions of the <code>EQUALS_PATH</code> and <code>UNDER_PATH</code> conditions. ",
        "detail": "The Syntax is: \n <eps> PATH(correlation_integer) </eps> \n The Purpose is: \n <code>PATH</code> is an ancillary function used only with the <code>UNDER_PATH</code> and <code>EQUALS_PATH</code> conditions. It returns the relative path that leads to the resource specified in the parent condition. The <code>correlation_integer</code> can be any <code>NUMBER</code> integer and is used to correlate this ancillary function with its primary condition. Values less than 1 are treated as 1. See Also: <link>EQUALS_PATH Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions009.htm#i1051094</link> and <link>UNDER_PATH Condition&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/conditions009.htm#i1041646</link> \n The Examples is: \n Refer to the related function <link>DEPTH&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions053.htm#i1150333</link> for an example using both of these ancillary functions of the <code>EQUALS_PATH</code> and <code>UNDER_PATH</code> conditions. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions125.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "RAWTOHEX",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c RAWTOHEX))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> RAWTOHEX(raw) </eps> \n The Purpose is: \n <code>RAWTOHEX</code> converts <code>raw</code> to a character value containing its hexadecimal representation. As a SQL built-in function, <code>RAWTOHEX</code> accepts an argument of any scalar data type other than <code>LONG</code>, <code>LONG</code> <code>RAW</code>, <code>CLOB</code>, <code>BLOB</code>, or <code>BFILE</code>. It returns a <code>VARCHAR2</code> value with the hexadecimal representation of bytes that make up the value of <code>raw</code>. Each byte is represented by two hexadecimal digits. Note: <code>RAWTOHEX</code> behaves differently when used as a PL/SQL built-in function. Refer to <link>Oracle Database PL/SQL Language Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/fundamentals.htm#LNPLS00212</link> for more information. \n The Examples is: \n The following hypothetical example returns the hexadecimal equivalent of a <code>RAW</code> column value: <code>SELECT RAWTOHEX(raw_column) \"Graphics\" FROM graphics; Graphics -------- 7D </code> See Also: <link>\"RAW and LONG RAW Data Types\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i46018</link> and <link>HEXTORAW&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions073.htm#i1023950</link> ",
        "detail": "The Syntax is: \n <eps> RAWTOHEX(raw) </eps> \n The Purpose is: \n <code>RAWTOHEX</code> converts <code>raw</code> to a character value containing its hexadecimal representation. As a SQL built-in function, <code>RAWTOHEX</code> accepts an argument of any scalar data type other than <code>LONG</code>, <code>LONG</code> <code>RAW</code>, <code>CLOB</code>, <code>BLOB</code>, or <code>BFILE</code>. It returns a <code>VARCHAR2</code> value with the hexadecimal representation of bytes that make up the value of <code>raw</code>. Each byte is represented by two hexadecimal digits. Note: <code>RAWTOHEX</code> behaves differently when used as a PL/SQL built-in function. Refer to <link>Oracle Database PL/SQL Language Reference&LINK&https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/fundamentals.htm#LNPLS00212</link> for more information. \n The Examples is: \n The following hypothetical example returns the hexadecimal equivalent of a <code>RAW</code> column value: <code>SELECT RAWTOHEX(raw_column) \"Graphics\" FROM graphics; Graphics -------- 7D </code> See Also: <link>\"RAW and LONG RAW Data Types\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i46018</link> and <link>HEXTORAW&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions073.htm#i1023950</link> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions143.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LPAD",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LPAD))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> LPAD(expr1, n [, expr2 ]) </eps> \n The Purpose is: \n <code>LPAD</code> returns <code>expr1</code>, left-padded to length <code>n</code> characters with the sequence of characters in <code>expr2</code>. This function is useful for formatting the output of a query. Both <code>expr1</code> and <code>expr2</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>expr1</code> is a character data type, <code>NVARCHAR2</code> if <code>expr1</code> is a national character data type, and a LOB if <code>expr1</code> is a LOB data type. The string returned is in the same character set as <code>expr1</code>. The argument <code>n</code> must be a <code>NUMBER</code> integer or a value that can be implicitly converted to a <code>NUMBER</code> integer. If you do not specify <code>expr2</code>, then the default is a single blank. If <code>expr1</code> is longer than <code>n</code>, then this function returns the portion of <code>expr1</code> that fits in <code>n</code>. The argument <code>n</code> is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string. \n The Examples is: \n The following example left-pads a string with the asterisk (*) and period (.) characters: <code>SELECT LPAD('Page 1',15,'*.') \"LPAD example\" FROM DUAL; LPAD example --------------- *.*.*.*.*Page 1 </code> ",
        "detail": "The Syntax is: \n <eps> LPAD(expr1, n [, expr2 ]) </eps> \n The Purpose is: \n <code>LPAD</code> returns <code>expr1</code>, left-padded to length <code>n</code> characters with the sequence of characters in <code>expr2</code>. This function is useful for formatting the output of a query. Both <code>expr1</code> and <code>expr2</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>CLOB</code>, or <code>NCLOB</code>. The string returned is of <code>VARCHAR2</code> data type if <code>expr1</code> is a character data type, <code>NVARCHAR2</code> if <code>expr1</code> is a national character data type, and a LOB if <code>expr1</code> is a LOB data type. The string returned is in the same character set as <code>expr1</code>. The argument <code>n</code> must be a <code>NUMBER</code> integer or a value that can be implicitly converted to a <code>NUMBER</code> integer. If you do not specify <code>expr2</code>, then the default is a single blank. If <code>expr1</code> is longer than <code>n</code>, then this function returns the portion of <code>expr1</code> that fits in <code>n</code>. The argument <code>n</code> is the total length of the return value as it is displayed on your terminal screen. In most character sets, this is also the number of characters in the return value. However, in some multibyte character sets, the display length of a character string can differ from the number of characters in the string. \n The Examples is: \n The following example left-pads a string with the asterisk (*) and period (.) characters: <code>SELECT LPAD('Page 1',15,'*.') \"LPAD example\" FROM DUAL; LPAD example --------------- *.*.*.*.*Page 1 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions095.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "SYS_CONNECT_BY_PATH",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c SYS_CONNECT_BY_PATH))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> SYS_CONNECT_BY_PATH(column, char) </eps> \n The Purpose is: \n <code>SYS_CONNECT_BY_PATH</code> is valid only in hierarchical queries. It returns the path of a column value from root to node, with column values separated by <code>char</code> for each row returned by <code>CONNECT</code> <code>BY</code> condition. Both <code>column</code> and <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The string returned is of <code>VARCHAR2</code> data type and is in the same character set as <code>column</code>. See Also: <link>\"Hierarchical Queries\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/queries003.htm#i2053935</link> for more information about hierarchical queries and <code>CONNECT</code> <code>BY</code> conditions \n The Examples is: \n The following example returns the path of employee names from employee <code>Kochhar</code> to all employees of <code>Kochhar</code> (and their employees): <code>SELECT LPAD(' ', 2*level-1)||SYS_CONNECT_BY_PATH(last_name, '/') \"Path\" FROM employees START WITH last_name = 'Kochhar' CONNECT BY PRIOR employee_id = manager_id; Path ------------------------------ /Kochhar/Greenberg/Chen /Kochhar/Greenberg/Faviet /Kochhar/Greenberg/Popp /Kochhar/Greenberg/Sciarra /Kochhar/Greenberg/Urman /Kochhar/Higgins/Gietz /Kochhar/Baer /Kochhar/Greenberg /Kochhar/Higgins /Kochhar/Mavris /Kochhar/Whalen /Kochhar </code> ",
        "detail": "The Syntax is: \n <eps> SYS_CONNECT_BY_PATH(column, char) </eps> \n The Purpose is: \n <code>SYS_CONNECT_BY_PATH</code> is valid only in hierarchical queries. It returns the path of a column value from root to node, with column values separated by <code>char</code> for each row returned by <code>CONNECT</code> <code>BY</code> condition. Both <code>column</code> and <code>char</code> can be any of the data types <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, or <code>NVARCHAR2</code>. The string returned is of <code>VARCHAR2</code> data type and is in the same character set as <code>column</code>. See Also: <link>\"Hierarchical Queries\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/queries003.htm#i2053935</link> for more information about hierarchical queries and <code>CONNECT</code> <code>BY</code> conditions \n The Examples is: \n The following example returns the path of employee names from employee <code>Kochhar</code> to all employees of <code>Kochhar</code> (and their employees): <code>SELECT LPAD(' ', 2*level-1)||SYS_CONNECT_BY_PATH(last_name, '/') \"Path\" FROM employees START WITH last_name = 'Kochhar' CONNECT BY PRIOR employee_id = manager_id; Path ------------------------------ /Kochhar/Greenberg/Chen /Kochhar/Greenberg/Faviet /Kochhar/Greenberg/Popp /Kochhar/Greenberg/Sciarra /Kochhar/Greenberg/Urman /Kochhar/Higgins/Gietz /Kochhar/Baer /Kochhar/Greenberg /Kochhar/Higgins /Kochhar/Mavris /Kochhar/Whalen /Kochhar </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions183.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "PREDICTION_PROBABILITY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c PREDICTION_PROBABILITY))) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> PREDICTION_PROBABILITY ( [ schema . ] model [ , class ] mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with classification models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It is not valid with other types of models. It returns the probability for a given prediction as an Oracle <code>NUMBER</code>. If you specify the optional <code>class</code> parameter, then the function returns the probability for the specified class. This is equivalent to the probability associated with choosing the given target class value. If you omit the <code>class</code> parameter, then the function returns the probability associated with the best prediction. You can use this form in conjunction with the <code>PREDICTION</code> function to obtain the best pair of prediction value and probability. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example returns the 10 customers living in Italy who are most likely to use an affinity card. This example, and the prerequisite data mining operations, including the creation of the view, can be found in the demo files <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT cust_id FROM ( SELECT cust_id FROM mining_data_apply_v WHERE country_name = 'Italy' ORDER BY PREDICTION_PROBABILITY(DT_SH_Clas_sample, 1 USING *) DESC, cust_id) WHERE rownum < 11; CUST_ID ---------- 100081 100179 100185 100324 100344 100554 100662 100733 101250 101306 10 rows selected. </code> ",
        "detail": "The Syntax is: \n <eps> PREDICTION_PROBABILITY ( [ schema . ] model [ , class ] mining_attribute_clause ) </eps> mining_attribute_clause::= <eps> USING { * | { [ schema . ] table . * | expr [ AS alias ] } [, { [ schema . ] table . * | expr [ AS alias ] } ]... } </eps> \n The Purpose is: \n This function is for use with classification models created by the <code>DBMS_DATA_MINING</code> package or with Oracle Data Miner. It is not valid with other types of models. It returns the probability for a given prediction as an Oracle <code>NUMBER</code>. If you specify the optional <code>class</code> parameter, then the function returns the probability for the specified class. This is equivalent to the probability associated with choosing the given target class value. If you omit the <code>class</code> parameter, then the function returns the probability associated with the best prediction. You can use this form in conjunction with the <code>PREDICTION</code> function to obtain the best pair of prediction value and probability. The <code>mining_attribute_clause</code> behaves as described for the <code>PREDICTION</code> function. Refer to <link>mining_attribute_clause&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions132.htm#CJAJACJD</link>. See Also: <link>Oracle Data Mining Concepts&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16808/toc.htm</link> for detailed information about Oracle Data Mining <link>Oracle Data Mining Application Developer's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e12218/models_deploying.htm#DMPRG004</link> for detailed information about scoring with the Data Mining SQL functions Example The following example returns the 10 customers living in Italy who are most likely to use an affinity card. This example, and the prerequisite data mining operations, including the creation of the view, can be found in the demo files <code>$ORACLE_HOME/rdbms/demo/dmdtdemo.sql</code>. General information on data mining demo files is available in <link>Oracle Data Mining Administrator's Guide&LINK&https://docs.oracle.com/cd/E11882_01/datamine.112/e16807/sampleprogs.htm#DMADM009</link>. The example is presented here to illustrate the syntactic use of the function. <code>SELECT cust_id FROM ( SELECT cust_id FROM mining_data_apply_v WHERE country_name = 'Italy' ORDER BY PREDICTION_PROBABILITY(DT_SH_Clas_sample, 1 USING *) DESC, cust_id) WHERE rownum < 11; CUST_ID ---------- 100081 100179 100185 100324 100344 100554 100662 100733 101250 101306 10 rows selected. </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions136.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "LAST",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c LAST))) (function_argument ( )))",
        "description": "The Syntax is: \n last::= <eps> aggregate_function KEEP (DENSE_RANK LAST ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) [ OVER ( [query_partition_clause] ) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>query_partitioning_clause</code> \n The Purpose is: \n <code>FIRST</code> and <code>LAST</code> are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the <code>FIRST</code> or <code>LAST</code> with respect to a given sorting specification. If only one row ranks as <code>FIRST</code> or <code>LAST</code>, then the aggregate operates on the set with only one element. Refer to <link>FIRST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions065.htm#i1000901</link> for complete information on this function and for examples of its use. ",
        "detail": "The Syntax is: \n last::= <eps> aggregate_function KEEP (DENSE_RANK LAST ORDER BY expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] [, expr [ DESC | ASC ] [ NULLS { FIRST | LAST } ] ]... ) [ OVER ( [query_partition_clause] ) ] </eps> See Also: <link>\"Analytic Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions004.htm#i81407</link> for information on syntax, semantics, and restrictions of the <code>query_partitioning_clause</code> \n The Purpose is: \n <code>FIRST</code> and <code>LAST</code> are very similar functions. Both are aggregate and analytic functions that operate on a set of values from a set of rows that rank as the <code>FIRST</code> or <code>LAST</code> with respect to a given sorting specification. If only one row ranks as <code>FIRST</code> or <code>LAST</code>, then the aggregate operates on the set with only one element. Refer to <link>FIRST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions065.htm#i1000901</link> for complete information on this function and for examples of its use. ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions083.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "TIMESTAMP_TO_SCN",
        "tree": "(general_element_part (id_expression (regular_id TIMESTAMP_TO_SCN)) (function_argument ( )))",
        "description": "The Syntax is: \n <eps> TIMESTAMP_TO_SCN(timestamp) </eps> \n The Purpose is: \n <code>TIMESTAMP_TO_SCN</code> takes as an argument a timestamp value and returns the approximate system change number (SCN) associated with that timestamp. The returned value is of data type <code>NUMBER</code>. This function is useful any time you want to know the SCN associated with a particular timestamp. Note: The association between an SCN and a timestamp when the SCN is generated is remembered by the database for a limited period of time. This period is the maximum of the auto-tuned undo retention period, if the database runs in the Automatic Undo Management mode, and the retention times of all flashback archives in the database, but no less than 120 hours. The time for the association to become obsolete elapses only when the database is open. An error is returned if the timestamp specified for the argument to <code>TIMESTAMP_TO_SCN</code> is too old. See Also: <link>SCN_TO_TIMESTAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions161.htm#BABEHBCB</link> for information on converting SCNs to timestamp \n The Examples is: \n The following example inserts a row into the <code>oe.orders</code> table and then uses <code>TIMESTAMP_TO_SCN</code> to determine the system change number of the insert operation. (The actual SCN returned will differ on each system.) <code>INSERT INTO orders (order_id, order_date, customer_id, order_total) VALUES (5000, SYSTIMESTAMP, 188, 2345); 1 row created. COMMIT; Commit complete. SELECT TIMESTAMP_TO_SCN(order_date) FROM orders WHERE order_id = 5000; TIMESTAMP_TO_SCN(ORDER_DATE) ---------------------------- 574100 </code> ",
        "detail": "The Syntax is: \n <eps> TIMESTAMP_TO_SCN(timestamp) </eps> \n The Purpose is: \n <code>TIMESTAMP_TO_SCN</code> takes as an argument a timestamp value and returns the approximate system change number (SCN) associated with that timestamp. The returned value is of data type <code>NUMBER</code>. This function is useful any time you want to know the SCN associated with a particular timestamp. Note: The association between an SCN and a timestamp when the SCN is generated is remembered by the database for a limited period of time. This period is the maximum of the auto-tuned undo retention period, if the database runs in the Automatic Undo Management mode, and the retention times of all flashback archives in the database, but no less than 120 hours. The time for the association to become obsolete elapses only when the database is open. An error is returned if the timestamp specified for the argument to <code>TIMESTAMP_TO_SCN</code> is too old. See Also: <link>SCN_TO_TIMESTAMP&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions161.htm#BABEHBCB</link> for information on converting SCNs to timestamp \n The Examples is: \n The following example inserts a row into the <code>oe.orders</code> table and then uses <code>TIMESTAMP_TO_SCN</code> to determine the system change number of the insert operation. (The actual SCN returned will differ on each system.) <code>INSERT INTO orders (order_id, order_date, customer_id, order_total) VALUES (5000, SYSTIMESTAMP, 188, 2345); 1 row created. COMMIT; Commit complete. SELECT TIMESTAMP_TO_SCN(order_date) FROM orders WHERE order_id = 5000; TIMESTAMP_TO_SCN(ORDER_DATE) ---------------------------- 574100 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions195.htm"
        ]
    },
    {
        "type": "function",
        "keyword": "CORR_S",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CORR_S))) (function_argument ( )))",
        "description": "The Syntax is:\nCORR_S (expr1, expr2 [, { COEFFICIENT | ONE_SIDED_SIG | ONE_SIDED_SIG_POS | ONE_SIDED_SIG_NEG | TWO_SIDED_SIG } ] )\nThe Purpose is:\nThe <code>CORR</code> function (see <link>CORR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions035.htm#i82637</link>) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The <code>CORR_</code>* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship. These functions takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence <code>expr1</code> and <code>expr2</code> are the two variables being analyzed. The third argument is a return value of type <code>VARCHAR2</code>. If you omit the third argument, then the default is <code>COEFFICIENT</code>. The meaning of the return values is shown in the table that follows: Table 5-2 CORR_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>COEFFICIENT</code> </td> <td> Coefficient of correlation </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> Positive one-tailed significance of the correlation </td> </tr> <tr> <td> <code>ONE_SIDED_SIG_POS</code> </td> <td> Same as <code>ONE_SIDED_SIG</code> </td> </tr> <tr> <td> <code>ONE_SIDED_SIG_NEG</code> </td> <td> Negative one-tailed significance of the correlation </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of the correlation </td> </tr> </tbody>\n<code>CORR_S</code> calculates the Spearman's rho correlation coefficient. The input expressions should be a set of (xi, yi) pairs of observations. The function first replaces each value with a rank. Each value of xi is replaced with its rank among all the other xis in the sample, and each value of yi is replaced with its rank among all the other yis. Thus, each xi and yi take on a value from 1 to <code>n</code>, where <code>n</code> is the total number of pairs of values. Ties are assigned the average of the ranks they would have had if their values had been slightly different. Then the function calculates the linear correlation coefficient of the ranks.\nThe Examples is:\nUsing Spearman's rho correlation coefficient. The following example derives a coefficient of correlation for each of two different comparisons -- <code>salary</code> and <code>commission_pct</code>, and <code>salary</code> and <code>employee_id</code>: <code>SELECT COUNT(*) count, CORR_S(salary, commission_pct) commission, CORR_S(salary, employee_id) empid FROM employees; COUNT COMMISSION EMPID ---------- ---------- ---------- 107 .735837022 -.04473016 </code>",
        "detail": "The Syntax is:\nCORR_S (expr1, expr2 [, { COEFFICIENT | ONE_SIDED_SIG | ONE_SIDED_SIG_POS | ONE_SIDED_SIG_NEG | TWO_SIDED_SIG } ] )\nThe Purpose is:\nThe <code>CORR</code> function (see <link>CORR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions035.htm#i82637</link>) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The <code>CORR_</code>* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship. These functions takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence <code>expr1</code> and <code>expr2</code> are the two variables being analyzed. The third argument is a return value of type <code>VARCHAR2</code>. If you omit the third argument, then the default is <code>COEFFICIENT</code>. The meaning of the return values is shown in the table that follows: Table 5-2 CORR_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>COEFFICIENT</code> </td> <td> Coefficient of correlation </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> Positive one-tailed significance of the correlation </td> </tr> <tr> <td> <code>ONE_SIDED_SIG_POS</code> </td> <td> Same as <code>ONE_SIDED_SIG</code> </td> </tr> <tr> <td> <code>ONE_SIDED_SIG_NEG</code> </td> <td> Negative one-tailed significance of the correlation </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of the correlation </td> </tr> </tbody>\n<code>CORR_S</code> calculates the Spearman's rho correlation coefficient. The input expressions should be a set of (xi, yi) pairs of observations. The function first replaces each value with a rank. Each value of xi is replaced with its rank among all the other xis in the sample, and each value of yi is replaced with its rank among all the other yis. Thus, each xi and yi take on a value from 1 to <code>n</code>, where <code>n</code> is the total number of pairs of values. Ties are assigned the average of the ranks they would have had if their values had been slightly different. Then the function calculates the linear correlation coefficient of the ranks.\nThe Examples is:\nUsing Spearman's rho correlation coefficient. The following example derives a coefficient of correlation for each of two different comparisons -- <code>salary</code> and <code>commission_pct</code>, and <code>salary</code> and <code>employee_id</code>: <code>SELECT COUNT(*) count, CORR_S(salary, commission_pct) commission, CORR_S(salary, employee_id) empid FROM employees; COUNT COMMISSION EMPID ---------- ---------- ---------- 107 .735837022 -.04473016 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions036.htm#SQLRF06314"
        ]
    },
    {
        "type": "function",
        "keyword": "CORR_K",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c CORR_K))) (function_argument ( )))",
        "description": "The Syntax is:\nCORR_K (expr1, expr2 [, { COEFFICIENT | ONE_SIDED_SIG | ONE_SIDED_SIG_POS | ONE_SIDED_SIG_NEG | TWO_SIDED_SIG } ] )\nThe Purpose is:\nThe <code>CORR</code> function (see <link>CORR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions035.htm#i82637</link>) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The <code>CORR_</code>* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship. These functions takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence <code>expr1</code> and <code>expr2</code> are the two variables being analyzed. The third argument is a return value of type <code>VARCHAR2</code>. If you omit the third argument, then the default is <code>COEFFICIENT</code>. The meaning of the return values is shown in the table that follows: Table 5-2 CORR_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>COEFFICIENT</code> </td> <td> Coefficient of correlation </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> Positive one-tailed significance of the correlation </td> </tr> <tr> <td> <code>ONE_SIDED_SIG_POS</code> </td> <td> Same as <code>ONE_SIDED_SIG</code> </td> </tr> <tr> <td> <code>ONE_SIDED_SIG_NEG</code> </td> <td> Negative one-tailed significance of the correlation </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of the correlation </td> </tr> </tbody>\n<code>CORR_K</code> calculates the Kendall's tau-b correlation coefficient. As for <code>CORR_S</code>, the input expressions are a set of (xi, yi) pairs of observations. To calculate the coefficient, the function counts the number of concordant and discordant pairs. A pair of observations is concordant if the observation with the larger x also has a larger value of y. A pair of observations is discordant if the observation with the larger x has a smaller y. The significance of tau-b is the probability that the correlation indicated by tau-b was due to chance\u9225\u6501 value of 0 to 1. A small value indicates a significant correlation for positive values of tau-b (or anticorrelation for negative values of tau-b).\nThe Examples is:\nUsing Kendall's tau-b correlation coefficient. The following example determines whether a correlation exists between an employee's salary and commission percent: <code>SELECT CORR_K(salary, commission_pct, 'COEFFICIENT') coefficient, CORR_K(salary, commission_pct, 'TWO_SIDED_SIG') two_sided_p_value FROM employees; COEFFICIENT TWO_SIDED_P_VALUE ----------- ----------------- .603079768 3.4702E-07 </code>",
        "detail": "The Syntax is:\nCORR_K (expr1, expr2 [, { COEFFICIENT | ONE_SIDED_SIG | ONE_SIDED_SIG_POS | ONE_SIDED_SIG_NEG | TWO_SIDED_SIG } ] )\nThe Purpose is:\nThe <code>CORR</code> function (see <link>CORR&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions035.htm#i82637</link>) calculates the Pearson's correlation coefficient and requires numeric expressions as input. The <code>CORR_</code>* functions support nonparametric or rank correlation. They let you find correlations between expressions that are ordinal scaled (where ranking of the values is possible). Correlation coefficients take on a value ranging from -1 to 1, where 1 indicates a perfect relationship, -1 a perfect inverse relationship (when one variable increases as the other decreases), and a value close to 0 means no relationship. These functions takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle Database determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, makes the calculation, and returns <code>NUMBER</code>. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence <code>expr1</code> and <code>expr2</code> are the two variables being analyzed. The third argument is a return value of type <code>VARCHAR2</code>. If you omit the third argument, then the default is <code>COEFFICIENT</code>. The meaning of the return values is shown in the table that follows: Table 5-2 CORR_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>COEFFICIENT</code> </td> <td> Coefficient of correlation </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> Positive one-tailed significance of the correlation </td> </tr> <tr> <td> <code>ONE_SIDED_SIG_POS</code> </td> <td> Same as <code>ONE_SIDED_SIG</code> </td> </tr> <tr> <td> <code>ONE_SIDED_SIG_NEG</code> </td> <td> Negative one-tailed significance of the correlation </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of the correlation </td> </tr> </tbody>\n<code>CORR_K</code> calculates the Kendall's tau-b correlation coefficient. As for <code>CORR_S</code>, the input expressions are a set of (xi, yi) pairs of observations. To calculate the coefficient, the function counts the number of concordant and discordant pairs. A pair of observations is concordant if the observation with the larger x also has a larger value of y. A pair of observations is discordant if the observation with the larger x has a smaller y. The significance of tau-b is the probability that the correlation indicated by tau-b was due to chance\u9225\u6501 value of 0 to 1. A small value indicates a significant correlation for positive values of tau-b (or anticorrelation for negative values of tau-b).\nThe Examples is:\nUsing Kendall's tau-b correlation coefficient. The following example determines whether a correlation exists between an employee's salary and commission percent: <code>SELECT CORR_K(salary, commission_pct, 'COEFFICIENT') coefficient, CORR_K(salary, commission_pct, 'TWO_SIDED_SIG') two_sided_p_value FROM employees; COEFFICIENT TWO_SIDED_P_VALUE ----------- ----------------- .603079768 3.4702E-07 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions036.htm#SQLRF06314"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_T_TEST_ONE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_T_TEST_ONE))) (function_argument ( )))",
        "description": "The Syntax is:\nSTATS_T_TEST_ONE ( expr1 [, expr2 ] ( expr1, expr2 } } [, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )\nThe Purpose is:\n<code>STATS_T_TEST_ONE</code>: A one-sample t-test.\nThe t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample <code>STATS_T_TEST_</code>* functions take three arguments: two expressions and a return value of type <code>VARCHAR2</code>. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-9&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#g1514103</link>. Table 5-9 STATS_T_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>STATISTIC</code> </td> <td> The observed value of t </td> </tr> <tr> <td> <code>DF</code> </td> <td> Degree of freedom </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> One-tailed significance of t </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of t </td> </tr> </tbody> </table> The two independent <code>STATS_T_TEST_</code>* functions can take a fourth argument (<code>expr3</code>) if the third argument is specified as <code>STATISTIC</code> or <code>ONE_SIDED_SIG</code>. In this case, <code>expr3</code> indicates which value of <code>expr1</code> is the high value, or the value whose rejection region is the upper tail. The significance of the observed value of t is the probability that the value of t would have been obtained by chance\u9225\u6501 number between 0 and 1. The smaller the value, the more significant the difference between the means. One-sided significance is always respect to the upper tail. For one-sample and paired t-test, the high value is the first expression. For independent t-test, the high value is the one specified by <code>expr3</code>. The degree of freedom depends on the type of t-test that resulted in the observed value of t. For example, for a one-sample t-test (<code>STATS_T_TEST_ONE</code>), the degree of freedom is the number of observations in the sample minus 1.\nIn the <code>STATS_T_TEST_ONE</code> function, <code>expr1</code> is the sample and <code>expr2</code> is the constant mean against which the sample mean is compared. For this t-test only, <code>expr2</code> is optional; the constant mean defaults to 0. This function obtains the value of t by dividing the difference between the sample mean and the known mean by the standard error of the mean (rather than the standard error of the difference of the means, as for <code>STATS_T_TEST_PAIRED</code>).\nThe Examples is:\nThe following example determines the significance of the difference between the average list price and the constant value 60: <code>SELECT AVG(prod_list_price) group_mean, STATS_T_TEST_ONE(prod_list_price, 60, 'STATISTIC') t_observed, STATS_T_TEST_ONE(prod_list_price, 60) two_sided_p_value FROM sh.products; GROUP_MEAN T_OBSERVED TWO_SIDED_P_VALUE ---------- ---------- ----------------- 139.545556 2.32107746 .023158537 </code> ",
        "detail": "The Syntax is:\nSTATS_T_TEST_ONE ( expr1 [, expr2 ] ( expr1, expr2 } } [, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )\nThe Purpose is:\n<code>STATS_T_TEST_ONE</code>: A one-sample t-test.\nThe t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample <code>STATS_T_TEST_</code>* functions take three arguments: two expressions and a return value of type <code>VARCHAR2</code>. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-9&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#g1514103</link>. Table 5-9 STATS_T_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>STATISTIC</code> </td> <td> The observed value of t </td> </tr> <tr> <td> <code>DF</code> </td> <td> Degree of freedom </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> One-tailed significance of t </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of t </td> </tr> </tbody> </table> The two independent <code>STATS_T_TEST_</code>* functions can take a fourth argument (<code>expr3</code>) if the third argument is specified as <code>STATISTIC</code> or <code>ONE_SIDED_SIG</code>. In this case, <code>expr3</code> indicates which value of <code>expr1</code> is the high value, or the value whose rejection region is the upper tail. The significance of the observed value of t is the probability that the value of t would have been obtained by chance\u9225\u6501 number between 0 and 1. The smaller the value, the more significant the difference between the means. One-sided significance is always respect to the upper tail. For one-sample and paired t-test, the high value is the first expression. For independent t-test, the high value is the one specified by <code>expr3</code>. The degree of freedom depends on the type of t-test that resulted in the observed value of t. For example, for a one-sample t-test (<code>STATS_T_TEST_ONE</code>), the degree of freedom is the number of observations in the sample minus 1.\nIn the <code>STATS_T_TEST_ONE</code> function, <code>expr1</code> is the sample and <code>expr2</code> is the constant mean against which the sample mean is compared. For this t-test only, <code>expr2</code> is optional; the constant mean defaults to 0. This function obtains the value of t by dividing the difference between the sample mean and the known mean by the standard error of the mean (rather than the standard error of the difference of the means, as for <code>STATS_T_TEST_PAIRED</code>).\nThe Examples is:\nThe following example determines the significance of the difference between the average list price and the constant value 60: <code>SELECT AVG(prod_list_price) group_mean, STATS_T_TEST_ONE(prod_list_price, 60, 'STATISTIC') t_observed, STATS_T_TEST_ONE(prod_list_price, 60) two_sided_p_value FROM sh.products; GROUP_MEAN T_OBSERVED TWO_SIDED_P_VALUE ---------- ---------- ----------------- 139.545556 2.32107746 .023158537 </code> ",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#SQLRF51788"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_T_TEST_PAIRED",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_T_TEST_PAIRED))) (function_argument ( )))",
        "description": "The Syntax is:\nSTATS_T_TEST_PAIRED ( expr1, expr2 [, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )\nThe Purpose is:\n<code>STATS_T_TEST_PAIRED</code>: A two-sample, paired t-test (also known as a crossed t-test).\nThe t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample <code>STATS_T_TEST_</code>* functions take three arguments: two expressions and a return value of type <code>VARCHAR2</code>. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-9&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#g1514103</link>. Table 5-9 STATS_T_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>STATISTIC</code> </td> <td> The observed value of t </td> </tr> <tr> <td> <code>DF</code> </td> <td> Degree of freedom </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> One-tailed significance of t </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of t </td> </tr> </tbody> </table> The two independent <code>STATS_T_TEST_</code>* functions can take a fourth argument (<code>expr3</code>) if the third argument is specified as <code>STATISTIC</code> or <code>ONE_SIDED_SIG</code>. In this case, <code>expr3</code> indicates which value of <code>expr1</code> is the high value, or the value whose rejection region is the upper tail. The significance of the observed value of t is the probability that the value of t would have been obtained by chance\u9225\u6501 number between 0 and 1. The smaller the value, the more significant the difference between the means. One-sided significance is always respect to the upper tail. For one-sample and paired t-test, the high value is the first expression. For independent t-test, the high value is the one specified by <code>expr3</code>. The degree of freedom depends on the type of t-test that resulted in the observed value of t. For example, for a one-sample t-test (<code>STATS_T_TEST_ONE</code>), the degree of freedom is the number of observations in the sample minus 1.\nIn the <code>STATS_T_TEST_PAIRED</code> function, <code>expr1</code> and <code>expr2</code> are the two samples whose means are being compared. This function obtains the value of t by dividing the difference between the sample means by the standard error of the difference of the means (rather than the standard error of the mean, as for <code>STATS_T_TEST_ONE</code>).",
        "detail": "The Syntax is:\nSTATS_T_TEST_PAIRED ( expr1, expr2 [, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )\nThe Purpose is:\n<code>STATS_T_TEST_PAIRED</code>: A two-sample, paired t-test (also known as a crossed t-test).\nThe t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample <code>STATS_T_TEST_</code>* functions take three arguments: two expressions and a return value of type <code>VARCHAR2</code>. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-9&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#g1514103</link>. Table 5-9 STATS_T_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>STATISTIC</code> </td> <td> The observed value of t </td> </tr> <tr> <td> <code>DF</code> </td> <td> Degree of freedom </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> One-tailed significance of t </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of t </td> </tr> </tbody> </table> The two independent <code>STATS_T_TEST_</code>* functions can take a fourth argument (<code>expr3</code>) if the third argument is specified as <code>STATISTIC</code> or <code>ONE_SIDED_SIG</code>. In this case, <code>expr3</code> indicates which value of <code>expr1</code> is the high value, or the value whose rejection region is the upper tail. The significance of the observed value of t is the probability that the value of t would have been obtained by chance\u9225\u6501 number between 0 and 1. The smaller the value, the more significant the difference between the means. One-sided significance is always respect to the upper tail. For one-sample and paired t-test, the high value is the first expression. For independent t-test, the high value is the one specified by <code>expr3</code>. The degree of freedom depends on the type of t-test that resulted in the observed value of t. For example, for a one-sample t-test (<code>STATS_T_TEST_ONE</code>), the degree of freedom is the number of observations in the sample minus 1.\nIn the <code>STATS_T_TEST_PAIRED</code> function, <code>expr1</code> and <code>expr2</code> are the two samples whose means are being compared. This function obtains the value of t by dividing the difference between the sample means by the standard error of the difference of the means (rather than the standard error of the mean, as for <code>STATS_T_TEST_ONE</code>).",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#SQLRF51788"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_T_TEST_INDEP",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_T_TEST_INDEP))) (function_argument ( )))",
        "description": "The Syntax is:\nSTATS_T_TEST_INDEP ( expr1, expr2 [, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )\nThe Purpose is:\n<code>STATS_T_TEST_INDEP</code>: A t-test of two independent groups with the same variance (pooled variances).\nThe t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample <code>STATS_T_TEST_</code>* functions take three arguments: two expressions and a return value of type <code>VARCHAR2</code>. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-9&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#g1514103</link>. Table 5-9 STATS_T_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>STATISTIC</code> </td> <td> The observed value of t </td> </tr> <tr> <td> <code>DF</code> </td> <td> Degree of freedom </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> One-tailed significance of t </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of t </td> </tr> </tbody> </table> The two independent <code>STATS_T_TEST_</code>* functions can take a fourth argument (<code>expr3</code>) if the third argument is specified as <code>STATISTIC</code> or <code>ONE_SIDED_SIG</code>. In this case, <code>expr3</code> indicates which value of <code>expr1</code> is the high value, or the value whose rejection region is the upper tail. The significance of the observed value of t is the probability that the value of t would have been obtained by chance\u9225\u6501 number between 0 and 1. The smaller the value, the more significant the difference between the means. One-sided significance is always respect to the upper tail. For one-sample and paired t-test, the high value is the first expression. For independent t-test, the high value is the one specified by <code>expr3</code>. The degree of freedom depends on the type of t-test that resulted in the observed value of t. For example, for a one-sample t-test (<code>STATS_T_TEST_ONE</code>), the degree of freedom is the number of observations in the sample minus 1.\nIn the <code>STATS_T_TEST_INDEP</code> and <code>STATS_T_TEST_INDEPU</code> functions, <code>expr1</code> is the grouping column and <code>expr2</code> is the sample of values. The pooled variances version (<code>STATS_T_TEST_INDEP</code>) tests whether the means are the same or different for two distributions that have similar variances. The unpooled variances version (<code>STATS_T_TEST_INDEPU</code>) tests whether the means are the same or different even if the two distributions are known to have significantly different variances. Before using these functions, it is advisable to determine whether the variances of the samples are significantly different. If they are, then the data may come from distributions with different shapes, and the difference of the means may not be very useful. You can perform an f-test to determine the difference of the variances. If they are not significantly different, use <code>STATS_T_TEST_INDEP</code>. If they are significantly different, use <code>STATS_T_TEST_INDEPU</code>. Refer to <link>STATS_F_TEST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm#i1279901</link> for information on performing an f-test.\nThe Examples is:\nThe following example determines the significance of the difference between the average sales to men and women where the distributions are assumed to have similar (pooled) variances: <code>SELECT SUBSTR(cust_income_level, 1, 22) income_level, AVG(DECODE(cust_gender, 'M', amount_sold, null)) sold_to_men, AVG(DECODE(cust_gender, 'F', amount_sold, null)) sold_to_women, STATS_T_TEST_INDEP(cust_gender, amount_sold, 'STATISTIC', 'F') t_observed, STATS_T_TEST_INDEP(cust_gender, amount_sold) two_sided_p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id GROUP BY ROLLUP(cust_income_level) ORDER BY income_level, sold_to_men, sold_to_women, t_observed; INCOME_LEVEL SOLD_TO_MEN SOLD_TO_WOMEN T_OBSERVED TWO_SIDED_P_VALUE ---------------------- ----------- ------------- ---------- ----------------- A: Below 30,000 105.28349 99.4281447 -1.9880629 .046811482 B: 30,000 - 49,999 102.59651 109.829642 3.04330875 .002341053 C: 50,000 - 69,999 105.627588 110.127931 2.36148671 .018204221 D: 70,000 - 89,999 106.630299 110.47287 2.28496443 .022316997 E: 90,000 - 109,999 103.396741 101.610416 -1.2544577 .209677823 F: 110,000 - 129,999 106.76476 105.981312 -.60444998 .545545304 G: 130,000 - 149,999 108.877532 107.31377 -.85298245 .393671218 H: 150,000 - 169,999 110.987258 107.152191 -1.9062363 .056622983 I: 170,000 - 189,999 102.808238 107.43556 2.18477851 .028908566 J: 190,000 - 249,999 108.040564 115.343356 2.58313425 .009794516 K: 250,000 - 299,999 112.377993 108.196097 -1.4107871 .158316973 L: 300,000 and above 120.970235 112.216342 -2.0642868 .039003862 107.121845 113.80441 .686144393 .492670059 106.663769 107.276386 1.08013499 .280082357 14 rows selected. </code>",
        "detail": "The Syntax is:\nSTATS_T_TEST_INDEP ( expr1, expr2 [, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )\nThe Purpose is:\n<code>STATS_T_TEST_INDEP</code>: A t-test of two independent groups with the same variance (pooled variances).\nThe t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample <code>STATS_T_TEST_</code>* functions take three arguments: two expressions and a return value of type <code>VARCHAR2</code>. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-9&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#g1514103</link>. Table 5-9 STATS_T_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>STATISTIC</code> </td> <td> The observed value of t </td> </tr> <tr> <td> <code>DF</code> </td> <td> Degree of freedom </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> One-tailed significance of t </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of t </td> </tr> </tbody> </table> The two independent <code>STATS_T_TEST_</code>* functions can take a fourth argument (<code>expr3</code>) if the third argument is specified as <code>STATISTIC</code> or <code>ONE_SIDED_SIG</code>. In this case, <code>expr3</code> indicates which value of <code>expr1</code> is the high value, or the value whose rejection region is the upper tail. The significance of the observed value of t is the probability that the value of t would have been obtained by chance\u9225\u6501 number between 0 and 1. The smaller the value, the more significant the difference between the means. One-sided significance is always respect to the upper tail. For one-sample and paired t-test, the high value is the first expression. For independent t-test, the high value is the one specified by <code>expr3</code>. The degree of freedom depends on the type of t-test that resulted in the observed value of t. For example, for a one-sample t-test (<code>STATS_T_TEST_ONE</code>), the degree of freedom is the number of observations in the sample minus 1.\nIn the <code>STATS_T_TEST_INDEP</code> and <code>STATS_T_TEST_INDEPU</code> functions, <code>expr1</code> is the grouping column and <code>expr2</code> is the sample of values. The pooled variances version (<code>STATS_T_TEST_INDEP</code>) tests whether the means are the same or different for two distributions that have similar variances. The unpooled variances version (<code>STATS_T_TEST_INDEPU</code>) tests whether the means are the same or different even if the two distributions are known to have significantly different variances. Before using these functions, it is advisable to determine whether the variances of the samples are significantly different. If they are, then the data may come from distributions with different shapes, and the difference of the means may not be very useful. You can perform an f-test to determine the difference of the variances. If they are not significantly different, use <code>STATS_T_TEST_INDEP</code>. If they are significantly different, use <code>STATS_T_TEST_INDEPU</code>. Refer to <link>STATS_F_TEST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm#i1279901</link> for information on performing an f-test.\nThe Examples is:\nThe following example determines the significance of the difference between the average sales to men and women where the distributions are assumed to have similar (pooled) variances: <code>SELECT SUBSTR(cust_income_level, 1, 22) income_level, AVG(DECODE(cust_gender, 'M', amount_sold, null)) sold_to_men, AVG(DECODE(cust_gender, 'F', amount_sold, null)) sold_to_women, STATS_T_TEST_INDEP(cust_gender, amount_sold, 'STATISTIC', 'F') t_observed, STATS_T_TEST_INDEP(cust_gender, amount_sold) two_sided_p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id GROUP BY ROLLUP(cust_income_level) ORDER BY income_level, sold_to_men, sold_to_women, t_observed; INCOME_LEVEL SOLD_TO_MEN SOLD_TO_WOMEN T_OBSERVED TWO_SIDED_P_VALUE ---------------------- ----------- ------------- ---------- ----------------- A: Below 30,000 105.28349 99.4281447 -1.9880629 .046811482 B: 30,000 - 49,999 102.59651 109.829642 3.04330875 .002341053 C: 50,000 - 69,999 105.627588 110.127931 2.36148671 .018204221 D: 70,000 - 89,999 106.630299 110.47287 2.28496443 .022316997 E: 90,000 - 109,999 103.396741 101.610416 -1.2544577 .209677823 F: 110,000 - 129,999 106.76476 105.981312 -.60444998 .545545304 G: 130,000 - 149,999 108.877532 107.31377 -.85298245 .393671218 H: 150,000 - 169,999 110.987258 107.152191 -1.9062363 .056622983 I: 170,000 - 189,999 102.808238 107.43556 2.18477851 .028908566 J: 190,000 - 249,999 108.040564 115.343356 2.58313425 .009794516 K: 250,000 - 299,999 112.377993 108.196097 -1.4107871 .158316973 L: 300,000 and above 120.970235 112.216342 -2.0642868 .039003862 107.121845 113.80441 .686144393 .492670059 106.663769 107.276386 1.08013499 .280082357 14 rows selected. </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#SQLRF51788"
        ]
    },
    {
        "type": "function",
        "keyword": "STATS_T_TEST_INDEPU",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c STATS_T_TEST_INDEPU))) (function_argument ( )))",
        "description": "The Syntax is:\nSTATS_T_TEST_INDEPU ( expr1, expr2 [, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )\nThe Purpose is:\n<code>STATS_T_TEST_INDEPU</code>: A t-test of two independent groups with unequal variance (unpooled variances).\nThe t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample <code>STATS_T_TEST_</code>* functions take three arguments: two expressions and a return value of type <code>VARCHAR2</code>. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-9&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#g1514103</link>. Table 5-9 STATS_T_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>STATISTIC</code> </td> <td> The observed value of t </td> </tr> <tr> <td> <code>DF</code> </td> <td> Degree of freedom </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> One-tailed significance of t </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of t </td> </tr> </tbody> </table> The two independent <code>STATS_T_TEST_</code>* functions can take a fourth argument (<code>expr3</code>) if the third argument is specified as <code>STATISTIC</code> or <code>ONE_SIDED_SIG</code>. In this case, <code>expr3</code> indicates which value of <code>expr1</code> is the high value, or the value whose rejection region is the upper tail. The significance of the observed value of t is the probability that the value of t would have been obtained by chance\u9225\u6501 number between 0 and 1. The smaller the value, the more significant the difference between the means. One-sided significance is always respect to the upper tail. For one-sample and paired t-test, the high value is the first expression. For independent t-test, the high value is the one specified by <code>expr3</code>. The degree of freedom depends on the type of t-test that resulted in the observed value of t. For example, for a one-sample t-test (<code>STATS_T_TEST_ONE</code>), the degree of freedom is the number of observations in the sample minus 1.\nIn the <code>STATS_T_TEST_INDEP</code> and <code>STATS_T_TEST_INDEPU</code> functions, <code>expr1</code> is the grouping column and <code>expr2</code> is the sample of values. The pooled variances version (<code>STATS_T_TEST_INDEP</code>) tests whether the means are the same or different for two distributions that have similar variances. The unpooled variances version (<code>STATS_T_TEST_INDEPU</code>) tests whether the means are the same or different even if the two distributions are known to have significantly different variances. Before using these functions, it is advisable to determine whether the variances of the samples are significantly different. If they are, then the data may come from distributions with different shapes, and the difference of the means may not be very useful. You can perform an f-test to determine the difference of the variances. If they are not significantly different, use <code>STATS_T_TEST_INDEP</code>. If they are significantly different, use <code>STATS_T_TEST_INDEPU</code>. Refer to <link>STATS_F_TEST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm#i1279901</link> for information on performing an f-test.\nThe Examples is:\nThe following example determines the significance of the difference between the average sales to men and women where the distributions are known to have significantly different (unpooled) variances: <code>SELECT SUBSTR(cust_income_level, 1, 22) income_level, AVG(DECODE(cust_gender, 'M', amount_sold, null)) sold_to_men, AVG(DECODE(cust_gender, 'F', amount_sold, null)) sold_to_women, STATS_T_TEST_INDEPU(cust_gender, amount_sold, 'STATISTIC', 'F') t_observed, STATS_T_TEST_INDEPU(cust_gender, amount_sold) two_sided_p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id GROUP BY ROLLUP(cust_income_level) ORDER BY income_level, sold_to_men, sold_to_women, t_observed; INCOME_LEVEL SOLD_TO_MEN SOLD_TO_WOMEN T_OBSERVED TWO_SIDED_P_VALUE ---------------------- ----------- ------------- ---------- ----------------- A: Below 30,000 105.28349 99.4281447 -2.0542592 .039964704 B: 30,000 - 49,999 102.59651 109.829642 2.96922332 .002987742 C: 50,000 - 69,999 105.627588 110.127931 2.3496854 .018792277 D: 70,000 - 89,999 106.630299 110.47287 2.26839281 .023307831 E: 90,000 - 109,999 103.396741 101.610416 -1.2603509 .207545662 F: 110,000 - 129,999 106.76476 105.981312 -.60580011 .544648553 G: 130,000 - 149,999 108.877532 107.31377 -.85219781 .394107755 H: 150,000 - 169,999 110.987258 107.152191 -1.9451486 .051762624 I: 170,000 - 189,999 102.808238 107.43556 2.14966921 .031587875 J: 190,000 - 249,999 108.040564 115.343356 2.54749867 .010854966 K: 250,000 - 299,999 112.377993 108.196097 -1.4115514 .158091676 L: 300,000 and above 120.970235 112.216342 -2.0726194 .038225611 107.121845 113.80441 .689462437 .490595765 106.663769 107.276386 1.07853782 .280794207 14 rows selected. </code>",
        "detail": "The Syntax is:\nSTATS_T_TEST_INDEPU ( expr1, expr2 [, { { STATISTIC | ONE_SIDED_SIG } , expr3 | TWO_SIDED_SIG | DF } ] )\nThe Purpose is:\n<code>STATS_T_TEST_INDEPU</code>: A t-test of two independent groups with unequal variance (unpooled variances).\nThe t-test measures the significance of a difference of means. You can use it to compare the means of two groups or the means of one group with a constant. The one-sample and two-sample <code>STATS_T_TEST_</code>* functions take three arguments: two expressions and a return value of type <code>VARCHAR2</code>. The functions return one number, determined by the value of the third argument. If you omit the third argument, then the default is <code>TWO_SIDED_SIG</code>. The meaning of the return values is shown in <link>Table 5-9&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#g1514103</link>. Table 5-9 STATS_T_TEST_* Return Values <table> <thead> <tr> <th>Return Value</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td> <code>STATISTIC</code> </td> <td> The observed value of t </td> </tr> <tr> <td> <code>DF</code> </td> <td> Degree of freedom </td> </tr> <tr> <td> <code>ONE_SIDED_SIG</code> </td> <td> One-tailed significance of t </td> </tr> <tr> <td> <code>TWO_SIDED_SIG</code> </td> <td> Two-tailed significance of t </td> </tr> </tbody> </table> The two independent <code>STATS_T_TEST_</code>* functions can take a fourth argument (<code>expr3</code>) if the third argument is specified as <code>STATISTIC</code> or <code>ONE_SIDED_SIG</code>. In this case, <code>expr3</code> indicates which value of <code>expr1</code> is the high value, or the value whose rejection region is the upper tail. The significance of the observed value of t is the probability that the value of t would have been obtained by chance\u9225\u6501 number between 0 and 1. The smaller the value, the more significant the difference between the means. One-sided significance is always respect to the upper tail. For one-sample and paired t-test, the high value is the first expression. For independent t-test, the high value is the one specified by <code>expr3</code>. The degree of freedom depends on the type of t-test that resulted in the observed value of t. For example, for a one-sample t-test (<code>STATS_T_TEST_ONE</code>), the degree of freedom is the number of observations in the sample minus 1.\nIn the <code>STATS_T_TEST_INDEP</code> and <code>STATS_T_TEST_INDEPU</code> functions, <code>expr1</code> is the grouping column and <code>expr2</code> is the sample of values. The pooled variances version (<code>STATS_T_TEST_INDEP</code>) tests whether the means are the same or different for two distributions that have similar variances. The unpooled variances version (<code>STATS_T_TEST_INDEPU</code>) tests whether the means are the same or different even if the two distributions are known to have significantly different variances. Before using these functions, it is advisable to determine whether the variances of the samples are significantly different. If they are, then the data may come from distributions with different shapes, and the difference of the means may not be very useful. You can perform an f-test to determine the difference of the variances. If they are not significantly different, use <code>STATS_T_TEST_INDEP</code>. If they are significantly different, use <code>STATS_T_TEST_INDEPU</code>. Refer to <link>STATS_F_TEST&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions171.htm#i1279901</link> for information on performing an f-test.\nThe Examples is:\nThe following example determines the significance of the difference between the average sales to men and women where the distributions are known to have significantly different (unpooled) variances: <code>SELECT SUBSTR(cust_income_level, 1, 22) income_level, AVG(DECODE(cust_gender, 'M', amount_sold, null)) sold_to_men, AVG(DECODE(cust_gender, 'F', amount_sold, null)) sold_to_women, STATS_T_TEST_INDEPU(cust_gender, amount_sold, 'STATISTIC', 'F') t_observed, STATS_T_TEST_INDEPU(cust_gender, amount_sold) two_sided_p_value FROM sh.customers c, sh.sales s WHERE c.cust_id = s.cust_id GROUP BY ROLLUP(cust_income_level) ORDER BY income_level, sold_to_men, sold_to_women, t_observed; INCOME_LEVEL SOLD_TO_MEN SOLD_TO_WOMEN T_OBSERVED TWO_SIDED_P_VALUE ---------------------- ----------- ------------- ---------- ----------------- A: Below 30,000 105.28349 99.4281447 -2.0542592 .039964704 B: 30,000 - 49,999 102.59651 109.829642 2.96922332 .002987742 C: 50,000 - 69,999 105.627588 110.127931 2.3496854 .018792277 D: 70,000 - 89,999 106.630299 110.47287 2.26839281 .023307831 E: 90,000 - 109,999 103.396741 101.610416 -1.2603509 .207545662 F: 110,000 - 129,999 106.76476 105.981312 -.60580011 .544648553 G: 130,000 - 149,999 108.877532 107.31377 -.85219781 .394107755 H: 150,000 - 169,999 110.987258 107.152191 -1.9451486 .051762624 I: 170,000 - 189,999 102.808238 107.43556 2.14966921 .031587875 J: 190,000 - 249,999 108.040564 115.343356 2.54749867 .010854966 K: 250,000 - 299,999 112.377993 108.196097 -1.4115514 .158091676 L: 300,000 and above 120.970235 112.216342 -2.0726194 .038225611 107.121845 113.80441 .689462437 .490595765 106.663769 107.276386 1.07853782 .280794207 14 rows selected. </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions176.htm#SQLRF51788"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_SLOPE",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_SLOPE))) (function_argument ( )))",
        "description": "The Syntax is:\nREGR_SLOPE (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\n<code>REGR_SLOPE</code> returns the slope of the line. The return value is a numeric data type and can be null. After the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs, it makes the following computation: <code>COVAR_POP(expr1, expr2) / VAR_POP(expr2) </code>\nThe Examples is:\nThe following example calculates the slope and regression of the linear regression model for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>. <code>SELECT job_id, REGR_SLOPE(SYSDATE-hire_date, salary) slope, REGR_INTERCEPT(SYSDATE-hire_date, salary) intercept FROM employees WHERE department_id in (50,80) GROUP BY job_id ORDER BY job_id; JOB_ID SLOPE INTERCEPT ---------- ----- ------------ SA_MAN .355 -1707.030762 SA_REP .257 404.767151 SH_CLERK .745 159.015293 ST_CLERK .904 134.409050 ST_MAN .479 -570.077291 </code>",
        "detail": "The Syntax is:\nREGR_SLOPE (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\n<code>REGR_SLOPE</code> returns the slope of the line. The return value is a numeric data type and can be null. After the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs, it makes the following computation: <code>COVAR_POP(expr1, expr2) / VAR_POP(expr2) </code>\nThe Examples is:\nThe following example calculates the slope and regression of the linear regression model for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>. <code>SELECT job_id, REGR_SLOPE(SYSDATE-hire_date, salary) slope, REGR_INTERCEPT(SYSDATE-hire_date, salary) intercept FROM employees WHERE department_id in (50,80) GROUP BY job_id ORDER BY job_id; JOB_ID SLOPE INTERCEPT ---------- ----- ------------ SA_MAN .355 -1707.030762 SA_REP .257 404.767151 SH_CLERK .745 159.015293 ST_CLERK .904 134.409050 ST_MAN .479 -570.077291 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_INTERCEPT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_INTERCEPT))) (function_argument ( )))",
        "description": "The Syntax is:\n REGR_INTERCEPT (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\n<code>REGR_INTERCEPT</code> returns the y-intercept of the regression line. The return value is a numeric data type and can be null. After the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs, it makes the following computation: <code>AVG(expr1) - REGR_SLOPE(expr1, expr2) * AVG(expr2) </code>\nThe Examples is:\nThe following example calculates the slope and regression of the linear regression model for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>. <code>SELECT job_id, REGR_SLOPE(SYSDATE-hire_date, salary) slope, REGR_INTERCEPT(SYSDATE-hire_date, salary) intercept FROM employees WHERE department_id in (50,80) GROUP BY job_id ORDER BY job_id; JOB_ID SLOPE INTERCEPT ---------- ----- ------------ SA_MAN .355 -1707.030762 SA_REP .257 404.767151 SH_CLERK .745 159.015293 ST_CLERK .904 134.409050 ST_MAN .479 -570.077291 </code>",
        "detail": "The Syntax is:\n REGR_INTERCEPT (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\n<code>REGR_INTERCEPT</code> returns the y-intercept of the regression line. The return value is a numeric data type and can be null. After the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs, it makes the following computation: <code>AVG(expr1) - REGR_SLOPE(expr1, expr2) * AVG(expr2) </code>\nThe Examples is:\nThe following example calculates the slope and regression of the linear regression model for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>. <code>SELECT job_id, REGR_SLOPE(SYSDATE-hire_date, salary) slope, REGR_INTERCEPT(SYSDATE-hire_date, salary) intercept FROM employees WHERE department_id in (50,80) GROUP BY job_id ORDER BY job_id; JOB_ID SLOPE INTERCEPT ---------- ----- ------------ SA_MAN .355 -1707.030762 SA_REP .257 404.767151 SH_CLERK .745 159.015293 ST_CLERK .904 134.409050 ST_MAN .479 -570.077291 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_COUNT",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_COUNT))) (function_argument ( )))",
        "description": "The Syntax is:\nREGR_COUNT (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\n<code>REGR_COUNT</code> returns an integer that is the number of non-null number pairs used to fit the regression line.\nThe Examples is:\nThe following example calculates the count of by <code>job_id</code> for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>. <code>SELECT job_id, REGR_COUNT(SYSDATE-hire_date, salary) count FROM employees WHERE department_id in (30, 50) GROUP BY job_id ORDER BY job_id, count; JOB_ID COUNT ---------- ---------- PU_CLERK 5 PU_MAN 1 SH_CLERK 20 ST_CLERK 20 ST_MAN 5 </code>",
        "detail": "The Syntax is:\nREGR_COUNT (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\n<code>REGR_COUNT</code> returns an integer that is the number of non-null number pairs used to fit the regression line.\nThe Examples is:\nThe following example calculates the count of by <code>job_id</code> for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>. <code>SELECT job_id, REGR_COUNT(SYSDATE-hire_date, salary) count FROM employees WHERE department_id in (30, 50) GROUP BY job_id ORDER BY job_id, count; JOB_ID COUNT ---------- ---------- PU_CLERK 5 PU_MAN 1 SH_CLERK 20 ST_CLERK 20 ST_MAN 5 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_R2",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_R2))) (function_argument ( )))",
        "description": "The Syntax is:\nREGR_R2 (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\n<code>REGR_R2</code> returns the coefficient of determination (also called R-squared or goodness of fit) for the regression. The return value is a numeric data type and can be null. <code>VAR_POP</code>(<code>expr1</code>) and <code>VAR_POP</code>(<code>expr2</code>) are evaluated after the elimination of null pairs. The return values are: <code> NULL if VAR_POP(expr2) = 0 1 if VAR_POP(expr1) = 0 and VAR_POP(expr2) != 0 POWER(CORR(expr1,expr),2) if VAR_POP(expr1) > 0 and VAR_POP(expr2 != 0 </code>\nThe Examples is:\nThe following example calculates the coefficient of determination the linear regression of time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, REGR_R2(SYSDATE-hire_date, salary) Regr_R2 FROM employees WHERE department_id in (80, 50) GROUP by job_id ORDER BY job_id, Regr_R2; JOB_ID REGR_R2 ---------- ---------- SA_MAN .83244748 SA_REP .647007156 SH_CLERK .879799698 ST_CLERK .742808493 ST_MAN .69418508 </code>",
        "detail": "The Syntax is:\nREGR_R2 (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\n<code>REGR_R2</code> returns the coefficient of determination (also called R-squared or goodness of fit) for the regression. The return value is a numeric data type and can be null. <code>VAR_POP</code>(<code>expr1</code>) and <code>VAR_POP</code>(<code>expr2</code>) are evaluated after the elimination of null pairs. The return values are: <code> NULL if VAR_POP(expr2) = 0 1 if VAR_POP(expr1) = 0 and VAR_POP(expr2) != 0 POWER(CORR(expr1,expr),2) if VAR_POP(expr1) > 0 and VAR_POP(expr2 != 0 </code>\nThe Examples is:\nThe following example calculates the coefficient of determination the linear regression of time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, REGR_R2(SYSDATE-hire_date, salary) Regr_R2 FROM employees WHERE department_id in (80, 50) GROUP by job_id ORDER BY job_id, Regr_R2; JOB_ID REGR_R2 ---------- ---------- SA_MAN .83244748 SA_REP .647007156 SH_CLERK .879799698 ST_CLERK .742808493 ST_MAN .69418508 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_AVGX",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_AVGX))) (function_argument ( )))",
        "description": "The Syntax is:\nREGR_AVGX (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null: <code>REGR_AVGX</code> evaluates the average of the independent variable (<code>expr2</code>) of the regression line. It makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>AVG(expr2) </code>\nThe Examples is:\nThe following example calculates the average values for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>: <code>SELECT job_id, REGR_AVGY(SYSDATE-hire_date, salary) avgy, REGR_AVGX(SYSDATE-hire_date, salary) avgx FROM employees WHERE department_id in (30,50) GROUP BY job_id ORDER BY job_id, avgy, avgx; JOB_ID AVGY AVGX ---------- ---------- ---------- PU_CLERK 2950.3778 2780 PU_MAN 4026.5778 11000 SH_CLERK 2773.0778 3215 ST_CLERK 2872.7278 2785 ST_MAN 3140.1778 7280 </code>",
        "detail": "The Syntax is:\nREGR_AVGX (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null: <code>REGR_AVGX</code> evaluates the average of the independent variable (<code>expr2</code>) of the regression line. It makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>AVG(expr2) </code>\nThe Examples is:\nThe following example calculates the average values for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>: <code>SELECT job_id, REGR_AVGY(SYSDATE-hire_date, salary) avgy, REGR_AVGX(SYSDATE-hire_date, salary) avgx FROM employees WHERE department_id in (30,50) GROUP BY job_id ORDER BY job_id, avgy, avgx; JOB_ID AVGY AVGX ---------- ---------- ---------- PU_CLERK 2950.3778 2780 PU_MAN 4026.5778 11000 SH_CLERK 2773.0778 3215 ST_CLERK 2872.7278 2785 ST_MAN 3140.1778 7280 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_AVGY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_AVGY))) (function_argument ( )))",
        "description": "The Syntax is:\nREGR_AVGY (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null: <code>REGR_AVGY</code> evaluates the average of the dependent variable (<code>expr1</code>) of the regression line. It makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>AVG(expr1) </code> <code>REGR_SXY</code>\nThe Examples is:\nThe following example calculates the average values for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>: <code>SELECT job_id, REGR_AVGY(SYSDATE-hire_date, salary) avgy, REGR_AVGX(SYSDATE-hire_date, salary) avgx FROM employees WHERE department_id in (30,50) GROUP BY job_id ORDER BY job_id, avgy, avgx; JOB_ID AVGY AVGX ---------- ---------- ---------- PU_CLERK 2950.3778 2780 PU_MAN 4026.5778 11000 SH_CLERK 2773.0778 3215 ST_CLERK 2872.7278 2785 ST_MAN 3140.1778 7280 </code>",
        "detail": "The Syntax is:\nREGR_AVGY (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null: <code>REGR_AVGY</code> evaluates the average of the dependent variable (<code>expr1</code>) of the regression line. It makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>AVG(expr1) </code> <code>REGR_SXY</code>\nThe Examples is:\nThe following example calculates the average values for time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>. Results are grouped by <code>job_id</code>: <code>SELECT job_id, REGR_AVGY(SYSDATE-hire_date, salary) avgy, REGR_AVGX(SYSDATE-hire_date, salary) avgx FROM employees WHERE department_id in (30,50) GROUP BY job_id ORDER BY job_id, avgy, avgx; JOB_ID AVGY AVGX ---------- ---------- ---------- PU_CLERK 2950.3778 2780 PU_MAN 4026.5778 11000 SH_CLERK 2773.0778 3215 ST_CLERK 2872.7278 2785 ST_MAN 3140.1778 7280 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_SXX",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_SXX))) (function_argument ( )))",
        "description": "The Syntax is:\nREGR_SXX (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null. <code>REGR_SXX</code>, <code>REGR_SYY</code> are auxiliary functions that are used to compute various diagnostic statistics. <code>REGR_SXX</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * VAR_POP(expr2) </code>\nThe Examples is:\nThe following example calculates three types of diagnostic statistics for the linear regression of time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, REGR_SXY(SYSDATE-hire_date, salary) regr_sxy, REGR_SXX(SYSDATE-hire_date, salary) regr_sxx, REGR_SYY(SYSDATE-hire_date, salary) regr_syy FROM employees WHERE department_id in (80, 50) GROUP BY job_id ORDER BY job_id; JOB_ID REGR_SXY REGR_SXX REGR_SYY ---------- ---------- ----------- ---------- SA_MAN 3303500 9300000.0 1409642 SA_REP 16819665.5 65489655.2 6676562.55 SH_CLERK 4248650 5705500.0 3596039 ST_CLERK 3531545 3905500.0 4299084.55 ST_MAN 2180460 4548000.0 1505915.2 </code>",
        "detail": "The Syntax is:\nREGR_SXX (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null. <code>REGR_SXX</code>, <code>REGR_SYY</code> are auxiliary functions that are used to compute various diagnostic statistics. <code>REGR_SXX</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * VAR_POP(expr2) </code>\nThe Examples is:\nThe following example calculates three types of diagnostic statistics for the linear regression of time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, REGR_SXY(SYSDATE-hire_date, salary) regr_sxy, REGR_SXX(SYSDATE-hire_date, salary) regr_sxx, REGR_SYY(SYSDATE-hire_date, salary) regr_syy FROM employees WHERE department_id in (80, 50) GROUP BY job_id ORDER BY job_id; JOB_ID REGR_SXY REGR_SXX REGR_SYY ---------- ---------- ----------- ---------- SA_MAN 3303500 9300000.0 1409642 SA_REP 16819665.5 65489655.2 6676562.55 SH_CLERK 4248650 5705500.0 3596039 ST_CLERK 3531545 3905500.0 4299084.55 ST_MAN 2180460 4548000.0 1505915.2 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_SYY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_SYY))) (function_argument ( )))",
        "description": "The Syntax is:\nREGR_SYY (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null. <code>REGR_SXX</code>, <code>REGR_SYY</code> are auxiliary functions that are used to compute various diagnostic statistics. <code>REGR_SXX</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * VAR_POP(expr2) </code>. <code>REGR_SYY</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * VAR_POP(expr1)\nThe Examples is:\nThe following example calculates three types of diagnostic statistics for the linear regression of time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, REGR_SXY(SYSDATE-hire_date, salary) regr_sxy, REGR_SXX(SYSDATE-hire_date, salary) regr_sxx, REGR_SYY(SYSDATE-hire_date, salary) regr_syy FROM employees WHERE department_id in (80, 50) GROUP BY job_id ORDER BY job_id; JOB_ID REGR_SXY REGR_SXX REGR_SYY ---------- ---------- ----------- ---------- SA_MAN 3303500 9300000.0 1409642 SA_REP 16819665.5 65489655.2 6676562.55 SH_CLERK 4248650 5705500.0 3596039 ST_CLERK 3531545 3905500.0 4299084.55 ST_MAN 2180460 4548000.0 1505915.2 </code>",
        "detail": "The Syntax is:\nREGR_SYY (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null. <code>REGR_SXX</code>, <code>REGR_SYY</code> are auxiliary functions that are used to compute various diagnostic statistics. <code>REGR_SXX</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * VAR_POP(expr2) </code>. <code>REGR_SYY</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * VAR_POP(expr1)\nThe Examples is:\nThe following example calculates three types of diagnostic statistics for the linear regression of time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, REGR_SXY(SYSDATE-hire_date, salary) regr_sxy, REGR_SXX(SYSDATE-hire_date, salary) regr_sxx, REGR_SYY(SYSDATE-hire_date, salary) regr_syy FROM employees WHERE department_id in (80, 50) GROUP BY job_id ORDER BY job_id; JOB_ID REGR_SXY REGR_SXX REGR_SYY ---------- ---------- ----------- ---------- SA_MAN 3303500 9300000.0 1409642 SA_REP 16819665.5 65489655.2 6676562.55 SH_CLERK 4248650 5705500.0 3596039 ST_CLERK 3531545 3905500.0 4299084.55 ST_MAN 2180460 4548000.0 1505915.2 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    },
    {
        "type": "function",
        "keyword": "REGR_SXY",
        "tree": "(general_element_part (id_expression (regular_id (non_reserved_keywords_pre12c REGR_SXY))) (function_argument ( )))",
        "description": "The Syntax is:\nREGR_SXY (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null. <code>REGR_SXX</code>, <code>REGR_SYY</code> are auxiliary functions that are used to compute various diagnostic statistics. <code>REGR_SXX</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * VAR_POP(expr2) </code>. <code>REGR_SXY</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * COVAR_POP(expr1, expr2) </code>\nThe Examples is:\nThe following example calculates three types of diagnostic statistics for the linear regression of time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, REGR_SXY(SYSDATE-hire_date, salary) regr_sxy, REGR_SXX(SYSDATE-hire_date, salary) regr_sxx, REGR_SYY(SYSDATE-hire_date, salary) regr_syy FROM employees WHERE department_id in (80, 50) GROUP BY job_id ORDER BY job_id; JOB_ID REGR_SXY REGR_SXX REGR_SYY ---------- ---------- ----------- ---------- SA_MAN 3303500 9300000.0 1409642 SA_REP 16819665.5 65489655.2 6676562.55 SH_CLERK 4248650 5705500.0 3596039 ST_CLERK 3531545 3905500.0 4299084.55 ST_MAN 2180460 4548000.0 1505915.2 </code>",
        "detail": "The Syntax is:\nREGR_SXY (expr1 , expr2) [ OVER (analytic_clause) ]\nThe Purpose is:\nThe linear regression functions fit an ordinary-least-squares regression line to a set of number pairs. You can use them as both aggregate and analytic functions. See Also: <link>\"Aggregate Functions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions003.htm#i89203</link> and <link>\"About SQL Expressions\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/expressions001.htm#i1002626</link> for information on valid forms of <code>expr</code> These functions take as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. Oracle determines the argument with the highest numeric precedence, implicitly converts the remaining arguments to that data type, and returns that data type. See Also: <link>Table 3-10, \"Implicit Type Conversion Matrix\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#g195937</link> for more information on implicit conversion and <link>\"Numeric Precedence\"&LINK&https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#i156865</link> for information on numeric precedence Oracle applies the function to the set of (<code>expr1</code>, <code>expr2</code>) pairs after eliminating all pairs for which either <code>expr1</code> or <code>expr2</code> is null. Oracle computes all the regression functions simultaneously during a single pass through the data. <code>expr1</code> is interpreted as a value of the dependent variable (a <code>y</code> value), and <code>expr2</code> is interpreted as a value of the independent variable (an <code>x</code> value).\nThis regression functions return a numeric data type and can be null. <code>REGR_SXX</code>, <code>REGR_SYY</code> are auxiliary functions that are used to compute various diagnostic statistics. <code>REGR_SXX</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * VAR_POP(expr2) </code>. <code>REGR_SXY</code> makes the following computation after the elimination of null (<code>expr1</code>, <code>expr2</code>) pairs: <code>REGR_COUNT(expr1, expr2) * COVAR_POP(expr1, expr2) </code>\nThe Examples is:\nThe following example calculates three types of diagnostic statistics for the linear regression of time employed (<code>SYSDATE</code> - <code>hire_date</code>) and salary using the sample table <code>hr.employees</code>: <code>SELECT job_id, REGR_SXY(SYSDATE-hire_date, salary) regr_sxy, REGR_SXX(SYSDATE-hire_date, salary) regr_sxx, REGR_SYY(SYSDATE-hire_date, salary) regr_syy FROM employees WHERE department_id in (80, 50) GROUP BY job_id ORDER BY job_id; JOB_ID REGR_SXY REGR_SXX REGR_SYY ---------- ---------- ----------- ---------- SA_MAN 3303500 9300000.0 1409642 SA_REP 16819665.5 65489655.2 6676562.55 SH_CLERK 4248650 5705500.0 3596039 ST_CLERK 3531545 3905500.0 4299084.55 ST_MAN 2180460 4548000.0 1505915.2 </code>",
        "example": [],
        "link": [
            "https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions151.htm#SQLRF00696"
        ]
    }
]