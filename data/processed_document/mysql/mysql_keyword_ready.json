[
    {
        "Keyword": [
            "ALL"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec ALL)"
        ],
        "Route": "",
        "Description": "The 'ALL' and 'DISTINCT' modifiers specify whether duplicate rows should be returned. 'ALL' (the default) specifies that all matching rows should be returned, including duplicates. 'DISTINCT' specifies removal of duplicate rows from the result set. It is an error to specify both modifiers. 'DISTINCTROW' is a synonym for 'DISTINCT'.",
        "Demo": [
            "SELECT ALL * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "DISTINCT"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec DISTINCT)"
        ],
        "Route": "",
        "Description": "The ALL and DISTINCT modifiers specify whether duplicate rows should be returned. ALL (the default) specifies that all matching rows should be returned, including duplicates. DISTINCT specifies removal of duplicate rows from the result set. It is an error to specify both modifiers. DISTINCTROW is a synonym for DISTINCT.",
        "Demo": [
            "SELECT DISTINCT * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "DISTINCTROW"
        ],
        "Src": "SELECT",
        "Tree": [
            "(selectSpec DISTINCTROW)"
        ],
        "Route": "",
        "Description": "DISTINCTROW is a synonym for DISTINCT.",
        "Demo": [
            "SELECT DISTINCTROW * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "FROM DUAL"
        ],
        "Src": "SELECT",
        "Tree": [
            " (fromClause FROM  (tableSources  (tableSource  (tableSourceItem  (tableName  (fullId  (uid  (simpleId DUAL))))))))"
        ],
        "Route": "",
        "Description": "You are permitted to specify <code>DUAL</code> as a dummy table name in situations where no tables are referenced:<code>mysql> SELECT 1 + 1 FROM DUAL;  -> 2</code>       <code>DUAL</code> is purely for the convenience of people who require that all <link><code>SELECT</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/select.html</link>       statements should have <code>FROM</code> and possibly other clauses. MySQL may ignore the clauses. MySQL does not require <code>FROM DUAL</code> if no tables are referenced.",
        "Demo": [
            "SELECT 1 + 1 FROM DUAL;"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "HIGH_PRIORITY"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec HIGH_PRIORITY)"
        ],
        "Route": "",
        "Description": "HIGH_PRIORITY gives the SELECT higher priority than a statement that updates a table. You should use this only for queries that are very fast and must be done at once. A SELECT HIGH_PRIORITY query that is issued while the table is locked for reading runs even if there is an update statement waiting for the table to be free. This affects only storage engines that use only table-level locking (such as MyISAM, MEMORY, and MERGE). HIGH_PRIORITY cannot be used with SELECT statements that are part of a UNION.",
        "Demo": [
            "SELECT HIGH_PRIORITY * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "STRAIGHT_JOIN"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec STRAIGHT_JOIN)"
        ],
        "Route": "",
        "Description": "STRAIGHT_JOIN forces the optimizer to join the tables in the order in which they are listed in the FROM clause. You can use this to speed up a query if the optimizer joins the tables in nonoptimal order. STRAIGHT_JOIN also can be used in the table_references list. See Section 15.2.13.2, \u201cJOIN Clause\u201d. STRAIGHT_JOIN does not apply to any table that the optimizer treats as a const or system table. Such a table produces a single row, is read during the optimization phase of query execution, and references to its columns are replaced with the appropriate column values before query execution proceeds. These tables appear first in the query plan displayed by EXPLAIN. See Section 10.8.1, \u201cOptimizing Queries with EXPLAIN\u201d. This exception may not apply to const or system tables that are used on the NULL-complemented side of an outer join (that is, the right-side table of a LEFT JOIN or the left-side table of a RIGHT JOIN.",
        "Demo": [
            "SELECT STRAIGHT_JOIN * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "SQL_SMALL_RESULT"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec SQL_SMALL_RESULT)"
        ],
        "Route": "",
        "Description": "SQL_SMALL_RESULT can be used with GROUP BY or DISTINCT to tell the optimizer that the result set is small. For SQL_SMALL_RESULT, MySQL uses in-memory temporary tables to store the resulting table instead of using sorting. This should not normally be needed.",
        "Demo": [
            "SELECT SQL_SMALL_RESULT * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "SQL_BIG_RESULT"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec SQL_BIG_RESULT)"
        ],
        "Route": "",
        "Description": "SQL_BIG_RESULT or SQL_SMALL_RESULT can be used with GROUP BY or DISTINCT to tell the optimizer that the result set has many rows or is small, respectively. For SQL_BIG_RESULT, MySQL directly uses disk-based temporary tables if they are created, and prefers sorting to using a temporary table with a key on the GROUP BY elements. For SQL_SMALL_RESULT, MySQL uses in-memory temporary tables to store the resulting table instead of using sorting. This should not normally be needed.",
        "Demo": [
            "SELECT SQL_BIG_RESULT * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "SQL_BUFFER_RESULT"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec SQL_BUFFER_RESULT)"
        ],
        "Route": "",
        "Description": "forces the result to be put into a temporary table. This helps MySQL free the table locks early and helps in cases where it takes a long time to send the result set to the client. This modifier can be used only for top-level SELECT statements, not for subqueries or following UNION.",
        "Demo": [
            "SELECT SQL_BUFFER_RESULT * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "SQL_NO_CACHE"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec SQL_NO_CACHE)"
        ],
        "Route": "",
        "Description": "The SQL_CACHE and SQL_NO_CACHE modifiers were used with the query cache prior to MySQL 8.0. The query cache was removed in MySQL 8.0. The SQL_CACHE modifier was removed as well. SQL_NO_CACHE is deprecated, and has no effect; expect it to be removed in a future MySQL release.",
        "Demo": [
            "SELECT SQL_NO_CACHE * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "SQL_CALC_FOUND_ROWS"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectSpec SQL_CALC_FOUND_ROWS)"
        ],
        "Route": "",
        "Description": "SQL_CALC_FOUND_ROWS tells MySQL to calculate how many rows there would be in the result set, disregarding any LIMIT clause. The number of rows can then be retrieved with SELECT FOUND_ROWS(). See Section 14.15, \u201cInformation Functions\u201d. Note The SQL_CALC_FOUND_ROWS query modifier and accompanying FOUND_ROWS() function are deprecated as of MySQL 8.0.17; expect them to be removed in a future version of MySQL. See the FOUND_ROWS() description for information about an alternative strategy.",
        "Demo": [
            "SELECT SQL_CALC_FOUND_ROWS * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "FROM table_references PARTITION partition_list",
            "FROM table_references"
        ],
        "Src": "SELECT",
        "Tree": [
            " (fromClause FROM  (tableSources  (tableSource  (tableSourceItem PARTITION))))",
            " (fromClause FROM)"
        ],
        "Route": "",
        "Description": "A table reference (when it refers to a partitioned table) may contain a PARTITION clause, including a list of comma-separated partitions, subpartitions, or both. This option follows the name of the table and precedes any alias declaration. The effect of this option is that rows are selected only from the listed partitions or subpartitions. Any partitions or subpartitions not named in the list are ignored. For more information and examples, see Section 26.5, \u201cPartition Selection",
        "Demo": [
            "SELECT * FROM employees PARTITION (p1);",
            "SELECT * FROM employees;"
        ],
        "Count": [
            2,
            1
        ]
    },
    {
        "Keyword": [
            "WHERE where_condition"
        ],
        "Src": "SELECT",
        "Tree": [
            " (fromClause WHERE)"
        ],
        "Route": "",
        "Description": "The WHERE clause, if given, indicates the condition or conditions that rows must satisfy to be selected. where_condition is an expression that evaluates to true for each row to be selected. The statement selects all rows if there is no WHERE clause. In the WHERE expression, you can use any of the functions and operators that MySQL supports, except for aggregate (group) functions. See Section 11.5, \u201cExpressions\u201d, and Chapter 14, Functions and Operators.",
        "Demo": [
            "SELECT * FROM table_a WHERE x > 1;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "GROUP BY col_name WITH ROLLUP",
            "GROUP BY col_name"
        ],
        "Src": "SELECT",
        "Tree": [
            " (groupByClause GROUP BY WITH ROLLUP)",
            " (groupByClause GROUP BY)"
        ],
        "Route": "",
        "Description": "The GROUP BY clause permits a WITH ROLLUP modifier that causes summary output to include extra rows that represent higher-level (that is, super-aggregate) summary operations. ROLLUP thus enables you to answer questions at multiple levels of analysis with a single query. For example, ROLLUP can be used to provide support for OLAP (Online Analytical Processing) operations.",
        "Demo": [
            "SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 WITH ROLLUP;",
            "SELECT COUNT(col1) AS col2 FROM t GROUP BY col2;"
        ],
        "Count": [
            4,
            2
        ]
    },
    {
        "Keyword": [
            "HAVING where_condition"
        ],
        "Src": "SELECT",
        "Tree": [
            " (havingClause HAVING)"
        ],
        "Route": "",
        "Description": "The HAVING clause, like the WHERE clause, specifies selection conditions. The WHERE clause specifies conditions on columns in the select list, but cannot refer to aggregate functions. The HAVING clause specifies conditions on groups, typically formed by the GROUP BY clause. The query result includes only groups satisfying the HAVING conditions. (If no GROUP BY is present, all rows implicitly form a single aggregate group.) The HAVING clause is applied nearly last, just before items are sent to the client, with no optimization. (LIMIT is applied after HAVING.)",
        "Demo": [
            "SELECT col_name FROM tbl_name HAVING col_name > 0;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "ORDER BY col_name ASC",
            "ORDER BY col_name DESC",
            "ORDER BY col_name WITH ROLLUP",
            "ORDER BY col_name"
        ],
        "Src": "SELECT",
        "Tree": [
            " (orderByClause ORDER BY  (orderByExpression ASC))",
            " (orderByClause ORDER BY  (orderByExpression DESC))",
            "Parse error",
            " (orderByClause ORDER BY)"
        ],
        "Route": "",
        "Description": "Columns selected for output can be referred to in ORDER BY and GROUP BY clauses using column names, column aliases, or column positions. Column positions are integers and begin with 1: SELECT college, region, seed FROM tournament ORDER BY region, seed; SELECT college, region AS r, seed AS s FROM tournament ORDER BY r, s; SELECT college, region, seed FROM tournament ORDER BY 2, 3; To sort in reverse order, add the DESC (descending) keyword to the name of the column in the ORDER BY clause that you are sorting by. The default is ascending order; this can be specified explicitly using the ASC keyword. If ORDER BY occurs within a parenthesized query expression and also is applied in the outer query, the results are undefined and may change in a future version of MySQL. Use of column positions is deprecated because the syntax has been removed from the SQL standard. Prior to MySQL 8.0.13, MySQL supported a nonstandard syntax extension that permitted explicit ASC or DESC designators for GROUP BY columns. MySQL 8.0.12 and later supports ORDER BY with grouping functions so that use of this extension is no longer necessary. (Bug #86312, Bug #26073525) This also means you can sort on an arbitrary column or columns when using GROUP BY, like this: SELECT a, b, COUNT(c) AS t FROM test_table GROUP BY a,b ORDER BY a,t DESC; As of MySQL 8.0.13, the GROUP BY extension is no longer supported: ASC or DESC designators for GROUP BY columns are not permitted.",
        "Demo": [
            "SELECT * FROM mytable ORDER BY full_name ASC;",
            "SELECT * FROM mytable ORDER BY full_name DESC;",
            "SELECT * FROM mytable ORDER BY full_name WITH ROLLUP;",
            "SELECT * FROM mytable ORDER BY full_name;"
        ],
        "Count": [
            3,
            3,
            null,
            2
        ]
    },
    {
        "Keyword": [
            "LIMIT row_count OFFSET offset",
            "LIMIT offset , row_count",
            "LIMIT row_count",
            "LIMIT row_count OFFSET offset",
            "LIMIT offset , row_count",
            "LIMIT row_count",
            "LIMIT row_count OFFSET offset",
            "LIMIT offset , row_count",
            "LIMIT row_count"
        ],
        "Src": "SELECT",
        "Tree": [
            "(querySpecification (limitClause LIMIT OFFSET))",
            "(querySpecificationNointo (limitClause LIMIT OFFSET))",
            "(selectStatement (limitClause LIMIT OFFSET))",
            "(querySpecification (limitClause LIMIT ,))",
            "(querySpecificationNointo (limitClause LIMIT ,))",
            "(selectStatement (limitClause LIMIT ,))",
            "(querySpecification (limitClause LIMIT))",
            "(querySpecificationNointo (limitClause LIMIT))",
            "(selectStatement (limitClause LIMIT))"
        ],
        "Route": "",
        "Description": "The <code>LIMIT</code> clause can be used to constrain the number of rows returned by the <code>SELECT</code> statement. <code>LIMIT</code> takes one or two numeric arguments, which must both be nonnegative integer constants, with these exceptions: Within prepared statements, <code>LIMIT</code> parameters can be specified using <code>?</code> placeholder markers. Within stored programs, <code>LIMIT</code> parameters can be specified using integer-valued routine parameters or local variables. With two arguments, the first argument specifies the offset of the first row to return, and the second specifies the maximum number of rows to return. The offset of the initial row is 0 (not 1): <code>SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15</code> To retrieve all rows from a certain offset up to the end of the result set, you can use some large number for the second parameter. This statement retrieves all rows from the 96th row to the last: <code>SELECT * FROM tbl LIMIT 95,18446744073709551615;</code> With one argument, the value specifies the number of rows to return from the beginning of the result set: <code>SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows</code> In other words, <code>LIMIT row_count</code> is equivalent to <code>LIMIT 0, row_count</code>. For prepared statements, you can use placeholders. The following statements return one row from the <code>tbl</code> table: <code>SET @a=1; PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?'; EXECUTE STMT USING @a;</code> The following statements return the second to sixth rows from the <code>tbl</code> table: <code>SET @skip=1; SET @numrows=5; PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?, ?'; EXECUTE STMT USING @skip, @numrows;</code> For compatibility with PostgreSQL, MySQL also supports the <code>LIMIT row_count OFFSET offset</code> syntax. If <code>LIMIT</code> occurs within a parenthesized query expression and also is applied in the outer query, the results are undefined and may change in a future version of MySQL.",
        "Demo": [
            "SELECT * FROM table_a LIMIT 5 OFFSET 5;",
            "SELECT * FROM table_a LIMIT 5, 10;",
            "SELECT * FROM table_a LIMIT 5;",
            "SELECT * FROM table_a LIMIT 5 OFFSET 5;",
            "SELECT * FROM table_a LIMIT 5, 10;",
            "SELECT * FROM table_a LIMIT 5;",
            "SELECT * FROM table_a LIMIT 5 OFFSET 5;",
            "SELECT * FROM table_a LIMIT 5, 10;",
            "SELECT * FROM table_a LIMIT 5;"
        ],
        "Count": [
            2,
            2,
            1,
            2,
            2,
            1,
            2,
            2,
            1
        ]
    },
    {
        "Keyword": [
            "FOR UPDATE OF tbl_name"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "If you use FOR UPDATE with a storage engine that uses page or row locks, rows examined by the query are write-locked until the end of the current transaction. OF tbl_name applies FOR UPDATE and FOR SHARE queries to named tables. For example: SELECT * FROM t1, t2 FOR SHARE OF t1 FOR UPDATE OF t2; All tables referenced by the query block are locked when OF tbl_name is omitted. Consequently, using a locking clause without OF tbl_name in combination with another locking clause returns an error. Specifying the same table in multiple locking clauses returns an error. If an alias is specified as the table name in the SELECT statement, a locking clause may only use the alias. If the SELECT statement does not specify an alias explicitly, the locking clause may only specify the actual table name.",
        "Demo": [
            "SELECT * FROM t1, t2 FOR UPDATE OF t2;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "FOR SHARE OF tbl_name"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "FOR SHARE and LOCK IN SHARE MODE set shared locks that permit other transactions to read the examined rows but not to update or delete them. FOR SHARE and LOCK IN SHARE MODE are equivalent. However, FOR SHARE, like FOR UPDATE, supports NOWAIT, SKIP LOCKED, and OF tbl_name options. FOR SHARE is a replacement for LOCK IN SHARE MODE, but LOCK IN SHARE MODE remains available for backward compatibility.",
        "Demo": [
            "SELECT * FROM t1, t2 FOR SHARE OF t1;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "LOCK IN SHARE MODE"
        ],
        "Src": "SELECT",
        "Tree": [
            " (lockClause LOCK IN SHARE MODE)"
        ],
        "Route": "",
        "Description": "You cannot use FOR UPDATE as part of the SELECT in a statement such as CREATE TABLE new_table SELECT ... FROM old_table .... (If you attempt to do so, the statement is rejected with the error Can't update table 'old_table' while 'new_table' is being created.) FOR SHARE and LOCK IN SHARE MODE set shared locks that permit other transactions to read the examined rows but not to update or delete them. FOR SHARE and LOCK IN SHARE MODE are equivalent. However, FOR SHARE, like FOR UPDATE, supports NOWAIT, SKIP LOCKED, and OF tbl_name options. FOR SHARE is a replacement for LOCK IN SHARE MODE, but LOCK IN SHARE MODE remains available for backward compatibility.",
        "Demo": [
            "SELECT * FROM t1, t2 LOCK IN SHARE MODE;"
        ],
        "Count": [
            4
        ]
    },
    {
        "Keyword": [
            "LATERAL table_subquery alias",
            "table_subquery AS alias"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error",
            " (tableSourceItem AS)"
        ],
        "Route": "",
        "Description": "A <code>table_subquery</code> is also known as a derived table or subquery in the <code>FROM</code> clause. Such subqueries must include an alias to give the subquery result a table name, and may optionally include a list of table column names in parentheses. A trivial example follows: <code>SELECT * FROM (SELECT 1, 2, 3) AS t1;</code>",
        "Demo": [
            "SELECT * FROM LATERAL (SELECT 1, 2, 3) t1;",
            "SELECT * FROM  (SELECT 1) AS t1;"
        ],
        "Count": [
            null,
            1
        ]
    },
    {
        "Keyword": [
            "table_reference INNER JOIN table_factor ON search_condition",
            "table_reference CROSS JOIN table_factor ON search_condition",
            "table_reference JOIN table_factor ON search_condition",
            "table_reference STRAIGHT_JOIN table_factor ON search_condition",
            "table_reference INNER JOIN table_factor USING ( join_column_list ) ",
            "table_reference CROSS JOIN table_factor USING ( join_column_list ) ",
            "table_reference JOIN table_factor USING ( join_column_list ) ",
            "table_reference STRAIGHT_JOIN table_factor USING ( join_column_list ) ",
            "table_reference INNER JOIN table_factor",
            "table_reference CROSS JOIN table_factor",
            "table_reference JOIN table_factor",
            "table_reference STRAIGHT_JOIN table_factor"
        ],
        "Src": "SELECT",
        "Tree": [
            " (joinPart INNER JOIN  (joinSpec ON))",
            " (joinPart CROSS JOIN  (joinSpec ON))",
            " (joinPart JOIN  (joinSpec ON))",
            " (joinPart STRAIGHT_JOIN ON)",
            " (joinPart INNER JOIN  (joinSpec USING ( )))",
            " (joinPart CROSS JOIN  (joinSpec USING ( )))",
            " (joinPart JOIN  (joinSpec USING ( )))",
            " (joinPart STRAIGHT_JOIN)",
            " (joinPart INNER JOIN)",
            " (joinPart CROSS JOIN)",
            " (joinPart JOIN)",
            " (joinPart STRAIGHT_JOIN)"
        ],
        "Route": "",
        "Description": "A table reference includes options for specifying join operations. It supports using INNER JOIN or CROSS JOIN, which are syntactically equivalent in MySQL, as well as STRAIGHT_JOIN. These can be used to join a table_factor, which can be a table name, a table subquery, or another nested table reference, based on a condition specified using ON or using a list of columns specified with USING. The ON clause allows any searchable condition typical in WHERE clauses, specifying exactly how tables should be joined, while USING lists columns that must exist in both tables to perform the join.",
        "Demo": [
            "SELECT * FROM t1 INNER JOIN t2 ON t1.name = t2.name;",
            "SELECT * FROM t1 CROSS JOIN t2 ON t1.name = t2.name;",
            "SELECT * FROM t1 JOIN t2 ON t1.name = t2.name;",
            "SELECT * FROM t1 STRAIGHT_JOIN t2 ON t1.name = t2.name;",
            "SELECT * FROM t1 INNER JOIN t2 USING (c1, c2);",
            "SELECT * FROM t1 CROSS JOIN t2 USING (c1, c2);",
            "SELECT * FROM t1 JOIN t2 USING (c1, c2);",
            "SELECT * FROM t1 STRAIGHT_JOIN t2 USING (c1, c2);",
            "SELECT * FROM t1 INNER JOIN t2;",
            "SELECT * FROM t1 CROSS JOIN t2;",
            "SELECT * FROM t1 JOIN t2;",
            "SELECT * FROM t1 STRAIGHT_JOIN t2;"
        ],
        "Count": [
            3,
            3,
            2,
            2,
            5,
            5,
            4,
            1,
            2,
            2,
            1,
            1
        ]
    },
    {
        "Keyword": [
            "table_reference LEFT OUTER JOIN table_reference",
            "table_reference RIGHT OUTER JOIN table_reference",
            "table_reference LEFT JOIN table_reference ON search_condition",
            "table_reference RIGHT JOIN table_reference ON search_condition",
            "table_reference LEFT JOIN table_reference USING ( join_column_list ) ",
            "table_reference RIGHT JOIN table_reference USING ( join_column_list ) ",
            "table_reference LEFT JOIN table_reference",
            "table_reference RIGHT JOIN table_reference"
        ],
        "Src": "SELECT",
        "Tree": [
            " (joinPart LEFT OUTER JOIN)",
            " (joinPart RIGHT OUTER JOIN)",
            " (tableSource  (tableSourceItem  (uid  (simpleId  (scalarFunctionName  (functionNameBase LEFT))))) (joinPart JOIN  (joinSpec ON)))",
            " (tableSource (tableSourceItem (uid (simpleId (scalarFunctionName (functionNameBase RIGHT))))) (joinPart JOIN (joinSpec ON)))",
            " (tableSource  (tableSourceItem  (uid  (simpleId  (scalarFunctionName  (functionNameBase LEFT))))) (joinPart JOIN  (joinSpec USING ( ))))",
            " (tableSource  (tableSourceItem  (uid  (simpleId  (scalarFunctionName  (functionNameBase RIGHT))))) (joinPart JOIN  (joinSpec USING ( ))))",
            " (tableSource  (tableSourceItem  (uid  (simpleId  (scalarFunctionName  (functionNameBase LEFT))))) (joinPart JOIN))",
            " (tableSource  (tableSourceItem  (uid  (simpleId  (scalarFunctionName  (functionNameBase RIGHT))))) (joinPart JOIN))"
        ],
        "Route": "",
        "Description": "joined_table: {     table_reference {[INNER | CROSS] JOIN | STRAIGHT_JOIN} table_factor [join_specification]   | table_reference {LEFT|RIGHT} [OUTER] JOIN table_reference join_specification   | table_reference NATURAL [INNER | {LEFT|RIGHT} [OUTER]] JOIN table_factor }  join_specification: {     ON search_condition   | USING (join_column_list) }",
        "Demo": [
            "SELECT * FROM t1 LEFT OUTER JOIN t2;",
            "SELECT * FROM t1 RIGHT OUTER JOIN t2;",
            "SELECT * FROM t1 LEFT JOIN t2 ON t1.name = t2.name;",
            "SELECT * FROM t1 RIGHT JOIN t2 ON t1.name = t2.name;",
            "SELECT * FROM t1 LEFT JOIN t2 USING (c1, c2);",
            "SELECT * FROM t1 RIGHT JOIN t2 USING (c1, c2);",
            "SELECT * FROM t1 LEFT JOIN t2;",
            "SELECT * FROM t1 RIGHT JOIN t2;"
        ],
        "Count": [
            3,
            3,
            3,
            3,
            5,
            5,
            2,
            2
        ]
    },
    {
        "Keyword": [
            "table_reference NATURAL INNER JOIN table_factor",
            "table_reference NATURAL LEFT OUTER JOIN table_factor",
            "table_reference NATURAL RIGHT OUTER JOIN table_factor",
            "table_reference NATURAL LEFT JOIN table_factor",
            "table_reference NATURAL RIGHT JOIN table_factor",
            "table_reference NATURAL JOIN table_factor"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error",
            " (joinPart NATURAL LEFT OUTER JOIN)",
            " (joinPart NATURAL RIGHT OUTER JOIN)",
            " (joinPart NATURAL LEFT JOIN)",
            " (joinPart NATURAL RIGHT JOIN)",
            " (joinPart NATURAL JOIN)"
        ],
        "Route": "",
        "Description": "The syntax described allows for natural joins between tables, incorporating optional specifications such as INNER, LEFT, or RIGHT JOIN, with further distinction for OUTER joins. Natural joins automatically merge tables based on all columns in the two tables that have the same names and select only those columns. This eliminates the requirement to specify a join condition explicitly, simplifying the syntax for performing joins.",
        "Demo": [
            "SELECT * FROM t1 NATURAL INNER JOIN t2;",
            "SELECT * FROM t1 NATURAL LEFT OUTER JOIN t2;",
            "SELECT * FROM t1 NATURAL RIGHT OUTER JOIN t2;",
            "SELECT * FROM t1 NATURAL LEFT JOIN t2;",
            "SELECT * FROM t1 NATURAL RIGHT JOIN t2;",
            "SELECT * FROM t1 NATURAL JOIN t2;"
        ],
        "Count": [
            null,
            4,
            4,
            3,
            3,
            2
        ]
    },
    {
        "Keyword": [
            "operand comparison_operator ANY ( subquery ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectStatement  (querySpecification  (fromClause  (expression  (predicate  (predicate  (expressionAtom  (fullColumnName  (uid  (simpleId  (keywordsCanBeId ANY)))))))))) (queryExpression ( )))"
        ],
        "Route": "",
        "Description": "The `ANY` keyword, which must follow a comparison operator, means 'return `TRUE` if the comparison is `TRUE` for `ANY` of the values in the column that the subquery returns.' For example: `SELECT s1 FROM t1 WHERE s1 > ANY (SELECT s1 FROM t2);` Suppose that there is a row in table `t1` containing `(10)`. The expression is `TRUE` if table `t2` contains `(21,14,7)` because there is a value `7` in `t2` that is less than `10`. The expression is `FALSE` if table `t2` contains `(20,10)`, or if table `t2` is empty. The expression is unknown (that is, `NULL`) if table `t2` contains `(NULL,NULL,NULL)`.",
        "Demo": [
            "SELECT s1 FROM t1 WHERE s1 > ANY (SELECT s1 FROM t2);"
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "operand IN ( subquery ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (predicate IN ( ))"
        ],
        "Route": "",
        "Description": "When used with a subquery, the word IN is an alias for = ANY. Thus, these two statements are the same: SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2); SELECT s1 FROM t1 WHERE s1 IN (SELECT s1 FROM t2);",
        "Demo": [
            "SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);"
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "operand comparison_operator SOME ( subquery ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectStatement  (querySpecification  (fromClause  (expression  (predicate  (predicate  (expressionAtom  (fullColumnName  (uid  (simpleId  (keywordsCanBeId SOME)))))))))) (queryExpression ( )))"
        ],
        "Route": "",
        "Description": "The word 'SOME' is an alias for 'ANY'. Thus, these two statements are the same: 'SELECT s1 FROM t1 WHERE s1 <> ANY  (SELECT s1 FROM t2); SELECT s1 FROM t1 WHERE s1 <> SOME (SELECT s1 FROM t2);' Use of the word 'SOME' is rare, but this example shows why it might be useful. To most people, the English phrase 'a is not equal to any b' means 'there is no b which is equal to a,' but that is not what is meant by the SQL syntax. The syntax means 'there is some b to which a is not equal.' Using '<> SOME' instead helps ensure that everyone understands the true meaning of the query.",
        "Demo": [
            "SELECT s1 FROM t1 WHERE s1 <> SOME (SELECT s1 FROM t2);"
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "operand comparison_operator ALL ( subquery ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (predicate ALL ( ))"
        ],
        "Route": "",
        "Description": "The word ALL, which must follow a comparison operator, means \u201creturn TRUE if the comparison is TRUE for ALL of the values in the column that the subquery returns.\u201d For example: SELECT s1 FROM t1 WHERE s1 > ALL (SELECT s1 FROM t2); Suppose that there is a row in table t1 containing (10). The expression is TRUE if table t2 contains (-5,0,+5) because 10 is greater than all three values in t2. The expression is FALSE if table t2 contains (12,6,NULL,-100) because there is a single value 12 in table t2 that is greater than 10. The expression is unknown (that is, NULL) if table t2 contains (0,NULL,1). Finally, the expression is TRUE if table t2 is empty.",
        "Demo": [
            "SELECT s1 FROM t1 WHERE s1 > ALL (SELECT s1 FROM t2);"
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "EXISTS ( subquery ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (expressionAtom EXISTS ( ))"
        ],
        "Route": "",
        "Description": "If a subquery returns any rows at all, <code>EXISTS subquery</code> is <code>TRUE</code>, and <code>NOT EXISTS subquery</code> is <code>FALSE</code>. For example: <code>SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);</code> Traditionally, an <code>EXISTS</code> subquery starts with <code>SELECT *</code>, but it could begin with <code>SELECT 5</code> or <code>SELECT column1</code> or anything at all. MySQL ignores the <code>SELECT</code> list in such a subquery, so it makes no difference.",
        "Demo": [
            "SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);"
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "NOT EXISTS ( subquery) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (expression NOT  (expression  (predicate  (expressionAtom EXISTS ( )))))"
        ],
        "Route": "",
        "Description": "If a subquery returns any rows at all, <code>EXISTS subquery</code> is <code>TRUE</code>, and <code>NOT EXISTS subquery</code> is <code>FALSE</code>.",
        "Demo": [
            "SELECT column1 FROM t1 WHERE NOT EXISTS (SELECT * FROM t2);"
        ],
        "Count": [
            4
        ]
    },
    {
        "Keyword": [
            "WITH RECURSIVE cte_name AS ( subquery ) ",
            "WITH cte_name AS ( subquery ) "
        ],
        "Src": "SELECT",
        "Tree": [
            "Found error",
            " (withStatement WITH  (commonTableExpressions AS ( )))"
        ],
        "Route": "",
        "Description": "To specify common table expressions, use a WITH clause that has one or more comma-separated subclauses. Each subclause provides a subquery that produces a result set, and associates a name with the subquery. In the statement containing the WITH clause, each CTE name can be referenced to access the corresponding CTE result set. A CTE name can be referenced in other CTEs, enabling CTEs to be defined based on other CTEs. A CTE can refer to itself to define a recursive CTE. Common applications of recursive CTEs include series generation and traversal of hierarchical or tree-structured data. WITH RECURSIVE cte (col1, col2) AS (  SELECT 1, 2  UNION ALL  SELECT 3, 4 ) SELECT col1, col2 FROM cte;",
        "Demo": [
            "WITH cte (col1, col2) AS (  SELECT 1, 2  UNION ALL  SELECT 3, 4 ) SELECT col1, col2 FROM cte;",
            "WITH RECURSIVE cte (col1, col2) AS (  SELECT 1, 2  UNION ALL  SELECT 3, 4 ) SELECT col1, col2 FROM cte;"
        ],
        "Count": [
            null,
            4
        ]
    },
    {
        "Keyword": [
            "PARTITION ( partition_names ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (tableSourceItem PARTITION ( ))"
        ],
        "Route": "",
        "Description": "Explicit partition selection is implemented using a `PARTITION` option. For all supported statements, this option uses the syntax shown here: `PARTITION (partition_names) partition_names: partition_name, ...` This option always follows the name of the table to which the partition or partitions belong. `partition_names` is a comma-separated list of partitions or subpartitions to be used. Each name in this list must be the name of an existing partition or subpartition of the specified table; if any of the partitions or subpartitions are not found, the statement fails with an error (partition '`partition_name`' doesn't exist). Partitions and subpartitions named in `partition_names` may be listed in any order, and may overlap. When the `PARTITION` option is used, only the partitions and subpartitions listed are checked for matching rows.",
        "Demo": [
            "SELECT * FROM employees PARTITION (p1);"
        ],
        "Count": [
            3
        ]
    },
    {
        "Keyword": [
            "INTO OUTFILE 'file_name' export_options",
            "INTO OUTFILE 'file_name' CHARACTER SET charset_name export_options"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error",
            "Parse error"
        ],
        "Route": "",
        "Description": "The <code>SELECT ... INTO OUTFILE 'file_name'</code> form of <code>SELECT</code> writes the selected rows to a file. The file is created on the server host, so you must have the <code>FILE</code> privilege to use this syntax. <code>file_name</code> cannot be an existing file, which among other things prevents files such as <code>/etc/passwd</code> and database tables from being modified. The <code>character_set_filesystem</code> system variable controls the interpretation of the file name.\nThe <code>SELECT ... INTO OUTFILE</code> statement is intended to enable dumping a table to a text file on the server host. Column values are written converted to the character set specified in the <code>CHARACTER SET</code> clause. If no such clause is present, values are dumped using the <code>binary</code> character set. In effect, there is no character set conversion. If a result set contains columns in several character sets, so is the output data file, and it may not be possible to reload the file correctly.\nThe syntax for the <code>export_options</code> part of the statement consists of the same <code>FIELDS</code> and <code>LINES</code> clauses that are used with the <code>LOAD DATA</code> statement. For information about the <code>FIELDS</code> and <code>LINES</code> clauses, including their default values and permissible values, see Section 15.2.9, \"LOAD DATA Statement\".",
        "Demo": [
            "SELECT a,b FROM test_table INTO OUTFILE '/tmp/result.txt';",
            "SELECT a,b FROM test_table INTO OUTFILE '/tmp/result.txt' CHARACTER SET utf8;"
        ],
        "Count": [
            null,
            null
        ]
    },
    {
        "Keyword": [
            "INTO DUMPFILE 'file_name'"
        ],
        "Src": "SELECT",
        "Tree": [
            " (selectIntoExpression INTO DUMPFILE)"
        ],
        "Route": "",
        "Description": "The <code>SELECT ... INTO DUMPFILE</code> writes a single row to a file without any formatting. This is useful for selecting a BLOB value and storing it in a file.",
        "Demo": [
            "SELECT a,b,a+b FROM test_table INTO DUMPFILE '/tmp/result.txt';"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "INTO var_name"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "The 'SELECT ... INTO var_list' selects column values and stores them into variables. 'var_list' names a list of one or more variables, which can be user-defined variables, stored procedure or function parameters, or stored program local variables. The query should return a single row. If no rows are returned, a warning occurs and the variable values remain unchanged. If multiple rows are returned, an error occurs. Variables must match the number of columns in the selected data.",
        "Demo": [
            "SELECT * FROM (VALUES ROW(2,4,8)) AS t INTO @x,@y,@z;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "USE INDEX FOR JOIN ( index_list ) ",
            "USE KEY FOR JOIN ( index_list ) ",
            "USE INDEX FOR ORDER BY ( index_list ) ",
            "USE KEY FOR ORDER BY ( index_list ) ",
            "USE INDEX FOR GROUP BY ( index_list ) ",
            "USE KEY FOR GROUP BY ( index_list ) ",
            "USE INDEX ( index_list ) ",
            "USE KEY ( index_list ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (indexHint USE INDEX FOR  (indexHintType JOIN) ( ))",
            " (indexHint USE KEY FOR  (indexHintType JOIN) ( ))",
            " (indexHint USE INDEX FOR  (indexHintType ORDER BY) ( ))",
            " (indexHint USE KEY FOR  (indexHintType ORDER BY) ( ))",
            " (indexHint USE INDEX FOR  (indexHintType GROUP BY) ( ))",
            " (indexHint USE KEY FOR  (indexHintType GROUP BY) ( ))",
            " (indexHint USE INDEX ( ))",
            " (indexHint USE KEY ( ))"
        ],
        "Route": "",
        "Description": "Index hints give the optimizer information about how to choose      indexes during query processing. Index hints, described here,         differ from optimizer hints, described in         <link>Section 10.9.3, \u201cOptimizer Hints\u201d&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html</link>. Index and optimizer hints may         be used separately or together.                Index hints apply to <link><code>SELECT</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/select.html</link> and         <link><code>UPDATE</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/update.html</link> statements. They also work         with multi-table <link><code>DELETE</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/delete.html</link>         statements, but not with single-table <code>DELETE</code>,         as shown later in this section.                Index hints are specified following a table name. (For the         general syntax for specifying tables in a         <link><code>SELECT</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/select.html</link> statement, see         <link>Section 15.2.13.2, \u201cJOIN Clause\u201d&LINK&https://dev.mysql.com/doc/refman/8.0/en/join.html</link>.) The syntax for referring to an         individual table, including index hints, looks like this:       <code>tbl_name [[AS] alias] [index_hint_list]  index_hint_list:     index_hint [index_hint] ...  index_hint:     USE {INDEX|KEY}       [FOR {JOIN|ORDER BY|GROUP BY}] ([index_list])   | {IGNORE|FORCE} {INDEX|KEY}       [FOR {JOIN|ORDER BY|GROUP BY}] (index_list)  index_list:     index_name [, index_name] ...</code>         The <code>USE INDEX         (index_list)</code> hint tells         MySQL to use only one of the named indexes to find rows in the         table. The alternative syntax <code>IGNORE INDEX         (index_list)</code> tells MySQL to         not use some particular index or indexes. These hints are useful         if <link><code>EXPLAIN</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/explain.html</link> shows that MySQL is         using the wrong index from the list of possible indexes.                The <code>FORCE INDEX</code> hint acts like <code>USE         INDEX (index_list)</code>, with         the addition that a table scan is assumed to be         very expensive. In other words, a table         scan is used only if there is no way to use one of the named         indexes to find rows in the table.     Note             As of MySQL 8.0.20, the server supports the index-level           optimizer hints <link><code>JOIN_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>,           <link><code>GROUP_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>,           <link><code>ORDER_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>, and           <link><code>INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>, which are equivalent           to and intended to supersede <code>FORCE INDEX</code>           index hints, as well as the           <link><code>NO_JOIN_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>,           <link><code>NO_GROUP_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>,           <link><code>NO_ORDER_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>, and           <link><code>NO_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link> optimizer hints,           which are equivalent to and intended to supersede           <code>IGNORE INDEX</code> index hints. Thus, you should           expect <code>USE INDEX</code>, <code>FORCE           INDEX</code>, and <code>IGNORE INDEX</code> to be           deprecated in a future release of MySQL, and at some time           thereafter to be removed altogether.                    These index-level optimizer hints are supported with both           single-table and multi-table           <link><code>DELETE</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/delete.html</link> statements.                    For more information, see           <link>Index-Level Optimizer Hints&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>.            Each hint requires index names, not column names. To refer to a         primary key, use the name <code>PRIMARY</code>. To see the         index names for a table, use the <link><code>SHOW         INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/show-index.html</link> statement or the Information Schema         <link><code>STATISTICS</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/information-schema-statistics-table.html</link> table.                An <code>index_name</code> value need not be a         full index name. It can be an unambiguous prefix of an index         name. If a prefix is ambiguous, an error occurs.                Examples:       <code>SELECT * FROM table1 USE INDEX (col1_index,col2_index)   WHERE col1=1 AND col2=2 AND col3=3;  SELECT * FROM table1 IGNORE INDEX (col3_index)   WHERE col1=1 AND col2=2 AND col3=3;</code>         The syntax for index hints has the following characteristics:                It is syntactically valid to omit             <code>index_list</code> for <code>USE             INDEX</code>, which means \u201cuse no indexes.\u201d             Omitting <code>index_list</code> for             <code>FORCE INDEX</code> or <code>IGNORE             INDEX</code> is a syntax error.                        You can specify the scope of an index hint by adding a             <code>FOR</code> clause to the hint. This provides             more fine-grained control over optimizer selection of an             execution plan for various phases of query processing. To             affect only the indexes used when MySQL decides how to find             rows in the table and how to process joins, use <code>FOR             JOIN</code>. To influence index usage for sorting or             grouping rows, use <code>FOR ORDER BY</code> or             <code>FOR GROUP BY</code>.                        You can specify multiple index hints:           <code>SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX FOR ORDER BY (i2) ORDER BY a;</code>             It is not an error to name the same index in several hints             (even within the same hint):           <code>SELECT * FROM t1 USE INDEX (i1) USE INDEX (i1,i1);</code>             However, it is an error to mix <code>USE INDEX</code>             and <code>FORCE INDEX</code> for the same table:           <code>SELECT * FROM t1 USE INDEX FOR JOIN (i1) FORCE INDEX FOR JOIN (i2);</code>           If an index hint includes no <code>FOR</code> clause, the         scope of the hint is to apply to all parts of the statement. For         example, this hint:       <code>IGNORE INDEX (i1)</code>         is equivalent to this combination of hints:       <code>IGNORE INDEX FOR JOIN (i1) IGNORE INDEX FOR ORDER BY (i1) IGNORE INDEX FOR GROUP BY (i1)</code>         In MySQL 5.0, hint scope with no <code>FOR</code> clause         was to apply only to row retrieval. To cause the server to use         this older behavior when no <code>FOR</code> clause is         present, enable the <link><code>old</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_old</link> system         variable at server startup. Take care about enabling this         variable in a replication setup. With statement-based binary         logging, having different modes for the source and replicas         might lead to replication errors.                When index hints are processed, they are collected in a single         list by type (<code>USE</code>, <code>FORCE</code>,         <code>IGNORE</code>) and by scope (<code>FOR         JOIN</code>, <code>FOR ORDER BY</code>, <code>FOR         GROUP BY</code>). For example:       <code>SELECT * FROM t1   USE INDEX () IGNORE INDEX (i2) USE INDEX (i1) USE INDEX (i2);</code>         is equivalent to:       <code>SELECT * FROM t1    USE INDEX (i1,i2) IGNORE INDEX (i2);</code>         The index hints then are applied for each scope in the following         order:                <code>{USE|FORCE} INDEX</code> is applied if present.             (If not, the optimizer-determined set of indexes is used.)                        <code>IGNORE INDEX</code> is applied over the result             of the previous step. For example, the following two queries             are equivalent:           <code>SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX (i2) USE INDEX (i2);  SELECT * FROM t1 USE INDEX (i1);</code>           For <code>FULLTEXT</code> searches, index hints work as         follows:                For natural language mode searches, index hints are silently             ignored. For example, <code>IGNORE INDEX(i1)</code> is             ignored with no warning and the index is still used.                        For boolean mode searches, index hints with <code>FOR             ORDER BY</code> or <code>FOR GROUP BY</code> are             silently ignored. Index hints with <code>FOR             JOIN</code> or no <code>FOR</code> modifier are             honored. In contrast to how hints apply for             non-<code>FULLTEXT</code> searches, the hint is used             for all phases of query execution (finding rows and             retrieval, grouping, and ordering). This is true even if the             hint is given for a non-<code>FULLTEXT</code> index.                        For example, the following two queries are equivalent:           <code>SELECT * FROM t   USE INDEX (index1)   IGNORE INDEX FOR ORDER BY (index1)   IGNORE INDEX FOR GROUP BY (index1)   WHERE ... IN BOOLEAN MODE ... ;  SELECT * FROM t   USE INDEX (index1)   WHERE ... IN BOOLEAN MODE ... ;</code>           Index hints work with <link><code>DELETE</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/delete.html</link>         statements, but only if you use multi-table         <code>DELETE</code> syntax, as shown here:       <code>mysql> EXPLAIN DELETE FROM t1 USE INDEX(col2)      -> WHERE col1 BETWEEN 1 AND 100 AND COL2 BETWEEN 1 AND 100\\G ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'use index(col2) where col1 between 1 and 100 and col2 between 1 and 100' at line 1    mysql> EXPLAIN DELETE t1.* FROM t1 USE INDEX(col2)      -> WHERE col1 BETWEEN 1 AND 100 AND COL2 BETWEEN 1 AND 100\\G *************************** 1. row ***************************            id: 1   select_type: DELETE         table: t1    partitions: NULL          type: range possible_keys: col2           key: col2       key_len: 5           ref: NULL          rows: 72      filtered: 11.11         Extra: Using where 1 row in set, 1 warning (0.00 sec)</code>",
        "Demo": [
            "SELECT * FROM table1 USE INDEX FOR JOIN (col3_index);",
            "SELECT * FROM table1 USE KEY FOR JOIN (col3_index);",
            "SELECT * FROM table1 USE INDEX FOR ORDER BY (col3_index);",
            "SELECT * FROM table1 USE KEY FOR ORDER BY (col3_index);",
            "SELECT * FROM table1 USE INDEX FOR GROUP BY (col3_index);",
            "SELECT * FROM table1 USE KEY FOR GROUP BY (col3_index);",
            "SELECT * FROM table1 USE INDEX (col3_index);",
            "SELECT * FROM table1 USE KEY (col3_index);"
        ],
        "Count": [
            6,
            6,
            7,
            7,
            7,
            7,
            4,
            4
        ]
    },
    {
        "Keyword": [
            "IGNORE INDEX FOR JOIN ( index_list ) ",
            "FORCE INDEX FOR JOIN ( index_list ) ",
            "IGNORE KEY FOR JOIN ( index_list ) ",
            "FORCE KEY FOR JOIN ( index_list ) ",
            "IGNORE INDEX FOR ORDER BY ( index_list ) ",
            "FORCE INDEX FOR ORDER BY ( index_list ) ",
            "IGNORE KEY FOR ORDER BY ( index_list ) ",
            "FORCE KEY FOR ORDER BY ( index_list ) ",
            "IGNORE INDEX FOR GROUP BY ( index_list ) ",
            "FORCE INDEX FOR GROUP BY ( index_list ) ",
            "IGNORE KEY FOR GROUP BY ( index_list ) ",
            "FORCE KEY FOR GROUP BY ( index_list ) ",
            "IGNORE INDEX ( index_list ) ",
            "FORCE INDEX ( index_list ) ",
            "IGNORE KEY ( index_list ) ",
            "FORCE KEY ( index_list ) "
        ],
        "Src": "SELECT",
        "Tree": [
            " (indexHint IGNORE INDEX FOR  (indexHintType JOIN) ( ))",
            " (indexHint FORCE INDEX FOR  (indexHintType JOIN) ( ))",
            " (indexHint IGNORE KEY FOR  (indexHintType JOIN) ( ))",
            " (indexHint FORCE KEY FOR  (indexHintType JOIN) ( ))",
            " (indexHint IGNORE INDEX FOR  (indexHintType ORDER BY) ( ))",
            " (indexHint FORCE INDEX FOR  (indexHintType ORDER BY) ( ))",
            " (indexHint IGNORE KEY FOR  (indexHintType ORDER BY) ( ))",
            " (indexHint FORCE KEY FOR  (indexHintType ORDER BY) ( ))",
            " (indexHint IGNORE INDEX FOR  (indexHintType GROUP BY) ( ))",
            " (indexHint FORCE INDEX FOR  (indexHintType GROUP BY) ( ))",
            " (indexHint IGNORE KEY FOR  (indexHintType GROUP BY) ( ))",
            " (indexHint FORCE KEY FOR  (indexHintType GROUP BY) ( ))",
            " (indexHint IGNORE INDEX ( ))",
            " (indexHint FORCE INDEX ( ))",
            " (indexHint IGNORE KEY ( ))",
            " (indexHint FORCE KEY ( ))"
        ],
        "Route": "",
        "Description": "Index hints give the optimizer information about how to choose      indexes during query processing. Index hints, described here,         differ from optimizer hints, described in         <link>Section 10.9.3, \u201cOptimizer Hints\u201d&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html</link>. Index and optimizer hints may         be used separately or together.                Index hints apply to <link><code>SELECT</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/select.html</link> and         <link><code>UPDATE</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/update.html</link> statements. They also work         with multi-table <link><code>DELETE</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/delete.html</link>         statements, but not with single-table <code>DELETE</code>,         as shown later in this section.                Index hints are specified following a table name. (For the         general syntax for specifying tables in a         <link><code>SELECT</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/select.html</link> statement, see         <link>Section 15.2.13.2, \u201cJOIN Clause\u201d&LINK&https://dev.mysql.com/doc/refman/8.0/en/join.html</link>.) The syntax for referring to an         individual table, including index hints, looks like this:       <code>tbl_name [[AS] alias] [index_hint_list]  index_hint_list:     index_hint [index_hint] ...  index_hint:     USE {INDEX|KEY}       [FOR {JOIN|ORDER BY|GROUP BY}] ([index_list])   | {IGNORE|FORCE} {INDEX|KEY}       [FOR {JOIN|ORDER BY|GROUP BY}] (index_list)  index_list:     index_name [, index_name] ...</code>         The <code>USE INDEX         (index_list)</code> hint tells         MySQL to use only one of the named indexes to find rows in the         table. The alternative syntax <code>IGNORE INDEX         (index_list)</code> tells MySQL to         not use some particular index or indexes. These hints are useful         if <link><code>EXPLAIN</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/explain.html</link> shows that MySQL is         using the wrong index from the list of possible indexes.                The <code>FORCE INDEX</code> hint acts like <code>USE         INDEX (index_list)</code>, with         the addition that a table scan is assumed to be         very expensive. In other words, a table         scan is used only if there is no way to use one of the named         indexes to find rows in the table.     Note             As of MySQL 8.0.20, the server supports the index-level           optimizer hints <link><code>JOIN_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>,           <link><code>GROUP_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>,           <link><code>ORDER_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>, and           <link><code>INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>, which are equivalent           to and intended to supersede <code>FORCE INDEX</code>           index hints, as well as the           <link><code>NO_JOIN_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>,           <link><code>NO_GROUP_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>,           <link><code>NO_ORDER_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>, and           <link><code>NO_INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link> optimizer hints,           which are equivalent to and intended to supersede           <code>IGNORE INDEX</code> index hints. Thus, you should           expect <code>USE INDEX</code>, <code>FORCE           INDEX</code>, and <code>IGNORE INDEX</code> to be           deprecated in a future release of MySQL, and at some time           thereafter to be removed altogether.                    These index-level optimizer hints are supported with both           single-table and multi-table           <link><code>DELETE</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/delete.html</link> statements.                    For more information, see           <link>Index-Level Optimizer Hints&LINK&https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-index-level</link>.            Each hint requires index names, not column names. To refer to a         primary key, use the name <code>PRIMARY</code>. To see the         index names for a table, use the <link><code>SHOW         INDEX</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/show-index.html</link> statement or the Information Schema         <link><code>STATISTICS</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/information-schema-statistics-table.html</link> table.                An <code>index_name</code> value need not be a         full index name. It can be an unambiguous prefix of an index         name. If a prefix is ambiguous, an error occurs.                Examples:       <code>SELECT * FROM table1 USE INDEX (col1_index,col2_index)   WHERE col1=1 AND col2=2 AND col3=3;  SELECT * FROM table1 IGNORE INDEX (col3_index)   WHERE col1=1 AND col2=2 AND col3=3;</code>         The syntax for index hints has the following characteristics:                It is syntactically valid to omit             <code>index_list</code> for <code>USE             INDEX</code>, which means \u201cuse no indexes.\u201d             Omitting <code>index_list</code> for             <code>FORCE INDEX</code> or <code>IGNORE             INDEX</code> is a syntax error.                        You can specify the scope of an index hint by adding a             <code>FOR</code> clause to the hint. This provides             more fine-grained control over optimizer selection of an             execution plan for various phases of query processing. To             affect only the indexes used when MySQL decides how to find             rows in the table and how to process joins, use <code>FOR             JOIN</code>. To influence index usage for sorting or             grouping rows, use <code>FOR ORDER BY</code> or             <code>FOR GROUP BY</code>.                        You can specify multiple index hints:           <code>SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX FOR ORDER BY (i2) ORDER BY a;</code>             It is not an error to name the same index in several hints             (even within the same hint):           <code>SELECT * FROM t1 USE INDEX (i1) USE INDEX (i1,i1);</code>             However, it is an error to mix <code>USE INDEX</code>             and <code>FORCE INDEX</code> for the same table:           <code>SELECT * FROM t1 USE INDEX FOR JOIN (i1) FORCE INDEX FOR JOIN (i2);</code>           If an index hint includes no <code>FOR</code> clause, the         scope of the hint is to apply to all parts of the statement. For         example, this hint:       <code>IGNORE INDEX (i1)</code>         is equivalent to this combination of hints:       <code>IGNORE INDEX FOR JOIN (i1) IGNORE INDEX FOR ORDER BY (i1) IGNORE INDEX FOR GROUP BY (i1)</code>         In MySQL 5.0, hint scope with no <code>FOR</code> clause         was to apply only to row retrieval. To cause the server to use         this older behavior when no <code>FOR</code> clause is         present, enable the <link><code>old</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_old</link> system         variable at server startup. Take care about enabling this         variable in a replication setup. With statement-based binary         logging, having different modes for the source and replicas         might lead to replication errors.                When index hints are processed, they are collected in a single         list by type (<code>USE</code>, <code>FORCE</code>,         <code>IGNORE</code>) and by scope (<code>FOR         JOIN</code>, <code>FOR ORDER BY</code>, <code>FOR         GROUP BY</code>). For example:       <code>SELECT * FROM t1   USE INDEX () IGNORE INDEX (i2) USE INDEX (i1) USE INDEX (i2);</code>         is equivalent to:       <code>SELECT * FROM t1    USE INDEX (i1,i2) IGNORE INDEX (i2);</code>         The index hints then are applied for each scope in the following         order:                <code>{USE|FORCE} INDEX</code> is applied if present.             (If not, the optimizer-determined set of indexes is used.)                        <code>IGNORE INDEX</code> is applied over the result             of the previous step. For example, the following two queries             are equivalent:           <code>SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX (i2) USE INDEX (i2);  SELECT * FROM t1 USE INDEX (i1);</code>           For <code>FULLTEXT</code> searches, index hints work as         follows:                For natural language mode searches, index hints are silently             ignored. For example, <code>IGNORE INDEX(i1)</code> is             ignored with no warning and the index is still used.                        For boolean mode searches, index hints with <code>FOR             ORDER BY</code> or <code>FOR GROUP BY</code> are             silently ignored. Index hints with <code>FOR             JOIN</code> or no <code>FOR</code> modifier are             honored. In contrast to how hints apply for             non-<code>FULLTEXT</code> searches, the hint is used             for all phases of query execution (finding rows and             retrieval, grouping, and ordering). This is true even if the             hint is given for a non-<code>FULLTEXT</code> index.                        For example, the following two queries are equivalent:           <code>SELECT * FROM t   USE INDEX (index1)   IGNORE INDEX FOR ORDER BY (index1)   IGNORE INDEX FOR GROUP BY (index1)   WHERE ... IN BOOLEAN MODE ... ;  SELECT * FROM t   USE INDEX (index1)   WHERE ... IN BOOLEAN MODE ... ;</code>           Index hints work with <link><code>DELETE</code>&LINK&https://dev.mysql.com/doc/refman/8.0/en/delete.html</link>         statements, but only if you use multi-table         <code>DELETE</code> syntax, as shown here:       <code>mysql> EXPLAIN DELETE FROM t1 USE INDEX(col2)      -> WHERE col1 BETWEEN 1 AND 100 AND COL2 BETWEEN 1 AND 100\\G ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'use index(col2) where col1 between 1 and 100 and col2 between 1 and 100' at line 1    mysql> EXPLAIN DELETE t1.* FROM t1 USE INDEX(col2)      -> WHERE col1 BETWEEN 1 AND 100 AND COL2 BETWEEN 1 AND 100\\G *************************** 1. row ***************************            id: 1   select_type: DELETE         table: t1    partitions: NULL          type: range possible_keys: col2           key: col2       key_len: 5           ref: NULL          rows: 72      filtered: 11.11         Extra: Using where 1 row in set, 1 warning (0.00 sec)</code>",
        "Demo": [
            "SELECT * FROM table1 IGNORE INDEX FOR JOIN (col3_index);",
            "SELECT * FROM table1 FORCE INDEX FOR JOIN (col3_index);",
            "SELECT * FROM table1 IGNORE KEY FOR JOIN (col3_index);",
            "SELECT * FROM table1 FORCE KEY FOR JOIN (col3_index);",
            "SELECT * FROM table1 IGNORE INDEX FOR ORDER BY (col3_index) ORDER BY a;",
            "SELECT * FROM table1 FORCE INDEX FOR ORDER BY (col3_index) ORDER BY a;",
            "SELECT * FROM table1 IGNORE KEY FOR ORDER BY (col3_index) ORDER BY a;",
            "SELECT * FROM table1 FORCE KEY FOR ORDER BY (col3_index) ORDER BY a;",
            "SELECT * FROM table1 IGNORE INDEX FOR GROUP BY (col3_index) GROUP BY a;",
            "SELECT * FROM table1 FORCE INDEX FOR GROUP BY (col3_index) GROUP BY a;",
            "SELECT * FROM table1 IGNORE KEY FOR GROUP BY (col3_index) GROUP BY a;",
            "SELECT * FROM table1 FORCE KEY FOR GROUP BY (col3_index) GROUP BY a;",
            "SELECT * FROM table1 IGNORE INDEX (col3_index);",
            "SELECT * FROM table1 FORCE INDEX (col3_index);",
            "SELECT * FROM table1 IGNORE KEY (col3_index);",
            "SELECT * FROM table1 FORCE KEY (col3_index);"
        ],
        "Count": [
            6,
            6,
            6,
            6,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            4,
            4,
            4,
            4
        ]
    },
    {
        "Keyword": [
            "FOR SHARE"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "Sets a shared mode lock on any rows that are read. Other sessions can read the rows, but cannot modify them until your transaction commits. If any of these rows were changed by another transaction that has not yet committed, your query waits until that transaction ends and then uses the latest values.",
        "Demo": [
            "SELECT * FROM t WHERE i = 2 FOR SHARE;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "FOR UPDATE"
        ],
        "Src": "SELECT",
        "Tree": [
            " (lockClause FOR UPDATE)"
        ],
        "Route": "",
        "Description": "For index records the search encounters, locks the rows and any associated index entries, the same as if you issued an <code>UPDATE</code> statement for those rows. Other transactions are blocked from updating those rows, from doing <code>SELECT ... FOR SHARE</code>, or from reading the data in certain transaction isolation levels. Consistent reads ignore any locks set on the records that exist in the read view. (Old versions of a record cannot be locked; they are reconstructed by applying undo logs on an in-memory copy of the record.) <code>SELECT ... FOR UPDATE</code> requires the <code>SELECT</code> privilege and at least one of the <code>DELETE</code>, <code>LOCK TABLES</code>, or <code>UPDATE</code> privileges.",
        "Demo": [
            "SELECT * FROM t WHERE i = 2 FOR UPDATE;"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "NOWAIT"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "A locking read that uses NOWAIT never waits to acquire a row lock. The query executes immediately, failing with an error if a requested row is locked.",
        "Demo": [
            "SELECT * FROM t WHERE i = 2 FOR SHARE NOWAIT;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "SKIP LOCKED"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "A locking read that uses <code>SKIP LOCKED</code> never waits to acquire a row lock. The query executes immediately, removing locked rows from the result set. Queries that skip locked rows return an inconsistent view of the data. <code>SKIP LOCKED</code> is therefore not suitable for general transactional work. However, it may be used to avoid lock contention when multiple sessions access the same queue-like table.",
        "Demo": [
            "SELECT * FROM t WHERE i = 2 FOR UPDATE SKIP LOCKED;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "query_expression_body INTERSECT query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "INTERSECT limits the result from multiple query blocks to those rows which are common to all.",
        "Demo": [
            "TABLE c INTERSECT TABLE c;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "query_expression_body INTERSECT ALL query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "For 'INTERSECT ALL', the maximum supported number of duplicates of any unique row in the left hand table is '4294967295'.",
        "Demo": [
            "TABLE c INTERSECT ALL TABLE c;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "query_expression_body INTERSECT DISTINCT query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "As with UNION and EXCEPT, if neither DISTINCT nor ALL is specified, the default is DISTINCT. DISTINCT can remove duplicates from either side of the intersection, as shown here: mysql> TABLE c INTERSECT DISTINCT TABLE c; +------+------+ | m    | n    | +------+------+ |    1 |    3 | |    3 |    4 | +------+------+ 2 rows in set (0.00 sec)",
        "Demo": [
            "TABLE c INTERSECT DISTINCT TABLE c;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "query_expression_body UNION query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            " (unionStatement UNION)"
        ],
        "Route": "",
        "Description": "UNION combines the result from multiple query blocks into a single result set. As with INTERSECT and EXCEPT, if neither DISTINCT nor ALL is specified, the default is DISTINCT. DISTINCT can remove duplicates rows from the result set. This example uses <code>SELECT</code> statements: <code>mysql> SELECT 1, 2; +---+---+ | 1 | 2 | +---+---+ | 1 | 2 | +---+---+ mysql> SELECT 'a', 'b'; +---+---+ | a | b | +---+---+ | a | b | +---+---+ mysql> SELECT 1, 2 UNION SELECT 'a', 'b'; +---+---+ | 1 | 2 | +---+---+ | 1 | 2 | | a | b | +---+---+</code>",
        "Demo": [
            "SELECT * FROM table_a UNION SELECT * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "query_expression_body UNION ALL query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            " (unionStatement UNION ALL)"
        ],
        "Route": "",
        "Description": "UNION combines the result from multiple query blocks into a single result set,  including duplicates as indicated by 'ALL'.",
        "Demo": [
            "SELECT * FROM table_a UNION ALL SELECT * FROM table_a;"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "query_expression_body UNION DISTINCT query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            " (unionStatement UNION DISTINCT)"
        ],
        "Route": "",
        "Description": "UNION combines the result from multiple query blocks into a single result set. As with INTERSECT and EXCEPT, if neither DISTINCT nor ALL is specified, the default is DISTINCT. DISTINCT can remove duplicates rows from the result set.",
        "Demo": [
            "SELECT * FROM table_a UNION DISTINCT SELECT * FROM table_a;"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "query_expression_body EXCEPT query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            " (keywordsCanBeId EXCEPT)"
        ],
        "Route": "",
        "Description": "limits the result from the first query block to those rows which are (also) not found in the second. As with UNION and INTERSECT, either query block can make use of any of SELECT, TABLE, or VALUES.",
        "Demo": [
            "SELECT * FROM table_a EXCEPT SELECT * FROM table_a;"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "query_expression_body EXCEPT ALL query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "limits the result from the first query block to those rows which are not found in the second, including duplicates from the first query block as indicated by 'ALL'.",
        "Demo": [
            "SELECT * FROM table_a EXCEPT ALL SELECT * FROM table_a;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "query_expression_body EXCEPT DISTINCT query_expression_body"
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "limits the result from the first query block to those rows which are (also) not found in the second. As with UNION and INTERSECT, either query block can make use of any of SELECT, TABLE, or VALUES.",
        "Demo": [
            "SELECT * FROM table_a EXCEPT DISTINCT SELECT * FROM table_a;"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "OVER ( window_spec ) "
        ],
        "Src": "SELECT",
        "Tree": [
            "Parse error"
        ],
        "Route": "",
        "Description": "For `OVER (window_spec)` syntax, the window specification has several parts, all optional:\n\n`window_spec: [window_name] [partition_clause] [order_clause] [frame_clause]`\n\nIf `OVER()` is empty, the window consists of all query rows and the window function computes a result using all rows. Otherwise, the clauses present within the parentheses determine which query rows are used to compute the function result and how they are partitioned and ordered:\n\n- `window_name`: The name of a window defined by a `WINDOW` clause elsewhere in the query. If `window_name` appears by itself within the `OVER` clause, it completely defines the window. If partitioning, ordering, or framing clauses are also given, they modify interpretation of the named window. For details, see [Section 14.20.4, \"Named Windows\"](https://dev.mysql.com/doc/refman/8.0/en/window-functions-named-windows.html).\n\n- `partition_clause`: A `PARTITION BY` clause indicates how to divide the query rows into groups. The window function result for a given row is based on the rows of the partition that contains the row. If `PARTITION BY` is omitted, there is a single partition consisting of all query rows.\n\n- `order_clause`: An `ORDER BY` clause indicates how to sort rows in each partition. Partition rows that are equal according to the `ORDER BY` clause are considered peers. If `ORDER BY` is omitted, partition rows are unordered, with no processing order implied, and all partition rows are peers.\n\n- `frame_clause`: A frame is a subset of the current partition, and the frame clause specifies how to define the subset. The frame clause has many subclauses of its own. For details, see [Section 14.20.3, \"Window Function Frame Specification\"](https://dev.mysql.com/doc/refman/8.0/en/window-functions-frames.html).",
        "Demo": [
            "SELECT time FROM observations OVER (PARTITION BY subject );"
        ],
        "Count": [
            null
        ]
    },
    {
        "Keyword": [
            "ORDER BY expr ASC",
            "ORDER BY expr DESC",
            "ORDER BY expr"
        ],
        "Src": "SELECT",
        "Tree": [
            " (orderByClause ORDER BY  (orderByExpression ASC))",
            " (orderByClause ORDER BY  (orderByExpression DESC))",
            " (orderByClause ORDER BY)"
        ],
        "Route": "",
        "Description": "An `ORDER BY` clause indicates how to sort rows in each partition. Partition rows that are equal according to the `ORDER BY` clause are considered peers. If `ORDER BY` is omitted, partition rows are unordered, with no processing order implied, and all partition rows are peers. Each `ORDER BY` expression optionally can be followed by `ASC` or `DESC` to indicate sort direction. The default is `ASC` if no direction is specified. `NULL` values sort first for ascending sorts, last for descending sorts. An `ORDER BY` in a window definition applies within individual partitions. To sort the result set as a whole, include an `ORDER BY` at the query top level.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS  (ORDER BY time ASC);",
            "SELECT time FROM observations WINDOW win AS (ORDER BY time DESC);",
            "SELECT time FROM observations WINDOW win AS (ORDER BY time);"
        ],
        "Count": [
            3,
            3,
            2
        ]
    },
    {
        "Keyword": [
            "PARTITION BY expr"
        ],
        "Src": "SELECT",
        "Tree": [
            " (partitionClause PARTITION BY)"
        ],
        "Route": "",
        "Description": "A `PARTITION BY` clause indicates how to divide the query rows into groups. The window function result for a given row is based on the rows of the partition that contains the row. If `PARTITION BY` is omitted, there is a single partition consisting of all query rows.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (PARTITION BY subject );"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "ROWS"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frameUnits ROWS)"
        ],
        "Route": "",
        "Description": "The frame_units value indicates the type of relationship between the current row and frame rows: 'ROWS': The frame is defined by beginning and ending row positions. Offsets are differences in row numbers from the current row number.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (ROWS UNBOUNDED PRECEDING);"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "RANGE"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frameUnits RANGE)"
        ],
        "Route": "",
        "Description": "The frame is defined by rows within a value range. Offsets are differences in row values from the current row value.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING);"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "BETWEEN frame_start AND frame_end"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frameBetween BETWEEN AND)"
        ],
        "Route": "",
        "Description": "The frame_extent value indicates the start and end points of the frame. You can specify just the start of the frame (in which case the current row is implicitly the end) or use BETWEEN to specify both frame endpoints: frame_extent: {frame_start | frame_between} frame_between: BETWEEN frame_start AND frame_end frame_start, frame_end: { CURRENT ROW | UNBOUNDED PRECEDING | UNBOUNDED FOLLOWING | expr PRECEDING | expr FOLLOWING } With BETWEEN syntax, frame_start must not occur later than frame_end.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING);"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "CURRENT ROW"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frameRange CURRENT ROW)"
        ],
        "Route": "",
        "Description": "For 'ROWS', the bound is the current row. For 'RANGE', the bound is the peers of the current row.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (ROWS CURRENT ROW);"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "UNBOUNDED PRECEDING"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frameRange UNBOUNDED PRECEDING)"
        ],
        "Route": "",
        "Description": "The bound is the first partition row.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (ROWS UNBOUNDED PRECEDING);"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "UNBOUNDED FOLLOWING"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frameRange UNBOUNDED FOLLOWING)"
        ],
        "Route": "",
        "Description": "The bound is the last partition row.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (ROWS UNBOUNDED FOLLOWING);"
        ],
        "Count": [
            2
        ]
    },
    {
        "Keyword": [
            "expr PRECEDING"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frameRange PRECEDING)"
        ],
        "Route": "",
        "Description": "For `ROWS`, the bound is `expr` rows before the current row. For `RANGE`, the bound is the rows with values equal to the current row value minus `expr`; if the current row value is `NULL`, the bound is the peers of the row. For `expr PRECEDING` (and `expr FOLLOWING`), `expr` can be a `?` parameter marker (for use in a prepared statement), a nonnegative numeric literal, or a temporal interval of the form `INTERVAL val unit`. For `INTERVAL` expressions, `val` specifies nonnegative interval value, and `unit` is a keyword indicating the units in which the value should be interpreted. (For details about the permitted `units` specifiers, see the description of the `DATE_ADD()` function in Section 14.7, \u201cDate and Time Functions\u201d.)",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (ROWS 10 PRECEDING);"
        ],
        "Count": [
            1
        ]
    },
    {
        "Keyword": [
            "expr FOLLOWING"
        ],
        "Src": "SELECT",
        "Tree": [
            " (frameRange FOLLOWING)"
        ],
        "Route": "",
        "Description": "For <code>ROWS</code>, the bound is <code>expr</code> rows after the current row. For <code>RANGE</code>, the bound is the rows with values equal to the current row value plus <code>expr</code>; if the current row value is <code>NULL</code>, the bound is the peers of the row.",
        "Demo": [
            "SELECT time FROM observations WINDOW win AS (ROWS 10 FOLLOWING);"
        ],
        "Count": [
            1
        ]
    }
]